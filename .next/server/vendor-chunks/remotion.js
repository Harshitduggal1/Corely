"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/remotion";
exports.ids = ["vendor-chunks/remotion"];
exports.modules = {

/***/ "(ssr)/./node_modules/remotion/dist/esm/index.mjs":
/*!**************************************************!*\
  !*** ./node_modules/remotion/dist/esm/index.mjs ***!
  \**************************************************/
/***/ ((__webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AbsoluteFill: () => (/* binding */ AbsoluteFill),\n/* harmony export */   Artifact: () => (/* binding */ Artifact),\n/* harmony export */   Audio: () => (/* binding */ Audio),\n/* harmony export */   Composition: () => (/* binding */ Composition),\n/* harmony export */   Config: () => (/* binding */ Config),\n/* harmony export */   Easing: () => (/* binding */ Easing),\n/* harmony export */   Experimental: () => (/* binding */ Experimental),\n/* harmony export */   Folder: () => (/* binding */ Folder),\n/* harmony export */   FolderContext: () => (/* binding */ FolderContext),\n/* harmony export */   Freeze: () => (/* binding */ Freeze),\n/* harmony export */   IFrame: () => (/* binding */ IFrame),\n/* harmony export */   Img: () => (/* binding */ Img),\n/* harmony export */   Internals: () => (/* binding */ Internals),\n/* harmony export */   Loop: () => (/* binding */ Loop),\n/* harmony export */   OffthreadVideo: () => (/* binding */ OffthreadVideo),\n/* harmony export */   Sequence: () => (/* binding */ Sequence),\n/* harmony export */   Series: () => (/* binding */ Series),\n/* harmony export */   Still: () => (/* binding */ Still),\n/* harmony export */   VERSION: () => (/* binding */ VERSION),\n/* harmony export */   Video: () => (/* binding */ Video),\n/* harmony export */   cancelRender: () => (/* binding */ cancelRender),\n/* harmony export */   continueRender: () => (/* binding */ continueRender),\n/* harmony export */   delayRender: () => (/* binding */ delayRender),\n/* harmony export */   getInputProps: () => (/* binding */ getInputProps),\n/* harmony export */   getRemotionEnvironment: () => (/* binding */ getRemotionEnvironment),\n/* harmony export */   getStaticFiles: () => (/* binding */ getStaticFiles),\n/* harmony export */   interpolate: () => (/* binding */ interpolate),\n/* harmony export */   interpolateColors: () => (/* binding */ interpolateColors),\n/* harmony export */   measureSpring: () => (/* binding */ measureSpring),\n/* harmony export */   prefetch: () => (/* binding */ prefetch),\n/* harmony export */   random: () => (/* binding */ random),\n/* harmony export */   registerRoot: () => (/* binding */ registerRoot),\n/* harmony export */   spring: () => (/* binding */ spring),\n/* harmony export */   staticFile: () => (/* binding */ staticFile),\n/* harmony export */   useBufferState: () => (/* binding */ useBufferState),\n/* harmony export */   useCurrentFrame: () => (/* binding */ useCurrentFrame),\n/* harmony export */   useCurrentScale: () => (/* binding */ useCurrentScale),\n/* harmony export */   useVideoConfig: () => (/* binding */ useVideoConfig),\n/* harmony export */   watchStaticFile: () => (/* binding */ watchStaticFile)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(ssr)/../../../../../../../node_modules/.pnpm/next@15.0.0-rc.0_@babel+core@7.24.4_@opentelemetry+api@1.9.0_react-dom@19.0.0-rc-d5bba18b-202_oliw3phgrggs3shcirdtxjs5wq/node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react/jsx-runtime */ \"(ssr)/../../../../../../../node_modules/.pnpm/next@15.0.0-rc.0_@babel+core@7.24.4_@opentelemetry+api@1.9.0_react-dom@19.0.0-rc-d5bba18b-202_oliw3phgrggs3shcirdtxjs5wq/node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react-jsx-runtime.js\");\n/* harmony import */ var react_dom__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! react-dom */ \"(ssr)/../../../../../../../node_modules/.pnpm/next@15.0.0-rc.0_@babel+core@7.24.4_@opentelemetry+api@1.9.0_react-dom@19.0.0-rc-d5bba18b-202_oliw3phgrggs3shcirdtxjs5wq/node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react-dom.js\");\nvar __defProp = Object.defineProperty;\nvar __export = (target, all)=>{\n    for(var name in all)__defProp(target, name, {\n        get: all[name],\n        enumerable: true,\n        configurable: true,\n        set: (newValue)=>all[name] = ()=>newValue\n    });\n};\n// src/_check-rsc.ts\n\nif (typeof react__WEBPACK_IMPORTED_MODULE_0__.createContext !== \"function\") {\n    const err = [\n        'Remotion requires React.createContext, but it is \"undefined\".',\n        'If you are in a React Server Component, turn it into a client component by adding \"use client\" at the top of the file.',\n        \"\",\n        \"Before:\",\n        '  import {useCurrentFrame} from \"remotion\";',\n        \"\",\n        \"After:\",\n        '  \"use client\";',\n        '  import {useCurrentFrame} from \"remotion\";'\n    ];\n    throw new Error(err.join(\"\\n\"));\n}\n// src/Clipper.tsx\n\n// src/NativeLayers.tsx\n\n\nvar NativeLayersContext = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_0__.createContext)({\n    setClipRegion: ()=>{\n        throw new Error(\"NativeLayers not set\");\n    },\n    clipRegion: null\n});\nvar NativeLayersProvider = ({ children })=>{\n    const [clipRegion, setClipRegion] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(null);\n    const context = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>{\n        return {\n            setClipRegion,\n            clipRegion\n        };\n    }, [\n        clipRegion,\n        setClipRegion\n    ]);\n    if (false) {}\n    return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(NativeLayersContext.Provider, {\n        value: context,\n        children\n    });\n};\n// src/Clipper.tsx\nvar Clipper = ({ height, width, x, y })=>{\n    const { setClipRegion } = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(NativeLayersContext);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        setClipRegion((c)=>{\n            if (c === \"hide\") {\n                throw new Error(\"Cannot render <Clipper>, because another <Null> is already rendered\");\n            }\n            if (c === null) {\n                return {\n                    height,\n                    width,\n                    x,\n                    y\n                };\n            }\n            throw new Error(\"Cannot render <Clipper>, because another component clipping the region was already rendered (most likely <Clipper>)\");\n        });\n        return ()=>{\n            setClipRegion(null);\n        };\n    }, [\n        height,\n        setClipRegion,\n        width,\n        x,\n        y\n    ]);\n    return null;\n};\n// src/enable-sequence-stack-traces.ts\n\n// src/get-remotion-environment.ts\nfunction getNodeEnvString() {\n    return [\n        \"NOD\",\n        \"E_EN\",\n        \"V\"\n    ].join(\"\");\n}\nvar getEnvString = ()=>{\n    return [\n        \"e\",\n        \"nv\"\n    ].join(\"\");\n};\nvar getRemotionEnvironment = ()=>{\n    const isPlayer =  false && 0;\n    const isRendering =  false && (0);\n    const isStudio =  false && 0;\n    return {\n        isStudio,\n        isRendering,\n        isPlayer\n    };\n};\n// src/enable-sequence-stack-traces.ts\nvar originalCreateElement = react__WEBPACK_IMPORTED_MODULE_0__.createElement;\nvar componentsToAddStacksTo = [];\nvar enableSequenceStackTraces = ()=>{\n    if (!getRemotionEnvironment().isStudio) {\n        return;\n    }\n    const proxy = new Proxy(originalCreateElement, {\n        apply (target, thisArg, argArray) {\n            if (componentsToAddStacksTo.includes(argArray[0])) {\n                const [first, props, ...rest] = argArray;\n                const newProps = {\n                    ...props ?? {},\n                    stack: new Error().stack\n                };\n                return Reflect.apply(target, thisArg, [\n                    first,\n                    newProps,\n                    ...rest\n                ]);\n            }\n            return Reflect.apply(target, thisArg, argArray);\n        }\n    });\n    react__WEBPACK_IMPORTED_MODULE_0__.createElement = proxy;\n};\nvar addSequenceStackTraces = (component)=>{\n    componentsToAddStacksTo.push(component);\n    enableSequenceStackTraces();\n};\n// src/is-player.tsx\n\n\nvar IsPlayerContext = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_0__.createContext)(false);\nvar IsPlayerContextProvider = ({ children })=>{\n    return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(IsPlayerContext.Provider, {\n        value: true,\n        children\n    });\n};\nvar useIsPlayer = ()=>{\n    return (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(IsPlayerContext);\n};\n// src/truthy.ts\nfunction truthy(value) {\n    return Boolean(value);\n}\n// src/version.ts\nvar VERSION = \"4.0.223\";\n// src/multiple-versions-warning.ts\nvar checkMultipleRemotionVersions = ()=>{\n    if (typeof globalThis === \"undefined\") {\n        return;\n    }\n    const alreadyImported = globalThis.remotion_imported ||  false && 0;\n    if (alreadyImported) {\n        if (alreadyImported === VERSION) {\n            return;\n        }\n        throw new TypeError(`\\uD83D\\uDEA8 Multiple versions of Remotion detected: ${[\n            VERSION,\n            typeof alreadyImported === \"string\" ? alreadyImported : \"an older version\"\n        ].filter(truthy).join(\" and \")}. This will cause things to break in an unexpected way.\\nCheck that all your Remotion packages are on the same version. If your dependencies depend on Remotion, make them peer dependencies. You can also run \\`npx remotion versions\\` from your terminal to see which versions are mismatching.`);\n    }\n    globalThis.remotion_imported = VERSION;\n    if (false) {}\n};\n// src/Null.tsx\n\nvar Null = ()=>{\n    const { setClipRegion } = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(NativeLayersContext);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        setClipRegion((c)=>{\n            if (c === null) {\n                return \"hide\";\n            }\n            if (c === \"hide\") {\n                return \"hide\";\n            }\n            throw new Error(\"Cannot render <Null>, because another component clipping the region was already rendered (most likely <Clipper>)\");\n        });\n        return ()=>{\n            setClipRegion(null);\n        };\n    }, [\n        setClipRegion\n    ]);\n    return null;\n};\n// src/Sequence.tsx\n\n// src/AbsoluteFill.tsx\n\n\nvar AbsoluteFillRefForwarding = (props, ref)=>{\n    const { style, ...other } = props;\n    const actualStyle = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>{\n        return {\n            position: \"absolute\",\n            top: 0,\n            left: 0,\n            right: 0,\n            bottom: 0,\n            width: \"100%\",\n            height: \"100%\",\n            display: \"flex\",\n            flexDirection: \"column\",\n            ...style\n        };\n    }, [\n        style\n    ]);\n    return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(\"div\", {\n        ref,\n        style: actualStyle,\n        ...other\n    });\n};\nvar AbsoluteFill = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_0__.forwardRef)(AbsoluteFillRefForwarding);\n// src/SequenceContext.tsx\n\nvar SequenceContext = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_0__.createContext)(null);\n// src/SequenceManager.tsx\n\n\nvar SequenceManager = /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createContext({\n    registerSequence: ()=>{\n        throw new Error(\"SequenceManagerContext not initialized\");\n    },\n    unregisterSequence: ()=>{\n        throw new Error(\"SequenceManagerContext not initialized\");\n    },\n    sequences: []\n});\nvar SequenceVisibilityToggleContext = /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createContext({\n    hidden: {},\n    setHidden: ()=>{\n        throw new Error(\"SequenceVisibilityToggle not initialized\");\n    }\n});\nvar SequenceManagerProvider = ({ children })=>{\n    const [sequences, setSequences] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)([]);\n    const [hidden, setHidden] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)({});\n    const registerSequence = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((seq)=>{\n        setSequences((seqs)=>{\n            return [\n                ...seqs,\n                seq\n            ];\n        });\n    }, []);\n    const unregisterSequence = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((seq)=>{\n        setSequences((seqs)=>seqs.filter((s)=>s.id !== seq));\n    }, []);\n    const sequenceContext = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>{\n        return {\n            registerSequence,\n            sequences,\n            unregisterSequence\n        };\n    }, [\n        registerSequence,\n        sequences,\n        unregisterSequence\n    ]);\n    const hiddenContext = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>{\n        return {\n            hidden,\n            setHidden\n        };\n    }, [\n        hidden\n    ]);\n    return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(SequenceManager.Provider, {\n        value: sequenceContext,\n        children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(SequenceVisibilityToggleContext.Provider, {\n            value: hiddenContext,\n            children\n        })\n    });\n};\n// src/nonce.ts\n\nvar NonceContext = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_0__.createContext)({\n    getNonce: ()=>0,\n    fastRefreshes: 0\n});\nvar useNonce = ()=>{\n    const context = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(NonceContext);\n    const [nonce, setNonce] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(()=>context.getNonce());\n    const lastContext = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(context);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        if (lastContext.current === context) {\n            return;\n        }\n        lastContext.current = context;\n        setNonce(context.getNonce);\n    }, [\n        context\n    ]);\n    return nonce;\n};\n// src/timeline-position-state.ts\nvar exports_timeline_position_state = {};\n__export(exports_timeline_position_state, {\n    useTimelineSetFrame: ()=>useTimelineSetFrame,\n    useTimelinePosition: ()=>useTimelinePosition,\n    usePlayingState: ()=>usePlayingState,\n    persistCurrentFrame: ()=>persistCurrentFrame,\n    getInitialFrameState: ()=>getInitialFrameState,\n    getFrameForComposition: ()=>getFrameForComposition,\n    TimelineContext: ()=>TimelineContext,\n    SetTimelineContext: ()=>SetTimelineContext\n});\n\n// src/use-video.ts\n\n// src/CompositionManagerContext.tsx\n\nvar CompositionManager = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_0__.createContext)({\n    compositions: [],\n    registerComposition: ()=>{\n        return;\n    },\n    unregisterComposition: ()=>{\n        return;\n    },\n    registerFolder: ()=>{\n        return;\n    },\n    unregisterFolder: ()=>{\n        return;\n    },\n    setCurrentCompositionMetadata: ()=>{\n        return;\n    },\n    updateCompositionDefaultProps: ()=>{\n        return;\n    },\n    folders: [],\n    currentCompositionMetadata: null,\n    canvasContent: null,\n    setCanvasContent: ()=>{\n        return;\n    }\n});\n// src/ResolveCompositionConfig.tsx\n\n// src/EditorProps.tsx\n\n\nvar EditorPropsContext = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_0__.createContext)({\n    props: {},\n    updateProps: ()=>{\n        throw new Error(\"Not implemented\");\n    },\n    resetUnsaved: ()=>{\n        throw new Error(\"Not implemented\");\n    }\n});\nvar editorPropsProviderRef = /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createRef();\nvar EditorPropsProvider = ({ children })=>{\n    const [props, setProps] = react__WEBPACK_IMPORTED_MODULE_0__.useState({});\n    const updateProps = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(({ defaultProps, id, newProps })=>{\n        setProps((prev)=>{\n            return {\n                ...prev,\n                [id]: typeof newProps === \"function\" ? newProps(prev[id] ?? defaultProps) : newProps\n            };\n        });\n    }, []);\n    const resetUnsaved = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(()=>{\n        setProps({});\n    }, []);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useImperativeHandle)(editorPropsProviderRef, ()=>{\n        return {\n            getProps: ()=>props,\n            setProps\n        };\n    }, [\n        props\n    ]);\n    const ctx = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>{\n        return {\n            props,\n            updateProps,\n            resetUnsaved\n        };\n    }, [\n        props,\n        resetUnsaved,\n        updateProps\n    ]);\n    return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(EditorPropsContext.Provider, {\n        value: ctx,\n        children\n    });\n};\n// src/static-file.ts\nvar problematicCharacters = {\n    \"%3A\": \":\",\n    \"%2F\": \"/\",\n    \"%3F\": \"?\",\n    \"%23\": \"#\",\n    \"%5B\": \"[\",\n    \"%5D\": \"]\",\n    \"%40\": \"@\",\n    \"%21\": \"!\",\n    \"%24\": \"$\",\n    \"%26\": \"&\",\n    \"%27\": \"'\",\n    \"%28\": \"(\",\n    \"%29\": \")\",\n    \"%2A\": \"*\",\n    \"%2B\": \"+\",\n    \"%2C\": \",\",\n    \"%3B\": \";\"\n};\nvar didWarn = {};\nvar warnOnce = (message)=>{\n    if (didWarn[message]) {\n        return;\n    }\n    console.warn(message);\n    didWarn[message] = true;\n};\nvar includesHexOfUnsafeChar = (path)=>{\n    for (const key of Object.keys(problematicCharacters)){\n        if (path.includes(key)) {\n            return {\n                containsHex: true,\n                hexCode: key\n            };\n        }\n    }\n    return {\n        containsHex: false\n    };\n};\nvar trimLeadingSlash = (path)=>{\n    if (path.startsWith(\"/\")) {\n        return trimLeadingSlash(path.substring(1));\n    }\n    return path;\n};\nvar inner = (path)=>{\n    if (false) {}\n    return `/${trimLeadingSlash(path)}`;\n};\nvar encodeBySplitting = (path)=>{\n    const splitBySlash = path.split(\"/\");\n    const encodedArray = splitBySlash.map((element)=>{\n        return encodeURIComponent(element);\n    });\n    const merged = encodedArray.join(\"/\");\n    return merged;\n};\nvar staticFile = (path)=>{\n    if (path === null) {\n        throw new TypeError(\"null was passed to staticFile()\");\n    }\n    if (typeof path === \"undefined\") {\n        throw new TypeError(\"undefined was passed to staticFile()\");\n    }\n    if (path.startsWith(\"http://\") || path.startsWith(\"https://\")) {\n        throw new TypeError(`staticFile() does not support remote URLs - got \"${path}\". Instead, pass the URL without wrapping it in staticFile(). See: https://remotion.dev/docs/staticfile-remote-urls`);\n    }\n    if (path.startsWith(\"..\") || path.startsWith(\"./\")) {\n        throw new TypeError(`staticFile() does not support relative paths - got \"${path}\". Instead, pass the name of a file that is inside the public/ folder. See: https://remotion.dev/docs/staticfile-relative-paths`);\n    }\n    if (path.startsWith(\"/Users\") || path.startsWith(\"/home\") || path.startsWith(\"/tmp\") || path.startsWith(\"/etc\") || path.startsWith(\"/opt\") || path.startsWith(\"/var\") || path.startsWith(\"C:\") || path.startsWith(\"D:\") || path.startsWith(\"E:\")) {\n        throw new TypeError(`staticFile() does not support absolute paths - got \"${path}\". Instead, pass the name of a file that is inside the public/ folder. See: https://remotion.dev/docs/staticfile-relative-paths`);\n    }\n    if (path.startsWith(\"public/\")) {\n        throw new TypeError(`Do not include the public/ prefix when using staticFile() - got \"${path}\". See: https://remotion.dev/docs/staticfile-relative-paths`);\n    }\n    const includesHex = includesHexOfUnsafeChar(path);\n    if (includesHex.containsHex) {\n        warnOnce(`WARNING: You seem to pass an already encoded path (path contains ${includesHex.hexCode}). Since Remotion 4.0, the encoding is done by staticFile() itself. You may want to remove a encodeURIComponent() wrapping.`);\n    }\n    const preprocessed = encodeBySplitting(path);\n    const preparsed = inner(preprocessed);\n    if (!preparsed.startsWith(\"/\")) {\n        return `/${preparsed}`;\n    }\n    return preparsed;\n};\n// src/input-props-serialization.ts\nvar DATE_TOKEN = \"remotion-date:\";\nvar FILE_TOKEN = \"remotion-file:\";\nvar serializeJSONWithDate = ({ data, indent, staticBase })=>{\n    let customDateUsed = false;\n    let customFileUsed = false;\n    let mapUsed = false;\n    let setUsed = false;\n    try {\n        const serializedString = JSON.stringify(data, function(key, value) {\n            const item = this[key];\n            if (item instanceof Date) {\n                customDateUsed = true;\n                return `${DATE_TOKEN}${item.toISOString()}`;\n            }\n            if (item instanceof Map) {\n                mapUsed = true;\n                return value;\n            }\n            if (item instanceof Set) {\n                setUsed = true;\n                return value;\n            }\n            if (typeof item === \"string\" && staticBase !== null && item.startsWith(staticBase)) {\n                customFileUsed = true;\n                return `${FILE_TOKEN}${item.replace(staticBase + \"/\", \"\")}`;\n            }\n            return value;\n        }, indent);\n        return {\n            serializedString,\n            customDateUsed,\n            customFileUsed,\n            mapUsed,\n            setUsed\n        };\n    } catch (err) {\n        throw new Error(\"Could not serialize the passed input props to JSON: \" + err.message);\n    }\n};\nvar deserializeJSONWithCustomFields = (data)=>{\n    return JSON.parse(data, (_, value)=>{\n        if (typeof value === \"string\" && value.startsWith(DATE_TOKEN)) {\n            return new Date(value.replace(DATE_TOKEN, \"\"));\n        }\n        if (typeof value === \"string\" && value.startsWith(FILE_TOKEN)) {\n            return staticFile(value.replace(FILE_TOKEN, \"\"));\n        }\n        return value;\n    });\n};\nvar serializeThenDeserializeInStudio = (props)=>{\n    if (getRemotionEnvironment().isStudio) {\n        return deserializeJSONWithCustomFields(serializeJSONWithDate({\n            data: props,\n            indent: 2,\n            staticBase: window.remotion_staticBase\n        }).serializedString);\n    }\n    return props;\n};\n// src/config/input-props.ts\nvar didWarnSSRImport = false;\nvar warnOnceSSRImport = ()=>{\n    if (didWarnSSRImport) {\n        return;\n    }\n    didWarnSSRImport = true;\n    console.warn(\"Called `getInputProps()` on the server. This function is not available server-side and has returned an empty object.\");\n    console.warn(\"To hide this warning, don't call this function on the server:\");\n    console.warn(\"  typeof window === 'undefined' ? {} : getInputProps()\");\n};\nvar getInputProps = ()=>{\n    if (true) {\n        warnOnceSSRImport();\n        return {};\n    }\n    if (getRemotionEnvironment().isPlayer) {\n        throw new Error(\"You cannot call `getInputProps()` from a <Player>. Instead, the props are available as React props from component that you passed as `component` prop.\");\n    }\n    const param = window.remotion_inputProps;\n    if (!param) {\n        return {};\n    }\n    const parsed = deserializeJSONWithCustomFields(param);\n    return parsed;\n};\n// src/codec.ts\nvar validCodecs = [\n    \"h264\",\n    \"h265\",\n    \"vp8\",\n    \"vp9\",\n    \"mp3\",\n    \"aac\",\n    \"wav\",\n    \"prores\",\n    \"h264-mkv\",\n    \"h264-ts\",\n    \"gif\"\n];\n// src/validation/validate-default-codec.ts\nfunction validateDefaultCodec(defaultCodec, location) {\n    if (typeof defaultCodec === \"undefined\") {\n        return;\n    }\n    if (typeof defaultCodec !== \"string\") {\n        throw new TypeError(`The \"defaultCodec\" prop ${location} must be a string, but you passed a value of type ${typeof defaultCodec}.`);\n    }\n    if (!validCodecs.includes(defaultCodec)) {\n        throw new Error(`The \"defaultCodec\" prop ${location} must be one of ${validCodecs.join(\", \")}, but you passed ${defaultCodec}.`);\n    }\n}\n// src/validation/validate-dimensions.ts\nfunction validateDimension(amount, nameOfProp, location) {\n    if (typeof amount !== \"number\") {\n        throw new Error(`The \"${nameOfProp}\" prop ${location} must be a number, but you passed a value of type ${typeof amount}`);\n    }\n    if (isNaN(amount)) {\n        throw new TypeError(`The \"${nameOfProp}\" prop ${location} must not be NaN, but is NaN.`);\n    }\n    if (!Number.isFinite(amount)) {\n        throw new TypeError(`The \"${nameOfProp}\" prop ${location} must be finite, but is ${amount}.`);\n    }\n    if (amount % 1 !== 0) {\n        throw new TypeError(`The \"${nameOfProp}\" prop ${location} must be an integer, but is ${amount}.`);\n    }\n    if (amount <= 0) {\n        throw new TypeError(`The \"${nameOfProp}\" prop ${location} must be positive, but got ${amount}.`);\n    }\n}\n// src/validation/validate-duration-in-frames.ts\nfunction validateDurationInFrames(durationInFrames, options) {\n    const { allowFloats, component } = options;\n    if (typeof durationInFrames === \"undefined\") {\n        throw new Error(`The \"durationInFrames\" prop ${component} is missing.`);\n    }\n    if (typeof durationInFrames !== \"number\") {\n        throw new Error(`The \"durationInFrames\" prop ${component} must be a number, but you passed a value of type ${typeof durationInFrames}`);\n    }\n    if (durationInFrames <= 0) {\n        throw new TypeError(`The \"durationInFrames\" prop ${component} must be positive, but got ${durationInFrames}.`);\n    }\n    if (!allowFloats && durationInFrames % 1 !== 0) {\n        throw new TypeError(`The \"durationInFrames\" prop ${component} must be an integer, but got ${durationInFrames}.`);\n    }\n    if (!Number.isFinite(durationInFrames)) {\n        throw new TypeError(`The \"durationInFrames\" prop ${component} must be finite, but got ${durationInFrames}.`);\n    }\n}\n// src/validation/validate-fps.ts\nfunction validateFps(fps, location, isGif) {\n    if (typeof fps !== \"number\") {\n        throw new Error(`\"fps\" must be a number, but you passed a value of type ${typeof fps} ${location}`);\n    }\n    if (!Number.isFinite(fps)) {\n        throw new Error(`\"fps\" must be a finite, but you passed ${fps} ${location}`);\n    }\n    if (isNaN(fps)) {\n        throw new Error(`\"fps\" must not be NaN, but got ${fps} ${location}`);\n    }\n    if (fps <= 0) {\n        throw new TypeError(`\"fps\" must be positive, but got ${fps} ${location}`);\n    }\n    if (isGif && fps > 50) {\n        throw new TypeError(`The FPS for a GIF cannot be higher than 50. Use the --every-nth-frame option to lower the FPS: https://remotion.dev/docs/render-as-gif`);\n    }\n}\n// src/resolve-video-config.ts\nvar validateCalculated = ({ calculated, compositionId, compositionFps, compositionHeight, compositionWidth, compositionDurationInFrames })=>{\n    const calculateMetadataErrorLocation = `calculated by calculateMetadata() for the composition \"${compositionId}\"`;\n    const defaultErrorLocation = `of the \"<Composition />\" component with the id \"${compositionId}\"`;\n    const width = calculated?.width ?? compositionWidth ?? undefined;\n    validateDimension(width, \"width\", calculated?.width ? calculateMetadataErrorLocation : defaultErrorLocation);\n    const height = calculated?.height ?? compositionHeight ?? undefined;\n    validateDimension(height, \"height\", calculated?.height ? calculateMetadataErrorLocation : defaultErrorLocation);\n    const fps = calculated?.fps ?? compositionFps ?? null;\n    validateFps(fps, calculated?.fps ? calculateMetadataErrorLocation : defaultErrorLocation, false);\n    const durationInFrames = calculated?.durationInFrames ?? compositionDurationInFrames ?? null;\n    validateDurationInFrames(durationInFrames, {\n        allowFloats: false,\n        component: `of the \"<Composition />\" component with the id \"${compositionId}\"`\n    });\n    const defaultCodec = calculated?.defaultCodec;\n    validateDefaultCodec(defaultCodec, calculateMetadataErrorLocation);\n    return {\n        width,\n        height,\n        fps,\n        durationInFrames,\n        defaultCodec\n    };\n};\nvar resolveVideoConfig = ({ calculateMetadata, signal, defaultProps, originalProps, compositionId, compositionDurationInFrames, compositionFps, compositionHeight, compositionWidth })=>{\n    const calculatedProm = calculateMetadata ? calculateMetadata({\n        defaultProps,\n        props: originalProps,\n        abortSignal: signal,\n        compositionId\n    }) : null;\n    if (calculatedProm !== null && typeof calculatedProm === \"object\" && \"then\" in calculatedProm) {\n        return calculatedProm.then((c)=>{\n            const { height, width, durationInFrames, fps, defaultCodec } = validateCalculated({\n                calculated: c,\n                compositionDurationInFrames,\n                compositionFps,\n                compositionHeight,\n                compositionWidth,\n                compositionId\n            });\n            return {\n                width,\n                height,\n                fps,\n                durationInFrames,\n                id: compositionId,\n                defaultProps: serializeThenDeserializeInStudio(defaultProps),\n                props: serializeThenDeserializeInStudio(c.props ?? originalProps),\n                defaultCodec: defaultCodec ?? null\n            };\n        });\n    }\n    const data = validateCalculated({\n        calculated: calculatedProm,\n        compositionDurationInFrames,\n        compositionFps,\n        compositionHeight,\n        compositionWidth,\n        compositionId\n    });\n    if (calculatedProm === null) {\n        return {\n            ...data,\n            id: compositionId,\n            defaultProps: serializeThenDeserializeInStudio(defaultProps ?? {}),\n            props: serializeThenDeserializeInStudio(originalProps),\n            defaultCodec: null\n        };\n    }\n    return {\n        ...data,\n        id: compositionId,\n        defaultProps: serializeThenDeserializeInStudio(defaultProps ?? {}),\n        props: serializeThenDeserializeInStudio(calculatedProm.props ?? originalProps),\n        defaultCodec: calculatedProm.defaultCodec ?? null\n    };\n};\nvar resolveVideoConfigOrCatch = (params)=>{\n    try {\n        const promiseOrReturnValue = resolveVideoConfig(params);\n        return {\n            type: \"success\",\n            result: promiseOrReturnValue\n        };\n    } catch (err) {\n        return {\n            type: \"error\",\n            error: err\n        };\n    }\n};\n// src/ResolveCompositionConfig.tsx\n\nvar ResolveCompositionContext = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_0__.createContext)(null);\nvar resolveCompositionsRef = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_0__.createRef)();\nvar needsResolution = (composition)=>{\n    return Boolean(composition.calculateMetadata);\n};\nvar PROPS_UPDATED_EXTERNALLY = \"remotion.propsUpdatedExternally\";\nvar ResolveCompositionConfig = ({ children })=>{\n    const [currentRenderModalComposition, setCurrentRenderModalComposition] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(null);\n    const { compositions, canvasContent, currentCompositionMetadata } = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(CompositionManager);\n    const { fastRefreshes } = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(NonceContext);\n    const selectedComposition = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>{\n        return compositions.find((c)=>canvasContent && canvasContent.type === \"composition\" && canvasContent.compositionId === c.id);\n    }, [\n        canvasContent,\n        compositions\n    ]);\n    const renderModalComposition = compositions.find((c)=>c.id === currentRenderModalComposition);\n    const { props: allEditorProps } = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(EditorPropsContext);\n    const inputProps = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>{\n        return  true ? {} : 0;\n    }, []);\n    const [resolvedConfigs, setResolvedConfigs] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)({});\n    const selectedEditorProps = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>{\n        return selectedComposition ? allEditorProps[selectedComposition.id] ?? {} : {};\n    }, [\n        allEditorProps,\n        selectedComposition\n    ]);\n    const renderModalProps = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>{\n        return renderModalComposition ? allEditorProps[renderModalComposition.id] ?? {} : {};\n    }, [\n        allEditorProps,\n        renderModalComposition\n    ]);\n    const hasResolution = Boolean(currentCompositionMetadata);\n    const doResolution = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(({ calculateMetadata, combinedProps, compositionDurationInFrames, compositionFps, compositionHeight, compositionId, compositionWidth, defaultProps })=>{\n        const controller = new AbortController;\n        if (hasResolution) {\n            return controller;\n        }\n        const { signal } = controller;\n        const result = resolveVideoConfigOrCatch({\n            compositionId,\n            calculateMetadata,\n            originalProps: combinedProps,\n            signal,\n            defaultProps,\n            compositionDurationInFrames,\n            compositionFps,\n            compositionHeight,\n            compositionWidth\n        });\n        if (result.type === \"error\") {\n            setResolvedConfigs((r)=>({\n                    ...r,\n                    [compositionId]: {\n                        type: \"error\",\n                        error: result.error\n                    }\n                }));\n            return controller;\n        }\n        const promOrNot = result.result;\n        if (typeof promOrNot === \"object\" && \"then\" in promOrNot) {\n            setResolvedConfigs((r)=>{\n                const prev = r[compositionId];\n                if (prev?.type === \"success\" || prev?.type === \"success-and-refreshing\") {\n                    return {\n                        ...r,\n                        [compositionId]: {\n                            type: \"success-and-refreshing\",\n                            result: prev.result\n                        }\n                    };\n                }\n                return {\n                    ...r,\n                    [compositionId]: {\n                        type: \"loading\"\n                    }\n                };\n            });\n            promOrNot.then((c)=>{\n                if (controller.signal.aborted) {\n                    return;\n                }\n                setResolvedConfigs((r)=>({\n                        ...r,\n                        [compositionId]: {\n                            type: \"success\",\n                            result: c\n                        }\n                    }));\n            }).catch((err)=>{\n                if (controller.signal.aborted) {\n                    return;\n                }\n                setResolvedConfigs((r)=>({\n                        ...r,\n                        [compositionId]: {\n                            type: \"error\",\n                            error: err\n                        }\n                    }));\n            });\n        } else {\n            setResolvedConfigs((r)=>({\n                    ...r,\n                    [compositionId]: {\n                        type: \"success\",\n                        result: promOrNot\n                    }\n                }));\n        }\n        return controller;\n    }, [\n        hasResolution\n    ]);\n    const currentComposition = canvasContent?.type === \"composition\" ? canvasContent.compositionId : null;\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useImperativeHandle)(resolveCompositionsRef, ()=>{\n        return {\n            setCurrentRenderModalComposition: (id)=>{\n                setCurrentRenderModalComposition(id);\n            },\n            reloadCurrentlySelectedComposition: ()=>{\n                if (!currentComposition) {\n                    return;\n                }\n                const composition = compositions.find((c)=>c.id === currentComposition);\n                if (!composition) {\n                    throw new Error(`Could not find composition with id ${currentComposition}`);\n                }\n                const editorProps = allEditorProps[currentComposition] ?? {};\n                const defaultProps = {\n                    ...composition.defaultProps ?? {},\n                    ...editorProps ?? {}\n                };\n                const props = {\n                    ...defaultProps,\n                    ...inputProps ?? {}\n                };\n                doResolution({\n                    defaultProps,\n                    calculateMetadata: composition.calculateMetadata,\n                    combinedProps: props,\n                    compositionDurationInFrames: composition.durationInFrames ?? null,\n                    compositionFps: composition.fps ?? null,\n                    compositionHeight: composition.height ?? null,\n                    compositionWidth: composition.width ?? null,\n                    compositionId: composition.id\n                });\n            }\n        };\n    }, [\n        allEditorProps,\n        compositions,\n        currentComposition,\n        doResolution,\n        inputProps\n    ]);\n    const isTheSame = selectedComposition?.id === renderModalComposition?.id;\n    const currentDefaultProps = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>{\n        return {\n            ...selectedComposition?.defaultProps ?? {},\n            ...selectedEditorProps ?? {}\n        };\n    }, [\n        selectedComposition?.defaultProps,\n        selectedEditorProps\n    ]);\n    const originalProps = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>{\n        return {\n            ...currentDefaultProps,\n            ...inputProps ?? {}\n        };\n    }, [\n        currentDefaultProps,\n        inputProps\n    ]);\n    const canResolve = selectedComposition && needsResolution(selectedComposition);\n    const shouldIgnoreUpdate =  false && 0;\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        if (shouldIgnoreUpdate) {\n            return;\n        }\n        if (canResolve) {\n            const controller = doResolution({\n                calculateMetadata: selectedComposition.calculateMetadata,\n                combinedProps: originalProps,\n                compositionDurationInFrames: selectedComposition.durationInFrames ?? null,\n                compositionFps: selectedComposition.fps ?? null,\n                compositionHeight: selectedComposition.height ?? null,\n                compositionWidth: selectedComposition.width ?? null,\n                defaultProps: currentDefaultProps,\n                compositionId: selectedComposition.id\n            });\n            return ()=>{\n                controller.abort();\n            };\n        }\n    }, [\n        canResolve,\n        currentDefaultProps,\n        doResolution,\n        originalProps,\n        selectedComposition?.calculateMetadata,\n        selectedComposition?.durationInFrames,\n        selectedComposition?.fps,\n        selectedComposition?.height,\n        selectedComposition?.id,\n        selectedComposition?.width,\n        shouldIgnoreUpdate\n    ]);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        if (shouldIgnoreUpdate) {\n            return;\n        }\n        window.dispatchEvent(new CustomEvent(\"remotion.propsUpdatedExternally\"));\n    }, [\n        fastRefreshes\n    ]);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        if (renderModalComposition && !isTheSame) {\n            const combinedProps = {\n                ...renderModalComposition.defaultProps ?? {},\n                ...renderModalProps ?? {},\n                ...inputProps ?? {}\n            };\n            const controller = doResolution({\n                calculateMetadata: renderModalComposition.calculateMetadata,\n                compositionDurationInFrames: renderModalComposition.durationInFrames ?? null,\n                compositionFps: renderModalComposition.fps ?? null,\n                compositionHeight: renderModalComposition.height ?? null,\n                compositionId: renderModalComposition.id,\n                compositionWidth: renderModalComposition.width ?? null,\n                defaultProps: currentDefaultProps,\n                combinedProps\n            });\n            return ()=>{\n                controller.abort();\n            };\n        }\n    }, [\n        currentDefaultProps,\n        doResolution,\n        inputProps,\n        isTheSame,\n        renderModalComposition,\n        renderModalProps\n    ]);\n    const resolvedConfigsIncludingStaticOnes = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>{\n        const staticComps = compositions.filter((c)=>{\n            return c.calculateMetadata === null;\n        });\n        return {\n            ...resolvedConfigs,\n            ...staticComps.reduce((acc, curr)=>{\n                return {\n                    ...acc,\n                    [curr.id]: {\n                        type: \"success\",\n                        result: {\n                            ...curr,\n                            defaultProps: curr.defaultProps ?? {}\n                        }\n                    }\n                };\n            }, {})\n        };\n    }, [\n        compositions,\n        resolvedConfigs\n    ]);\n    return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(ResolveCompositionContext.Provider, {\n        value: resolvedConfigsIncludingStaticOnes,\n        children\n    });\n};\nvar useResolvedVideoConfig = (preferredCompositionId)=>{\n    const context = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(ResolveCompositionContext);\n    const { props: allEditorProps } = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(EditorPropsContext);\n    const { compositions, canvasContent, currentCompositionMetadata } = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(CompositionManager);\n    const currentComposition = canvasContent?.type === \"composition\" ? canvasContent.compositionId : null;\n    const compositionId = preferredCompositionId ?? currentComposition;\n    const composition = compositions.find((c)=>c.id === compositionId);\n    const selectedEditorProps = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>{\n        return composition ? allEditorProps[composition.id] ?? {} : {};\n    }, [\n        allEditorProps,\n        composition\n    ]);\n    return (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>{\n        if (!composition) {\n            return null;\n        }\n        if (currentCompositionMetadata) {\n            return {\n                type: \"success\",\n                result: {\n                    ...currentCompositionMetadata,\n                    id: composition.id,\n                    props: currentCompositionMetadata.props,\n                    defaultProps: composition.defaultProps ?? {},\n                    defaultCodec: currentCompositionMetadata.defaultCodec\n                }\n            };\n        }\n        if (!needsResolution(composition)) {\n            validateDurationInFrames(composition.durationInFrames, {\n                allowFloats: false,\n                component: `in <Composition id=\"${composition.id}\">`\n            });\n            validateFps(composition.fps, `in <Composition id=\"${composition.id}\">`, false);\n            validateDimension(composition.width, \"width\", `in <Composition id=\"${composition.id}\">`);\n            validateDimension(composition.height, \"height\", `in <Composition id=\"${composition.id}\">`);\n            return {\n                type: \"success\",\n                result: {\n                    width: composition.width,\n                    height: composition.height,\n                    fps: composition.fps,\n                    id: composition.id,\n                    durationInFrames: composition.durationInFrames,\n                    defaultProps: composition.defaultProps ?? {},\n                    props: {\n                        ...composition.defaultProps ?? {},\n                        ...selectedEditorProps ?? {},\n                        ... true ? {} : 0\n                    },\n                    defaultCodec: null\n                }\n            };\n        }\n        if (!context[composition.id]) {\n            return null;\n        }\n        return context[composition.id];\n    }, [\n        composition,\n        context,\n        currentCompositionMetadata,\n        selectedEditorProps\n    ]);\n};\n// src/use-video.ts\nvar useVideo = ()=>{\n    const { canvasContent, compositions, currentCompositionMetadata } = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(CompositionManager);\n    const selected = compositions.find((c)=>{\n        return canvasContent?.type === \"composition\" && c.id === canvasContent.compositionId;\n    });\n    const resolved = useResolvedVideoConfig(selected?.id ?? null);\n    return (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>{\n        if (!resolved) {\n            return null;\n        }\n        if (resolved.type === \"error\") {\n            return null;\n        }\n        if (resolved.type === \"loading\") {\n            return null;\n        }\n        if (!selected) {\n            return null;\n        }\n        return {\n            ...resolved.result,\n            defaultProps: selected.defaultProps ?? {},\n            id: selected.id,\n            ...currentCompositionMetadata ?? {},\n            component: selected.component\n        };\n    }, [\n        currentCompositionMetadata,\n        resolved,\n        selected\n    ]);\n};\n// src/timeline-position-state.ts\nvar TimelineContext = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_0__.createContext)({\n    frame: {},\n    playing: false,\n    playbackRate: 1,\n    rootId: \"\",\n    imperativePlaying: {\n        current: false\n    },\n    setPlaybackRate: ()=>{\n        throw new Error(\"default\");\n    },\n    audioAndVideoTags: {\n        current: []\n    }\n});\nvar SetTimelineContext = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_0__.createContext)({\n    setFrame: ()=>{\n        throw new Error(\"default\");\n    },\n    setPlaying: ()=>{\n        throw new Error(\"default\");\n    }\n});\nvar makeKey = ()=>{\n    return `remotion.time-all`;\n};\nvar persistCurrentFrame = (time)=>{\n    localStorage.setItem(makeKey(), JSON.stringify(time));\n};\nvar getInitialFrameState = ()=>{\n    const item = localStorage.getItem(makeKey()) ?? \"{}\";\n    const obj = JSON.parse(item);\n    return obj;\n};\nvar getFrameForComposition = (composition)=>{\n    const item = localStorage.getItem(makeKey()) ?? \"{}\";\n    const obj = JSON.parse(item);\n    if (obj[composition] !== undefined) {\n        return Number(obj[composition]);\n    }\n    if (true) {\n        return 0;\n    }\n    return window.remotion_initialFrame ?? 0;\n};\nvar useTimelinePosition = ()=>{\n    const videoConfig = useVideo();\n    const state = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(TimelineContext);\n    if (!videoConfig) {\n        return  true ? 0 : 0;\n    }\n    const unclamped = state.frame[videoConfig.id] ?? (getRemotionEnvironment().isPlayer ? 0 : getFrameForComposition(videoConfig.id));\n    return Math.min(videoConfig.durationInFrames - 1, unclamped);\n};\nvar useTimelineSetFrame = ()=>{\n    const { setFrame } = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(SetTimelineContext);\n    return setFrame;\n};\nvar usePlayingState = ()=>{\n    const { playing, imperativePlaying } = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(TimelineContext);\n    const { setPlaying } = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(SetTimelineContext);\n    return (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>[\n            playing,\n            setPlaying,\n            imperativePlaying\n        ], [\n        imperativePlaying,\n        playing,\n        setPlaying\n    ]);\n};\n// src/use-video-config.ts\n\n// src/CanUseRemotionHooks.tsx\n\n\nvar CanUseRemotionHooks = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_0__.createContext)(false);\nvar CanUseRemotionHooksProvider = ({ children })=>{\n    return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(CanUseRemotionHooks.Provider, {\n        value: true,\n        children\n    });\n};\n// src/use-unsafe-video-config.ts\n\nvar useUnsafeVideoConfig = ()=>{\n    const context = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(SequenceContext);\n    const ctxWidth = context?.width ?? null;\n    const ctxHeight = context?.height ?? null;\n    const ctxDuration = context?.durationInFrames ?? null;\n    const video = useVideo();\n    return (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>{\n        if (!video) {\n            return null;\n        }\n        const { id, durationInFrames, fps, height, width, defaultProps, props, defaultCodec } = video;\n        return {\n            id,\n            width: ctxWidth ?? width,\n            height: ctxHeight ?? height,\n            fps,\n            durationInFrames: ctxDuration ?? durationInFrames,\n            defaultProps,\n            props,\n            defaultCodec\n        };\n    }, [\n        ctxDuration,\n        ctxHeight,\n        ctxWidth,\n        video\n    ]);\n};\n// src/use-video-config.ts\nvar useVideoConfig = ()=>{\n    const videoConfig = useUnsafeVideoConfig();\n    const context = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(CanUseRemotionHooks);\n    const isPlayer = useIsPlayer();\n    if (!videoConfig) {\n        if ( false || isPlayer) {\n            throw new Error([\n                \"No video config found. Likely reasons:\",\n                \"- You are probably calling useVideoConfig() from outside the component passed to <Player />. See https://www.remotion.dev/docs/player/examples for how to set up the Player correctly.\",\n                \"- You have multiple versions of Remotion installed which causes the React context to get lost.\"\n            ].join(\"-\"));\n        }\n        throw new Error(\"No video config found. You are probably calling useVideoConfig() from a component which has not been registered as a <Composition />. See https://www.remotion.dev/docs/the-fundamentals#defining-compositions for more information.\");\n    }\n    if (!context) {\n        throw new Error(\"Called useVideoConfig() outside a Remotion composition.\");\n    }\n    return videoConfig;\n};\n// src/freeze.tsx\n\n// src/use-current-frame.ts\n\nvar useCurrentFrame = ()=>{\n    const canUseRemotionHooks = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(CanUseRemotionHooks);\n    if (!canUseRemotionHooks) {\n        if (getRemotionEnvironment().isPlayer) {\n            throw new Error(`useCurrentFrame can only be called inside a component that was passed to <Player>. See: https://www.remotion.dev/docs/player/examples`);\n        }\n        throw new Error(`useCurrentFrame() can only be called inside a component that was registered as a composition. See https://www.remotion.dev/docs/the-fundamentals#defining-compositions`);\n    }\n    const frame = useTimelinePosition();\n    const context = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(SequenceContext);\n    const contextOffset = context ? context.cumulatedFrom + context.relativeFrom : 0;\n    return frame - contextOffset;\n};\n// src/freeze.tsx\n\nvar Freeze = ({ frame: frameToFreeze, children, active = true })=>{\n    const frame = useCurrentFrame();\n    const videoConfig = useVideoConfig();\n    if (typeof frameToFreeze === \"undefined\") {\n        throw new Error(`The <Freeze /> component requires a 'frame' prop, but none was passed.`);\n    }\n    if (typeof frameToFreeze !== \"number\") {\n        throw new Error(`The 'frame' prop of <Freeze /> must be a number, but is of type ${typeof frameToFreeze}`);\n    }\n    if (Number.isNaN(frameToFreeze)) {\n        throw new Error(`The 'frame' prop of <Freeze /> must be a real number, but it is NaN.`);\n    }\n    if (!Number.isFinite(frameToFreeze)) {\n        throw new Error(`The 'frame' prop of <Freeze /> must be a finite number, but it is ${frameToFreeze}.`);\n    }\n    const isActive = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>{\n        if (typeof active === \"boolean\") {\n            return active;\n        }\n        if (typeof active === \"function\") {\n            return active(frame);\n        }\n    }, [\n        active,\n        frame\n    ]);\n    const timelineContext = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(TimelineContext);\n    const sequenceContext = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(SequenceContext);\n    const relativeFrom = sequenceContext?.relativeFrom ?? 0;\n    const timelineValue = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>{\n        if (!isActive) {\n            return timelineContext;\n        }\n        return {\n            ...timelineContext,\n            playing: false,\n            imperativePlaying: {\n                current: false\n            },\n            frame: {\n                [videoConfig.id]: frameToFreeze + relativeFrom\n            }\n        };\n    }, [\n        isActive,\n        timelineContext,\n        videoConfig.id,\n        frameToFreeze,\n        relativeFrom\n    ]);\n    return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(TimelineContext.Provider, {\n        value: timelineValue,\n        children\n    });\n};\n// src/Sequence.tsx\n\nvar RegularSequenceRefForwardingFunction = ({ from = 0, durationInFrames = Infinity, children, name, height, width, showInTimeline = true, _remotionInternalLoopDisplay: loopDisplay, _remotionInternalStack: stack, _remotionInternalPremountDisplay: premountDisplay, ...other }, ref)=>{\n    const { layout = \"absolute-fill\" } = other;\n    const [id] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(()=>String(Math.random()));\n    const parentSequence = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(SequenceContext);\n    const { rootId } = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(TimelineContext);\n    const cumulatedFrom = parentSequence ? parentSequence.cumulatedFrom + parentSequence.relativeFrom : 0;\n    const nonce = useNonce();\n    if (layout !== \"absolute-fill\" && layout !== \"none\") {\n        throw new TypeError(`The layout prop of <Sequence /> expects either \"absolute-fill\" or \"none\", but you passed: ${layout}`);\n    }\n    if (layout === \"none\" && typeof other.style !== \"undefined\") {\n        throw new TypeError('If layout=\"none\", you may not pass a style.');\n    }\n    if (typeof durationInFrames !== \"number\") {\n        throw new TypeError(`You passed to durationInFrames an argument of type ${typeof durationInFrames}, but it must be a number.`);\n    }\n    if (durationInFrames <= 0) {\n        throw new TypeError(`durationInFrames must be positive, but got ${durationInFrames}`);\n    }\n    if (typeof from !== \"number\") {\n        throw new TypeError(`You passed to the \"from\" props of your <Sequence> an argument of type ${typeof from}, but it must be a number.`);\n    }\n    if (!Number.isFinite(from)) {\n        throw new TypeError(`The \"from\" prop of a sequence must be finite, but got ${from}.`);\n    }\n    const absoluteFrame = useTimelinePosition();\n    const videoConfig = useVideoConfig();\n    const parentSequenceDuration = parentSequence ? Math.min(parentSequence.durationInFrames - from, durationInFrames) : durationInFrames;\n    const actualDurationInFrames = Math.max(0, Math.min(videoConfig.durationInFrames - from, parentSequenceDuration));\n    const { registerSequence, unregisterSequence } = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(SequenceManager);\n    const { hidden } = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(SequenceVisibilityToggleContext);\n    const premounting = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>{\n        return parentSequence?.premounting ?? Boolean(other._remotionInternalIsPremounting);\n    }, [\n        other._remotionInternalIsPremounting,\n        parentSequence?.premounting\n    ]);\n    const contextValue = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>{\n        return {\n            cumulatedFrom,\n            relativeFrom: from,\n            durationInFrames: actualDurationInFrames,\n            parentFrom: parentSequence?.relativeFrom ?? 0,\n            id,\n            height: height ?? parentSequence?.height ?? null,\n            width: width ?? parentSequence?.width ?? null,\n            premounting\n        };\n    }, [\n        cumulatedFrom,\n        from,\n        actualDurationInFrames,\n        parentSequence,\n        id,\n        height,\n        width,\n        premounting\n    ]);\n    const timelineClipName = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>{\n        return name ?? \"\";\n    }, [\n        name\n    ]);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        if (!getRemotionEnvironment().isStudio) {\n            return;\n        }\n        registerSequence({\n            from,\n            duration: actualDurationInFrames,\n            id,\n            displayName: timelineClipName,\n            parent: parentSequence?.id ?? null,\n            type: \"sequence\",\n            rootId,\n            showInTimeline,\n            nonce,\n            loopDisplay,\n            stack: stack ?? null,\n            premountDisplay: premountDisplay ?? null\n        });\n        return ()=>{\n            unregisterSequence(id);\n        };\n    }, [\n        durationInFrames,\n        id,\n        name,\n        registerSequence,\n        timelineClipName,\n        unregisterSequence,\n        parentSequence?.id,\n        actualDurationInFrames,\n        rootId,\n        from,\n        showInTimeline,\n        nonce,\n        loopDisplay,\n        stack,\n        premountDisplay\n    ]);\n    const endThreshold = Math.ceil(cumulatedFrom + from + durationInFrames - 1);\n    const content = absoluteFrame < cumulatedFrom + from ? null : absoluteFrame > endThreshold ? null : children;\n    const styleIfThere = other.layout === \"none\" ? undefined : other.style;\n    const defaultStyle = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>{\n        return {\n            flexDirection: undefined,\n            ...width ? {\n                width\n            } : {},\n            ...height ? {\n                height\n            } : {},\n            ...styleIfThere ?? {}\n        };\n    }, [\n        height,\n        styleIfThere,\n        width\n    ]);\n    if (ref !== null && layout === \"none\") {\n        throw new TypeError('It is not supported to pass both a `ref` and `layout=\"none\"` to <Sequence />.');\n    }\n    const isSequenceHidden = hidden[id] ?? false;\n    if (isSequenceHidden) {\n        return null;\n    }\n    return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(SequenceContext.Provider, {\n        value: contextValue,\n        children: content === null ? null : other.layout === \"none\" ? content : /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(AbsoluteFill, {\n            ref,\n            style: defaultStyle,\n            className: other.className,\n            children: content\n        })\n    });\n};\nvar RegularSequence = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_0__.forwardRef)(RegularSequenceRefForwardingFunction);\nvar PremountedSequenceRefForwardingFunction = (props, ref)=>{\n    const frame = useCurrentFrame();\n    if (props.layout === \"none\") {\n        throw new Error('`<Sequence>` with `premountFor` prop does not support layout=\"none\"');\n    }\n    const { style: passedStyle, from = 0, premountFor = 0, ...otherProps } = props;\n    const premountingActive = frame < from && frame >= from - premountFor;\n    const style = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>{\n        return {\n            ...passedStyle,\n            opacity: premountingActive ? 0 : 1,\n            pointerEvents: premountingActive ? \"none\" : passedStyle?.pointerEvents ?? undefined\n        };\n    }, [\n        premountingActive,\n        passedStyle\n    ]);\n    return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(Freeze, {\n        frame: from,\n        active: premountingActive,\n        children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(Sequence, {\n            ref,\n            from,\n            style,\n            _remotionInternalPremountDisplay: premountFor,\n            _remotionInternalIsPremounting: premountingActive,\n            ...otherProps\n        })\n    });\n};\nvar PremountedSequence = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_0__.forwardRef)(PremountedSequenceRefForwardingFunction);\nvar SequenceRefForwardingFunction = (props, ref)=>{\n    if (props.layout !== \"none\" && props.premountFor && !getRemotionEnvironment().isRendering) {\n        return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(PremountedSequence, {\n            ...props,\n            ref\n        });\n    }\n    return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(RegularSequence, {\n        ...props,\n        ref\n    });\n};\nvar Sequence = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_0__.forwardRef)(SequenceRefForwardingFunction);\n// src/Artifact.tsx\n\n// src/RenderAssetManager.tsx\n\n// src/validation/validate-artifact.ts\nvar validateArtifactFilename = (filename)=>{\n    if (typeof filename !== \"string\") {\n        throw new TypeError(`The \"filename\" must be a string, but you passed a value of type ${typeof filename}`);\n    }\n    if (filename.trim() === \"\") {\n        throw new Error(\"The `filename` must not be empty\");\n    }\n    if (!filename.match(/^([0-9a-zA-Z-!_.*'()/:&$@=;+,?]+)/g)) {\n        throw new Error('The `filename` must match \"/^([0-9a-zA-Z-!_.*\\'()/:&$@=;+,?]+)/g\". Use forward slashes only, even on Windows.');\n    }\n};\nvar validateContent = (content)=>{\n    if (typeof content !== \"string\" && !(content instanceof Uint8Array)) {\n        throw new TypeError(`The \"content\" must be a string or Uint8Array, but you passed a value of type ${typeof content}`);\n    }\n    if (typeof content === \"string\" && content.trim() === \"\") {\n        throw new Error(\"The `content` must not be empty\");\n    }\n};\nvar validateRenderAsset = (artifact)=>{\n    if (artifact.type !== \"artifact\") {\n        return;\n    }\n    validateArtifactFilename(artifact.filename);\n    validateContent(artifact.content);\n};\n// src/RenderAssetManager.tsx\n\nvar RenderAssetManager = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_0__.createContext)({\n    registerRenderAsset: ()=>{\n        return;\n    },\n    unregisterRenderAsset: ()=>{\n        return;\n    },\n    renderAssets: []\n});\nvar RenderAssetManagerProvider = ({ children })=>{\n    const [renderAssets, setRenderAssets] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)([]);\n    const registerRenderAsset = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((renderAsset)=>{\n        validateRenderAsset(renderAsset);\n        setRenderAssets((assets)=>{\n            return [\n                ...assets,\n                renderAsset\n            ];\n        });\n    }, []);\n    const unregisterRenderAsset = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((id)=>{\n        setRenderAssets((assts)=>{\n            return assts.filter((a)=>a.id !== id);\n        });\n    }, []);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useLayoutEffect)(()=>{\n        if (false) {}\n    }, [\n        renderAssets\n    ]);\n    const contextValue = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>{\n        return {\n            registerRenderAsset,\n            unregisterRenderAsset,\n            renderAssets\n        };\n    }, [\n        renderAssets,\n        registerRenderAsset,\n        unregisterRenderAsset\n    ]);\n    return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(RenderAssetManager.Provider, {\n        value: contextValue,\n        children\n    });\n};\n// src/Artifact.tsx\nvar Artifact = ({ filename, content })=>{\n    const { registerRenderAsset, unregisterRenderAsset } = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(RenderAssetManager);\n    const [env] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(()=>getRemotionEnvironment());\n    const frame = useCurrentFrame();\n    const [id] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(()=>{\n        return String(Math.random());\n    });\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        if (!env.isRendering) {\n            return;\n        }\n        if (content instanceof Uint8Array) {\n            registerRenderAsset({\n                type: \"artifact\",\n                id,\n                content: btoa(new TextDecoder(\"utf8\").decode(content)),\n                filename,\n                frame,\n                binary: true\n            });\n        } else {\n            registerRenderAsset({\n                type: \"artifact\",\n                id,\n                content,\n                filename,\n                frame,\n                binary: false\n            });\n        }\n        return ()=>{\n            return unregisterRenderAsset(id);\n        };\n    }, [\n        content,\n        env.isRendering,\n        filename,\n        frame,\n        id,\n        registerRenderAsset,\n        unregisterRenderAsset\n    ]);\n    return null;\n};\n// src/audio/Audio.tsx\n\n// src/absolute-src.ts\nvar getAbsoluteSrc = (relativeSrc)=>{\n    if (true) {\n        return relativeSrc;\n    }\n    return new URL(relativeSrc, window.origin).href;\n};\n// src/calculate-loop.ts\nvar calculateLoopDuration = ({ endAt, mediaDuration, playbackRate, startFrom })=>{\n    let duration = mediaDuration;\n    if (typeof endAt !== \"undefined\") {\n        duration = endAt;\n    }\n    if (typeof startFrom !== \"undefined\") {\n        duration -= startFrom;\n    }\n    const actualDuration = duration / playbackRate;\n    return Math.floor(actualDuration);\n};\n// src/cancel-render.ts\nfunction cancelRender(err) {\n    let error;\n    if (isErrorLike(err)) {\n        error = err;\n        if (!error.stack) {\n            error.stack = new Error(error.message).stack;\n        }\n    } else if (typeof err === \"string\") {\n        error = Error(err);\n    } else {\n        error = Error(\"Rendering was cancelled\");\n    }\n    window.remotion_cancelledError = error.stack;\n    throw error;\n}\nvar isErrorLike = (err)=>{\n    if (err instanceof Error) {\n        return true;\n    }\n    if (err === null) {\n        return false;\n    }\n    if (typeof err !== \"object\") {\n        return false;\n    }\n    if (!(\"stack\" in err)) {\n        return false;\n    }\n    if (typeof err.stack !== \"string\") {\n        return false;\n    }\n    if (!(\"message\" in err)) {\n        return false;\n    }\n    if (typeof err.message !== \"string\") {\n        return false;\n    }\n    return true;\n};\n// src/loop/index.tsx\n\n\nvar LoopContext = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_0__.createContext)(null);\nvar useLoop = ()=>{\n    return react__WEBPACK_IMPORTED_MODULE_0__.useContext(LoopContext);\n};\nvar Loop = ({ durationInFrames, times = Infinity, children, name, ...props })=>{\n    const currentFrame = useCurrentFrame();\n    const { durationInFrames: compDuration } = useVideoConfig();\n    validateDurationInFrames(durationInFrames, {\n        component: \"of the <Loop /> component\",\n        allowFloats: true\n    });\n    if (typeof times !== \"number\") {\n        throw new TypeError(`You passed to \"times\" an argument of type ${typeof times}, but it must be a number.`);\n    }\n    if (times !== Infinity && times % 1 !== 0) {\n        throw new TypeError(`The \"times\" prop of a loop must be an integer, but got ${times}.`);\n    }\n    if (times < 0) {\n        throw new TypeError(`The \"times\" prop of a loop must be at least 0, but got ${times}`);\n    }\n    const maxTimes = Math.ceil(compDuration / durationInFrames);\n    const actualTimes = Math.min(maxTimes, times);\n    const style = props.layout === \"none\" ? undefined : props.style;\n    const maxFrame = durationInFrames * (actualTimes - 1);\n    const iteration = Math.floor(currentFrame / durationInFrames);\n    const start = iteration * durationInFrames;\n    const from = Math.min(start, maxFrame);\n    const loopDisplay = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>{\n        return {\n            numberOfTimes: actualTimes,\n            startOffset: -from,\n            durationInFrames\n        };\n    }, [\n        actualTimes,\n        durationInFrames,\n        from\n    ]);\n    const loopContext = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>{\n        return {\n            iteration: Math.floor(currentFrame / durationInFrames),\n            durationInFrames\n        };\n    }, [\n        currentFrame,\n        durationInFrames\n    ]);\n    return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(LoopContext.Provider, {\n        value: loopContext,\n        children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(Sequence, {\n            durationInFrames,\n            from,\n            name: name ?? \"<Loop>\",\n            _remotionInternalLoopDisplay: loopDisplay,\n            layout: props.layout,\n            style,\n            children\n        })\n    });\n};\nLoop.useLoop = useLoop;\n// src/prefetch.ts\n\n// src/prefetch-state.tsx\n\n\nvar PreloadContext = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_0__.createContext)({});\nvar preloads = {};\nvar updaters = [];\nvar setPreloads = (updater)=>{\n    preloads = updater(preloads);\n    updaters.forEach((u)=>u());\n};\nvar PrefetchProvider = ({ children })=>{\n    const [_preloads, _setPreloads] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(()=>preloads);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        const updaterFunction = ()=>{\n            _setPreloads(preloads);\n        };\n        updaters.push(updaterFunction);\n        return ()=>{\n            updaters = updaters.filter((u)=>u !== updaterFunction);\n        };\n    }, []);\n    return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(PreloadContext.Provider, {\n        value: _preloads,\n        children\n    });\n};\n// src/prefetch.ts\nvar usePreload = (src)=>{\n    const preloads2 = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(PreloadContext);\n    return preloads2[src] ?? src;\n};\nvar blobToBase64 = function(blob) {\n    const reader = new FileReader;\n    return new Promise((resolve, reject)=>{\n        reader.onload = function() {\n            const dataUrl = reader.result;\n            resolve(dataUrl);\n        };\n        reader.onerror = (err)=>{\n            return reject(err);\n        };\n        reader.readAsDataURL(blob);\n    });\n};\nvar getBlobFromReader = async ({ reader, contentType, contentLength, onProgress })=>{\n    let receivedLength = 0;\n    const chunks = [];\n    while(true){\n        const { done, value } = await reader.read();\n        if (done) {\n            break;\n        }\n        chunks.push(value);\n        receivedLength += value.length;\n        if (onProgress) {\n            onProgress({\n                loadedBytes: receivedLength,\n                totalBytes: contentLength\n            });\n        }\n    }\n    const chunksAll = new Uint8Array(receivedLength);\n    let position = 0;\n    for (const chunk of chunks){\n        chunksAll.set(chunk, position);\n        position += chunk.length;\n    }\n    return new Blob([\n        chunksAll\n    ], {\n        type: contentType ?? undefined\n    });\n};\nvar prefetch = (src, options)=>{\n    const method = options?.method ?? \"blob-url\";\n    if (getRemotionEnvironment().isRendering) {\n        return {\n            free: ()=>{\n                return;\n            },\n            waitUntilDone: ()=>Promise.resolve(src)\n        };\n    }\n    let canceled = false;\n    let objectUrl = null;\n    let resolve = ()=>{\n        return;\n    };\n    let reject = ()=>{\n        return;\n    };\n    const waitUntilDone = new Promise((res, rej)=>{\n        resolve = res;\n        reject = rej;\n    });\n    const controller = new AbortController;\n    let canBeAborted = true;\n    fetch(src, {\n        signal: controller.signal\n    }).then((res)=>{\n        canBeAborted = false;\n        if (canceled) {\n            return null;\n        }\n        if (!res.ok) {\n            throw new Error(`HTTP error, status = ${res.status}`);\n        }\n        const headerContentType = res.headers.get(\"Content-Type\");\n        const contentType = options?.contentType ?? headerContentType;\n        const hasProperContentType = contentType && (contentType.startsWith(\"video/\") || contentType.startsWith(\"audio/\") || contentType.startsWith(\"image/\"));\n        if (!hasProperContentType) {\n            console.warn(`Called prefetch() on ${src} which returned a \"Content-Type\" of ${headerContentType}. Prefetched content should have a proper content type (video/... or audio/...) or a contentType passed the options of prefetch(). Otherwise, prefetching will not work properly in all browsers.`);\n        }\n        if (!res.body) {\n            throw new Error(`HTTP response of ${src} has no body`);\n        }\n        const reader = res.body.getReader();\n        return getBlobFromReader({\n            reader,\n            contentType: options?.contentType ?? headerContentType ?? null,\n            contentLength: res.headers.get(\"Content-Length\") ? parseInt(res.headers.get(\"Content-Length\"), 10) : null,\n            onProgress: options?.onProgress\n        });\n    }).then((buf)=>{\n        if (!buf) {\n            return;\n        }\n        const actualBlob = options?.contentType ? new Blob([\n            buf\n        ], {\n            type: options.contentType\n        }) : buf;\n        if (method === \"base64\") {\n            return blobToBase64(actualBlob);\n        }\n        return URL.createObjectURL(actualBlob);\n    }).then((url)=>{\n        if (canceled) {\n            return;\n        }\n        objectUrl = url;\n        setPreloads((p)=>({\n                ...p,\n                [src]: objectUrl\n            }));\n        resolve(objectUrl);\n    }).catch((err)=>{\n        reject(err);\n    });\n    return {\n        free: ()=>{\n            if (objectUrl) {\n                if (method === \"blob-url\") {\n                    URL.revokeObjectURL(objectUrl);\n                }\n                setPreloads((p)=>{\n                    const copy = {\n                        ...p\n                    };\n                    delete copy[src];\n                    return copy;\n                });\n            } else {\n                canceled = true;\n                if (canBeAborted) {\n                    try {\n                        controller.abort(new Error(\"free() called\"));\n                    } catch (e) {}\n                }\n            }\n        },\n        waitUntilDone: ()=>{\n            return waitUntilDone;\n        }\n    };\n};\n// src/validate-media-props.ts\nvar validateMediaProps = (props, component)=>{\n    if (typeof props.volume !== \"number\" && typeof props.volume !== \"function\" && typeof props.volume !== \"undefined\") {\n        throw new TypeError(`You have passed a volume of type ${typeof props.volume} to your <${component} /> component. Volume must be a number or a function with the signature '(frame: number) => number' undefined.`);\n    }\n    if (typeof props.volume === \"number\" && props.volume < 0) {\n        throw new TypeError(`You have passed a volume below 0 to your <${component} /> component. Volume must be between 0 and 1`);\n    }\n    if (typeof props.playbackRate !== \"number\" && typeof props.playbackRate !== \"undefined\") {\n        throw new TypeError(`You have passed a playbackRate of type ${typeof props.playbackRate} to your <${component} /> component. Playback rate must a real number or undefined.`);\n    }\n    if (typeof props.playbackRate === \"number\" && (isNaN(props.playbackRate) || !Number.isFinite(props.playbackRate) || props.playbackRate <= 0)) {\n        throw new TypeError(`You have passed a playbackRate of ${props.playbackRate} to your <${component} /> component. Playback rate must be a real number above 0.`);\n    }\n};\n// src/validate-start-from-props.ts\nvar validateStartFromProps = (startFrom, endAt)=>{\n    if (typeof startFrom !== \"undefined\") {\n        if (typeof startFrom !== \"number\") {\n            throw new TypeError(`type of startFrom prop must be a number, instead got type ${typeof startFrom}.`);\n        }\n        if (isNaN(startFrom) || startFrom === Infinity) {\n            throw new TypeError(\"startFrom prop can not be NaN or Infinity.\");\n        }\n        if (startFrom < 0) {\n            throw new TypeError(`startFrom must be greater than equal to 0 instead got ${startFrom}.`);\n        }\n    }\n    if (typeof endAt !== \"undefined\") {\n        if (typeof endAt !== \"number\") {\n            throw new TypeError(`type of endAt prop must be a number, instead got type ${typeof endAt}.`);\n        }\n        if (isNaN(endAt)) {\n            throw new TypeError(\"endAt prop can not be NaN.\");\n        }\n        if (endAt <= 0) {\n            throw new TypeError(`endAt must be a positive number, instead got ${endAt}.`);\n        }\n    }\n    if (endAt < startFrom) {\n        throw new TypeError(\"endAt prop must be greater than startFrom prop.\");\n    }\n};\n// src/video/duration-state.tsx\n\n\nvar durationReducer = (state, action)=>{\n    switch(action.type){\n        case \"got-duration\":\n            {\n                const absoluteSrc = getAbsoluteSrc(action.src);\n                if (state[absoluteSrc] === action.durationInSeconds) {\n                    return state;\n                }\n                return {\n                    ...state,\n                    [absoluteSrc]: action.durationInSeconds\n                };\n            }\n        default:\n            return state;\n    }\n};\nvar DurationsContext = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_0__.createContext)({\n    durations: {},\n    setDurations: ()=>{\n        throw new Error(\"context missing\");\n    }\n});\nvar DurationsContextProvider = ({ children })=>{\n    const [durations, setDurations] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useReducer)(durationReducer, {});\n    const value = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>{\n        return {\n            durations,\n            setDurations\n        };\n    }, [\n        durations\n    ]);\n    return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(DurationsContext.Provider, {\n        value,\n        children\n    });\n};\n// src/audio/AudioForPreview.tsx\n\n// src/random.ts\nfunction mulberry32(a) {\n    let t = a + 1831565813;\n    t = Math.imul(t ^ t >>> 15, t | 1);\n    t ^= t + Math.imul(t ^ t >>> 7, t | 61);\n    return ((t ^ t >>> 14) >>> 0) / 4294967296;\n}\nfunction hashCode(str) {\n    let i = 0;\n    let chr = 0;\n    let hash = 0;\n    for(i = 0; i < str.length; i++){\n        chr = str.charCodeAt(i);\n        hash = (hash << 5) - hash + chr;\n        hash |= 0;\n    }\n    return hash;\n}\nvar random = (seed, dummy)=>{\n    if (dummy !== undefined) {\n        throw new TypeError(\"random() takes only one argument\");\n    }\n    if (seed === null) {\n        return Math.random();\n    }\n    if (typeof seed === \"string\") {\n        return mulberry32(hashCode(seed));\n    }\n    if (typeof seed === \"number\") {\n        return mulberry32(seed * 10000000000);\n    }\n    throw new Error(\"random() argument must be a number or a string\");\n};\n// src/use-media-in-timeline.ts\n\n// src/audio/use-audio-frame.ts\n\nvar useMediaStartsAt = ()=>{\n    const parentSequence = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(SequenceContext);\n    const startsAt = Math.min(0, parentSequence?.relativeFrom ?? 0);\n    return startsAt;\n};\nvar useFrameForVolumeProp = (behavior)=>{\n    const loop = Loop.useLoop();\n    const frame = useCurrentFrame();\n    const startsAt = useMediaStartsAt();\n    if (behavior === \"repeat\" || loop === null) {\n        return frame + startsAt;\n    }\n    return frame + startsAt + loop.durationInFrames * loop.iteration;\n};\n// src/get-asset-file-name.ts\nvar getAssetDisplayName = (filename)=>{\n    if (/data:|blob:/.test(filename.substring(0, 5))) {\n        return \"Data URL\";\n    }\n    const splitted = filename.split(\"/\").map((s)=>s.split(\"\\\\\")).flat(1);\n    return splitted[splitted.length - 1];\n};\n// src/play-and-handle-not-allowed-error.ts\nvar playAndHandleNotAllowedError = (mediaRef, mediaType, onAutoPlayError)=>{\n    const { current } = mediaRef;\n    if (!current) {\n        return;\n    }\n    const prom = current.play();\n    if (prom.catch) {\n        prom.catch((err)=>{\n            if (!current) {\n                return;\n            }\n            if (err.message.includes(\"request was interrupted by a call to pause\")) {\n                return;\n            }\n            if (err.message.includes(\"The operation was aborted.\")) {\n                return;\n            }\n            if (err.message.includes(\"The fetching process for the media resource was aborted by the user agent\")) {\n                return;\n            }\n            if (err.message.includes(\"request was interrupted by a new load request\")) {\n                return;\n            }\n            if (err.message.includes(\"because the media was removed from the document\")) {\n                return;\n            }\n            console.log(`Could not play ${mediaType} due to following error: `, err);\n            if (!current.muted) {\n                if (onAutoPlayError) {\n                    onAutoPlayError();\n                    return;\n                }\n                console.log(`The video will be muted and we'll retry playing it.`);\n                if (mediaType === \"video\" && getRemotionEnvironment().isPlayer) {\n                    console.log(\"Use onAutoPlayError() to handle this error yourself.\");\n                }\n                current.muted = true;\n                current.play();\n            }\n        });\n    }\n};\n// src/volume-prop.ts\nvar evaluateVolume = ({ frame, volume, mediaVolume = 1, allowAmplificationDuringRender })=>{\n    const maxVolume = allowAmplificationDuringRender ? Infinity : 1;\n    if (typeof volume === \"number\") {\n        return Math.min(maxVolume, volume * mediaVolume);\n    }\n    if (typeof volume === \"undefined\") {\n        return Number(mediaVolume);\n    }\n    const evaluated = volume(frame) * mediaVolume;\n    if (typeof evaluated !== \"number\") {\n        throw new TypeError(`You passed in a a function to the volume prop but it did not return a number but a value of type ${typeof evaluated} for frame ${frame}`);\n    }\n    if (Number.isNaN(evaluated)) {\n        throw new TypeError(`You passed in a function to the volume prop but it returned NaN for frame ${frame}.`);\n    }\n    if (!Number.isFinite(evaluated)) {\n        throw new TypeError(`You passed in a function to the volume prop but it returned a non-finite number for frame ${frame}.`);\n    }\n    return Math.max(0, Math.min(maxVolume, evaluated));\n};\n// src/use-media-in-timeline.ts\nvar didWarn2 = {};\nvar warnOnce2 = (message)=>{\n    if (didWarn2[message]) {\n        return;\n    }\n    console.warn(message);\n    didWarn2[message] = true;\n};\nvar useMediaInTimeline = ({ volume, mediaVolume, mediaRef, src, mediaType, playbackRate, displayName, id, stack, showInTimeline, premountDisplay, onAutoPlayError })=>{\n    const videoConfig = useVideoConfig();\n    const { rootId, audioAndVideoTags } = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(TimelineContext);\n    const parentSequence = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(SequenceContext);\n    const actualFrom = parentSequence ? parentSequence.relativeFrom + parentSequence.cumulatedFrom : 0;\n    const [playing] = usePlayingState();\n    const startsAt = useMediaStartsAt();\n    const { registerSequence, unregisterSequence } = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(SequenceManager);\n    const [initialVolume] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(()=>volume);\n    const nonce = useNonce();\n    const duration = parentSequence ? Math.min(parentSequence.durationInFrames, videoConfig.durationInFrames) : videoConfig.durationInFrames;\n    const doesVolumeChange = typeof volume === \"function\";\n    const volumes = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>{\n        if (typeof volume === \"number\") {\n            return volume;\n        }\n        return new Array(Math.floor(Math.max(0, duration + startsAt))).fill(true).map((_, i)=>{\n            return evaluateVolume({\n                frame: i + startsAt,\n                volume,\n                mediaVolume,\n                allowAmplificationDuringRender: false\n            });\n        }).join(\",\");\n    }, [\n        duration,\n        startsAt,\n        volume,\n        mediaVolume\n    ]);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        if (typeof volume === \"number\" && volume !== initialVolume) {\n            warnOnce2(`Remotion: The ${mediaType} with src ${src} has changed it's volume. Prefer the callback syntax for setting volume to get better timeline display: https://www.remotion.dev/docs/using-audio/#controlling-volume`);\n        }\n    }, [\n        initialVolume,\n        mediaType,\n        src,\n        volume\n    ]);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        if (!mediaRef.current) {\n            return;\n        }\n        if (!src) {\n            throw new Error(\"No src passed\");\n        }\n        if (!getRemotionEnvironment().isStudio && window.process?.env?.NODE_ENV !== \"test\") {\n            return;\n        }\n        if (!showInTimeline) {\n            return;\n        }\n        registerSequence({\n            type: mediaType,\n            src,\n            id,\n            duration,\n            from: 0,\n            parent: parentSequence?.id ?? null,\n            displayName: displayName ?? getAssetDisplayName(src),\n            rootId,\n            volume: volumes,\n            showInTimeline: true,\n            nonce,\n            startMediaFrom: 0 - startsAt,\n            doesVolumeChange,\n            loopDisplay: undefined,\n            playbackRate,\n            stack,\n            premountDisplay\n        });\n        return ()=>{\n            unregisterSequence(id);\n        };\n    }, [\n        actualFrom,\n        duration,\n        id,\n        parentSequence,\n        src,\n        registerSequence,\n        rootId,\n        unregisterSequence,\n        videoConfig,\n        volumes,\n        doesVolumeChange,\n        nonce,\n        mediaRef,\n        mediaType,\n        startsAt,\n        playbackRate,\n        displayName,\n        stack,\n        showInTimeline,\n        premountDisplay\n    ]);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        const tag = {\n            id,\n            play: ()=>{\n                if (!playing) {\n                    return;\n                }\n                return playAndHandleNotAllowedError(mediaRef, mediaType, onAutoPlayError);\n            }\n        };\n        audioAndVideoTags.current.push(tag);\n        return ()=>{\n            audioAndVideoTags.current = audioAndVideoTags.current.filter((a)=>a.id !== id);\n        };\n    }, [\n        audioAndVideoTags,\n        id,\n        mediaRef,\n        mediaType,\n        onAutoPlayError,\n        playing\n    ]);\n};\n// src/use-media-playback.ts\n\n// src/buffer-until-first-frame.ts\n\n// src/use-buffer-state.ts\n\n// src/buffering.tsx\n\n\nvar useBufferManager = ()=>{\n    const [blocks, setBlocks] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)([]);\n    const [onBufferingCallbacks, setOnBufferingCallbacks] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)([]);\n    const [onResumeCallbacks, setOnResumeCallbacks] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)([]);\n    const buffering = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(false);\n    const addBlock = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((block)=>{\n        setBlocks((b)=>[\n                ...b,\n                block\n            ]);\n        return {\n            unblock: ()=>{\n                setBlocks((b)=>{\n                    const newArr = b.filter((bx)=>bx !== block);\n                    if (newArr.length === b.length) {\n                        return b;\n                    }\n                    return newArr;\n                });\n            }\n        };\n    }, []);\n    const listenForBuffering = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((callback)=>{\n        setOnBufferingCallbacks((c)=>[\n                ...c,\n                callback\n            ]);\n        return {\n            remove: ()=>{\n                setOnBufferingCallbacks((c)=>c.filter((cb)=>cb !== callback));\n            }\n        };\n    }, []);\n    const listenForResume = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((callback)=>{\n        setOnResumeCallbacks((c)=>[\n                ...c,\n                callback\n            ]);\n        return {\n            remove: ()=>{\n                setOnResumeCallbacks((c)=>c.filter((cb)=>cb !== callback));\n            }\n        };\n    }, []);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        if (blocks.length > 0) {\n            onBufferingCallbacks.forEach((c)=>c());\n        }\n    }, [\n        blocks\n    ]);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        if (blocks.length === 0) {\n            onResumeCallbacks.forEach((c)=>c());\n        }\n    }, [\n        blocks\n    ]);\n    return (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>{\n        return {\n            addBlock,\n            listenForBuffering,\n            listenForResume,\n            buffering\n        };\n    }, [\n        addBlock,\n        buffering,\n        listenForBuffering,\n        listenForResume\n    ]);\n};\nvar BufferingContextReact = /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createContext(null);\nvar BufferingProvider = ({ children })=>{\n    const bufferManager = useBufferManager();\n    return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(BufferingContextReact.Provider, {\n        value: bufferManager,\n        children\n    });\n};\nvar useIsPlayerBuffering = (bufferManager)=>{\n    const [isBuffering, setIsBuffering] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(bufferManager.buffering.current);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        const onBuffer = ()=>{\n            setIsBuffering(true);\n        };\n        const onResume = ()=>{\n            setIsBuffering(false);\n        };\n        bufferManager.listenForBuffering(onBuffer);\n        bufferManager.listenForResume(onResume);\n        return ()=>{\n            bufferManager.listenForBuffering(()=>{\n                return;\n            });\n            bufferManager.listenForResume(()=>{\n                return;\n            });\n        };\n    }, [\n        bufferManager\n    ]);\n    return isBuffering;\n};\n// src/use-buffer-state.ts\nvar useBufferState = ()=>{\n    const buffer = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(BufferingContextReact);\n    const addBlock = buffer ? buffer.addBlock : null;\n    return (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>({\n            delayPlayback: ()=>{\n                if (!addBlock) {\n                    throw new Error(\"Tried to enable the buffering state, but a Remotion context was not found. This API can only be called in a component that was passed to the Remotion Player or a <Composition>. Or you might have experienced a version mismatch - run `npx remotion versions` and ensure all packages have the same version. This error is thrown by the buffer state https://remotion.dev/docs/player/buffer-state\");\n                }\n                const { unblock } = addBlock({\n                    id: String(Math.random())\n                });\n                return {\n                    unblock\n                };\n            }\n        }), [\n        addBlock\n    ]);\n};\n// src/buffer-until-first-frame.ts\nvar useBufferUntilFirstFrame = ({ mediaRef, mediaType, onVariableFpsVideoDetected, pauseWhenBuffering })=>{\n    const bufferingRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(false);\n    const { delayPlayback } = useBufferState();\n    const bufferUntilFirstFrame = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((requestedTime)=>{\n        if (mediaType !== \"video\") {\n            return;\n        }\n        if (!pauseWhenBuffering) {\n            return;\n        }\n        const current = mediaRef.current;\n        if (!current) {\n            return;\n        }\n        if (!current.requestVideoFrameCallback) {\n            return;\n        }\n        bufferingRef.current = true;\n        const playback = delayPlayback();\n        const unblock = ()=>{\n            playback.unblock();\n            current.removeEventListener(\"ended\", unblock, {\n                once: true\n            });\n            current.removeEventListener(\"pause\", unblock, {\n                once: true\n            });\n            bufferingRef.current = false;\n        };\n        const onEndedOrPauseOrCanPlay = ()=>{\n            unblock();\n        };\n        current.requestVideoFrameCallback((_, info)=>{\n            const differenceFromRequested = Math.abs(info.mediaTime - requestedTime);\n            if (differenceFromRequested > 0.5) {\n                onVariableFpsVideoDetected();\n            }\n            unblock();\n        });\n        current.addEventListener(\"ended\", onEndedOrPauseOrCanPlay, {\n            once: true\n        });\n        current.addEventListener(\"pause\", onEndedOrPauseOrCanPlay, {\n            once: true\n        });\n        current.addEventListener(\"canplay\", onEndedOrPauseOrCanPlay, {\n            once: true\n        });\n    }, [\n        delayPlayback,\n        mediaRef,\n        mediaType,\n        onVariableFpsVideoDetected,\n        pauseWhenBuffering\n    ]);\n    return (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>{\n        return {\n            isBuffering: ()=>bufferingRef.current,\n            bufferUntilFirstFrame\n        };\n    }, [\n        bufferUntilFirstFrame\n    ]);\n};\n// src/use-media-buffering.ts\n\nvar useMediaBuffering = ({ element, shouldBuffer, isPremounting })=>{\n    const buffer = useBufferState();\n    const [isBuffering, setIsBuffering] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(false);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        let cleanupFns = [];\n        const { current } = element;\n        if (!current) {\n            return;\n        }\n        if (!shouldBuffer) {\n            return;\n        }\n        if (isPremounting) {\n            return;\n        }\n        const cleanup = ()=>{\n            cleanupFns.forEach((fn)=>fn());\n            cleanupFns = [];\n            setIsBuffering(false);\n        };\n        const onWaiting = ()=>{\n            setIsBuffering(true);\n            const { unblock } = buffer.delayPlayback();\n            const onCanPlay = ()=>{\n                cleanup();\n                init();\n            };\n            const onError = ()=>{\n                cleanup();\n                init();\n            };\n            current.addEventListener(\"canplay\", onCanPlay, {\n                once: true\n            });\n            cleanupFns.push(()=>{\n                current.removeEventListener(\"canplay\", onCanPlay);\n            });\n            current.addEventListener(\"error\", onError, {\n                once: true\n            });\n            cleanupFns.push(()=>{\n                current.removeEventListener(\"error\", onError);\n            });\n            cleanupFns.push(()=>{\n                unblock();\n            });\n        };\n        const init = ()=>{\n            if (current.readyState < current.HAVE_FUTURE_DATA) {\n                onWaiting();\n                if (!navigator.userAgent.includes(\"Firefox/\")) {\n                    current.load();\n                }\n            } else {\n                current.addEventListener(\"waiting\", onWaiting);\n                cleanupFns.push(()=>{\n                    current.removeEventListener(\"waiting\", onWaiting);\n                });\n            }\n        };\n        init();\n        return ()=>{\n            cleanup();\n        };\n    }, [\n        buffer,\n        element,\n        isPremounting,\n        shouldBuffer\n    ]);\n    return isBuffering;\n};\n// src/use-request-video-callback-time.ts\n\nvar useRequestVideoCallbackTime = ({ mediaRef, mediaType, lastSeek, onVariableFpsVideoDetected })=>{\n    const currentTime = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        const { current } = mediaRef;\n        if (current) {\n            currentTime.current = current.currentTime;\n        } else {\n            currentTime.current = null;\n            return;\n        }\n        if (mediaType !== \"video\") {\n            currentTime.current = null;\n            return;\n        }\n        const videoTag = current;\n        if (!videoTag.requestVideoFrameCallback) {\n            return;\n        }\n        let cancel = ()=>{\n            return;\n        };\n        const request = ()=>{\n            if (!videoTag) {\n                return;\n            }\n            const cb = videoTag.requestVideoFrameCallback((_, info)=>{\n                if (currentTime.current !== null) {\n                    const difference = Math.abs(currentTime.current - info.mediaTime);\n                    const differenceToLastSeek = Math.abs(lastSeek.current === null ? Infinity : info.mediaTime - lastSeek.current);\n                    if (difference > 0.5 && differenceToLastSeek > 0.5 && info.mediaTime > currentTime.current) {\n                        onVariableFpsVideoDetected();\n                    }\n                }\n                currentTime.current = info.mediaTime;\n                request();\n            });\n            cancel = ()=>{\n                videoTag.cancelVideoFrameCallback(cb);\n                cancel = ()=>{\n                    return;\n                };\n            };\n        };\n        request();\n        return ()=>{\n            cancel();\n        };\n    }, [\n        lastSeek,\n        mediaRef,\n        mediaType,\n        onVariableFpsVideoDetected\n    ]);\n    return currentTime;\n};\n// src/interpolate.ts\nfunction interpolateFunction(input, inputRange, outputRange, options) {\n    const { extrapolateLeft, extrapolateRight, easing } = options;\n    let result = input;\n    const [inputMin, inputMax] = inputRange;\n    const [outputMin, outputMax] = outputRange;\n    if (result < inputMin) {\n        if (extrapolateLeft === \"identity\") {\n            return result;\n        }\n        if (extrapolateLeft === \"clamp\") {\n            result = inputMin;\n        } else if (extrapolateLeft === \"wrap\") {\n            const range = inputMax - inputMin;\n            result = ((result - inputMin) % range + range) % range + inputMin;\n        } else if (extrapolateLeft === \"extend\") {}\n    }\n    if (result > inputMax) {\n        if (extrapolateRight === \"identity\") {\n            return result;\n        }\n        if (extrapolateRight === \"clamp\") {\n            result = inputMax;\n        } else if (extrapolateRight === \"wrap\") {\n            const range = inputMax - inputMin;\n            result = ((result - inputMin) % range + range) % range + inputMin;\n        } else if (extrapolateRight === \"extend\") {}\n    }\n    if (outputMin === outputMax) {\n        return outputMin;\n    }\n    result = (result - inputMin) / (inputMax - inputMin);\n    result = easing(result);\n    result = result * (outputMax - outputMin) + outputMin;\n    return result;\n}\nfunction findRange(input, inputRange) {\n    let i;\n    for(i = 1; i < inputRange.length - 1; ++i){\n        if (inputRange[i] >= input) {\n            break;\n        }\n    }\n    return i - 1;\n}\nfunction checkValidInputRange(arr) {\n    for(let i = 1; i < arr.length; ++i){\n        if (!(arr[i] > arr[i - 1])) {\n            throw new Error(`inputRange must be strictly monotonically increasing but got [${arr.join(\",\")}]`);\n        }\n    }\n}\nfunction checkInfiniteRange(name, arr) {\n    if (arr.length < 2) {\n        throw new Error(name + \" must have at least 2 elements\");\n    }\n    for (const element of arr){\n        if (typeof element !== \"number\") {\n            throw new Error(`${name} must contain only numbers`);\n        }\n        if (!Number.isFinite(element)) {\n            throw new Error(`${name} must contain only finite numbers, but got [${arr.join(\",\")}]`);\n        }\n    }\n}\nfunction interpolate(input, inputRange, outputRange, options) {\n    if (typeof input === \"undefined\") {\n        throw new Error(\"input can not be undefined\");\n    }\n    if (typeof inputRange === \"undefined\") {\n        throw new Error(\"inputRange can not be undefined\");\n    }\n    if (typeof outputRange === \"undefined\") {\n        throw new Error(\"outputRange can not be undefined\");\n    }\n    if (inputRange.length !== outputRange.length) {\n        throw new Error(\"inputRange (\" + inputRange.length + \") and outputRange (\" + outputRange.length + \") must have the same length\");\n    }\n    checkInfiniteRange(\"inputRange\", inputRange);\n    checkInfiniteRange(\"outputRange\", outputRange);\n    checkValidInputRange(inputRange);\n    const easing = options?.easing ?? ((num)=>num);\n    let extrapolateLeft = \"extend\";\n    if (options?.extrapolateLeft !== undefined) {\n        extrapolateLeft = options.extrapolateLeft;\n    }\n    let extrapolateRight = \"extend\";\n    if (options?.extrapolateRight !== undefined) {\n        extrapolateRight = options.extrapolateRight;\n    }\n    if (typeof input !== \"number\") {\n        throw new TypeError(\"Cannot interpolate an input which is not a number\");\n    }\n    const range = findRange(input, inputRange);\n    return interpolateFunction(input, [\n        inputRange[range],\n        inputRange[range + 1]\n    ], [\n        outputRange[range],\n        outputRange[range + 1]\n    ], {\n        easing,\n        extrapolateLeft,\n        extrapolateRight\n    });\n}\n// src/video/get-current-time.ts\nvar getExpectedMediaFrameUncorrected = ({ frame, playbackRate, startFrom })=>{\n    return interpolate(frame, [\n        -1,\n        startFrom,\n        startFrom + 1\n    ], [\n        -1,\n        startFrom,\n        startFrom + playbackRate\n    ]);\n};\nvar getMediaTime = ({ fps, frame, playbackRate, startFrom })=>{\n    const expectedFrame = getExpectedMediaFrameUncorrected({\n        frame,\n        playbackRate,\n        startFrom\n    });\n    const msPerFrame = 1000 / fps;\n    return expectedFrame * msPerFrame / 1000;\n};\n// src/video/video-fragment.ts\n\nvar toSeconds = (time, fps)=>{\n    return Math.round(time / fps * 100) / 100;\n};\nvar isIosSafari = ()=>{\n    if (true) {\n        return false;\n    }\n    const isIpadIPodIPhone = /iP(ad|od|hone)/i.test(window.navigator.userAgent);\n    const isAppleWebKit = /AppleWebKit/.test(window.navigator.userAgent);\n    return isIpadIPodIPhone && isAppleWebKit;\n};\nvar isIOSSafariAndBlob = (actualSrc)=>{\n    return isIosSafari() && actualSrc.startsWith(\"blob:\");\n};\nvar getVideoFragmentStart = ({ actualFrom, fps })=>{\n    return toSeconds(Math.max(0, -actualFrom), fps);\n};\nvar getVideoFragmentEnd = ({ duration, fps })=>{\n    return toSeconds(duration, fps);\n};\nvar appendVideoFragment = ({ actualSrc, actualFrom, duration, fps })=>{\n    if (isIOSSafariAndBlob(actualSrc)) {\n        return actualSrc;\n    }\n    if (actualSrc.startsWith(\"data:\")) {\n        return actualSrc;\n    }\n    const existingHash = Boolean(new URL(actualSrc, ( null) ?? \"http://localhost:3000\").hash);\n    if (existingHash) {\n        return actualSrc;\n    }\n    if (!Number.isFinite(actualFrom)) {\n        return actualSrc;\n    }\n    const withStartHash = `${actualSrc}#t=${getVideoFragmentStart({\n        actualFrom,\n        fps\n    })}`;\n    if (!Number.isFinite(duration)) {\n        return withStartHash;\n    }\n    return `${withStartHash},${getVideoFragmentEnd({\n        duration,\n        fps\n    })}`;\n};\nvar isSubsetOfDuration = ({ prevStartFrom, newStartFrom, prevDuration, newDuration, fps })=>{\n    const previousFrom = getVideoFragmentStart({\n        actualFrom: prevStartFrom,\n        fps\n    });\n    const newFrom = getVideoFragmentStart({\n        actualFrom: newStartFrom,\n        fps\n    });\n    const previousEnd = getVideoFragmentEnd({\n        duration: prevDuration,\n        fps\n    });\n    const newEnd = getVideoFragmentEnd({\n        duration: newDuration,\n        fps\n    });\n    if (newFrom < previousFrom) {\n        return false;\n    }\n    if (newEnd > previousEnd) {\n        return false;\n    }\n    return true;\n};\nvar useAppendVideoFragment = ({ actualSrc: initialActualSrc, actualFrom: initialActualFrom, duration: initialDuration, fps })=>{\n    const actualFromRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(initialActualFrom);\n    const actualDuration = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(initialDuration);\n    const actualSrc = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(initialActualSrc);\n    if (!isSubsetOfDuration({\n        prevStartFrom: actualFromRef.current,\n        newStartFrom: initialActualFrom,\n        prevDuration: actualDuration.current,\n        newDuration: initialDuration,\n        fps\n    }) || initialActualSrc !== actualSrc.current) {\n        actualFromRef.current = initialActualFrom;\n        actualDuration.current = initialDuration;\n        actualSrc.current = initialActualSrc;\n    }\n    const appended = appendVideoFragment({\n        actualSrc: actualSrc.current,\n        actualFrom: actualFromRef.current,\n        duration: actualDuration.current,\n        fps\n    });\n    return appended;\n};\n// src/warn-about-non-seekable-media.ts\nvar alreadyWarned = {};\nvar warnAboutNonSeekableMedia = (ref, type)=>{\n    if (ref === null) {\n        return;\n    }\n    if (ref.seekable.length === 0) {\n        return;\n    }\n    if (ref.seekable.length > 1) {\n        return;\n    }\n    if (alreadyWarned[ref.src]) {\n        return;\n    }\n    const range = {\n        start: ref.seekable.start(0),\n        end: ref.seekable.end(0)\n    };\n    if (range.start === 0 && range.end === 0) {\n        const msg = [\n            `The media ${ref.src} cannot be seeked. This could be one of few reasons:`,\n            \"1) The media resource was replaced while the video is playing but it was not loaded yet.\",\n            \"2) The media does not support seeking.\",\n            \"3) The media was loaded with security headers prventing it from being included.\",\n            \"Please see https://remotion.dev/docs/non-seekable-media for assistance.\"\n        ].join(\"\\n\");\n        if (type === \"console-error\") {\n            console.error(msg);\n        } else if (type === \"console-warning\") {\n            console.warn(`The media ${ref.src} does not support seeking. The video will render fine, but may not play correctly in the Remotion Studio and in the <Player>. See https://remotion.dev/docs/non-seekable-media for an explanation.`);\n        } else {\n            throw new Error(msg);\n        }\n        alreadyWarned[ref.src] = true;\n    }\n};\n// src/use-media-playback.ts\nvar DEFAULT_ACCEPTABLE_TIMESHIFT = 0.45;\nvar seek = (mediaRef, time)=>{\n    if (!mediaRef.current) {\n        return;\n    }\n    const timeToSet = isIosSafari() ? Number(time.toFixed(1)) : time;\n    mediaRef.current.currentTime = timeToSet;\n};\nvar useMediaPlayback = ({ mediaRef, src, mediaType, playbackRate: localPlaybackRate, onlyWarnForMediaSeekingError, acceptableTimeshift, pauseWhenBuffering, isPremounting, debugSeeking, onAutoPlayError })=>{\n    const { playbackRate: globalPlaybackRate } = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(TimelineContext);\n    const frame = useCurrentFrame();\n    const absoluteFrame = useTimelinePosition();\n    const [playing] = usePlayingState();\n    const buffering = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(BufferingContextReact);\n    const { fps } = useVideoConfig();\n    const mediaStartsAt = useMediaStartsAt();\n    const lastSeekDueToShift = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n    const lastSeek = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n    if (!buffering) {\n        throw new Error(\"useMediaPlayback must be used inside a <BufferingContext>\");\n    }\n    const isVariableFpsVideoMap = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)({});\n    const onVariableFpsVideoDetected = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(()=>{\n        if (!src) {\n            return;\n        }\n        if (debugSeeking) {\n            console.log(`Detected ${src} as a variable FPS video. Disabling buffering while seeking.`);\n        }\n        isVariableFpsVideoMap.current[src] = true;\n    }, [\n        debugSeeking,\n        src\n    ]);\n    const currentTime = useRequestVideoCallbackTime({\n        mediaRef,\n        mediaType,\n        lastSeek,\n        onVariableFpsVideoDetected\n    });\n    const desiredUnclampedTime = getMediaTime({\n        frame,\n        playbackRate: localPlaybackRate,\n        startFrom: -mediaStartsAt,\n        fps\n    });\n    const isMediaTagBuffering = useMediaBuffering({\n        element: mediaRef,\n        shouldBuffer: pauseWhenBuffering,\n        isPremounting\n    });\n    const { bufferUntilFirstFrame, isBuffering } = useBufferUntilFirstFrame({\n        mediaRef,\n        mediaType,\n        onVariableFpsVideoDetected,\n        pauseWhenBuffering\n    });\n    const playbackRate = localPlaybackRate * globalPlaybackRate;\n    const acceptableTimeShiftButLessThanDuration = (()=>{\n        if (mediaRef.current?.duration) {\n            return Math.min(mediaRef.current.duration, acceptableTimeshift ?? DEFAULT_ACCEPTABLE_TIMESHIFT);\n        }\n        return acceptableTimeshift;\n    })();\n    const isPlayerBuffering = useIsPlayerBuffering(buffering);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        if (!playing) {\n            mediaRef.current?.pause();\n            return;\n        }\n        const isMediaTagBufferingOrStalled = isMediaTagBuffering || isBuffering();\n        if (isPlayerBuffering && !isMediaTagBufferingOrStalled) {\n            mediaRef.current?.pause();\n        }\n    }, [\n        isBuffering,\n        isMediaTagBuffering,\n        isPlayerBuffering,\n        mediaRef,\n        playing\n    ]);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        const tagName = mediaType === \"audio\" ? \"<Audio>\" : \"<Video>\";\n        if (!mediaRef.current) {\n            throw new Error(`No ${mediaType} ref found`);\n        }\n        if (!src) {\n            throw new Error(`No 'src' attribute was passed to the ${tagName} element.`);\n        }\n        const playbackRateToSet = Math.max(0, playbackRate);\n        if (mediaRef.current.playbackRate !== playbackRateToSet) {\n            mediaRef.current.playbackRate = playbackRateToSet;\n        }\n        const { duration } = mediaRef.current;\n        const shouldBeTime = !Number.isNaN(duration) && Number.isFinite(duration) ? Math.min(duration, desiredUnclampedTime) : desiredUnclampedTime;\n        const mediaTagTime = mediaRef.current.currentTime;\n        const rvcTime = currentTime.current ?? null;\n        const isVariableFpsVideo = isVariableFpsVideoMap.current[src];\n        const timeShiftMediaTag = Math.abs(shouldBeTime - mediaTagTime);\n        const timeShiftRvcTag = rvcTime ? Math.abs(shouldBeTime - rvcTime) : null;\n        const timeShift = timeShiftRvcTag && !isVariableFpsVideo ? timeShiftRvcTag : timeShiftMediaTag;\n        if (debugSeeking) {\n            console.log({\n                mediaTagTime,\n                rvcTime,\n                shouldBeTime,\n                state: mediaRef.current.readyState,\n                playing: !mediaRef.current.paused,\n                isVariableFpsVideo\n            });\n        }\n        if (timeShift > acceptableTimeShiftButLessThanDuration && lastSeekDueToShift.current !== shouldBeTime) {\n            if (debugSeeking) {\n                console.log(\"Seeking\", {\n                    shouldBeTime,\n                    isTime: mediaTagTime,\n                    rvcTime,\n                    timeShift,\n                    isVariableFpsVideo\n                });\n            }\n            seek(mediaRef, shouldBeTime);\n            lastSeek.current = shouldBeTime;\n            lastSeekDueToShift.current = shouldBeTime;\n            if (playing && !isVariableFpsVideo) {\n                if (playbackRate > 0) {\n                    bufferUntilFirstFrame(shouldBeTime);\n                }\n                if (mediaRef.current.paused) {\n                    playAndHandleNotAllowedError(mediaRef, mediaType, onAutoPlayError);\n                }\n            }\n            if (!onlyWarnForMediaSeekingError) {\n                warnAboutNonSeekableMedia(mediaRef.current, onlyWarnForMediaSeekingError ? \"console-warning\" : \"console-error\");\n            }\n            return;\n        }\n        const seekThreshold = playing ? 0.15 : 0.00001;\n        const makesSenseToSeek = Math.abs(mediaRef.current.currentTime - shouldBeTime) > seekThreshold;\n        const isMediaTagBufferingOrStalled = isMediaTagBuffering || isBuffering();\n        const isSomethingElseBuffering = buffering.buffering.current && !isMediaTagBufferingOrStalled;\n        if (!playing || isSomethingElseBuffering) {\n            if (makesSenseToSeek) {\n                seek(mediaRef, shouldBeTime);\n                lastSeek.current = shouldBeTime;\n            }\n            return;\n        }\n        if (mediaRef.current.paused && !mediaRef.current.ended || absoluteFrame === 0) {\n            if (makesSenseToSeek) {\n                seek(mediaRef, shouldBeTime);\n                lastSeek.current = shouldBeTime;\n            }\n            playAndHandleNotAllowedError(mediaRef, mediaType, onAutoPlayError);\n            if (!isVariableFpsVideo) {\n                if (playbackRate > 0) {\n                    bufferUntilFirstFrame(shouldBeTime);\n                }\n            }\n        }\n    }, [\n        absoluteFrame,\n        acceptableTimeShiftButLessThanDuration,\n        bufferUntilFirstFrame,\n        buffering.buffering,\n        currentTime,\n        debugSeeking,\n        desiredUnclampedTime,\n        isBuffering,\n        isMediaTagBuffering,\n        mediaRef,\n        mediaType,\n        onlyWarnForMediaSeekingError,\n        playbackRate,\n        playing,\n        src,\n        onAutoPlayError\n    ]);\n};\n// src/use-media-tag-volume.ts\n\nvar useMediaTagVolume = (mediaRef)=>{\n    const [actualVolume, setActualVolume] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(1);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        const ref = mediaRef.current;\n        if (!ref) {\n            return;\n        }\n        const onChange = ()=>{\n            setActualVolume(ref.volume);\n        };\n        ref.addEventListener(\"volumechange\", onChange);\n        return ()=>ref.removeEventListener(\"volumechange\", onChange);\n    }, [\n        mediaRef\n    ]);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        const ref = mediaRef.current;\n        if (!ref) {\n            return;\n        }\n        if (ref.volume !== actualVolume) {\n            setActualVolume(ref.volume);\n        }\n    }, [\n        actualVolume,\n        mediaRef\n    ]);\n    return actualVolume;\n};\n// src/use-sync-volume-with-media-tag.ts\n\n// src/is-approximately-the-same.ts\nvar FLOATING_POINT_ERROR_THRESHOLD = 0.00001;\nvar isApproximatelyTheSame = (num1, num2)=>{\n    return Math.abs(num1 - num2) < FLOATING_POINT_ERROR_THRESHOLD;\n};\n// src/use-sync-volume-with-media-tag.ts\nvar useSyncVolumeWithMediaTag = ({ volumePropFrame, actualVolume, volume, mediaVolume, mediaRef })=>{\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        const userPreferredVolume = evaluateVolume({\n            frame: volumePropFrame,\n            volume,\n            mediaVolume,\n            allowAmplificationDuringRender: false\n        });\n        if (!isApproximatelyTheSame(userPreferredVolume, actualVolume) && mediaRef.current) {\n            mediaRef.current.volume = userPreferredVolume;\n        }\n    }, [\n        actualVolume,\n        volumePropFrame,\n        mediaRef,\n        volume,\n        mediaVolume\n    ]);\n};\n// src/volume-position-state.ts\n\nvar MediaVolumeContext = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_0__.createContext)({\n    mediaMuted: false,\n    mediaVolume: 1\n});\nvar SetMediaVolumeContext = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_0__.createContext)({\n    setMediaMuted: ()=>{\n        throw new Error(\"default\");\n    },\n    setMediaVolume: ()=>{\n        throw new Error(\"default\");\n    }\n});\nvar useMediaVolumeState = ()=>{\n    const { mediaVolume } = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(MediaVolumeContext);\n    const { setMediaVolume } = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(SetMediaVolumeContext);\n    return (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>{\n        return [\n            mediaVolume,\n            setMediaVolume\n        ];\n    }, [\n        mediaVolume,\n        setMediaVolume\n    ]);\n};\nvar useMediaMutedState = ()=>{\n    const { mediaMuted } = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(MediaVolumeContext);\n    const { setMediaMuted } = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(SetMediaVolumeContext);\n    return (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>{\n        return [\n            mediaMuted,\n            setMediaMuted\n        ];\n    }, [\n        mediaMuted,\n        setMediaMuted\n    ]);\n};\n// src/audio/shared-audio-tags.tsx\n\n\nvar EMPTY_AUDIO = \"data:audio/mp3;base64,/+MYxAAJcAV8AAgAABn//////+/gQ5BAMA+D4Pg+BAQBAEAwD4Pg+D4EBAEAQDAPg++hYBH///hUFQVBUFREDQNHmf///////+MYxBUGkAGIMAAAAP/29Xt6lUxBTUUzLjEwMFVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVV/+MYxDUAAANIAAAAAFVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVV\";\nvar compareProps = (obj1, obj2)=>{\n    const keysA = Object.keys(obj1).sort();\n    const keysB = Object.keys(obj2).sort();\n    if (keysA.length !== keysB.length) {\n        return false;\n    }\n    for(let i = 0; i < keysA.length; i++){\n        if (keysA[i] !== keysB[i]) {\n            return false;\n        }\n        if (obj1[keysA[i]] !== obj2[keysB[i]]) {\n            return false;\n        }\n    }\n    return true;\n};\nvar didPropChange = (key, newProp, prevProp)=>{\n    if (key === \"src\" && !prevProp.startsWith(\"data:\") && !newProp.startsWith(\"data:\")) {\n        return new URL(prevProp, window.origin).toString() !== new URL(newProp, window.origin).toString();\n    }\n    if (prevProp === newProp) {\n        return false;\n    }\n    return true;\n};\nvar SharedAudioContext = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_0__.createContext)(null);\nvar SharedAudioContextProvider = ({ children, numberOfAudioTags, component })=>{\n    const audios = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)([]);\n    const [initialNumberOfAudioTags] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(numberOfAudioTags);\n    if (numberOfAudioTags !== initialNumberOfAudioTags) {\n        throw new Error(\"The number of shared audio tags has changed dynamically. Once you have set this property, you cannot change it afterwards.\");\n    }\n    const refs = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>{\n        return new Array(numberOfAudioTags).fill(true).map(()=>{\n            return {\n                id: Math.random(),\n                ref: /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_0__.createRef)()\n            };\n        });\n    }, [\n        numberOfAudioTags\n    ]);\n    const takenAudios = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(new Array(numberOfAudioTags).fill(false));\n    const rerenderAudios = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(()=>{\n        refs.forEach(({ ref, id })=>{\n            const data = audios.current?.find((a)=>a.id === id);\n            const { current } = ref;\n            if (!current) {\n                return;\n            }\n            if (data === undefined) {\n                current.src = EMPTY_AUDIO;\n                return;\n            }\n            if (!data) {\n                throw new TypeError(\"Expected audio data to be there\");\n            }\n            Object.keys(data.props).forEach((key)=>{\n                if (didPropChange(key, data.props[key], current[key])) {\n                    current[key] = data.props[key];\n                }\n            });\n        });\n    }, [\n        refs\n    ]);\n    const registerAudio = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((aud, audioId)=>{\n        const found = audios.current?.find((a)=>a.audioId === audioId);\n        if (found) {\n            return found;\n        }\n        const firstFreeAudio = takenAudios.current.findIndex((a)=>a === false);\n        if (firstFreeAudio === -1) {\n            throw new Error(`Tried to simultaneously mount ${numberOfAudioTags + 1} <Audio /> tags at the same time. With the current settings, the maximum amount of <Audio /> tags is limited to ${numberOfAudioTags} at the same time. Remotion pre-mounts silent audio tags to help avoid browser autoplay restrictions. See https://remotion.dev/docs/player/autoplay#use-the-numberofsharedaudiotags-property for more information on how to increase this limit.`);\n        }\n        const { id, ref } = refs[firstFreeAudio];\n        const cloned = [\n            ...takenAudios.current\n        ];\n        cloned[firstFreeAudio] = id;\n        takenAudios.current = cloned;\n        const newElem = {\n            props: aud,\n            id,\n            el: ref,\n            audioId\n        };\n        audios.current?.push(newElem);\n        rerenderAudios();\n        return newElem;\n    }, [\n        numberOfAudioTags,\n        refs,\n        rerenderAudios\n    ]);\n    const unregisterAudio = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((id)=>{\n        const cloned = [\n            ...takenAudios.current\n        ];\n        const index = refs.findIndex((r)=>r.id === id);\n        if (index === -1) {\n            throw new TypeError(\"Error occured in \");\n        }\n        cloned[index] = false;\n        takenAudios.current = cloned;\n        audios.current = audios.current?.filter((a)=>a.id !== id);\n        rerenderAudios();\n    }, [\n        refs,\n        rerenderAudios\n    ]);\n    const updateAudio = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(({ aud, audioId, id })=>{\n        let changed = false;\n        audios.current = audios.current?.map((prevA)=>{\n            if (prevA.id === id) {\n                const isTheSame = compareProps(aud, prevA.props);\n                if (isTheSame) {\n                    return prevA;\n                }\n                changed = true;\n                return {\n                    ...prevA,\n                    props: aud,\n                    audioId\n                };\n            }\n            return prevA;\n        });\n        if (changed) {\n            rerenderAudios();\n        }\n    }, [\n        rerenderAudios\n    ]);\n    const playAllAudios = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(()=>{\n        refs.forEach((ref)=>{\n            playAndHandleNotAllowedError(ref.ref, \"audio\", null);\n        });\n    }, [\n        refs\n    ]);\n    const value = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>{\n        return {\n            registerAudio,\n            unregisterAudio,\n            updateAudio,\n            playAllAudios,\n            numberOfAudioTags\n        };\n    }, [\n        numberOfAudioTags,\n        playAllAudios,\n        registerAudio,\n        unregisterAudio,\n        updateAudio\n    ]);\n    const resetAudio = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(()=>{\n        takenAudios.current = new Array(numberOfAudioTags).fill(false);\n        audios.current = [];\n        rerenderAudios();\n    }, [\n        numberOfAudioTags,\n        rerenderAudios\n    ]);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        return ()=>{\n            resetAudio();\n        };\n    }, [\n        component,\n        resetAudio\n    ]);\n    return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsxs)(SharedAudioContext.Provider, {\n        value,\n        children: [\n            refs.map(({ id, ref })=>{\n                return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(\"audio\", {\n                    ref,\n                    preload: \"metadata\",\n                    src: EMPTY_AUDIO\n                }, id);\n            }),\n            children\n        ]\n    });\n};\nvar useSharedAudio = (aud, audioId)=>{\n    const ctx = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(SharedAudioContext);\n    const [elem] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(()=>{\n        if (ctx && ctx.numberOfAudioTags > 0) {\n            return ctx.registerAudio(aud, audioId);\n        }\n        return {\n            el: /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createRef(),\n            id: Math.random(),\n            props: aud,\n            audioId\n        };\n    });\n    const effectToUse = react__WEBPACK_IMPORTED_MODULE_0__.useInsertionEffect ?? react__WEBPACK_IMPORTED_MODULE_0__.useLayoutEffect;\n    if (typeof document !== \"undefined\") {\n        effectToUse(()=>{\n            if (ctx && ctx.numberOfAudioTags > 0) {\n                ctx.updateAudio({\n                    id: elem.id,\n                    aud,\n                    audioId\n                });\n            }\n        }, [\n            aud,\n            ctx,\n            elem.id,\n            audioId\n        ]);\n        effectToUse(()=>{\n            return ()=>{\n                if (ctx && ctx.numberOfAudioTags > 0) {\n                    ctx.unregisterAudio(elem.id);\n                }\n            };\n        }, [\n            ctx,\n            elem.id\n        ]);\n    }\n    return elem;\n};\n// src/audio/AudioForPreview.tsx\n\nvar AudioForDevelopmentForwardRefFunction = (props, ref)=>{\n    const [initialShouldPreMountAudioElements] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(props.shouldPreMountAudioTags);\n    if (props.shouldPreMountAudioTags !== initialShouldPreMountAudioElements) {\n        throw new Error(\"Cannot change the behavior for pre-mounting audio tags dynamically.\");\n    }\n    const { volume, muted, playbackRate, shouldPreMountAudioTags, src, onDuration, acceptableTimeShiftInSeconds, _remotionInternalNeedsDurationCalculation, _remotionInternalNativeLoopPassed, _remotionInternalStack, _remotionDebugSeeking, allowAmplificationDuringRender, name, pauseWhenBuffering, showInTimeline, loopVolumeCurveBehavior, stack, ...nativeProps } = props;\n    const [mediaVolume] = useMediaVolumeState();\n    const [mediaMuted] = useMediaMutedState();\n    const volumePropFrame = useFrameForVolumeProp(loopVolumeCurveBehavior ?? \"repeat\");\n    const { hidden } = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(SequenceVisibilityToggleContext);\n    if (!src) {\n        throw new TypeError(\"No 'src' was passed to <Audio>.\");\n    }\n    const preloadedSrc = usePreload(src);\n    const sequenceContext = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(SequenceContext);\n    const [timelineId] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(()=>String(Math.random()));\n    const isSequenceHidden = hidden[timelineId] ?? false;\n    const userPreferredVolume = evaluateVolume({\n        frame: volumePropFrame,\n        volume,\n        mediaVolume,\n        allowAmplificationDuringRender: false\n    });\n    const propsToPass = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>{\n        return {\n            muted: muted || mediaMuted || isSequenceHidden || userPreferredVolume <= 0,\n            src: preloadedSrc,\n            loop: _remotionInternalNativeLoopPassed,\n            ...nativeProps\n        };\n    }, [\n        _remotionInternalNativeLoopPassed,\n        isSequenceHidden,\n        mediaMuted,\n        muted,\n        nativeProps,\n        preloadedSrc,\n        userPreferredVolume\n    ]);\n    const id = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>`audio-${random(src ?? \"\")}-${sequenceContext?.relativeFrom}-${sequenceContext?.cumulatedFrom}-${sequenceContext?.durationInFrames}-muted:${props.muted}-loop:${props.loop}`, [\n        src,\n        sequenceContext?.relativeFrom,\n        sequenceContext?.cumulatedFrom,\n        sequenceContext?.durationInFrames,\n        props.muted,\n        props.loop\n    ]);\n    const audioRef = useSharedAudio(propsToPass, id).el;\n    const actualVolume = useMediaTagVolume(audioRef);\n    useSyncVolumeWithMediaTag({\n        volumePropFrame,\n        actualVolume,\n        volume,\n        mediaVolume,\n        mediaRef: audioRef\n    });\n    useMediaInTimeline({\n        volume,\n        mediaVolume,\n        mediaRef: audioRef,\n        src,\n        mediaType: \"audio\",\n        playbackRate: playbackRate ?? 1,\n        displayName: name ?? null,\n        id: timelineId,\n        stack: _remotionInternalStack,\n        showInTimeline,\n        premountDisplay: null,\n        onAutoPlayError: null\n    });\n    useMediaPlayback({\n        mediaRef: audioRef,\n        src,\n        mediaType: \"audio\",\n        playbackRate: playbackRate ?? 1,\n        onlyWarnForMediaSeekingError: false,\n        acceptableTimeshift: acceptableTimeShiftInSeconds ?? DEFAULT_ACCEPTABLE_TIMESHIFT,\n        isPremounting: Boolean(sequenceContext?.premounting),\n        pauseWhenBuffering,\n        debugSeeking: _remotionDebugSeeking,\n        onAutoPlayError: null\n    });\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useImperativeHandle)(ref, ()=>{\n        return audioRef.current;\n    }, [\n        audioRef\n    ]);\n    const currentOnDurationCallback = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)();\n    currentOnDurationCallback.current = onDuration;\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        const { current } = audioRef;\n        if (!current) {\n            return;\n        }\n        if (current.duration) {\n            currentOnDurationCallback.current?.(current.src, current.duration);\n            return;\n        }\n        const onLoadedMetadata = ()=>{\n            currentOnDurationCallback.current?.(current.src, current.duration);\n        };\n        current.addEventListener(\"loadedmetadata\", onLoadedMetadata);\n        return ()=>{\n            current.removeEventListener(\"loadedmetadata\", onLoadedMetadata);\n        };\n    }, [\n        audioRef,\n        src\n    ]);\n    if (initialShouldPreMountAudioElements) {\n        return null;\n    }\n    return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(\"audio\", {\n        ref: audioRef,\n        preload: \"metadata\",\n        ...propsToPass\n    });\n};\nvar AudioForPreview = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_0__.forwardRef)(AudioForDevelopmentForwardRefFunction);\n// src/audio/AudioForRendering.tsx\n\n// src/delay-render.ts\nif (false) {}\nvar handles = [];\nif (false) {}\nvar DELAY_RENDER_CALLSTACK_TOKEN = \"The delayRender was called:\";\nvar DELAY_RENDER_RETRIES_LEFT = \"Retries left: \";\nvar DELAY_RENDER_RETRY_TOKEN = \"- Rendering the frame will be retried.\";\nvar defaultTimeout = 30000;\nvar delayRender = (label, options)=>{\n    if (typeof label !== \"string\" && typeof label !== \"undefined\") {\n        throw new Error(\"The label parameter of delayRender() must be a string or undefined, got: \" + JSON.stringify(label));\n    }\n    const handle = Math.random();\n    handles.push(handle);\n    const called = Error().stack?.replace(/^Error/g, \"\") ?? \"\";\n    if (getRemotionEnvironment().isRendering) {\n        const timeoutToUse = (options?.timeoutInMilliseconds ?? ( true ? defaultTimeout : 0)) - 2000;\n        if (false) {}\n    }\n    if (false) {}\n    return handle;\n};\nvar continueRender = (handle)=>{\n    if (typeof handle === \"undefined\") {\n        throw new TypeError(\"The continueRender() method must be called with a parameter that is the return value of delayRender(). No value was passed.\");\n    }\n    if (typeof handle !== \"number\") {\n        throw new TypeError(\"The parameter passed into continueRender() must be the return value of delayRender() which is a number. Got: \" + JSON.stringify(handle));\n    }\n    handles = handles.filter((h)=>{\n        if (h === handle) {\n            if (getRemotionEnvironment().isRendering) {\n                clearTimeout(window.remotion_delayRenderTimeouts[handle].timeout);\n                delete window.remotion_delayRenderTimeouts[handle];\n            }\n            return false;\n        }\n        return true;\n    });\n    if (handles.length === 0 && \"undefined\" !== \"undefined\") {}\n};\n// src/audio/AudioForRendering.tsx\n\nvar AudioForRenderingRefForwardingFunction = (props, ref)=>{\n    const audioRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n    const { volume: volumeProp, playbackRate, allowAmplificationDuringRender, onDuration, toneFrequency, _remotionInternalNeedsDurationCalculation, _remotionInternalNativeLoopPassed, acceptableTimeShiftInSeconds, name, onError, delayRenderRetries, delayRenderTimeoutInMilliseconds, loopVolumeCurveBehavior, pauseWhenBuffering, ...nativeProps } = props;\n    const absoluteFrame = useTimelinePosition();\n    const volumePropFrame = useFrameForVolumeProp(loopVolumeCurveBehavior ?? \"repeat\");\n    const frame = useCurrentFrame();\n    const sequenceContext = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(SequenceContext);\n    const { registerRenderAsset, unregisterRenderAsset } = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(RenderAssetManager);\n    const id = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>`audio-${random(props.src ?? \"\")}-${sequenceContext?.relativeFrom}-${sequenceContext?.cumulatedFrom}-${sequenceContext?.durationInFrames}`, [\n        props.src,\n        sequenceContext?.relativeFrom,\n        sequenceContext?.cumulatedFrom,\n        sequenceContext?.durationInFrames\n    ]);\n    const volume = evaluateVolume({\n        volume: volumeProp,\n        frame: volumePropFrame,\n        mediaVolume: 1,\n        allowAmplificationDuringRender: allowAmplificationDuringRender ?? false\n    });\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useImperativeHandle)(ref, ()=>{\n        return audioRef.current;\n    }, []);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        if (!props.src) {\n            throw new Error(\"No src passed\");\n        }\n        if (!window.remotion_audioEnabled) {\n            return;\n        }\n        if (props.muted) {\n            return;\n        }\n        if (volume <= 0) {\n            return;\n        }\n        registerRenderAsset({\n            type: \"audio\",\n            src: getAbsoluteSrc(props.src),\n            id,\n            frame: absoluteFrame,\n            volume,\n            mediaFrame: frame,\n            playbackRate: props.playbackRate ?? 1,\n            allowAmplificationDuringRender: allowAmplificationDuringRender ?? false,\n            toneFrequency: toneFrequency ?? null,\n            audioStartFrame: Math.max(0, -(sequenceContext?.relativeFrom ?? 0))\n        });\n        return ()=>unregisterRenderAsset(id);\n    }, [\n        props.muted,\n        props.src,\n        registerRenderAsset,\n        absoluteFrame,\n        id,\n        unregisterRenderAsset,\n        volume,\n        volumePropFrame,\n        frame,\n        playbackRate,\n        props.playbackRate,\n        allowAmplificationDuringRender,\n        toneFrequency,\n        sequenceContext?.relativeFrom\n    ]);\n    const { src } = props;\n    const needsToRenderAudioTag = ref || _remotionInternalNeedsDurationCalculation;\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useLayoutEffect)(()=>{\n        if (window.process?.env?.NODE_ENV === \"test\") {\n            return;\n        }\n        if (!needsToRenderAudioTag) {\n            return;\n        }\n        const newHandle = delayRender(\"Loading <Audio> duration with src=\" + src, {\n            retries: delayRenderRetries ?? undefined,\n            timeoutInMilliseconds: delayRenderTimeoutInMilliseconds ?? undefined\n        });\n        const { current } = audioRef;\n        const didLoad = ()=>{\n            if (current?.duration) {\n                onDuration(current.src, current.duration);\n            }\n            continueRender(newHandle);\n        };\n        if (current?.duration) {\n            onDuration(current.src, current.duration);\n            continueRender(newHandle);\n        } else {\n            current?.addEventListener(\"loadedmetadata\", didLoad, {\n                once: true\n            });\n        }\n        return ()=>{\n            current?.removeEventListener(\"loadedmetadata\", didLoad);\n            continueRender(newHandle);\n        };\n    }, [\n        src,\n        onDuration,\n        needsToRenderAudioTag,\n        delayRenderRetries,\n        delayRenderTimeoutInMilliseconds\n    ]);\n    if (!needsToRenderAudioTag) {\n        return null;\n    }\n    return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(\"audio\", {\n        ref: audioRef,\n        ...nativeProps\n    });\n};\nvar AudioForRendering = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_0__.forwardRef)(AudioForRenderingRefForwardingFunction);\n// src/audio/Audio.tsx\n\nvar AudioRefForwardingFunction = (props, ref)=>{\n    const audioContext = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(SharedAudioContext);\n    const { startFrom, endAt, name, stack, pauseWhenBuffering, showInTimeline, _remotionDebugSeeking, ...otherProps } = props;\n    const { loop, ...propsOtherThanLoop } = props;\n    const { fps } = useVideoConfig();\n    const environment = getRemotionEnvironment();\n    const { durations, setDurations } = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(DurationsContext);\n    if (typeof props.src !== \"string\") {\n        throw new TypeError(`The \\`<Audio>\\` tag requires a string for \\`src\\`, but got ${JSON.stringify(props.src)} instead.`);\n    }\n    const preloadedSrc = usePreload(props.src);\n    const onError = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((e)=>{\n        console.log(e.currentTarget.error);\n        const errMessage = `Could not play audio with src ${preloadedSrc}: ${e.currentTarget.error}. See https://remotion.dev/docs/media-playback-error for help.`;\n        if (loop) {\n            cancelRender(new Error(errMessage));\n        } else {\n            console.warn(errMessage);\n        }\n    }, [\n        loop,\n        preloadedSrc\n    ]);\n    const onDuration = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((src, durationInSeconds)=>{\n        setDurations({\n            type: \"got-duration\",\n            durationInSeconds,\n            src\n        });\n    }, [\n        setDurations\n    ]);\n    const durationFetched = durations[getAbsoluteSrc(preloadedSrc)] ?? durations[getAbsoluteSrc(props.src)];\n    if (loop && durationFetched !== undefined) {\n        const duration = durationFetched * fps;\n        return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(Loop, {\n            layout: \"none\",\n            durationInFrames: calculateLoopDuration({\n                endAt,\n                mediaDuration: duration,\n                playbackRate: props.playbackRate ?? 1,\n                startFrom\n            }),\n            children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(Audio, {\n                ...propsOtherThanLoop,\n                ref,\n                _remotionInternalNativeLoopPassed: true\n            })\n        });\n    }\n    if (typeof startFrom !== \"undefined\" || typeof endAt !== \"undefined\") {\n        validateStartFromProps(startFrom, endAt);\n        const startFromFrameNo = startFrom ?? 0;\n        const endAtFrameNo = endAt ?? Infinity;\n        return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(Sequence, {\n            layout: \"none\",\n            from: 0 - startFromFrameNo,\n            showInTimeline: false,\n            durationInFrames: endAtFrameNo,\n            name,\n            children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(Audio, {\n                _remotionInternalNeedsDurationCalculation: Boolean(loop),\n                pauseWhenBuffering: pauseWhenBuffering ?? false,\n                ...otherProps,\n                ref\n            })\n        });\n    }\n    validateMediaProps(props, \"Audio\");\n    if (environment.isRendering) {\n        return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(AudioForRendering, {\n            onDuration,\n            ...props,\n            ref,\n            onError,\n            _remotionInternalNeedsDurationCalculation: Boolean(loop)\n        });\n    }\n    return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(AudioForPreview, {\n        _remotionInternalNativeLoopPassed: props._remotionInternalNativeLoopPassed ?? false,\n        _remotionDebugSeeking: _remotionDebugSeeking ?? false,\n        _remotionInternalStack: stack ?? null,\n        shouldPreMountAudioTags: audioContext !== null && audioContext.numberOfAudioTags > 0,\n        ...props,\n        ref,\n        onError,\n        onDuration,\n        pauseWhenBuffering: pauseWhenBuffering ?? false,\n        _remotionInternalNeedsDurationCalculation: Boolean(loop),\n        showInTimeline: showInTimeline ?? true\n    });\n};\nvar Audio = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_0__.forwardRef)(AudioRefForwardingFunction);\naddSequenceStackTraces(Audio);\n// src/Composition.tsx\n\n\n// src/Folder.tsx\n\n// src/validation/validate-folder-name.ts\nvar getRegex = ()=>/^([a-zA-Z0-9-\\u4E00-\\u9FFF])+$/g;\nvar isFolderNameValid = (name)=>name.match(getRegex());\nvar validateFolderName = (name)=>{\n    if (name === undefined || name === null) {\n        throw new TypeError(\"You must pass a name to a <Folder />.\");\n    }\n    if (typeof name !== \"string\") {\n        throw new TypeError(`The \"name\" you pass into <Folder /> must be a string. Got: ${typeof name}`);\n    }\n    if (!isFolderNameValid(name)) {\n        throw new Error(`Folder name can only contain a-z, A-Z, 0-9 and -. You passed ${name}`);\n    }\n};\nvar invalidFolderNameErrorMessage = `Folder name must match ${String(getRegex())}`;\n// src/Folder.tsx\n\nvar FolderContext = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_0__.createContext)({\n    folderName: null,\n    parentName: null\n});\nvar Folder = ({ name, children })=>{\n    const parent = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(FolderContext);\n    const { registerFolder, unregisterFolder } = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(CompositionManager);\n    validateFolderName(name);\n    const parentNameArr = [\n        parent.parentName,\n        parent.folderName\n    ].filter(truthy);\n    const parentName = parentNameArr.length === 0 ? null : parentNameArr.join(\"/\");\n    const value = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>{\n        return {\n            folderName: name,\n            parentName\n        };\n    }, [\n        name,\n        parentName\n    ]);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        registerFolder(name, parentName);\n        return ()=>{\n            unregisterFolder(name, parentName);\n        };\n    }, [\n        name,\n        parent.folderName,\n        parentName,\n        registerFolder,\n        unregisterFolder\n    ]);\n    return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(FolderContext.Provider, {\n        value,\n        children\n    });\n};\n// src/loading-indicator.tsx\n\nvar rotate = {\n    transform: `rotate(90deg)`\n};\nvar ICON_SIZE = 40;\nvar label = {\n    color: \"white\",\n    fontSize: 14,\n    fontFamily: \"sans-serif\"\n};\nvar container = {\n    justifyContent: \"center\",\n    alignItems: \"center\"\n};\nvar Loading = ()=>{\n    return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsxs)(AbsoluteFill, {\n        style: container,\n        id: \"remotion-comp-loading\",\n        children: [\n            /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(\"style\", {\n                type: \"text/css\",\n                children: `\n\t\t\t\t@keyframes anim {\n\t\t\t\t\tfrom {\n\t\t\t\t\t\topacity: 0\n\t\t\t\t\t}\n\t\t\t\t\tto {\n\t\t\t\t\t\topacity: 1\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t#remotion-comp-loading {\n\t\t\t\t\tanimation: anim 2s;\n\t\t\t\t\tanimation-fill-mode: forwards;\n\t\t\t\t}\n\t\t\t`\n            }),\n            /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(\"svg\", {\n                width: ICON_SIZE,\n                height: ICON_SIZE,\n                viewBox: \"-100 -100 400 400\",\n                style: rotate,\n                children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(\"path\", {\n                    fill: \"#555\",\n                    stroke: \"#555\",\n                    strokeWidth: \"100\",\n                    strokeLinejoin: \"round\",\n                    d: \"M 2 172 a 196 100 0 0 0 195 5 A 196 240 0 0 0 100 2.259 A 196 240 0 0 0 2 172 z\"\n                })\n            }),\n            /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsxs)(\"p\", {\n                style: label,\n                children: [\n                    \"Resolving \",\n                    \"<Suspense>\",\n                    \"...\"\n                ]\n            })\n        ]\n    });\n};\n// src/portal-node.ts\nvar _portalNode = null;\nvar portalNode = ()=>{\n    if (!_portalNode) {\n        if (typeof document === \"undefined\") {\n            throw new Error(\"Tried to call an API that only works in the browser from outside the browser\");\n        }\n        _portalNode = document.createElement(\"div\");\n        _portalNode.style.position = \"absolute\";\n        _portalNode.style.top = \"0px\";\n        _portalNode.style.left = \"0px\";\n        _portalNode.style.right = \"0px\";\n        _portalNode.style.bottom = \"0px\";\n        _portalNode.style.width = \"100%\";\n        _portalNode.style.height = \"100%\";\n        _portalNode.style.display = \"flex\";\n        _portalNode.style.flexDirection = \"column\";\n        const containerNode = document.createElement(\"div\");\n        containerNode.style.position = \"fixed\";\n        containerNode.style.top = -999999 + \"px\";\n        containerNode.appendChild(_portalNode);\n        document.body.appendChild(containerNode);\n    }\n    return _portalNode;\n};\n// src/use-lazy-component.ts\n\nvar useLazyComponent = (compProps)=>{\n    const lazy = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>{\n        if (\"lazyComponent\" in compProps && typeof compProps.lazyComponent !== \"undefined\") {\n            return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.lazy(compProps.lazyComponent);\n        }\n        if (\"component\" in compProps) {\n            if (typeof document === \"undefined\") {\n                return compProps.component;\n            }\n            return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.lazy(()=>Promise.resolve({\n                    default: compProps.component\n                }));\n        }\n        throw new Error(\"You must pass either 'component' or 'lazyComponent'\");\n    }, [\n        compProps.component,\n        compProps.lazyComponent\n    ]);\n    return lazy;\n};\n// src/validation/validate-composition-id.ts\nvar getRegex2 = ()=>/^([a-zA-Z0-9-\\u4E00-\\u9FFF])+$/g;\nvar isCompositionIdValid = (id)=>id.match(getRegex2());\nvar validateCompositionId = (id)=>{\n    if (!isCompositionIdValid(id)) {\n        throw new Error(`Composition id can only contain a-z, A-Z, 0-9, CJK characters and -. You passed ${id}`);\n    }\n};\nvar invalidCompositionErrorMessage = `Composition ID must match ${String(getRegex2())}`;\n// src/validation/validate-default-props.ts\nvar validateDefaultAndInputProps = (defaultProps, name, compositionId)=>{\n    if (!defaultProps) {\n        return;\n    }\n    if (typeof defaultProps !== \"object\") {\n        throw new Error(`\"${name}\" must be an object, but you passed a value of type ${typeof defaultProps}`);\n    }\n    if (Array.isArray(defaultProps)) {\n        throw new Error(`\"${name}\" must be an object, an array was passed ${compositionId ? `for composition \"${compositionId}\"` : \"\"}`);\n    }\n};\n// src/Composition.tsx\n\nvar ClipComposition = ({ children })=>{\n    const { clipRegion } = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(NativeLayersContext);\n    const style = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>{\n        return {\n            display: \"flex\",\n            flexDirection: \"row\",\n            opacity: clipRegion === \"hide\" ? 0 : 1,\n            clipPath: clipRegion && clipRegion !== \"hide\" ? `polygon(${clipRegion.x}px ${clipRegion.y}px, ${clipRegion.x}px ${clipRegion.height + clipRegion.y}px, ${clipRegion.width + clipRegion.x}px ${clipRegion.height + clipRegion.y}px, ${clipRegion.width + clipRegion.x}px ${clipRegion.y}px)` : undefined\n        };\n    }, [\n        clipRegion\n    ]);\n    return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(AbsoluteFill, {\n        style,\n        children\n    });\n};\nvar Fallback = ()=>{\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        const fallback = delayRender(\"Waiting for Root component to unsuspend\");\n        return ()=>continueRender(fallback);\n    }, []);\n    return null;\n};\nvar Composition = ({ width, height, fps, durationInFrames, id, defaultProps, schema, ...compProps })=>{\n    const { registerComposition, unregisterComposition } = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(CompositionManager);\n    const video = useVideo();\n    const lazy = useLazyComponent(compProps);\n    const nonce = useNonce();\n    const isPlayer = useIsPlayer();\n    const environment = getRemotionEnvironment();\n    const canUseComposition = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(CanUseRemotionHooks);\n    if (canUseComposition) {\n        if (isPlayer) {\n            throw new Error(\"<Composition> was mounted inside the `component` that was passed to the <Player>. See https://remotion.dev/docs/wrong-composition-mount for help.\");\n        }\n        throw new Error(\"<Composition> mounted inside another composition. See https://remotion.dev/docs/wrong-composition-mount for help.\");\n    }\n    const { folderName, parentName } = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(FolderContext);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        if (!id) {\n            throw new Error(\"No id for composition passed.\");\n        }\n        validateCompositionId(id);\n        validateDefaultAndInputProps(defaultProps, \"defaultProps\", id);\n        registerComposition({\n            durationInFrames: durationInFrames ?? undefined,\n            fps: fps ?? undefined,\n            height: height ?? undefined,\n            width: width ?? undefined,\n            id,\n            folderName,\n            component: lazy,\n            defaultProps: serializeThenDeserializeInStudio(defaultProps ?? {}),\n            nonce,\n            parentFolderName: parentName,\n            schema: schema ?? null,\n            calculateMetadata: compProps.calculateMetadata ?? null\n        });\n        return ()=>{\n            unregisterComposition(id);\n        };\n    }, [\n        durationInFrames,\n        fps,\n        height,\n        lazy,\n        id,\n        folderName,\n        defaultProps,\n        registerComposition,\n        unregisterComposition,\n        width,\n        nonce,\n        parentName,\n        schema,\n        compProps.calculateMetadata\n    ]);\n    const resolved = useResolvedVideoConfig(id);\n    if (environment.isStudio && video && video.component === lazy) {\n        const Comp = lazy;\n        if (resolved === null || resolved.type !== \"success\") {\n            return null;\n        }\n        return /*#__PURE__*/ (0,react_dom__WEBPACK_IMPORTED_MODULE_2__.createPortal)(/* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(ClipComposition, {\n            children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(CanUseRemotionHooksProvider, {\n                children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(react__WEBPACK_IMPORTED_MODULE_0__.Suspense, {\n                    fallback: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(Loading, {}),\n                    children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(Comp, {\n                        ...resolved.result.props ?? {}\n                    })\n                })\n            })\n        }), portalNode());\n    }\n    if (environment.isRendering && video && video.component === lazy) {\n        const Comp = lazy;\n        if (resolved === null || resolved.type !== \"success\") {\n            return null;\n        }\n        return /*#__PURE__*/ (0,react_dom__WEBPACK_IMPORTED_MODULE_2__.createPortal)(/* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(CanUseRemotionHooksProvider, {\n            children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(react__WEBPACK_IMPORTED_MODULE_0__.Suspense, {\n                fallback: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(Fallback, {}),\n                children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(Comp, {\n                    ...resolved.result.props ?? {}\n                })\n            })\n        }), portalNode());\n    }\n    return null;\n};\n// src/CompositionManager.tsx\n\n\nvar compositionsRef = /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createRef();\nvar CompositionManagerProvider = ({ children, numberOfAudioTags })=>{\n    const [compositions, setCompositions] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)([]);\n    const currentcompositionsRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(compositions);\n    const [folders, setFolders] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)([]);\n    const [canvasContent, setCanvasContent] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(null);\n    const [currentCompositionMetadata, setCurrentCompositionMetadata] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(null);\n    const updateCompositions = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((updateComps)=>{\n        setCompositions((comps)=>{\n            const updated = updateComps(comps);\n            currentcompositionsRef.current = updated;\n            return updated;\n        });\n    }, []);\n    const registerComposition = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((comp)=>{\n        updateCompositions((comps)=>{\n            if (comps.find((c)=>c.id === comp.id)) {\n                throw new Error(`Multiple composition with id ${comp.id} are registered.`);\n            }\n            const value = [\n                ...comps,\n                comp\n            ].slice().sort((a, b)=>a.nonce - b.nonce);\n            return value;\n        });\n    }, [\n        updateCompositions\n    ]);\n    const unregisterComposition = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((id)=>{\n        setCompositions((comps)=>{\n            return comps.filter((c)=>c.id !== id);\n        });\n    }, []);\n    const registerFolder = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((name, parent)=>{\n        setFolders((prevFolders)=>{\n            return [\n                ...prevFolders,\n                {\n                    name,\n                    parent\n                }\n            ];\n        });\n    }, []);\n    const unregisterFolder = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((name, parent)=>{\n        setFolders((prevFolders)=>{\n            return prevFolders.filter((p)=>!(p.name === name && p.parent === parent));\n        });\n    }, []);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useImperativeHandle)(compositionsRef, ()=>{\n        return {\n            getCompositions: ()=>currentcompositionsRef.current\n        };\n    }, []);\n    const composition = compositions.find((c)=>canvasContent?.type === \"composition\" ? c.id === canvasContent.compositionId : null);\n    const updateCompositionDefaultProps = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((id, newDefaultProps)=>{\n        setCompositions((comps)=>{\n            const updated = comps.map((c)=>{\n                if (c.id === id) {\n                    return {\n                        ...c,\n                        defaultProps: newDefaultProps\n                    };\n                }\n                return c;\n            });\n            return updated;\n        });\n    }, []);\n    const contextValue = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>{\n        return {\n            compositions,\n            registerComposition,\n            unregisterComposition,\n            folders,\n            registerFolder,\n            unregisterFolder,\n            currentCompositionMetadata,\n            setCurrentCompositionMetadata,\n            canvasContent,\n            setCanvasContent,\n            updateCompositionDefaultProps\n        };\n    }, [\n        compositions,\n        registerComposition,\n        unregisterComposition,\n        folders,\n        registerFolder,\n        unregisterFolder,\n        currentCompositionMetadata,\n        canvasContent,\n        updateCompositionDefaultProps\n    ]);\n    return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(CompositionManager.Provider, {\n        value: contextValue,\n        children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(SequenceManagerProvider, {\n            children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(RenderAssetManagerProvider, {\n                children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(ResolveCompositionConfig, {\n                    children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(SharedAudioContextProvider, {\n                        numberOfAudioTags,\n                        component: composition?.component ?? null,\n                        children\n                    })\n                })\n            })\n        })\n    });\n};\n// src/bezier.ts\nfunction a(aA1, aA2) {\n    return 1 - 3 * aA2 + 3 * aA1;\n}\nfunction b(aA1, aA2) {\n    return 3 * aA2 - 6 * aA1;\n}\nfunction c(aA1) {\n    return 3 * aA1;\n}\nfunction calcBezier(aT, aA1, aA2) {\n    return ((a(aA1, aA2) * aT + b(aA1, aA2)) * aT + c(aA1)) * aT;\n}\nfunction getSlope(aT, aA1, aA2) {\n    return 3 * a(aA1, aA2) * aT * aT + 2 * b(aA1, aA2) * aT + c(aA1);\n}\nfunction binarySubdivide({ aX, _aA, _aB, mX1, mX2 }) {\n    let currentX;\n    let currentT;\n    let i = 0;\n    let aA = _aA;\n    let aB = _aB;\n    do {\n        currentT = aA + (aB - aA) / 2;\n        currentX = calcBezier(currentT, mX1, mX2) - aX;\n        if (currentX > 0) {\n            aB = currentT;\n        } else {\n            aA = currentT;\n        }\n    }while (Math.abs(currentX) > SUBDIVISION_PRECISION && ++i < SUBDIVISION_MAX_ITERATIONS);\n    return currentT;\n}\nfunction newtonRaphsonIterate(aX, _aGuessT, mX1, mX2) {\n    let aGuessT = _aGuessT;\n    for(let i = 0; i < NEWTON_ITERATIONS; ++i){\n        const currentSlope = getSlope(aGuessT, mX1, mX2);\n        if (currentSlope === 0) {\n            return aGuessT;\n        }\n        const currentX = calcBezier(aGuessT, mX1, mX2) - aX;\n        aGuessT -= currentX / currentSlope;\n    }\n    return aGuessT;\n}\nfunction bezier(mX1, mY1, mX2, mY2) {\n    if (!(mX1 >= 0 && mX1 <= 1 && mX2 >= 0 && mX2 <= 1)) {\n        throw new Error(\"bezier x values must be in [0, 1] range\");\n    }\n    const sampleValues = float32ArraySupported ? new Float32Array(kSplineTableSize) : new Array(kSplineTableSize);\n    if (mX1 !== mY1 || mX2 !== mY2) {\n        for(let i = 0; i < kSplineTableSize; ++i){\n            sampleValues[i] = calcBezier(i * kSampleStepSize, mX1, mX2);\n        }\n    }\n    function getTForX(aX) {\n        let intervalStart = 0;\n        let currentSample = 1;\n        const lastSample = kSplineTableSize - 1;\n        for(; currentSample !== lastSample && sampleValues[currentSample] <= aX; ++currentSample){\n            intervalStart += kSampleStepSize;\n        }\n        --currentSample;\n        const dist = (aX - sampleValues[currentSample]) / (sampleValues[currentSample + 1] - sampleValues[currentSample]);\n        const guessForT = intervalStart + dist * kSampleStepSize;\n        const initialSlope = getSlope(guessForT, mX1, mX2);\n        if (initialSlope >= NEWTON_MIN_SLOPE) {\n            return newtonRaphsonIterate(aX, guessForT, mX1, mX2);\n        }\n        if (initialSlope === 0) {\n            return guessForT;\n        }\n        return binarySubdivide({\n            aX,\n            _aA: intervalStart,\n            _aB: intervalStart + kSampleStepSize,\n            mX1,\n            mX2\n        });\n    }\n    return function(x) {\n        if (mX1 === mY1 && mX2 === mY2) {\n            return x;\n        }\n        if (x === 0) {\n            return 0;\n        }\n        if (x === 1) {\n            return 1;\n        }\n        return calcBezier(getTForX(x), mY1, mY2);\n    };\n}\nvar NEWTON_ITERATIONS = 4;\nvar NEWTON_MIN_SLOPE = 0.001;\nvar SUBDIVISION_PRECISION = 0.0000001;\nvar SUBDIVISION_MAX_ITERATIONS = 10;\nvar kSplineTableSize = 11;\nvar kSampleStepSize = 1 / (kSplineTableSize - 1);\nvar float32ArraySupported = typeof Float32Array === \"function\";\n// src/easing.ts\nclass Easing {\n    static step0(n) {\n        return n > 0 ? 1 : 0;\n    }\n    static step1(n) {\n        return n >= 1 ? 1 : 0;\n    }\n    static linear(t) {\n        return t;\n    }\n    static ease(t) {\n        return Easing.bezier(0.42, 0, 1, 1)(t);\n    }\n    static quad(t) {\n        return t * t;\n    }\n    static cubic(t) {\n        return t * t * t;\n    }\n    static poly(n) {\n        return (t)=>t ** n;\n    }\n    static sin(t) {\n        return 1 - Math.cos(t * Math.PI / 2);\n    }\n    static circle(t) {\n        return 1 - Math.sqrt(1 - t * t);\n    }\n    static exp(t) {\n        return 2 ** (10 * (t - 1));\n    }\n    static elastic(bounciness = 1) {\n        const p = bounciness * Math.PI;\n        return (t)=>1 - Math.cos(t * Math.PI / 2) ** 3 * Math.cos(t * p);\n    }\n    static back(s = 1.70158) {\n        return (t)=>t * t * ((s + 1) * t - s);\n    }\n    static bounce(t) {\n        if (t < 1 / 2.75) {\n            return 7.5625 * t * t;\n        }\n        if (t < 2 / 2.75) {\n            const t2_ = t - 1.5 / 2.75;\n            return 7.5625 * t2_ * t2_ + 0.75;\n        }\n        if (t < 2.5 / 2.75) {\n            const t2_ = t - 2.25 / 2.75;\n            return 7.5625 * t2_ * t2_ + 0.9375;\n        }\n        const t2 = t - 2.625 / 2.75;\n        return 7.5625 * t2 * t2 + 0.984375;\n    }\n    static bezier(x1, y1, x2, y2) {\n        return bezier(x1, y1, x2, y2);\n    }\n    static in(easing) {\n        return easing;\n    }\n    static out(easing) {\n        return (t)=>1 - easing(1 - t);\n    }\n    static inOut(easing) {\n        return (t)=>{\n            if (t < 0.5) {\n                return easing(t * 2) / 2;\n            }\n            return 1 - easing((1 - t) * 2) / 2;\n        };\n    }\n}\n// src/v5-flag.ts\nvar ENABLE_V5_BREAKING_CHANGES = false;\n// src/get-static-files.ts\nvar warnedServer = false;\nvar warnedPlayer = false;\nvar warnServerOnce = ()=>{\n    if (warnedServer) {\n        return;\n    }\n    warnedServer = true;\n    console.warn(\"Called getStaticFiles() on the server. The API is only available in the browser. An empty array was returned.\");\n};\nvar warnPlayerOnce = ()=>{\n    if (warnedPlayer) {\n        return;\n    }\n    warnedPlayer = true;\n    console.warn(\"Called getStaticFiles() while using the Remotion Player. The API is only available while using the Remotion Studio. An empty array was returned.\");\n};\nvar getStaticFiles = ()=>{\n    if (ENABLE_V5_BREAKING_CHANGES) {\n        throw new Error(\"getStaticFiles() has moved into the `@remotion/studio` package. Update your imports.\");\n    }\n    if (typeof document === \"undefined\") {\n        warnServerOnce();\n        return [];\n    }\n    if (window.remotion_isPlayer) {\n        warnPlayerOnce();\n        return [];\n    }\n    return window.remotion_staticFiles;\n};\n// src/IFrame.tsx\n\n\nvar IFrameRefForwarding = ({ onLoad, onError, delayRenderRetries, delayRenderTimeoutInMilliseconds, ...props2 }, ref)=>{\n    const [handle] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(()=>delayRender(`Loading <IFrame> with source ${props2.src}`, {\n            retries: delayRenderRetries ?? undefined,\n            timeoutInMilliseconds: delayRenderTimeoutInMilliseconds ?? undefined\n        }));\n    const didLoad = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((e)=>{\n        continueRender(handle);\n        onLoad?.(e);\n    }, [\n        handle,\n        onLoad\n    ]);\n    const didGetError = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((e)=>{\n        continueRender(handle);\n        if (onError) {\n            onError(e);\n        } else {\n            console.error(\"Error loading iframe:\", e, \"Handle the event using the onError() prop to make this message disappear.\");\n        }\n    }, [\n        handle,\n        onError\n    ]);\n    return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(\"iframe\", {\n        ...props2,\n        ref,\n        onError: didGetError,\n        onLoad: didLoad\n    });\n};\nvar IFrame = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_0__.forwardRef)(IFrameRefForwarding);\n// src/Img.tsx\n\nfunction exponentialBackoff(errorCount) {\n    return 1000 * 2 ** (errorCount - 1);\n}\n\nvar ImgRefForwarding = ({ onError, maxRetries = 2, src, pauseWhenLoading, delayRenderRetries, delayRenderTimeoutInMilliseconds, onImageFrame, ...props2 }, ref)=>{\n    const imageRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n    const errors = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)({});\n    const { delayPlayback } = useBufferState();\n    const sequenceContext = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(SequenceContext);\n    if (!src) {\n        throw new Error('No \"src\" prop was passed to <Img>.');\n    }\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useImperativeHandle)(ref, ()=>{\n        return imageRef.current;\n    }, []);\n    const actualSrc = usePreload(src);\n    const retryIn = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((timeout)=>{\n        if (!imageRef.current) {\n            return;\n        }\n        const currentSrc = imageRef.current.src;\n        setTimeout(()=>{\n            if (!imageRef.current) {\n                return;\n            }\n            const newSrc = imageRef.current?.src;\n            if (newSrc !== currentSrc) {\n                return;\n            }\n            imageRef.current.removeAttribute(\"src\");\n            imageRef.current.setAttribute(\"src\", newSrc);\n        }, timeout);\n    }, []);\n    const didGetError = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((e)=>{\n        if (!errors.current) {\n            return;\n        }\n        errors.current[imageRef.current?.src] = (errors.current[imageRef.current?.src] ?? 0) + 1;\n        if (onError && (errors.current[imageRef.current?.src] ?? 0) > maxRetries) {\n            onError(e);\n            return;\n        }\n        if ((errors.current[imageRef.current?.src] ?? 0) <= maxRetries) {\n            const backoff = exponentialBackoff(errors.current[imageRef.current?.src] ?? 0);\n            console.warn(`Could not load image with source ${imageRef.current?.src}, retrying again in ${backoff}ms`);\n            retryIn(backoff);\n            return;\n        }\n        cancelRender(\"Error loading image with src: \" + imageRef.current?.src);\n    }, [\n        maxRetries,\n        onError,\n        retryIn\n    ]);\n    if (false) {}\n    return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(\"img\", {\n        ...props2,\n        ref: imageRef,\n        onError: didGetError\n    });\n};\nvar Img = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_0__.forwardRef)(ImgRefForwarding);\n// src/default-css.ts\nvar exports_default_css = {};\n__export(exports_default_css, {\n    makeDefaultPreviewCSS: ()=>makeDefaultPreviewCSS,\n    injectCSS: ()=>injectCSS,\n    OFFTHREAD_VIDEO_CLASS_NAME: ()=>OFFTHREAD_VIDEO_CLASS_NAME\n});\nvar injected = {};\nvar injectCSS = (css)=>{\n    if (typeof document === \"undefined\") {\n        return;\n    }\n    if (injected[css]) {\n        return;\n    }\n    const head = document.head || document.getElementsByTagName(\"head\")[0];\n    const style = document.createElement(\"style\");\n    style.appendChild(document.createTextNode(css));\n    head.prepend(style);\n    injected[css] = true;\n};\nvar OFFTHREAD_VIDEO_CLASS_NAME = \"__remotion_offthreadvideo\";\nvar makeDefaultPreviewCSS = (scope, backgroundColor)=>{\n    if (!scope) {\n        return `\n    * {\n      box-sizing: border-box;\n    }\n    body {\n      margin: 0;\n\t    background-color: ${backgroundColor};\n    }\n    .${OFFTHREAD_VIDEO_CLASS_NAME} {\n      object-fit: contain;\n    }\n    `;\n    }\n    return `\n    ${scope} * {\n      box-sizing: border-box;\n    }\n    ${scope} *:-webkit-full-screen {\n      width: 100%;\n      height: 100%;\n    }\n    ${scope} .${OFFTHREAD_VIDEO_CLASS_NAME} {\n      object-fit: contain;\n    }\n  `;\n};\n// src/get-preview-dom-element.ts\nvar REMOTION_STUDIO_CONTAINER_ELEMENT = \"__remotion-studio-container\";\nvar getPreviewDomElement = ()=>{\n    return document.getElementById(REMOTION_STUDIO_CONTAINER_ELEMENT);\n};\n// src/register-root.ts\nvar Root = null;\nvar listeners = [];\nvar registerRoot = (comp)=>{\n    if (!comp) {\n        throw new Error(`You must pass a React component to registerRoot(), but ${JSON.stringify(comp)} was passed.`);\n    }\n    if (Root) {\n        throw new Error(\"registerRoot() was called more than once.\");\n    }\n    Root = comp;\n    listeners.forEach((l)=>{\n        l(comp);\n    });\n};\nvar getRoot = ()=>{\n    return Root;\n};\nvar waitForRoot = (fn)=>{\n    if (Root) {\n        fn(Root);\n        return ()=>{\n            return;\n        };\n    }\n    listeners.push(fn);\n    return ()=>{\n        listeners = listeners.filter((l)=>l !== fn);\n    };\n};\n// src/RemotionRoot.tsx\n\n\nvar RemotionRoot = ({ children, numberOfAudioTags })=>{\n    const [remotionRootId] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(()=>String(random(null)));\n    const [frame, setFrame] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(()=>getInitialFrameState());\n    const [playing, setPlaying] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(false);\n    const imperativePlaying = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(false);\n    const [fastRefreshes, setFastRefreshes] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(0);\n    const [playbackRate, setPlaybackRate] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(1);\n    const audioAndVideoTags = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)([]);\n    if (false) {}\n    const timelineContextValue = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>{\n        return {\n            frame,\n            playing,\n            imperativePlaying,\n            rootId: remotionRootId,\n            playbackRate,\n            setPlaybackRate,\n            audioAndVideoTags\n        };\n    }, [\n        frame,\n        playbackRate,\n        playing,\n        remotionRootId\n    ]);\n    const setTimelineContextValue = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>{\n        return {\n            setFrame,\n            setPlaying\n        };\n    }, []);\n    const nonceContext = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>{\n        let counter = 0;\n        return {\n            getNonce: ()=>counter++,\n            fastRefreshes\n        };\n    }, [\n        fastRefreshes\n    ]);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        if (true) {\n            if (__webpack_module__.hot) {\n                __webpack_module__.hot.addStatusHandler((status)=>{\n                    if (status === \"idle\") {\n                        setFastRefreshes((i)=>i + 1);\n                    }\n                });\n            }\n        }\n    }, []);\n    return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(NonceContext.Provider, {\n        value: nonceContext,\n        children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(TimelineContext.Provider, {\n            value: timelineContextValue,\n            children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(SetTimelineContext.Provider, {\n                value: setTimelineContextValue,\n                children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(EditorPropsProvider, {\n                    children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(PrefetchProvider, {\n                        children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(NativeLayersProvider, {\n                            children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(CompositionManagerProvider, {\n                                numberOfAudioTags,\n                                children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(DurationsContextProvider, {\n                                    children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(BufferingProvider, {\n                                        children\n                                    })\n                                })\n                            })\n                        })\n                    })\n                })\n            })\n        })\n    });\n};\n// src/setup-env-variables.ts\nvar getEnvVariables = ()=>{\n    if (getRemotionEnvironment().isRendering) {\n        const param = window.remotion_envVariables;\n        if (!param) {\n            return {};\n        }\n        return {\n            ...JSON.parse(param),\n            NODE_ENV: \"production\"\n        };\n    }\n    if (false) {}\n    return {\n        NODE_ENV: \"production\"\n    };\n};\nvar setupEnvVariables = ()=>{\n    const env = getEnvVariables();\n    if (!window.process) {\n        window.process = {};\n    }\n    if (!window.process.env) {\n        window.process.env = {};\n    }\n    Object.keys(env).forEach((key)=>{\n        window.process.env[key] = env[key];\n    });\n};\n// src/use-current-scale.ts\n\nvar CurrentScaleContext = /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createContext(null);\nvar PreviewSizeContext = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_0__.createContext)({\n    setSize: ()=>{\n        return;\n    },\n    size: {\n        size: \"auto\",\n        translation: {\n            x: 0,\n            y: 0\n        }\n    }\n});\nvar calculateScale = ({ canvasSize, compositionHeight, compositionWidth, previewSize })=>{\n    const heightRatio = canvasSize.height / compositionHeight;\n    const widthRatio = canvasSize.width / compositionWidth;\n    const ratio = Math.min(heightRatio, widthRatio);\n    return previewSize === \"auto\" ? ratio : Number(previewSize);\n};\nvar useCurrentScale = (options)=>{\n    const hasContext = react__WEBPACK_IMPORTED_MODULE_0__.useContext(CurrentScaleContext);\n    const zoomContext = react__WEBPACK_IMPORTED_MODULE_0__.useContext(PreviewSizeContext);\n    const config = useUnsafeVideoConfig();\n    if (hasContext === null || config === null || zoomContext === null) {\n        if (options?.dontThrowIfOutsideOfRemotion) {\n            return 1;\n        }\n        if (getRemotionEnvironment().isRendering) {\n            return 1;\n        }\n        throw new Error([\n            \"useCurrentScale() was called outside of a Remotion context.\",\n            \"This hook can only be called in a component that is being rendered by Remotion.\",\n            \"If you want to this hook to return 1 outside of Remotion, pass {dontThrowIfOutsideOfRemotion: true} as an option.\",\n            \"If you think you called this hook in a Remotion component, make sure all versions of Remotion are aligned.\"\n        ].join(\"\\n\"));\n    }\n    if (hasContext.type === \"scale\") {\n        return hasContext.scale;\n    }\n    return calculateScale({\n        canvasSize: hasContext.canvasSize,\n        compositionHeight: config.height,\n        compositionWidth: config.width,\n        previewSize: zoomContext.size.size\n    });\n};\n// src/watch-static-file.ts\nvar WATCH_REMOTION_STATIC_FILES = \"remotion_staticFilesChanged\";\nvar watchStaticFile = (fileName, callback)=>{\n    if (ENABLE_V5_BREAKING_CHANGES) {\n        throw new Error(\"watchStaticFile() has moved into the `@remotion/studio` package. Update your imports.\");\n    }\n    if (!getRemotionEnvironment().isStudio) {\n        console.warn(\"The API is only available while using the Remotion Studio.\");\n        return {\n            cancel: ()=>{\n                return;\n            }\n        };\n    }\n    const withoutStaticBase = fileName.startsWith(window.remotion_staticBase) ? fileName.replace(window.remotion_staticBase, \"\") : fileName;\n    const withoutLeadingSlash = withoutStaticBase.startsWith(\"/\") ? withoutStaticBase.slice(1) : withoutStaticBase;\n    let prevFileData = window.remotion_staticFiles.find((file)=>file.name === withoutLeadingSlash);\n    const checkFile = (event)=>{\n        const staticFiles = event.detail.files;\n        const newFileData = staticFiles.find((file)=>file.name === withoutLeadingSlash);\n        if (!newFileData) {\n            if (prevFileData !== undefined) {\n                callback(null);\n            }\n            prevFileData = undefined;\n            return;\n        }\n        if (prevFileData === undefined || prevFileData.lastModified !== newFileData.lastModified) {\n            callback(newFileData);\n            prevFileData = newFileData;\n        }\n    };\n    window.addEventListener(WATCH_REMOTION_STATIC_FILES, checkFile);\n    const cancel = ()=>{\n        return window.removeEventListener(WATCH_REMOTION_STATIC_FILES, checkFile);\n    };\n    return {\n        cancel\n    };\n};\n// src/wrap-remotion-context.tsx\n\nfunction useRemotionContexts() {\n    const compositionManagerCtx = react__WEBPACK_IMPORTED_MODULE_0__.useContext(CompositionManager);\n    const timelineContext = react__WEBPACK_IMPORTED_MODULE_0__.useContext(TimelineContext);\n    const setTimelineContext = react__WEBPACK_IMPORTED_MODULE_0__.useContext(SetTimelineContext);\n    const sequenceContext = react__WEBPACK_IMPORTED_MODULE_0__.useContext(SequenceContext);\n    const nonceContext = react__WEBPACK_IMPORTED_MODULE_0__.useContext(NonceContext);\n    const canUseRemotionHooksContext = react__WEBPACK_IMPORTED_MODULE_0__.useContext(CanUseRemotionHooks);\n    const nativeLayersContext = react__WEBPACK_IMPORTED_MODULE_0__.useContext(NativeLayersContext);\n    const preloadContext = react__WEBPACK_IMPORTED_MODULE_0__.useContext(PreloadContext);\n    const resolveCompositionContext = react__WEBPACK_IMPORTED_MODULE_0__.useContext(ResolveCompositionContext);\n    const renderAssetManagerContext = react__WEBPACK_IMPORTED_MODULE_0__.useContext(RenderAssetManager);\n    const sequenceManagerContext = react__WEBPACK_IMPORTED_MODULE_0__.useContext(SequenceManager);\n    const bufferManagerContext = react__WEBPACK_IMPORTED_MODULE_0__.useContext(BufferingContextReact);\n    return (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>({\n            compositionManagerCtx,\n            timelineContext,\n            setTimelineContext,\n            sequenceContext,\n            nonceContext,\n            canUseRemotionHooksContext,\n            nativeLayersContext,\n            preloadContext,\n            resolveCompositionContext,\n            renderAssetManagerContext,\n            sequenceManagerContext,\n            bufferManagerContext\n        }), [\n        compositionManagerCtx,\n        nonceContext,\n        sequenceContext,\n        setTimelineContext,\n        timelineContext,\n        canUseRemotionHooksContext,\n        nativeLayersContext,\n        preloadContext,\n        resolveCompositionContext,\n        renderAssetManagerContext,\n        sequenceManagerContext,\n        bufferManagerContext\n    ]);\n}\n\nvar RemotionContextProvider = (props2)=>{\n    const { children, contexts } = props2;\n    return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(CanUseRemotionHooks.Provider, {\n        value: contexts.canUseRemotionHooksContext,\n        children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(NonceContext.Provider, {\n            value: contexts.nonceContext,\n            children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(NativeLayersContext.Provider, {\n                value: contexts.nativeLayersContext,\n                children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(PreloadContext.Provider, {\n                    value: contexts.preloadContext,\n                    children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(CompositionManager.Provider, {\n                        value: contexts.compositionManagerCtx,\n                        children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(SequenceManager.Provider, {\n                            value: contexts.sequenceManagerContext,\n                            children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(RenderAssetManager.Provider, {\n                                value: contexts.renderAssetManagerContext,\n                                children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(ResolveCompositionContext.Provider, {\n                                    value: contexts.resolveCompositionContext,\n                                    children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(TimelineContext.Provider, {\n                                        value: contexts.timelineContext,\n                                        children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(SetTimelineContext.Provider, {\n                                            value: contexts.setTimelineContext,\n                                            children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(SequenceContext.Provider, {\n                                                value: contexts.sequenceContext,\n                                                children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(BufferingContextReact.Provider, {\n                                                    value: contexts.bufferManagerContext,\n                                                    children\n                                                })\n                                            })\n                                        })\n                                    })\n                                })\n                            })\n                        })\n                    })\n                })\n            })\n        })\n    });\n};\n// src/internals.ts\nvar Internals = {\n    useUnsafeVideoConfig,\n    Timeline: exports_timeline_position_state,\n    CompositionManager,\n    SequenceManager,\n    SequenceVisibilityToggleContext,\n    RemotionRoot,\n    useVideo,\n    getRoot,\n    useMediaVolumeState,\n    useMediaMutedState,\n    useLazyComponent,\n    truthy,\n    SequenceContext,\n    useRemotionContexts,\n    RemotionContextProvider,\n    CSSUtils: exports_default_css,\n    setupEnvVariables,\n    MediaVolumeContext,\n    SetMediaVolumeContext,\n    getRemotionEnvironment,\n    SharedAudioContext,\n    SharedAudioContextProvider,\n    invalidCompositionErrorMessage,\n    isCompositionIdValid,\n    getPreviewDomElement,\n    compositionsRef,\n    portalNode,\n    waitForRoot,\n    CanUseRemotionHooksProvider,\n    CanUseRemotionHooks,\n    PrefetchProvider,\n    DurationsContextProvider,\n    IsPlayerContextProvider,\n    useIsPlayer,\n    EditorPropsProvider,\n    EditorPropsContext,\n    usePreload,\n    NonceContext,\n    resolveVideoConfig,\n    useResolvedVideoConfig,\n    resolveCompositionsRef,\n    ResolveCompositionConfig,\n    REMOTION_STUDIO_CONTAINER_ELEMENT,\n    RenderAssetManager,\n    persistCurrentFrame,\n    useTimelineSetFrame,\n    NativeLayersProvider,\n    ClipComposition,\n    isIosSafari,\n    WATCH_REMOTION_STATIC_FILES,\n    addSequenceStackTraces,\n    useMediaStartsAt,\n    BufferingProvider,\n    BufferingContextReact,\n    enableSequenceStackTraces,\n    CurrentScaleContext,\n    PreviewSizeContext,\n    calculateScale,\n    editorPropsProviderRef,\n    PROPS_UPDATED_EXTERNALLY,\n    validateRenderAsset\n};\n// src/interpolate-colors.ts\nfunction call(...args) {\n    return \"\\\\(\\\\s*(\" + args.join(\")\\\\s*,\\\\s*(\") + \")\\\\s*\\\\)\";\n}\nfunction getMatchers() {\n    const cachedMatchers = {\n        rgb: undefined,\n        rgba: undefined,\n        hsl: undefined,\n        hsla: undefined,\n        hex3: undefined,\n        hex4: undefined,\n        hex5: undefined,\n        hex6: undefined,\n        hex8: undefined\n    };\n    if (cachedMatchers.rgb === undefined) {\n        cachedMatchers.rgb = new RegExp(\"rgb\" + call(NUMBER, NUMBER, NUMBER));\n        cachedMatchers.rgba = new RegExp(\"rgba\" + call(NUMBER, NUMBER, NUMBER, NUMBER));\n        cachedMatchers.hsl = new RegExp(\"hsl\" + call(NUMBER, PERCENTAGE, PERCENTAGE));\n        cachedMatchers.hsla = new RegExp(\"hsla\" + call(NUMBER, PERCENTAGE, PERCENTAGE, NUMBER));\n        cachedMatchers.hex3 = /^#([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})$/;\n        cachedMatchers.hex4 = /^#([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})$/;\n        cachedMatchers.hex6 = /^#([0-9a-fA-F]{6})$/;\n        cachedMatchers.hex8 = /^#([0-9a-fA-F]{8})$/;\n    }\n    return cachedMatchers;\n}\nfunction hue2rgb(p, q, t) {\n    if (t < 0) {\n        t += 1;\n    }\n    if (t > 1) {\n        t -= 1;\n    }\n    if (t < 1 / 6) {\n        return p + (q - p) * 6 * t;\n    }\n    if (t < 1 / 2) {\n        return q;\n    }\n    if (t < 2 / 3) {\n        return p + (q - p) * (2 / 3 - t) * 6;\n    }\n    return p;\n}\nfunction hslToRgb(h, s, l) {\n    const q = l < 0.5 ? l * (1 + s) : l + s - l * s;\n    const p = 2 * l - q;\n    const r = hue2rgb(p, q, h + 1 / 3);\n    const g = hue2rgb(p, q, h);\n    const b2 = hue2rgb(p, q, h - 1 / 3);\n    return Math.round(r * 255) << 24 | Math.round(g * 255) << 16 | Math.round(b2 * 255) << 8;\n}\nfunction parse255(str) {\n    const int = Number.parseInt(str, 10);\n    if (int < 0) {\n        return 0;\n    }\n    if (int > 255) {\n        return 255;\n    }\n    return int;\n}\nfunction parse360(str) {\n    const int = Number.parseFloat(str);\n    return (int % 360 + 360) % 360 / 360;\n}\nfunction parse1(str) {\n    const num = Number.parseFloat(str);\n    if (num < 0) {\n        return 0;\n    }\n    if (num > 1) {\n        return 255;\n    }\n    return Math.round(num * 255);\n}\nfunction parsePercentage(str) {\n    const int = Number.parseFloat(str);\n    if (int < 0) {\n        return 0;\n    }\n    if (int > 100) {\n        return 1;\n    }\n    return int / 100;\n}\nfunction normalizeColor(color) {\n    const matchers = getMatchers();\n    let match;\n    if (matchers.hex6) {\n        if (match = matchers.hex6.exec(color)) {\n            return Number.parseInt(match[1] + \"ff\", 16) >>> 0;\n        }\n    }\n    if (colorNames[color] !== undefined) {\n        return colorNames[color];\n    }\n    if (matchers.rgb) {\n        if (match = matchers.rgb.exec(color)) {\n            return (parse255(match[1]) << 24 | parse255(match[2]) << 16 | parse255(match[3]) << 8 | 255) >>> 0;\n        }\n    }\n    if (matchers.rgba) {\n        if (match = matchers.rgba.exec(color)) {\n            return (parse255(match[1]) << 24 | parse255(match[2]) << 16 | parse255(match[3]) << 8 | parse1(match[4])) >>> 0;\n        }\n    }\n    if (matchers.hex3) {\n        if (match = matchers.hex3.exec(color)) {\n            return Number.parseInt(match[1] + match[1] + match[2] + match[2] + match[3] + match[3] + \"ff\", 16) >>> 0;\n        }\n    }\n    if (matchers.hex8) {\n        if (match = matchers.hex8.exec(color)) {\n            return Number.parseInt(match[1], 16) >>> 0;\n        }\n    }\n    if (matchers.hex4) {\n        if (match = matchers.hex4.exec(color)) {\n            return Number.parseInt(match[1] + match[1] + match[2] + match[2] + match[3] + match[3] + match[4] + match[4], 16) >>> 0;\n        }\n    }\n    if (matchers.hsl) {\n        if (match = matchers.hsl.exec(color)) {\n            return (hslToRgb(parse360(match[1]), parsePercentage(match[2]), parsePercentage(match[3])) | 255) >>> 0;\n        }\n    }\n    if (matchers.hsla) {\n        if (match = matchers.hsla.exec(color)) {\n            return (hslToRgb(parse360(match[1]), parsePercentage(match[2]), parsePercentage(match[3])) | parse1(match[4])) >>> 0;\n        }\n    }\n    throw new Error(`invalid color string ${color} provided`);\n}\nfunction processColor(color) {\n    const normalizedColor = normalizeColor(color);\n    return (normalizedColor << 24 | normalizedColor >>> 8) >>> 0;\n}\nvar NUMBER = \"[-+]?\\\\d*\\\\.?\\\\d+\";\nvar PERCENTAGE = NUMBER + \"%\";\nvar colorNames = {\n    transparent: 0,\n    aliceblue: 4042850303,\n    antiquewhite: 4209760255,\n    aqua: 16777215,\n    aquamarine: 2147472639,\n    azure: 4043309055,\n    beige: 4126530815,\n    bisque: 4293182719,\n    black: 255,\n    blanchedalmond: 4293643775,\n    blue: 65535,\n    blueviolet: 2318131967,\n    brown: 2771004159,\n    burlywood: 3736635391,\n    burntsienna: 3934150143,\n    cadetblue: 1604231423,\n    chartreuse: 2147418367,\n    chocolate: 3530104575,\n    coral: 4286533887,\n    cornflowerblue: 1687547391,\n    cornsilk: 4294499583,\n    crimson: 3692313855,\n    cyan: 16777215,\n    darkblue: 35839,\n    darkcyan: 9145343,\n    darkgoldenrod: 3095792639,\n    darkgray: 2846468607,\n    darkgreen: 6553855,\n    darkgrey: 2846468607,\n    darkkhaki: 3182914559,\n    darkmagenta: 2332068863,\n    darkolivegreen: 1433087999,\n    darkorange: 4287365375,\n    darkorchid: 2570243327,\n    darkred: 2332033279,\n    darksalmon: 3918953215,\n    darkseagreen: 2411499519,\n    darkslateblue: 1211993087,\n    darkslategray: 793726975,\n    darkslategrey: 793726975,\n    darkturquoise: 13554175,\n    darkviolet: 2483082239,\n    deeppink: 4279538687,\n    deepskyblue: 12582911,\n    dimgray: 1768516095,\n    dimgrey: 1768516095,\n    dodgerblue: 512819199,\n    firebrick: 2988581631,\n    floralwhite: 4294635775,\n    forestgreen: 579543807,\n    fuchsia: 4278255615,\n    gainsboro: 3705462015,\n    ghostwhite: 4177068031,\n    gold: 4292280575,\n    goldenrod: 3668254975,\n    gray: 2155905279,\n    green: 8388863,\n    greenyellow: 2919182335,\n    grey: 2155905279,\n    honeydew: 4043305215,\n    hotpink: 4285117695,\n    indianred: 3445382399,\n    indigo: 1258324735,\n    ivory: 4294963455,\n    khaki: 4041641215,\n    lavender: 3873897215,\n    lavenderblush: 4293981695,\n    lawngreen: 2096890111,\n    lemonchiffon: 4294626815,\n    lightblue: 2916673279,\n    lightcoral: 4034953471,\n    lightcyan: 3774873599,\n    lightgoldenrodyellow: 4210742015,\n    lightgray: 3553874943,\n    lightgreen: 2431553791,\n    lightgrey: 3553874943,\n    lightpink: 4290167295,\n    lightsalmon: 4288707327,\n    lightseagreen: 548580095,\n    lightskyblue: 2278488831,\n    lightslategray: 2005441023,\n    lightslategrey: 2005441023,\n    lightsteelblue: 2965692159,\n    lightyellow: 4294959359,\n    lime: 16711935,\n    limegreen: 852308735,\n    linen: 4210091775,\n    magenta: 4278255615,\n    maroon: 2147483903,\n    mediumaquamarine: 1724754687,\n    mediumblue: 52735,\n    mediumorchid: 3126187007,\n    mediumpurple: 2473647103,\n    mediumseagreen: 1018393087,\n    mediumslateblue: 2070474495,\n    mediumspringgreen: 16423679,\n    mediumturquoise: 1221709055,\n    mediumvioletred: 3340076543,\n    midnightblue: 421097727,\n    mintcream: 4127193855,\n    mistyrose: 4293190143,\n    moccasin: 4293178879,\n    navajowhite: 4292783615,\n    navy: 33023,\n    oldlace: 4260751103,\n    olive: 2155872511,\n    olivedrab: 1804477439,\n    orange: 4289003775,\n    orangered: 4282712319,\n    orchid: 3664828159,\n    palegoldenrod: 4008225535,\n    palegreen: 2566625535,\n    paleturquoise: 2951671551,\n    palevioletred: 3681588223,\n    papayawhip: 4293907967,\n    peachpuff: 4292524543,\n    peru: 3448061951,\n    pink: 4290825215,\n    plum: 3718307327,\n    powderblue: 2967529215,\n    purple: 2147516671,\n    rebeccapurple: 1714657791,\n    red: 4278190335,\n    rosybrown: 3163525119,\n    royalblue: 1097458175,\n    saddlebrown: 2336560127,\n    salmon: 4202722047,\n    sandybrown: 4104413439,\n    seagreen: 780883967,\n    seashell: 4294307583,\n    sienna: 2689740287,\n    silver: 3233857791,\n    skyblue: 2278484991,\n    slateblue: 1784335871,\n    slategray: 1887473919,\n    slategrey: 1887473919,\n    snow: 4294638335,\n    springgreen: 16744447,\n    steelblue: 1182971135,\n    tan: 3535047935,\n    teal: 8421631,\n    thistle: 3636451583,\n    tomato: 4284696575,\n    turquoise: 1088475391,\n    violet: 4001558271,\n    wheat: 4125012991,\n    white: 4294967295,\n    whitesmoke: 4126537215,\n    yellow: 4294902015,\n    yellowgreen: 2597139199\n};\nvar opacity = (c2)=>{\n    return (c2 >> 24 & 255) / 255;\n};\nvar red = (c2)=>{\n    return c2 >> 16 & 255;\n};\nvar green = (c2)=>{\n    return c2 >> 8 & 255;\n};\nvar blue = (c2)=>{\n    return c2 & 255;\n};\nvar rgbaColor = (r, g, b2, alpha)=>{\n    return `rgba(${r}, ${g}, ${b2}, ${alpha})`;\n};\nvar interpolateColorsRGB = (value, inputRange, colors)=>{\n    const [r, g, b2, a2] = [\n        red,\n        green,\n        blue,\n        opacity\n    ].map((f)=>{\n        const unrounded = interpolate(value, inputRange, colors.map((c2)=>f(c2)), {\n            extrapolateLeft: \"clamp\",\n            extrapolateRight: \"clamp\"\n        });\n        if (f === opacity) {\n            return Number(unrounded.toFixed(3));\n        }\n        return Math.round(unrounded);\n    });\n    return rgbaColor(r, g, b2, a2);\n};\nvar interpolateColors = (input, inputRange, outputRange)=>{\n    if (typeof input === \"undefined\") {\n        throw new TypeError(\"input can not be undefined\");\n    }\n    if (typeof inputRange === \"undefined\") {\n        throw new TypeError(\"inputRange can not be undefined\");\n    }\n    if (typeof outputRange === \"undefined\") {\n        throw new TypeError(\"outputRange can not be undefined\");\n    }\n    if (inputRange.length !== outputRange.length) {\n        throw new TypeError(\"inputRange (\" + inputRange.length + \" values provided) and outputRange (\" + outputRange.length + \" values provided) must have the same length\");\n    }\n    const processedOutputRange = outputRange.map((c2)=>processColor(c2));\n    return interpolateColorsRGB(input, inputRange, processedOutputRange);\n};\n// src/validate-frame.ts\nvar validateFrame = ({ allowFloats, durationInFrames, frame })=>{\n    if (typeof frame === \"undefined\") {\n        throw new TypeError(`Argument missing for parameter \"frame\"`);\n    }\n    if (typeof frame !== \"number\") {\n        throw new TypeError(`Argument passed for \"frame\" is not a number: ${frame}`);\n    }\n    if (!Number.isFinite(frame)) {\n        throw new RangeError(`Frame ${frame} is not finite`);\n    }\n    if (frame % 1 !== 0 && !allowFloats) {\n        throw new RangeError(`Argument for frame must be an integer, but got ${frame}`);\n    }\n    if (frame < 0 && frame < -durationInFrames) {\n        throw new RangeError(`Cannot use frame ${frame}: Duration of composition is ${durationInFrames}, therefore the lowest frame that can be rendered is ${-durationInFrames}`);\n    }\n    if (frame > durationInFrames - 1) {\n        throw new RangeError(`Cannot use frame ${frame}: Duration of composition is ${durationInFrames}, therefore the highest frame that can be rendered is ${durationInFrames - 1}`);\n    }\n};\n// src/video/offthread-video-source.ts\nvar getOffthreadVideoSource = ({ src, transparent, currentTime, toneMapped })=>{\n    return `http://localhost:${window.remotion_proxyPort}/proxy?src=${encodeURIComponent(getAbsoluteSrc(src))}&time=${encodeURIComponent(currentTime)}&transparent=${String(transparent)}&toneMapped=${String(toneMapped)}`;\n};\n// src/series/index.tsx\n\n// src/series/flatten-children.tsx\n\nvar flattenChildren = (children)=>{\n    const childrenArray = react__WEBPACK_IMPORTED_MODULE_0__.Children.toArray(children);\n    return childrenArray.reduce((flatChildren, child)=>{\n        if (child.type === react__WEBPACK_IMPORTED_MODULE_0__.Fragment) {\n            return flatChildren.concat(flattenChildren(child.props.children));\n        }\n        flatChildren.push(child);\n        return flatChildren;\n    }, []);\n};\n// src/series/is-inside-series.tsx\n\n\nvar IsInsideSeriesContext = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_0__.createContext)(false);\nvar IsInsideSeriesContainer = ({ children })=>{\n    return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(IsInsideSeriesContext.Provider, {\n        value: true,\n        children\n    });\n};\nvar IsNotInsideSeriesProvider = ({ children })=>{\n    return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(IsInsideSeriesContext.Provider, {\n        value: false,\n        children\n    });\n};\nvar useRequireToBeInsideSeries = ()=>{\n    const isInsideSeries = react__WEBPACK_IMPORTED_MODULE_0__.useContext(IsInsideSeriesContext);\n    if (!isInsideSeries) {\n        throw new Error(\"This component must be inside a <Series /> component.\");\n    }\n};\n// src/series/index.tsx\n\nvar SeriesSequenceRefForwardingFunction = ({ children }, _ref)=>{\n    useRequireToBeInsideSeries();\n    return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(IsNotInsideSeriesProvider, {\n        children\n    });\n};\nvar SeriesSequence = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_0__.forwardRef)(SeriesSequenceRefForwardingFunction);\nvar Series = (props2)=>{\n    const childrenValue = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>{\n        let startFrame = 0;\n        const flattenedChildren = flattenChildren(props2.children);\n        return react__WEBPACK_IMPORTED_MODULE_0__.Children.map(flattenedChildren, (child, i)=>{\n            const castedChild = child;\n            if (typeof castedChild === \"string\") {\n                if (castedChild.trim() === \"\") {\n                    return null;\n                }\n                throw new TypeError(`The <Series /> component only accepts a list of <Series.Sequence /> components as its children, but you passed a string \"${castedChild}\"`);\n            }\n            if (castedChild.type !== SeriesSequence) {\n                throw new TypeError(`The <Series /> component only accepts a list of <Series.Sequence /> components as its children, but got ${castedChild} instead`);\n            }\n            const debugInfo = `index = ${i}, duration = ${castedChild.props.durationInFrames}`;\n            if (!castedChild?.props.children) {\n                throw new TypeError(`A <Series.Sequence /> component (${debugInfo}) was detected to not have any children. Delete it to fix this error.`);\n            }\n            const durationInFramesProp = castedChild.props.durationInFrames;\n            const { durationInFrames, children: _children, from, name, ...passedProps } = castedChild.props;\n            if (i !== flattenedChildren.length - 1 || durationInFramesProp !== Infinity) {\n                validateDurationInFrames(durationInFramesProp, {\n                    component: `of a <Series.Sequence /> component`,\n                    allowFloats: true\n                });\n            }\n            const offset = castedChild.props.offset ?? 0;\n            if (Number.isNaN(offset)) {\n                throw new TypeError(`The \"offset\" property of a <Series.Sequence /> must not be NaN, but got NaN (${debugInfo}).`);\n            }\n            if (!Number.isFinite(offset)) {\n                throw new TypeError(`The \"offset\" property of a <Series.Sequence /> must be finite, but got ${offset} (${debugInfo}).`);\n            }\n            if (offset % 1 !== 0) {\n                throw new TypeError(`The \"offset\" property of a <Series.Sequence /> must be finite, but got ${offset} (${debugInfo}).`);\n            }\n            const currentStartFrame = startFrame + offset;\n            startFrame += durationInFramesProp + offset;\n            return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(Sequence, {\n                name: name || \"<Series.Sequence>\",\n                from: currentStartFrame,\n                durationInFrames: durationInFramesProp,\n                ...passedProps,\n                ref: castedChild.ref,\n                children: child\n            });\n        });\n    }, [\n        props2.children\n    ]);\n    if (ENABLE_V5_BREAKING_CHANGES) {\n        return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(IsInsideSeriesContainer, {\n            children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(Sequence, {\n                ...props2,\n                children: childrenValue\n            })\n        });\n    }\n    return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(IsInsideSeriesContainer, {\n        children: childrenValue\n    });\n};\nSeries.Sequence = SeriesSequence;\naddSequenceStackTraces(SeriesSequence);\n// src/validation/validation-spring-duration.ts\nvar validateSpringDuration = (dur)=>{\n    if (typeof dur === \"undefined\") {\n        return;\n    }\n    if (typeof dur !== \"number\") {\n        throw new TypeError(`A \"duration\" of a spring must be a \"number\" but is \"${typeof dur}\"`);\n    }\n    if (Number.isNaN(dur)) {\n        throw new TypeError('A \"duration\" of a spring is NaN, which it must not be');\n    }\n    if (!Number.isFinite(dur)) {\n        throw new TypeError('A \"duration\" of a spring must be finite, but is ' + dur);\n    }\n    if (dur <= 0) {\n        throw new TypeError('A \"duration\" of a spring must be positive, but is ' + dur);\n    }\n};\n// src/spring/spring-utils.ts\nfunction advance({ animation, now, config }) {\n    const { toValue, lastTimestamp, current, velocity } = animation;\n    const deltaTime = Math.min(now - lastTimestamp, 64);\n    if (config.damping <= 0) {\n        throw new Error(\"Spring damping must be greater than 0, otherwise the spring() animation will never end, causing an infinite loop.\");\n    }\n    const c2 = config.damping;\n    const m = config.mass;\n    const k = config.stiffness;\n    const cacheKey = [\n        toValue,\n        lastTimestamp,\n        current,\n        velocity,\n        c2,\n        m,\n        k,\n        now\n    ].join(\"-\");\n    if (advanceCache[cacheKey]) {\n        return advanceCache[cacheKey];\n    }\n    const v0 = -velocity;\n    const x0 = toValue - current;\n    const zeta = c2 / (2 * Math.sqrt(k * m));\n    const omega0 = Math.sqrt(k / m);\n    const omega1 = omega0 * Math.sqrt(1 - zeta ** 2);\n    const t = deltaTime / 1000;\n    const sin1 = Math.sin(omega1 * t);\n    const cos1 = Math.cos(omega1 * t);\n    const underDampedEnvelope = Math.exp(-zeta * omega0 * t);\n    const underDampedFrag1 = underDampedEnvelope * (sin1 * ((v0 + zeta * omega0 * x0) / omega1) + x0 * cos1);\n    const underDampedPosition = toValue - underDampedFrag1;\n    const underDampedVelocity = zeta * omega0 * underDampedFrag1 - underDampedEnvelope * (cos1 * (v0 + zeta * omega0 * x0) - omega1 * x0 * sin1);\n    const criticallyDampedEnvelope = Math.exp(-omega0 * t);\n    const criticallyDampedPosition = toValue - criticallyDampedEnvelope * (x0 + (v0 + omega0 * x0) * t);\n    const criticallyDampedVelocity = criticallyDampedEnvelope * (v0 * (t * omega0 - 1) + t * x0 * omega0 * omega0);\n    const animationNode = {\n        toValue,\n        prevPosition: current,\n        lastTimestamp: now,\n        current: zeta < 1 ? underDampedPosition : criticallyDampedPosition,\n        velocity: zeta < 1 ? underDampedVelocity : criticallyDampedVelocity\n    };\n    advanceCache[cacheKey] = animationNode;\n    return animationNode;\n}\nfunction springCalculation({ frame, fps, config = {} }) {\n    const from = 0;\n    const to = 1;\n    const cacheKey = [\n        frame,\n        fps,\n        config.damping,\n        config.mass,\n        config.overshootClamping,\n        config.stiffness\n    ].join(\"-\");\n    if (calculationCache[cacheKey]) {\n        return calculationCache[cacheKey];\n    }\n    let animation = {\n        lastTimestamp: 0,\n        current: from,\n        toValue: to,\n        velocity: 0,\n        prevPosition: 0\n    };\n    const frameClamped = Math.max(0, frame);\n    const unevenRest = frameClamped % 1;\n    for(let f = 0; f <= Math.floor(frameClamped); f++){\n        if (f === Math.floor(frameClamped)) {\n            f += unevenRest;\n        }\n        const time = f / fps * 1000;\n        animation = advance({\n            animation,\n            now: time,\n            config: {\n                ...defaultSpringConfig,\n                ...config\n            }\n        });\n    }\n    calculationCache[cacheKey] = animation;\n    return animation;\n}\nvar defaultSpringConfig = {\n    damping: 10,\n    mass: 1,\n    stiffness: 100,\n    overshootClamping: false\n};\nvar advanceCache = {};\nvar calculationCache = {};\n// src/spring/measure-spring.ts\nfunction measureSpring({ fps, config = {}, threshold = 0.005 }) {\n    if (typeof threshold !== \"number\") {\n        throw new TypeError(`threshold must be a number, got ${threshold} of type ${typeof threshold}`);\n    }\n    if (threshold === 0) {\n        return Infinity;\n    }\n    if (threshold === 1) {\n        return 0;\n    }\n    if (isNaN(threshold)) {\n        throw new TypeError(\"Threshold is NaN\");\n    }\n    if (!Number.isFinite(threshold)) {\n        throw new TypeError(\"Threshold is not finite\");\n    }\n    if (threshold < 0) {\n        throw new TypeError(\"Threshold is below 0\");\n    }\n    const cacheKey = [\n        fps,\n        config.damping,\n        config.mass,\n        config.overshootClamping,\n        config.stiffness,\n        threshold\n    ].join(\"-\");\n    if (cache.has(cacheKey)) {\n        return cache.get(cacheKey);\n    }\n    validateFps(fps, \"to the measureSpring() function\", false);\n    let frame = 0;\n    let finishedFrame = 0;\n    const calc = ()=>{\n        return springCalculation({\n            fps,\n            frame,\n            config\n        });\n    };\n    let animation = calc();\n    const calcDifference = ()=>{\n        return Math.abs(animation.current - animation.toValue);\n    };\n    let difference = calcDifference();\n    while(difference >= threshold){\n        frame++;\n        animation = calc();\n        difference = calcDifference();\n    }\n    finishedFrame = frame;\n    for(let i = 0; i < 20; i++){\n        frame++;\n        animation = calc();\n        difference = calcDifference();\n        if (difference >= threshold) {\n            i = 0;\n            finishedFrame = frame + 1;\n        }\n    }\n    cache.set(cacheKey, finishedFrame);\n    return finishedFrame;\n}\nvar cache = new Map;\n// src/spring/index.ts\nfunction spring({ frame: passedFrame, fps, config = {}, from = 0, to = 1, durationInFrames: passedDurationInFrames, durationRestThreshold, delay = 0, reverse = false }) {\n    validateSpringDuration(passedDurationInFrames);\n    validateFrame({\n        frame: passedFrame,\n        durationInFrames: Infinity,\n        allowFloats: true\n    });\n    validateFps(fps, \"to spring()\", false);\n    const needsToCalculateNaturalDuration = reverse || typeof passedDurationInFrames !== \"undefined\";\n    const naturalDuration = needsToCalculateNaturalDuration ? measureSpring({\n        fps,\n        config,\n        threshold: durationRestThreshold\n    }) : undefined;\n    const naturalDurationGetter = needsToCalculateNaturalDuration ? {\n        get: ()=>naturalDuration\n    } : {\n        get: ()=>{\n            throw new Error(\"did not calculate natural duration, this is an error with Remotion. Please report\");\n        }\n    };\n    const reverseProcessed = reverse ? (passedDurationInFrames ?? naturalDurationGetter.get()) - passedFrame : passedFrame;\n    const delayProcessed = reverseProcessed + (reverse ? delay : -delay);\n    const durationProcessed = passedDurationInFrames === undefined ? delayProcessed : delayProcessed / (passedDurationInFrames / naturalDurationGetter.get());\n    if (passedDurationInFrames && delayProcessed > passedDurationInFrames) {\n        return to;\n    }\n    const spr = springCalculation({\n        fps,\n        frame: durationProcessed,\n        config\n    });\n    const inner2 = config.overshootClamping ? to >= from ? Math.min(spr.current, to) : Math.max(spr.current, to) : spr.current;\n    const interpolated = from === 0 && to === 1 ? inner2 : interpolate(inner2, [\n        0,\n        1\n    ], [\n        from,\n        to\n    ]);\n    return interpolated;\n}\n// src/Still.tsx\n\nvar Still = (props2)=>{\n    const newProps = {\n        ...props2,\n        durationInFrames: 1,\n        fps: 1\n    };\n    return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(Composition, newProps);\n};\n// src/video/OffthreadVideo.tsx\n\n// src/video/OffthreadVideoForRendering.tsx\n\n\nvar OffthreadVideoForRendering = ({ onError, volume: volumeProp, playbackRate, src, muted, allowAmplificationDuringRender, transparent = false, toneMapped = true, toneFrequency, name, loopVolumeCurveBehavior, delayRenderRetries, delayRenderTimeoutInMilliseconds, onVideoFrame, ...props2 })=>{\n    const absoluteFrame = useTimelinePosition();\n    const frame = useCurrentFrame();\n    const volumePropsFrame = useFrameForVolumeProp(loopVolumeCurveBehavior ?? \"repeat\");\n    const videoConfig = useUnsafeVideoConfig();\n    const sequenceContext = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(SequenceContext);\n    const mediaStartsAt = useMediaStartsAt();\n    const { registerRenderAsset, unregisterRenderAsset } = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(RenderAssetManager);\n    if (!src) {\n        throw new TypeError(\"No `src` was passed to <OffthreadVideo>.\");\n    }\n    const id = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>`offthreadvideo-${random(src ?? \"\")}-${sequenceContext?.cumulatedFrom}-${sequenceContext?.relativeFrom}-${sequenceContext?.durationInFrames}`, [\n        src,\n        sequenceContext?.cumulatedFrom,\n        sequenceContext?.relativeFrom,\n        sequenceContext?.durationInFrames\n    ]);\n    if (!videoConfig) {\n        throw new Error(\"No video config found\");\n    }\n    const volume = evaluateVolume({\n        volume: volumeProp,\n        frame: volumePropsFrame,\n        mediaVolume: 1,\n        allowAmplificationDuringRender: allowAmplificationDuringRender ?? false\n    });\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        if (!src) {\n            throw new Error(\"No src passed\");\n        }\n        if (!window.remotion_audioEnabled) {\n            return;\n        }\n        if (muted) {\n            return;\n        }\n        if (volume <= 0) {\n            return;\n        }\n        registerRenderAsset({\n            type: \"video\",\n            src: getAbsoluteSrc(src),\n            id,\n            frame: absoluteFrame,\n            volume,\n            mediaFrame: frame,\n            playbackRate: playbackRate ?? 1,\n            allowAmplificationDuringRender: allowAmplificationDuringRender ?? false,\n            toneFrequency: toneFrequency ?? null,\n            audioStartFrame: Math.max(0, -(sequenceContext?.relativeFrom ?? 0))\n        });\n        return ()=>unregisterRenderAsset(id);\n    }, [\n        muted,\n        src,\n        registerRenderAsset,\n        id,\n        unregisterRenderAsset,\n        volume,\n        frame,\n        absoluteFrame,\n        playbackRate,\n        allowAmplificationDuringRender,\n        toneFrequency,\n        sequenceContext?.relativeFrom\n    ]);\n    const currentTime = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>{\n        return getExpectedMediaFrameUncorrected({\n            frame,\n            playbackRate: playbackRate || 1,\n            startFrom: -mediaStartsAt\n        }) / videoConfig.fps;\n    }, [\n        frame,\n        mediaStartsAt,\n        playbackRate,\n        videoConfig.fps\n    ]);\n    const actualSrc = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>{\n        return getOffthreadVideoSource({\n            src,\n            currentTime,\n            transparent,\n            toneMapped\n        });\n    }, [\n        toneMapped,\n        currentTime,\n        src,\n        transparent\n    ]);\n    const [imageSrc, setImageSrc] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(null);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useLayoutEffect)(()=>{\n        if (!window.remotion_videoEnabled) {\n            return;\n        }\n        const cleanup = [];\n        setImageSrc(null);\n        const controller = new AbortController;\n        const newHandle = delayRender(`Fetching ${actualSrc} from server`, {\n            retries: delayRenderRetries ?? undefined,\n            timeoutInMilliseconds: delayRenderTimeoutInMilliseconds ?? undefined\n        });\n        const execute = async ()=>{\n            try {\n                const res = await fetch(actualSrc, {\n                    signal: controller.signal\n                });\n                if (res.status !== 200) {\n                    if (res.status === 500) {\n                        const json = await res.json();\n                        if (json.error) {\n                            const cleanedUpErrorMessage = json.error.replace(/^Error: /, \"\");\n                            throw new Error(cleanedUpErrorMessage);\n                        }\n                    }\n                    throw new Error(`Server returned status ${res.status} while fetching ${actualSrc}`);\n                }\n                const blob = await res.blob();\n                const url = URL.createObjectURL(blob);\n                cleanup.push(()=>URL.revokeObjectURL(url));\n                setImageSrc({\n                    src: url,\n                    handle: newHandle\n                });\n            } catch (err) {\n                if (err.message.includes(\"aborted\")) {\n                    continueRender(newHandle);\n                    return;\n                }\n                if (controller.signal.aborted) {\n                    continueRender(newHandle);\n                    return;\n                }\n                if (err.message.includes(\"Failed to fetch\")) {\n                    err = new Error(`Failed to fetch ${actualSrc}. This could be caused by Chrome rejecting the request because the disk space is low. Consider increasing the disk size of your environment.`, {\n                        cause: err\n                    });\n                }\n                if (onError) {\n                    onError(err);\n                } else {\n                    cancelRender(err);\n                }\n            }\n        };\n        execute();\n        cleanup.push(()=>{\n            if (controller.signal.aborted) {\n                return;\n            }\n            controller.abort();\n        });\n        return ()=>{\n            cleanup.forEach((c2)=>c2());\n        };\n    }, [\n        actualSrc,\n        delayRenderRetries,\n        delayRenderTimeoutInMilliseconds,\n        onError\n    ]);\n    const onErr = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(()=>{\n        if (onError) {\n            onError?.(new Error(\"Failed to load image with src \" + imageSrc));\n        } else {\n            cancelRender(\"Failed to load image with src \" + imageSrc);\n        }\n    }, [\n        imageSrc,\n        onError\n    ]);\n    const className = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>{\n        return [\n            OFFTHREAD_VIDEO_CLASS_NAME,\n            props2.className\n        ].filter(truthy).join(\" \");\n    }, [\n        props2.className\n    ]);\n    const onImageFrame = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((img)=>{\n        if (onVideoFrame) {\n            onVideoFrame(img);\n        }\n    }, [\n        onVideoFrame\n    ]);\n    if (!imageSrc || !window.remotion_videoEnabled) {\n        return null;\n    }\n    continueRender(imageSrc.handle);\n    return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(Img, {\n        src: imageSrc.src,\n        className,\n        delayRenderRetries,\n        delayRenderTimeoutInMilliseconds,\n        onImageFrame,\n        ...props2,\n        onError: onErr\n    });\n};\n// src/video/VideoForPreview.tsx\n\n// src/video/emit-video-frame.ts\n\nvar useEmitVideoFrame = ({ ref, onVideoFrame })=>{\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        const { current } = ref;\n        if (!current) {\n            return;\n        }\n        if (!onVideoFrame) {\n            return;\n        }\n        let handle = 0;\n        const callback = ()=>{\n            if (!ref.current) {\n                return;\n            }\n            onVideoFrame(ref.current);\n            handle = ref.current.requestVideoFrameCallback(callback);\n        };\n        callback();\n        return ()=>{\n            current.cancelVideoFrameCallback(handle);\n        };\n    }, [\n        onVideoFrame,\n        ref\n    ]);\n};\n// src/video/VideoForPreview.tsx\n\nvar VideoForDevelopmentRefForwardingFunction = (props2, ref)=>{\n    const videoRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n    const { volume, muted, playbackRate, onlyWarnForMediaSeekingError, src, onDuration, acceptableTimeShift, acceptableTimeShiftInSeconds, toneFrequency, name, _remotionInternalNativeLoopPassed, _remotionInternalStack, _remotionDebugSeeking, style, pauseWhenBuffering, showInTimeline, loopVolumeCurveBehavior, onError, onAutoPlayError, onVideoFrame, crossOrigin, ...nativeProps } = props2;\n    const volumePropFrame = useFrameForVolumeProp(loopVolumeCurveBehavior ?? \"repeat\");\n    const { fps, durationInFrames } = useVideoConfig();\n    const parentSequence = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(SequenceContext);\n    const { hidden } = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(SequenceVisibilityToggleContext);\n    const [timelineId] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(()=>String(Math.random()));\n    const isSequenceHidden = hidden[timelineId] ?? false;\n    if (typeof acceptableTimeShift !== \"undefined\") {\n        throw new Error(\"acceptableTimeShift has been removed. Use acceptableTimeShiftInSeconds instead.\");\n    }\n    const actualVolume = useMediaTagVolume(videoRef);\n    const [mediaVolume] = useMediaVolumeState();\n    const [mediaMuted] = useMediaMutedState();\n    useMediaInTimeline({\n        mediaRef: videoRef,\n        volume,\n        mediaVolume,\n        mediaType: \"video\",\n        src,\n        playbackRate: props2.playbackRate ?? 1,\n        displayName: name ?? null,\n        id: timelineId,\n        stack: _remotionInternalStack,\n        showInTimeline,\n        premountDisplay: null,\n        onAutoPlayError: onAutoPlayError ?? null\n    });\n    useSyncVolumeWithMediaTag({\n        volumePropFrame,\n        actualVolume,\n        volume,\n        mediaVolume,\n        mediaRef: videoRef\n    });\n    useMediaPlayback({\n        mediaRef: videoRef,\n        src,\n        mediaType: \"video\",\n        playbackRate: props2.playbackRate ?? 1,\n        onlyWarnForMediaSeekingError,\n        acceptableTimeshift: acceptableTimeShiftInSeconds ?? DEFAULT_ACCEPTABLE_TIMESHIFT,\n        isPremounting: Boolean(parentSequence?.premounting),\n        pauseWhenBuffering,\n        debugSeeking: _remotionDebugSeeking,\n        onAutoPlayError: onAutoPlayError ?? null\n    });\n    const actualFrom = parentSequence ? parentSequence.relativeFrom : 0;\n    const duration = parentSequence ? Math.min(parentSequence.durationInFrames, durationInFrames) : durationInFrames;\n    const actualSrc = useAppendVideoFragment({\n        actualSrc: usePreload(src),\n        actualFrom,\n        duration,\n        fps\n    });\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useImperativeHandle)(ref, ()=>{\n        return videoRef.current;\n    }, []);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        const { current } = videoRef;\n        if (!current) {\n            return;\n        }\n        const errorHandler = ()=>{\n            if (current.error) {\n                console.error(\"Error occurred in video\", current?.error);\n                if (onError) {\n                    const err = new Error(`Code ${current.error.code}: ${current.error.message}`);\n                    onError(err);\n                    return;\n                }\n                throw new Error(`The browser threw an error while playing the video ${src}: Code ${current.error.code} - ${current?.error?.message}. See https://remotion.dev/docs/media-playback-error for help. Pass an onError() prop to handle the error.`);\n            } else {\n                if (onError) {\n                    const err = new Error(`The browser threw an error while playing the video ${src}`);\n                    onError(err);\n                    return;\n                }\n                throw new Error(\"The browser threw an error while playing the video\");\n            }\n        };\n        current.addEventListener(\"error\", errorHandler, {\n            once: true\n        });\n        return ()=>{\n            current.removeEventListener(\"error\", errorHandler);\n        };\n    }, [\n        onError,\n        src\n    ]);\n    const currentOnDurationCallback = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)();\n    currentOnDurationCallback.current = onDuration;\n    useEmitVideoFrame({\n        ref: videoRef,\n        onVideoFrame\n    });\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        const { current } = videoRef;\n        if (!current) {\n            return;\n        }\n        if (current.duration) {\n            currentOnDurationCallback.current?.(src, current.duration);\n            return;\n        }\n        const onLoadedMetadata = ()=>{\n            currentOnDurationCallback.current?.(src, current.duration);\n        };\n        current.addEventListener(\"loadedmetadata\", onLoadedMetadata);\n        return ()=>{\n            current.removeEventListener(\"loadedmetadata\", onLoadedMetadata);\n        };\n    }, [\n        src\n    ]);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        const { current } = videoRef;\n        if (!current) {\n            return;\n        }\n        if (isIosSafari()) {\n            current.preload = \"metadata\";\n        } else {\n            current.preload = \"auto\";\n        }\n    }, []);\n    const actualStyle = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>{\n        return {\n            ...style,\n            opacity: isSequenceHidden ? 0 : style?.opacity ?? 1\n        };\n    }, [\n        isSequenceHidden,\n        style\n    ]);\n    const crossOriginValue = crossOrigin ?? (onVideoFrame ? \"anonymous\" : undefined);\n    return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(\"video\", {\n        ref: videoRef,\n        muted: muted || mediaMuted,\n        playsInline: true,\n        src: actualSrc,\n        loop: _remotionInternalNativeLoopPassed,\n        style: actualStyle,\n        disableRemotePlayback: true,\n        crossOrigin: crossOriginValue,\n        ...nativeProps\n    });\n};\nvar VideoForPreview = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_0__.forwardRef)(VideoForDevelopmentRefForwardingFunction);\n// src/video/OffthreadVideo.tsx\n\nvar OffthreadVideo = (props2)=>{\n    const { startFrom, endAt, name, pauseWhenBuffering, stack, showInTimeline, ...otherProps } = props2;\n    const environment = getRemotionEnvironment();\n    const onDuration = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(()=>{\n        return;\n    }, []);\n    if (typeof props2.src !== \"string\") {\n        throw new TypeError(`The \\`<OffthreadVideo>\\` tag requires a string for \\`src\\`, but got ${JSON.stringify(props2.src)} instead.`);\n    }\n    if (props2.imageFormat) {\n        throw new TypeError(`The \\`<OffthreadVideo>\\` tag does no longer accept \\`imageFormat\\`. Use the \\`transparent\\` prop if you want to render a transparent video.`);\n    }\n    if (typeof startFrom !== \"undefined\" || typeof endAt !== \"undefined\") {\n        validateStartFromProps(startFrom, endAt);\n        const startFromFrameNo = startFrom ?? 0;\n        const endAtFrameNo = endAt ?? Infinity;\n        return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(Sequence, {\n            layout: \"none\",\n            from: 0 - startFromFrameNo,\n            showInTimeline: false,\n            durationInFrames: endAtFrameNo,\n            name,\n            children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(OffthreadVideo, {\n                pauseWhenBuffering: pauseWhenBuffering ?? false,\n                ...otherProps\n            })\n        });\n    }\n    validateMediaProps(props2, \"Video\");\n    if (environment.isRendering) {\n        return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(OffthreadVideoForRendering, {\n            ...otherProps\n        });\n    }\n    const { transparent, toneMapped, _remotionDebugSeeking, onAutoPlayError, onVideoFrame, crossOrigin, ...withoutTransparent } = otherProps;\n    return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(VideoForPreview, {\n        _remotionInternalStack: stack ?? null,\n        _remotionInternalNativeLoopPassed: false,\n        _remotionDebugSeeking: _remotionDebugSeeking ?? false,\n        onDuration,\n        onlyWarnForMediaSeekingError: true,\n        pauseWhenBuffering: pauseWhenBuffering ?? false,\n        showInTimeline: showInTimeline ?? true,\n        onAutoPlayError: onAutoPlayError ?? undefined,\n        onVideoFrame: onVideoFrame ?? null,\n        crossOrigin,\n        ...withoutTransparent\n    });\n};\n// src/video/Video.tsx\n\n// src/video/VideoForRendering.tsx\n\n// src/video/seek-until-right.ts\nvar roundTo6Commas = (num)=>{\n    return Math.round(num * 1e5) / 1e5;\n};\nvar seekToTime = (element, desiredTime)=>{\n    element.currentTime = desiredTime;\n    let cancel;\n    let cancelSeeked = null;\n    const prom = new Promise((resolve)=>{\n        cancel = element.requestVideoFrameCallback((now, metadata)=>{\n            const displayIn = metadata.expectedDisplayTime - now;\n            if (displayIn <= 0) {\n                resolve(metadata.mediaTime);\n                return;\n            }\n            setTimeout(()=>{\n                resolve(metadata.mediaTime);\n            }, displayIn + 150);\n        });\n    });\n    const waitForSeekedEvent = new Promise((resolve)=>{\n        const onDone = ()=>{\n            resolve();\n        };\n        element.addEventListener(\"seeked\", onDone, {\n            once: true\n        });\n        cancelSeeked = ()=>{\n            element.removeEventListener(\"seeked\", onDone);\n        };\n    });\n    return {\n        wait: Promise.all([\n            prom,\n            waitForSeekedEvent\n        ]).then(([time])=>time),\n        cancel: ()=>{\n            cancelSeeked?.();\n            element.cancelVideoFrameCallback(cancel);\n        }\n    };\n};\nvar seekToTimeMultipleUntilRight = (element, desiredTime, fps)=>{\n    const threshold = 1 / fps / 2;\n    let currentCancel = ()=>{\n        return;\n    };\n    if (Number.isFinite(element.duration) && element.currentTime >= element.duration && desiredTime >= element.duration) {\n        return {\n            prom: Promise.resolve(),\n            cancel: ()=>{}\n        };\n    }\n    const prom = new Promise((resolve, reject)=>{\n        const firstSeek = seekToTime(element, desiredTime + threshold);\n        firstSeek.wait.then((seekedTo)=>{\n            const difference = Math.abs(desiredTime - seekedTo);\n            if (difference <= threshold) {\n                return resolve();\n            }\n            const sign = desiredTime > seekedTo ? 1 : -1;\n            const newSeek = seekToTime(element, seekedTo + threshold * sign);\n            currentCancel = newSeek.cancel;\n            newSeek.wait.then((newTime)=>{\n                const newDifference = Math.abs(desiredTime - newTime);\n                if (roundTo6Commas(newDifference) <= roundTo6Commas(threshold)) {\n                    return resolve();\n                }\n                const thirdSeek = seekToTime(element, desiredTime + threshold);\n                currentCancel = thirdSeek.cancel;\n                return thirdSeek.wait.then(()=>{\n                    resolve();\n                }).catch((err)=>{\n                    reject(err);\n                });\n            }).catch((err)=>{\n                reject(err);\n            });\n        });\n        currentCancel = firstSeek.cancel;\n    });\n    return {\n        prom,\n        cancel: ()=>{\n            currentCancel();\n        }\n    };\n};\n// src/video/VideoForRendering.tsx\n\nvar VideoForRenderingForwardFunction = ({ onError, volume: volumeProp, allowAmplificationDuringRender, playbackRate, onDuration, toneFrequency, name, acceptableTimeShiftInSeconds, delayRenderRetries, delayRenderTimeoutInMilliseconds, loopVolumeCurveBehavior, ...props2 }, ref)=>{\n    const absoluteFrame = useTimelinePosition();\n    const frame = useCurrentFrame();\n    const volumePropsFrame = useFrameForVolumeProp(loopVolumeCurveBehavior ?? \"repeat\");\n    const videoConfig = useUnsafeVideoConfig();\n    const videoRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n    const sequenceContext = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(SequenceContext);\n    const mediaStartsAt = useMediaStartsAt();\n    const environment = getRemotionEnvironment();\n    const { registerRenderAsset, unregisterRenderAsset } = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(RenderAssetManager);\n    const id = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>`video-${random(props2.src ?? \"\")}-${sequenceContext?.cumulatedFrom}-${sequenceContext?.relativeFrom}-${sequenceContext?.durationInFrames}`, [\n        props2.src,\n        sequenceContext?.cumulatedFrom,\n        sequenceContext?.relativeFrom,\n        sequenceContext?.durationInFrames\n    ]);\n    if (!videoConfig) {\n        throw new Error(\"No video config found\");\n    }\n    const volume = evaluateVolume({\n        volume: volumeProp,\n        frame: volumePropsFrame,\n        mediaVolume: 1,\n        allowAmplificationDuringRender: allowAmplificationDuringRender ?? false\n    });\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        if (!props2.src) {\n            throw new Error(\"No src passed\");\n        }\n        if (props2.muted) {\n            return;\n        }\n        if (volume <= 0) {\n            return;\n        }\n        if (!window.remotion_audioEnabled) {\n            return;\n        }\n        registerRenderAsset({\n            type: \"video\",\n            src: getAbsoluteSrc(props2.src),\n            id,\n            frame: absoluteFrame,\n            volume,\n            mediaFrame: frame,\n            playbackRate: playbackRate ?? 1,\n            allowAmplificationDuringRender: allowAmplificationDuringRender ?? false,\n            toneFrequency: toneFrequency ?? null,\n            audioStartFrame: Math.max(0, -(sequenceContext?.relativeFrom ?? 0))\n        });\n        return ()=>unregisterRenderAsset(id);\n    }, [\n        props2.muted,\n        props2.src,\n        registerRenderAsset,\n        id,\n        unregisterRenderAsset,\n        volume,\n        frame,\n        absoluteFrame,\n        playbackRate,\n        allowAmplificationDuringRender,\n        toneFrequency,\n        sequenceContext?.relativeFrom\n    ]);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useImperativeHandle)(ref, ()=>{\n        return videoRef.current;\n    }, []);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        if (!window.remotion_videoEnabled) {\n            return;\n        }\n        const { current } = videoRef;\n        if (!current) {\n            return;\n        }\n        const currentTime = getMediaTime({\n            frame,\n            playbackRate: playbackRate || 1,\n            startFrom: -mediaStartsAt,\n            fps: videoConfig.fps\n        });\n        const handle = delayRender(`Rendering <Video /> with src=\"${props2.src}\"`, {\n            retries: delayRenderRetries ?? undefined,\n            timeoutInMilliseconds: delayRenderTimeoutInMilliseconds ?? undefined\n        });\n        if (window.process?.env?.NODE_ENV === \"test\") {\n            continueRender(handle);\n            return;\n        }\n        if (isApproximatelyTheSame(current.currentTime, currentTime)) {\n            if (current.readyState >= 2) {\n                continueRender(handle);\n                return;\n            }\n            const loadedDataHandler = ()=>{\n                continueRender(handle);\n            };\n            current.addEventListener(\"loadeddata\", loadedDataHandler, {\n                once: true\n            });\n            return ()=>{\n                current.removeEventListener(\"loadeddata\", loadedDataHandler);\n            };\n        }\n        const endedHandler = ()=>{\n            continueRender(handle);\n        };\n        const seek2 = seekToTimeMultipleUntilRight(current, currentTime, videoConfig.fps);\n        seek2.prom.then(()=>{\n            continueRender(handle);\n        });\n        current.addEventListener(\"ended\", endedHandler, {\n            once: true\n        });\n        const errorHandler = ()=>{\n            if (current?.error) {\n                console.error(\"Error occurred in video\", current?.error);\n                if (onError) {\n                    return;\n                }\n                throw new Error(`The browser threw an error while playing the video ${props2.src}: Code ${current.error.code} - ${current?.error?.message}. See https://remotion.dev/docs/media-playback-error for help. Pass an onError() prop to handle the error.`);\n            } else {\n                throw new Error(\"The browser threw an error\");\n            }\n        };\n        current.addEventListener(\"error\", errorHandler, {\n            once: true\n        });\n        return ()=>{\n            seek2.cancel();\n            current.removeEventListener(\"ended\", endedHandler);\n            current.removeEventListener(\"error\", errorHandler);\n            continueRender(handle);\n        };\n    }, [\n        volumePropsFrame,\n        props2.src,\n        playbackRate,\n        videoConfig.fps,\n        frame,\n        mediaStartsAt,\n        onError,\n        delayRenderRetries,\n        delayRenderTimeoutInMilliseconds\n    ]);\n    const { src } = props2;\n    if (environment.isRendering) {\n        (0,react__WEBPACK_IMPORTED_MODULE_0__.useLayoutEffect)(()=>{\n            if (window.process?.env?.NODE_ENV === \"test\") {\n                return;\n            }\n            const newHandle = delayRender(\"Loading <Video> duration with src=\" + src, {\n                retries: delayRenderRetries ?? undefined,\n                timeoutInMilliseconds: delayRenderTimeoutInMilliseconds ?? undefined\n            });\n            const { current } = videoRef;\n            const didLoad = ()=>{\n                if (current?.duration) {\n                    onDuration(src, current.duration);\n                }\n                continueRender(newHandle);\n            };\n            if (current?.duration) {\n                onDuration(src, current.duration);\n                continueRender(newHandle);\n            } else {\n                current?.addEventListener(\"loadedmetadata\", didLoad, {\n                    once: true\n                });\n            }\n            return ()=>{\n                current?.removeEventListener(\"loadedmetadata\", didLoad);\n                continueRender(newHandle);\n            };\n        }, [\n            src,\n            onDuration,\n            delayRenderRetries,\n            delayRenderTimeoutInMilliseconds\n        ]);\n    }\n    return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(\"video\", {\n        ref: videoRef,\n        disableRemotePlayback: true,\n        ...props2\n    });\n};\nvar VideoForRendering = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_0__.forwardRef)(VideoForRenderingForwardFunction);\n// src/video/Video.tsx\n\nvar VideoForwardingFunction = (props2, ref)=>{\n    const { startFrom, endAt, name, pauseWhenBuffering, stack, _remotionInternalNativeLoopPassed, showInTimeline, onAutoPlayError, ...otherProps } = props2;\n    const { loop, _remotionDebugSeeking, ...propsOtherThanLoop } = props2;\n    const { fps } = useVideoConfig();\n    const environment = getRemotionEnvironment();\n    const { durations, setDurations } = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(DurationsContext);\n    if (typeof ref === \"string\") {\n        throw new Error(\"string refs are not supported\");\n    }\n    if (typeof props2.src !== \"string\") {\n        throw new TypeError(`The \\`<Video>\\` tag requires a string for \\`src\\`, but got ${JSON.stringify(props2.src)} instead.`);\n    }\n    const preloadedSrc = usePreload(props2.src);\n    const onDuration = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((src, durationInSeconds)=>{\n        setDurations({\n            type: \"got-duration\",\n            durationInSeconds,\n            src\n        });\n    }, [\n        setDurations\n    ]);\n    const onVideoFrame = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(()=>{}, []);\n    const durationFetched = durations[getAbsoluteSrc(preloadedSrc)] ?? durations[getAbsoluteSrc(props2.src)];\n    if (loop && durationFetched !== undefined) {\n        const mediaDuration = durationFetched * fps;\n        return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(Loop, {\n            durationInFrames: calculateLoopDuration({\n                endAt,\n                mediaDuration,\n                playbackRate: props2.playbackRate ?? 1,\n                startFrom\n            }),\n            layout: \"none\",\n            name,\n            children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(Video, {\n                ...propsOtherThanLoop,\n                ref,\n                _remotionInternalNativeLoopPassed: true\n            })\n        });\n    }\n    if (typeof startFrom !== \"undefined\" || typeof endAt !== \"undefined\") {\n        validateStartFromProps(startFrom, endAt);\n        const startFromFrameNo = startFrom ?? 0;\n        const endAtFrameNo = endAt ?? Infinity;\n        return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(Sequence, {\n            layout: \"none\",\n            from: 0 - startFromFrameNo,\n            showInTimeline: false,\n            durationInFrames: endAtFrameNo,\n            name,\n            children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(Video, {\n                pauseWhenBuffering: pauseWhenBuffering ?? false,\n                ...otherProps,\n                ref\n            })\n        });\n    }\n    validateMediaProps(props2, \"Video\");\n    if (environment.isRendering) {\n        return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(VideoForRendering, {\n            onDuration,\n            onVideoFrame: onVideoFrame ?? null,\n            ...otherProps,\n            ref\n        });\n    }\n    return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(VideoForPreview, {\n        onlyWarnForMediaSeekingError: false,\n        ...otherProps,\n        ref,\n        onVideoFrame: null,\n        pauseWhenBuffering: pauseWhenBuffering ?? false,\n        onDuration,\n        _remotionInternalStack: stack ?? null,\n        _remotionInternalNativeLoopPassed: _remotionInternalNativeLoopPassed ?? false,\n        _remotionDebugSeeking: _remotionDebugSeeking ?? false,\n        showInTimeline: showInTimeline ?? true,\n        onAutoPlayError: onAutoPlayError ?? undefined\n    });\n};\nvar Video = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_0__.forwardRef)(VideoForwardingFunction);\naddSequenceStackTraces(Video);\n// src/index.ts\ncheckMultipleRemotionVersions();\nvar Experimental = {\n    Clipper,\n    Null,\n    useIsPlayer\n};\nvar proxyObj = {};\nvar Config = new Proxy(proxyObj, {\n    get (_, prop) {\n        if (prop === \"Bundling\" || prop === \"Rendering\" || prop === \"Log\" || prop === \"Puppeteer\" || prop === \"Output\") {\n            return Config;\n        }\n        return ()=>{\n            console.warn(\"\\u26A0\\uFE0F  The CLI configuration has been extracted from Remotion Core.\");\n            console.warn(\"Update the import from the config file:\");\n            console.warn();\n            console.warn(\"- Delete:\");\n            console.warn('import {Config} from \"remotion\";');\n            console.warn(\"+ Replace:\");\n            console.warn('import {Config} from \"@remotion/cli/config\";');\n            console.warn();\n            console.warn(\"For more information, see https://www.remotion.dev/docs/4-0-migration.\");\n            process.exit(1);\n        };\n    }\n});\naddSequenceStackTraces(Sequence);\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvcmVtb3Rpb24vZGlzdC9lc20vaW5kZXgubWpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBLElBQUlBLFlBQVlDLE9BQU9DLGNBQWM7QUFDckMsSUFBSUMsV0FBVyxDQUFDQyxRQUFRQztJQUN0QixJQUFLLElBQUlDLFFBQVFELElBQ2ZMLFVBQVVJLFFBQVFFLE1BQU07UUFDdEJDLEtBQUtGLEdBQUcsQ0FBQ0MsS0FBSztRQUNkRSxZQUFZO1FBQ1pDLGNBQWM7UUFDZEMsS0FBSyxDQUFDQyxXQUFhTixHQUFHLENBQUNDLEtBQUssR0FBRyxJQUFNSztJQUN2QztBQUNKO0FBRUEsb0JBQW9CO0FBQ2tCO0FBQ3RDLElBQUksT0FBT0MsZ0RBQWFBLEtBQUssWUFBWTtJQUN2QyxNQUFNQyxNQUFNO1FBQ1Y7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO0tBQ0Q7SUFDRCxNQUFNLElBQUlDLE1BQU1ELElBQUlFLElBQUksQ0FBQztBQUMzQjtBQUVBLGtCQUFrQjtBQUM0QjtBQUU5Qyx1QkFBdUI7QUFDcUU7QUFDcEQ7QUFDeEMsSUFBSVEsb0NBQXNCTCxvREFBY0EsQ0FBQztJQUN2Q00sZUFBZTtRQUNiLE1BQU0sSUFBSVYsTUFBTTtJQUNsQjtJQUNBVyxZQUFZO0FBQ2Q7QUFDQSxJQUFJQyx1QkFBdUIsQ0FBQyxFQUMxQkMsUUFBUSxFQUNUO0lBQ0MsTUFBTSxDQUFDRixZQUFZRCxjQUFjLEdBQUdILCtDQUFRQSxDQUFDO0lBQzdDLE1BQU1PLFVBQVVSLDhDQUFPQSxDQUFDO1FBQ3RCLE9BQU87WUFDTEk7WUFDQUM7UUFDRjtJQUNGLEdBQUc7UUFBQ0E7UUFBWUQ7S0FBYztJQUM5QixJQUFJLEtBQTZCLEVBQUUsRUFNbEM7SUFDRCxPQUFPLGFBQWEsR0FBR0Ysc0RBQUdBLENBQUNDLG9CQUFvQlEsUUFBUSxFQUFFO1FBQ3ZEQyxPQUFPSjtR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QSxTQUFTLGVBQWVBLFNBQVMsVUFBVTtZQUM5RyxPQUFPRDtRQUNUO1FBQ0EsT0FBTztZQUNMNzVDLFFBQVFDLElBQUksQ0FBQztZQUNiRCxRQUFRQyxJQUFJLENBQUM7WUFDYkQsUUFBUUMsSUFBSTtZQUNaRCxRQUFRQyxJQUFJLENBQUM7WUFDYkQsUUFBUUMsSUFBSSxDQUFDO1lBQ2JELFFBQVFDLElBQUksQ0FBQztZQUNiRCxRQUFRQyxJQUFJLENBQUM7WUFDYkQsUUFBUUMsSUFBSTtZQUNaRCxRQUFRQyxJQUFJLENBQUM7WUFDYjFKLFFBQVF3akQsSUFBSSxDQUFDO1FBQ2Y7SUFDRjtBQUNGO0FBQ0FuaUQsdUJBQXVCNFc7QUF5Q3JCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbXktYXBwLy4vbm9kZV9tb2R1bGVzL3JlbW90aW9uL2Rpc3QvZXNtL2luZGV4Lm1qcz83ZDRhIl0sInNvdXJjZXNDb250ZW50IjpbInZhciBfX2RlZlByb3AgPSBPYmplY3QuZGVmaW5lUHJvcGVydHk7XG52YXIgX19leHBvcnQgPSAodGFyZ2V0LCBhbGwpID0+IHtcbiAgZm9yICh2YXIgbmFtZSBpbiBhbGwpXG4gICAgX19kZWZQcm9wKHRhcmdldCwgbmFtZSwge1xuICAgICAgZ2V0OiBhbGxbbmFtZV0sXG4gICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgc2V0OiAobmV3VmFsdWUpID0+IGFsbFtuYW1lXSA9ICgpID0+IG5ld1ZhbHVlXG4gICAgfSk7XG59O1xuXG4vLyBzcmMvX2NoZWNrLXJzYy50c1xuaW1wb3J0IHsgY3JlYXRlQ29udGV4dCB9IGZyb20gXCJyZWFjdFwiO1xuaWYgKHR5cGVvZiBjcmVhdGVDb250ZXh0ICE9PSBcImZ1bmN0aW9uXCIpIHtcbiAgY29uc3QgZXJyID0gW1xuICAgICdSZW1vdGlvbiByZXF1aXJlcyBSZWFjdC5jcmVhdGVDb250ZXh0LCBidXQgaXQgaXMgXCJ1bmRlZmluZWRcIi4nLFxuICAgICdJZiB5b3UgYXJlIGluIGEgUmVhY3QgU2VydmVyIENvbXBvbmVudCwgdHVybiBpdCBpbnRvIGEgY2xpZW50IGNvbXBvbmVudCBieSBhZGRpbmcgXCJ1c2UgY2xpZW50XCIgYXQgdGhlIHRvcCBvZiB0aGUgZmlsZS4nLFxuICAgIFwiXCIsXG4gICAgXCJCZWZvcmU6XCIsXG4gICAgJyAgaW1wb3J0IHt1c2VDdXJyZW50RnJhbWV9IGZyb20gXCJyZW1vdGlvblwiOycsXG4gICAgXCJcIixcbiAgICBcIkFmdGVyOlwiLFxuICAgICcgIFwidXNlIGNsaWVudFwiOycsXG4gICAgJyAgaW1wb3J0IHt1c2VDdXJyZW50RnJhbWV9IGZyb20gXCJyZW1vdGlvblwiOydcbiAgXTtcbiAgdGhyb3cgbmV3IEVycm9yKGVyci5qb2luKFwiXFxuXCIpKTtcbn1cblxuLy8gc3JjL0NsaXBwZXIudHN4XG5pbXBvcnQgeyB1c2VDb250ZXh0LCB1c2VFZmZlY3QgfSBmcm9tIFwicmVhY3RcIjtcblxuLy8gc3JjL05hdGl2ZUxheWVycy50c3hcbmltcG9ydCB7IGNyZWF0ZUNvbnRleHQgYXMgY3JlYXRlQ29udGV4dDIsIHVzZUxheW91dEVmZmVjdCwgdXNlTWVtbywgdXNlU3RhdGUgfSBmcm9tIFwicmVhY3RcIjtcbmltcG9ydCB7IGpzeCB9IGZyb20gXCJyZWFjdC9qc3gtcnVudGltZVwiO1xudmFyIE5hdGl2ZUxheWVyc0NvbnRleHQgPSBjcmVhdGVDb250ZXh0Mih7XG4gIHNldENsaXBSZWdpb246ICgpID0+IHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJOYXRpdmVMYXllcnMgbm90IHNldFwiKTtcbiAgfSxcbiAgY2xpcFJlZ2lvbjogbnVsbFxufSk7XG52YXIgTmF0aXZlTGF5ZXJzUHJvdmlkZXIgPSAoe1xuICBjaGlsZHJlblxufSkgPT4ge1xuICBjb25zdCBbY2xpcFJlZ2lvbiwgc2V0Q2xpcFJlZ2lvbl0gPSB1c2VTdGF0ZShudWxsKTtcbiAgY29uc3QgY29udGV4dCA9IHVzZU1lbW8oKCkgPT4ge1xuICAgIHJldHVybiB7XG4gICAgICBzZXRDbGlwUmVnaW9uLFxuICAgICAgY2xpcFJlZ2lvblxuICAgIH07XG4gIH0sIFtjbGlwUmVnaW9uLCBzZXRDbGlwUmVnaW9uXSk7XG4gIGlmICh0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgdXNlTGF5b3V0RWZmZWN0KCgpID0+IHtcbiAgICAgIHdpbmRvdy5yZW1vdGlvbl9nZXRDbGlwUmVnaW9uID0gKCkgPT4ge1xuICAgICAgICByZXR1cm4gY2xpcFJlZ2lvbjtcbiAgICAgIH07XG4gICAgfSwgW2NsaXBSZWdpb24sIHNldENsaXBSZWdpb25dKTtcbiAgfVxuICByZXR1cm4gLyogQF9fUFVSRV9fICovIGpzeChOYXRpdmVMYXllcnNDb250ZXh0LlByb3ZpZGVyLCB7XG4gICAgdmFsdWU6IGNvbnRleHQsXG4gICAgY2hpbGRyZW5cbiAgfSk7XG59O1xuXG4vLyBzcmMvQ2xpcHBlci50c3hcbnZhciBDbGlwcGVyID0gKHsgaGVpZ2h0LCB3aWR0aCwgeCwgeSB9KSA9PiB7XG4gIGNvbnN0IHsgc2V0Q2xpcFJlZ2lvbiB9ID0gdXNlQ29udGV4dChOYXRpdmVMYXllcnNDb250ZXh0KTtcbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICBzZXRDbGlwUmVnaW9uKChjKSA9PiB7XG4gICAgICBpZiAoYyA9PT0gXCJoaWRlXCIpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IHJlbmRlciA8Q2xpcHBlcj4sIGJlY2F1c2UgYW5vdGhlciA8TnVsbD4gaXMgYWxyZWFkeSByZW5kZXJlZFwiKTtcbiAgICAgIH1cbiAgICAgIGlmIChjID09PSBudWxsKSB7XG4gICAgICAgIHJldHVybiB7IGhlaWdodCwgd2lkdGgsIHgsIHkgfTtcbiAgICAgIH1cbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbm5vdCByZW5kZXIgPENsaXBwZXI+LCBiZWNhdXNlIGFub3RoZXIgY29tcG9uZW50IGNsaXBwaW5nIHRoZSByZWdpb24gd2FzIGFscmVhZHkgcmVuZGVyZWQgKG1vc3QgbGlrZWx5IDxDbGlwcGVyPilcIik7XG4gICAgfSk7XG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgIHNldENsaXBSZWdpb24obnVsbCk7XG4gICAgfTtcbiAgfSwgW2hlaWdodCwgc2V0Q2xpcFJlZ2lvbiwgd2lkdGgsIHgsIHldKTtcbiAgcmV0dXJuIG51bGw7XG59O1xuXG4vLyBzcmMvZW5hYmxlLXNlcXVlbmNlLXN0YWNrLXRyYWNlcy50c1xuaW1wb3J0IFJlYWN0IGZyb20gXCJyZWFjdFwiO1xuXG4vLyBzcmMvZ2V0LXJlbW90aW9uLWVudmlyb25tZW50LnRzXG5mdW5jdGlvbiBnZXROb2RlRW52U3RyaW5nKCkge1xuICByZXR1cm4gW1wiTk9EXCIsIFwiRV9FTlwiLCBcIlZcIl0uam9pbihcIlwiKTtcbn1cbnZhciBnZXRFbnZTdHJpbmcgPSAoKSA9PiB7XG4gIHJldHVybiBbXCJlXCIsIFwibnZcIl0uam9pbihcIlwiKTtcbn07XG52YXIgZ2V0UmVtb3Rpb25FbnZpcm9ubWVudCA9ICgpID0+IHtcbiAgY29uc3QgaXNQbGF5ZXIgPSB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiICYmIHdpbmRvdy5yZW1vdGlvbl9pc1BsYXllcjtcbiAgY29uc3QgaXNSZW5kZXJpbmcgPSB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiICYmIHR5cGVvZiB3aW5kb3cucHJvY2VzcyAhPT0gXCJ1bmRlZmluZWRcIiAmJiB0eXBlb2Ygd2luZG93LnByb2Nlc3MuZW52ICE9PSBcInVuZGVmaW5lZFwiICYmICh3aW5kb3cucHJvY2Vzc1tnZXRFbnZTdHJpbmcoKV1bZ2V0Tm9kZUVudlN0cmluZygpXSA9PT0gXCJ0ZXN0XCIgfHwgd2luZG93LnByb2Nlc3NbZ2V0RW52U3RyaW5nKCldW2dldE5vZGVFbnZTdHJpbmcoKV0gPT09IFwicHJvZHVjdGlvblwiICYmIHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgJiYgdHlwZW9mIHdpbmRvdy5yZW1vdGlvbl9wdXBwZXRlZXJUaW1lb3V0ICE9PSBcInVuZGVmaW5lZFwiKTtcbiAgY29uc3QgaXNTdHVkaW8gPSB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiICYmIHdpbmRvdy5yZW1vdGlvbl9pc1N0dWRpbztcbiAgcmV0dXJuIHtcbiAgICBpc1N0dWRpbyxcbiAgICBpc1JlbmRlcmluZyxcbiAgICBpc1BsYXllclxuICB9O1xufTtcblxuLy8gc3JjL2VuYWJsZS1zZXF1ZW5jZS1zdGFjay10cmFjZXMudHNcbnZhciBvcmlnaW5hbENyZWF0ZUVsZW1lbnQgPSBSZWFjdC5jcmVhdGVFbGVtZW50O1xudmFyIGNvbXBvbmVudHNUb0FkZFN0YWNrc1RvID0gW107XG52YXIgZW5hYmxlU2VxdWVuY2VTdGFja1RyYWNlcyA9ICgpID0+IHtcbiAgaWYgKCFnZXRSZW1vdGlvbkVudmlyb25tZW50KCkuaXNTdHVkaW8pIHtcbiAgICByZXR1cm47XG4gIH1cbiAgY29uc3QgcHJveHkgPSBuZXcgUHJveHkob3JpZ2luYWxDcmVhdGVFbGVtZW50LCB7XG4gICAgYXBwbHkodGFyZ2V0LCB0aGlzQXJnLCBhcmdBcnJheSkge1xuICAgICAgaWYgKGNvbXBvbmVudHNUb0FkZFN0YWNrc1RvLmluY2x1ZGVzKGFyZ0FycmF5WzBdKSkge1xuICAgICAgICBjb25zdCBbZmlyc3QsIHByb3BzLCAuLi5yZXN0XSA9IGFyZ0FycmF5O1xuICAgICAgICBjb25zdCBuZXdQcm9wcyA9IHtcbiAgICAgICAgICAuLi5wcm9wcyA/PyB7fSxcbiAgICAgICAgICBzdGFjazogbmV3IEVycm9yKCkuc3RhY2tcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIFJlZmxlY3QuYXBwbHkodGFyZ2V0LCB0aGlzQXJnLCBbZmlyc3QsIG5ld1Byb3BzLCAuLi5yZXN0XSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gUmVmbGVjdC5hcHBseSh0YXJnZXQsIHRoaXNBcmcsIGFyZ0FycmF5KTtcbiAgICB9XG4gIH0pO1xuICBSZWFjdC5jcmVhdGVFbGVtZW50ID0gcHJveHk7XG59O1xudmFyIGFkZFNlcXVlbmNlU3RhY2tUcmFjZXMgPSAoY29tcG9uZW50KSA9PiB7XG4gIGNvbXBvbmVudHNUb0FkZFN0YWNrc1RvLnB1c2goY29tcG9uZW50KTtcbiAgZW5hYmxlU2VxdWVuY2VTdGFja1RyYWNlcygpO1xufTtcblxuLy8gc3JjL2lzLXBsYXllci50c3hcbmltcG9ydCB7IGNyZWF0ZUNvbnRleHQgYXMgY3JlYXRlQ29udGV4dDMsIHVzZUNvbnRleHQgYXMgdXNlQ29udGV4dDIgfSBmcm9tIFwicmVhY3RcIjtcbmltcG9ydCB7IGpzeCBhcyBqc3gyIH0gZnJvbSBcInJlYWN0L2pzeC1ydW50aW1lXCI7XG52YXIgSXNQbGF5ZXJDb250ZXh0ID0gY3JlYXRlQ29udGV4dDMoZmFsc2UpO1xudmFyIElzUGxheWVyQ29udGV4dFByb3ZpZGVyID0gKHtcbiAgY2hpbGRyZW5cbn0pID0+IHtcbiAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqLyBqc3gyKElzUGxheWVyQ29udGV4dC5Qcm92aWRlciwge1xuICAgIHZhbHVlOiB0cnVlLFxuICAgIGNoaWxkcmVuXG4gIH0pO1xufTtcbnZhciB1c2VJc1BsYXllciA9ICgpID0+IHtcbiAgcmV0dXJuIHVzZUNvbnRleHQyKElzUGxheWVyQ29udGV4dCk7XG59O1xuXG4vLyBzcmMvdHJ1dGh5LnRzXG5mdW5jdGlvbiB0cnV0aHkodmFsdWUpIHtcbiAgcmV0dXJuIEJvb2xlYW4odmFsdWUpO1xufVxuXG4vLyBzcmMvdmVyc2lvbi50c1xudmFyIFZFUlNJT04gPSBcIjQuMC4yMjNcIjtcblxuLy8gc3JjL211bHRpcGxlLXZlcnNpb25zLXdhcm5pbmcudHNcbnZhciBjaGVja011bHRpcGxlUmVtb3Rpb25WZXJzaW9ucyA9ICgpID0+IHtcbiAgaWYgKHR5cGVvZiBnbG9iYWxUaGlzID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGNvbnN0IGFscmVhZHlJbXBvcnRlZCA9IGdsb2JhbFRoaXMucmVtb3Rpb25faW1wb3J0ZWQgfHwgdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiAmJiB3aW5kb3cucmVtb3Rpb25faW1wb3J0ZWQ7XG4gIGlmIChhbHJlYWR5SW1wb3J0ZWQpIHtcbiAgICBpZiAoYWxyZWFkeUltcG9ydGVkID09PSBWRVJTSU9OKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYFxcdUQ4M0RcXHVERUE4IE11bHRpcGxlIHZlcnNpb25zIG9mIFJlbW90aW9uIGRldGVjdGVkOiAke1tcbiAgICAgIFZFUlNJT04sXG4gICAgICB0eXBlb2YgYWxyZWFkeUltcG9ydGVkID09PSBcInN0cmluZ1wiID8gYWxyZWFkeUltcG9ydGVkIDogXCJhbiBvbGRlciB2ZXJzaW9uXCJcbiAgICBdLmZpbHRlcih0cnV0aHkpLmpvaW4oXCIgYW5kIFwiKX0uIFRoaXMgd2lsbCBjYXVzZSB0aGluZ3MgdG8gYnJlYWsgaW4gYW4gdW5leHBlY3RlZCB3YXkuXFxuQ2hlY2sgdGhhdCBhbGwgeW91ciBSZW1vdGlvbiBwYWNrYWdlcyBhcmUgb24gdGhlIHNhbWUgdmVyc2lvbi4gSWYgeW91ciBkZXBlbmRlbmNpZXMgZGVwZW5kIG9uIFJlbW90aW9uLCBtYWtlIHRoZW0gcGVlciBkZXBlbmRlbmNpZXMuIFlvdSBjYW4gYWxzbyBydW4gXFxgbnB4IHJlbW90aW9uIHZlcnNpb25zXFxgIGZyb20geW91ciB0ZXJtaW5hbCB0byBzZWUgd2hpY2ggdmVyc2lvbnMgYXJlIG1pc21hdGNoaW5nLmApO1xuICB9XG4gIGdsb2JhbFRoaXMucmVtb3Rpb25faW1wb3J0ZWQgPSBWRVJTSU9OO1xuICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgIHdpbmRvdy5yZW1vdGlvbl9pbXBvcnRlZCA9IFZFUlNJT047XG4gIH1cbn07XG5cbi8vIHNyYy9OdWxsLnRzeFxuaW1wb3J0IHsgdXNlQ29udGV4dCBhcyB1c2VDb250ZXh0MywgdXNlRWZmZWN0IGFzIHVzZUVmZmVjdDIgfSBmcm9tIFwicmVhY3RcIjtcbnZhciBOdWxsID0gKCkgPT4ge1xuICBjb25zdCB7IHNldENsaXBSZWdpb24gfSA9IHVzZUNvbnRleHQzKE5hdGl2ZUxheWVyc0NvbnRleHQpO1xuICB1c2VFZmZlY3QyKCgpID0+IHtcbiAgICBzZXRDbGlwUmVnaW9uKChjKSA9PiB7XG4gICAgICBpZiAoYyA9PT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gXCJoaWRlXCI7XG4gICAgICB9XG4gICAgICBpZiAoYyA9PT0gXCJoaWRlXCIpIHtcbiAgICAgICAgcmV0dXJuIFwiaGlkZVwiO1xuICAgICAgfVxuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IHJlbmRlciA8TnVsbD4sIGJlY2F1c2UgYW5vdGhlciBjb21wb25lbnQgY2xpcHBpbmcgdGhlIHJlZ2lvbiB3YXMgYWxyZWFkeSByZW5kZXJlZCAobW9zdCBsaWtlbHkgPENsaXBwZXI+KVwiKTtcbiAgICB9KTtcbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgc2V0Q2xpcFJlZ2lvbihudWxsKTtcbiAgICB9O1xuICB9LCBbc2V0Q2xpcFJlZ2lvbl0pO1xuICByZXR1cm4gbnVsbDtcbn07XG5cbi8vIHNyYy9TZXF1ZW5jZS50c3hcbmltcG9ydCB7XG4gIGZvcndhcmRSZWYgYXMgZm9yd2FyZFJlZjIsXG4gIHVzZUNvbnRleHQgYXMgdXNlQ29udGV4dDEyLFxuICB1c2VFZmZlY3QgYXMgdXNlRWZmZWN0NSxcbiAgdXNlTWVtbyBhcyB1c2VNZW1vMTAsXG4gIHVzZVN0YXRlIGFzIHVzZVN0YXRlNVxufSBmcm9tIFwicmVhY3RcIjtcblxuLy8gc3JjL0Fic29sdXRlRmlsbC50c3hcbmltcG9ydCB7IGZvcndhcmRSZWYsIHVzZU1lbW8gYXMgdXNlTWVtbzIgfSBmcm9tIFwicmVhY3RcIjtcbmltcG9ydCB7IGpzeCBhcyBqc3gzIH0gZnJvbSBcInJlYWN0L2pzeC1ydW50aW1lXCI7XG52YXIgQWJzb2x1dGVGaWxsUmVmRm9yd2FyZGluZyA9IChwcm9wcywgcmVmKSA9PiB7XG4gIGNvbnN0IHsgc3R5bGUsIC4uLm90aGVyIH0gPSBwcm9wcztcbiAgY29uc3QgYWN0dWFsU3R5bGUgPSB1c2VNZW1vMigoKSA9PiB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHBvc2l0aW9uOiBcImFic29sdXRlXCIsXG4gICAgICB0b3A6IDAsXG4gICAgICBsZWZ0OiAwLFxuICAgICAgcmlnaHQ6IDAsXG4gICAgICBib3R0b206IDAsXG4gICAgICB3aWR0aDogXCIxMDAlXCIsXG4gICAgICBoZWlnaHQ6IFwiMTAwJVwiLFxuICAgICAgZGlzcGxheTogXCJmbGV4XCIsXG4gICAgICBmbGV4RGlyZWN0aW9uOiBcImNvbHVtblwiLFxuICAgICAgLi4uc3R5bGVcbiAgICB9O1xuICB9LCBbc3R5bGVdKTtcbiAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqLyBqc3gzKFwiZGl2XCIsIHtcbiAgICByZWYsXG4gICAgc3R5bGU6IGFjdHVhbFN0eWxlLFxuICAgIC4uLm90aGVyXG4gIH0pO1xufTtcbnZhciBBYnNvbHV0ZUZpbGwgPSBmb3J3YXJkUmVmKEFic29sdXRlRmlsbFJlZkZvcndhcmRpbmcpO1xuXG4vLyBzcmMvU2VxdWVuY2VDb250ZXh0LnRzeFxuaW1wb3J0IHsgY3JlYXRlQ29udGV4dCBhcyBjcmVhdGVDb250ZXh0NCB9IGZyb20gXCJyZWFjdFwiO1xudmFyIFNlcXVlbmNlQ29udGV4dCA9IGNyZWF0ZUNvbnRleHQ0KG51bGwpO1xuXG4vLyBzcmMvU2VxdWVuY2VNYW5hZ2VyLnRzeFxuaW1wb3J0IFJlYWN0MywgeyB1c2VDYWxsYmFjaywgdXNlTWVtbyBhcyB1c2VNZW1vMywgdXNlU3RhdGUgYXMgdXNlU3RhdGUyIH0gZnJvbSBcInJlYWN0XCI7XG5pbXBvcnQgeyBqc3ggYXMganN4NCB9IGZyb20gXCJyZWFjdC9qc3gtcnVudGltZVwiO1xudmFyIFNlcXVlbmNlTWFuYWdlciA9IFJlYWN0My5jcmVhdGVDb250ZXh0KHtcbiAgcmVnaXN0ZXJTZXF1ZW5jZTogKCkgPT4ge1xuICAgIHRocm93IG5ldyBFcnJvcihcIlNlcXVlbmNlTWFuYWdlckNvbnRleHQgbm90IGluaXRpYWxpemVkXCIpO1xuICB9LFxuICB1bnJlZ2lzdGVyU2VxdWVuY2U6ICgpID0+IHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJTZXF1ZW5jZU1hbmFnZXJDb250ZXh0IG5vdCBpbml0aWFsaXplZFwiKTtcbiAgfSxcbiAgc2VxdWVuY2VzOiBbXVxufSk7XG52YXIgU2VxdWVuY2VWaXNpYmlsaXR5VG9nZ2xlQ29udGV4dCA9IFJlYWN0My5jcmVhdGVDb250ZXh0KHtcbiAgaGlkZGVuOiB7fSxcbiAgc2V0SGlkZGVuOiAoKSA9PiB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiU2VxdWVuY2VWaXNpYmlsaXR5VG9nZ2xlIG5vdCBpbml0aWFsaXplZFwiKTtcbiAgfVxufSk7XG52YXIgU2VxdWVuY2VNYW5hZ2VyUHJvdmlkZXIgPSAoeyBjaGlsZHJlbiB9KSA9PiB7XG4gIGNvbnN0IFtzZXF1ZW5jZXMsIHNldFNlcXVlbmNlc10gPSB1c2VTdGF0ZTIoW10pO1xuICBjb25zdCBbaGlkZGVuLCBzZXRIaWRkZW5dID0gdXNlU3RhdGUyKHt9KTtcbiAgY29uc3QgcmVnaXN0ZXJTZXF1ZW5jZSA9IHVzZUNhbGxiYWNrKChzZXEpID0+IHtcbiAgICBzZXRTZXF1ZW5jZXMoKHNlcXMpID0+IHtcbiAgICAgIHJldHVybiBbLi4uc2Vxcywgc2VxXTtcbiAgICB9KTtcbiAgfSwgW10pO1xuICBjb25zdCB1bnJlZ2lzdGVyU2VxdWVuY2UgPSB1c2VDYWxsYmFjaygoc2VxKSA9PiB7XG4gICAgc2V0U2VxdWVuY2VzKChzZXFzKSA9PiBzZXFzLmZpbHRlcigocykgPT4gcy5pZCAhPT0gc2VxKSk7XG4gIH0sIFtdKTtcbiAgY29uc3Qgc2VxdWVuY2VDb250ZXh0ID0gdXNlTWVtbzMoKCkgPT4ge1xuICAgIHJldHVybiB7XG4gICAgICByZWdpc3RlclNlcXVlbmNlLFxuICAgICAgc2VxdWVuY2VzLFxuICAgICAgdW5yZWdpc3RlclNlcXVlbmNlXG4gICAgfTtcbiAgfSwgW3JlZ2lzdGVyU2VxdWVuY2UsIHNlcXVlbmNlcywgdW5yZWdpc3RlclNlcXVlbmNlXSk7XG4gIGNvbnN0IGhpZGRlbkNvbnRleHQgPSB1c2VNZW1vMygoKSA9PiB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGhpZGRlbixcbiAgICAgIHNldEhpZGRlblxuICAgIH07XG4gIH0sIFtoaWRkZW5dKTtcbiAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqLyBqc3g0KFNlcXVlbmNlTWFuYWdlci5Qcm92aWRlciwge1xuICAgIHZhbHVlOiBzZXF1ZW5jZUNvbnRleHQsXG4gICAgY2hpbGRyZW46IC8qIEBfX1BVUkVfXyAqLyBqc3g0KFNlcXVlbmNlVmlzaWJpbGl0eVRvZ2dsZUNvbnRleHQuUHJvdmlkZXIsIHtcbiAgICAgIHZhbHVlOiBoaWRkZW5Db250ZXh0LFxuICAgICAgY2hpbGRyZW5cbiAgICB9KVxuICB9KTtcbn07XG5cbi8vIHNyYy9ub25jZS50c1xuaW1wb3J0IHsgY3JlYXRlQ29udGV4dCBhcyBjcmVhdGVDb250ZXh0NSwgdXNlQ29udGV4dCBhcyB1c2VDb250ZXh0NCwgdXNlRWZmZWN0IGFzIHVzZUVmZmVjdDMsIHVzZVJlZiwgdXNlU3RhdGUgYXMgdXNlU3RhdGUzIH0gZnJvbSBcInJlYWN0XCI7XG52YXIgTm9uY2VDb250ZXh0ID0gY3JlYXRlQ29udGV4dDUoe1xuICBnZXROb25jZTogKCkgPT4gMCxcbiAgZmFzdFJlZnJlc2hlczogMFxufSk7XG52YXIgdXNlTm9uY2UgPSAoKSA9PiB7XG4gIGNvbnN0IGNvbnRleHQgPSB1c2VDb250ZXh0NChOb25jZUNvbnRleHQpO1xuICBjb25zdCBbbm9uY2UsIHNldE5vbmNlXSA9IHVzZVN0YXRlMygoKSA9PiBjb250ZXh0LmdldE5vbmNlKCkpO1xuICBjb25zdCBsYXN0Q29udGV4dCA9IHVzZVJlZihjb250ZXh0KTtcbiAgdXNlRWZmZWN0MygoKSA9PiB7XG4gICAgaWYgKGxhc3RDb250ZXh0LmN1cnJlbnQgPT09IGNvbnRleHQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgbGFzdENvbnRleHQuY3VycmVudCA9IGNvbnRleHQ7XG4gICAgc2V0Tm9uY2UoY29udGV4dC5nZXROb25jZSk7XG4gIH0sIFtjb250ZXh0XSk7XG4gIHJldHVybiBub25jZTtcbn07XG5cbi8vIHNyYy90aW1lbGluZS1wb3NpdGlvbi1zdGF0ZS50c1xudmFyIGV4cG9ydHNfdGltZWxpbmVfcG9zaXRpb25fc3RhdGUgPSB7fTtcbl9fZXhwb3J0KGV4cG9ydHNfdGltZWxpbmVfcG9zaXRpb25fc3RhdGUsIHtcbiAgdXNlVGltZWxpbmVTZXRGcmFtZTogKCkgPT4gdXNlVGltZWxpbmVTZXRGcmFtZSxcbiAgdXNlVGltZWxpbmVQb3NpdGlvbjogKCkgPT4gdXNlVGltZWxpbmVQb3NpdGlvbixcbiAgdXNlUGxheWluZ1N0YXRlOiAoKSA9PiB1c2VQbGF5aW5nU3RhdGUsXG4gIHBlcnNpc3RDdXJyZW50RnJhbWU6ICgpID0+IHBlcnNpc3RDdXJyZW50RnJhbWUsXG4gIGdldEluaXRpYWxGcmFtZVN0YXRlOiAoKSA9PiBnZXRJbml0aWFsRnJhbWVTdGF0ZSxcbiAgZ2V0RnJhbWVGb3JDb21wb3NpdGlvbjogKCkgPT4gZ2V0RnJhbWVGb3JDb21wb3NpdGlvbixcbiAgVGltZWxpbmVDb250ZXh0OiAoKSA9PiBUaW1lbGluZUNvbnRleHQsXG4gIFNldFRpbWVsaW5lQ29udGV4dDogKCkgPT4gU2V0VGltZWxpbmVDb250ZXh0XG59KTtcbmltcG9ydCB7IGNyZWF0ZUNvbnRleHQgYXMgY3JlYXRlQ29udGV4dDksIHVzZUNvbnRleHQgYXMgdXNlQ29udGV4dDcsIHVzZU1lbW8gYXMgdXNlTWVtbzcgfSBmcm9tIFwicmVhY3RcIjtcblxuLy8gc3JjL3VzZS12aWRlby50c1xuaW1wb3J0IHsgdXNlQ29udGV4dCBhcyB1c2VDb250ZXh0NiwgdXNlTWVtbyBhcyB1c2VNZW1vNiB9IGZyb20gXCJyZWFjdFwiO1xuXG4vLyBzcmMvQ29tcG9zaXRpb25NYW5hZ2VyQ29udGV4dC50c3hcbmltcG9ydCB7IGNyZWF0ZUNvbnRleHQgYXMgY3JlYXRlQ29udGV4dDYgfSBmcm9tIFwicmVhY3RcIjtcbnZhciBDb21wb3NpdGlvbk1hbmFnZXIgPSBjcmVhdGVDb250ZXh0Nih7XG4gIGNvbXBvc2l0aW9uczogW10sXG4gIHJlZ2lzdGVyQ29tcG9zaXRpb246ICgpID0+IHtcbiAgICByZXR1cm47XG4gIH0sXG4gIHVucmVnaXN0ZXJDb21wb3NpdGlvbjogKCkgPT4ge1xuICAgIHJldHVybjtcbiAgfSxcbiAgcmVnaXN0ZXJGb2xkZXI6ICgpID0+IHtcbiAgICByZXR1cm47XG4gIH0sXG4gIHVucmVnaXN0ZXJGb2xkZXI6ICgpID0+IHtcbiAgICByZXR1cm47XG4gIH0sXG4gIHNldEN1cnJlbnRDb21wb3NpdGlvbk1ldGFkYXRhOiAoKSA9PiB7XG4gICAgcmV0dXJuO1xuICB9LFxuICB1cGRhdGVDb21wb3NpdGlvbkRlZmF1bHRQcm9wczogKCkgPT4ge1xuICAgIHJldHVybjtcbiAgfSxcbiAgZm9sZGVyczogW10sXG4gIGN1cnJlbnRDb21wb3NpdGlvbk1ldGFkYXRhOiBudWxsLFxuICBjYW52YXNDb250ZW50OiBudWxsLFxuICBzZXRDYW52YXNDb250ZW50OiAoKSA9PiB7XG4gICAgcmV0dXJuO1xuICB9XG59KTtcblxuLy8gc3JjL1Jlc29sdmVDb21wb3NpdGlvbkNvbmZpZy50c3hcbmltcG9ydCB7XG4gIGNyZWF0ZUNvbnRleHQgYXMgY3JlYXRlQ29udGV4dDgsXG4gIGNyZWF0ZVJlZixcbiAgdXNlQ2FsbGJhY2sgYXMgdXNlQ2FsbGJhY2szLFxuICB1c2VDb250ZXh0IGFzIHVzZUNvbnRleHQ1LFxuICB1c2VFZmZlY3QgYXMgdXNlRWZmZWN0NCxcbiAgdXNlSW1wZXJhdGl2ZUhhbmRsZSBhcyB1c2VJbXBlcmF0aXZlSGFuZGxlMixcbiAgdXNlTWVtbyBhcyB1c2VNZW1vNSxcbiAgdXNlU3RhdGUgYXMgdXNlU3RhdGU0XG59IGZyb20gXCJyZWFjdFwiO1xuXG4vLyBzcmMvRWRpdG9yUHJvcHMudHN4XG5pbXBvcnQgUmVhY3Q0LCB7XG4gIGNyZWF0ZUNvbnRleHQgYXMgY3JlYXRlQ29udGV4dDcsXG4gIHVzZUNhbGxiYWNrIGFzIHVzZUNhbGxiYWNrMixcbiAgdXNlSW1wZXJhdGl2ZUhhbmRsZSxcbiAgdXNlTWVtbyBhcyB1c2VNZW1vNFxufSBmcm9tIFwicmVhY3RcIjtcbmltcG9ydCB7IGpzeCBhcyBqc3g1IH0gZnJvbSBcInJlYWN0L2pzeC1ydW50aW1lXCI7XG52YXIgRWRpdG9yUHJvcHNDb250ZXh0ID0gY3JlYXRlQ29udGV4dDcoe1xuICBwcm9wczoge30sXG4gIHVwZGF0ZVByb3BzOiAoKSA9PiB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiTm90IGltcGxlbWVudGVkXCIpO1xuICB9LFxuICByZXNldFVuc2F2ZWQ6ICgpID0+IHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJOb3QgaW1wbGVtZW50ZWRcIik7XG4gIH1cbn0pO1xudmFyIGVkaXRvclByb3BzUHJvdmlkZXJSZWYgPSBSZWFjdDQuY3JlYXRlUmVmKCk7XG52YXIgRWRpdG9yUHJvcHNQcm92aWRlciA9ICh7IGNoaWxkcmVuIH0pID0+IHtcbiAgY29uc3QgW3Byb3BzLCBzZXRQcm9wc10gPSBSZWFjdDQudXNlU3RhdGUoe30pO1xuICBjb25zdCB1cGRhdGVQcm9wcyA9IHVzZUNhbGxiYWNrMigoe1xuICAgIGRlZmF1bHRQcm9wcyxcbiAgICBpZCxcbiAgICBuZXdQcm9wc1xuICB9KSA9PiB7XG4gICAgc2V0UHJvcHMoKHByZXYpID0+IHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIC4uLnByZXYsXG4gICAgICAgIFtpZF06IHR5cGVvZiBuZXdQcm9wcyA9PT0gXCJmdW5jdGlvblwiID8gbmV3UHJvcHMocHJldltpZF0gPz8gZGVmYXVsdFByb3BzKSA6IG5ld1Byb3BzXG4gICAgICB9O1xuICAgIH0pO1xuICB9LCBbXSk7XG4gIGNvbnN0IHJlc2V0VW5zYXZlZCA9IHVzZUNhbGxiYWNrMigoKSA9PiB7XG4gICAgc2V0UHJvcHMoe30pO1xuICB9LCBbXSk7XG4gIHVzZUltcGVyYXRpdmVIYW5kbGUoZWRpdG9yUHJvcHNQcm92aWRlclJlZiwgKCkgPT4ge1xuICAgIHJldHVybiB7XG4gICAgICBnZXRQcm9wczogKCkgPT4gcHJvcHMsXG4gICAgICBzZXRQcm9wc1xuICAgIH07XG4gIH0sIFtwcm9wc10pO1xuICBjb25zdCBjdHggPSB1c2VNZW1vNCgoKSA9PiB7XG4gICAgcmV0dXJuIHsgcHJvcHMsIHVwZGF0ZVByb3BzLCByZXNldFVuc2F2ZWQgfTtcbiAgfSwgW3Byb3BzLCByZXNldFVuc2F2ZWQsIHVwZGF0ZVByb3BzXSk7XG4gIHJldHVybiAvKiBAX19QVVJFX18gKi8ganN4NShFZGl0b3JQcm9wc0NvbnRleHQuUHJvdmlkZXIsIHtcbiAgICB2YWx1ZTogY3R4LFxuICAgIGNoaWxkcmVuXG4gIH0pO1xufTtcblxuLy8gc3JjL3N0YXRpYy1maWxlLnRzXG52YXIgcHJvYmxlbWF0aWNDaGFyYWN0ZXJzID0ge1xuICBcIiUzQVwiOiBcIjpcIixcbiAgXCIlMkZcIjogXCIvXCIsXG4gIFwiJTNGXCI6IFwiP1wiLFxuICBcIiUyM1wiOiBcIiNcIixcbiAgXCIlNUJcIjogXCJbXCIsXG4gIFwiJTVEXCI6IFwiXVwiLFxuICBcIiU0MFwiOiBcIkBcIixcbiAgXCIlMjFcIjogXCIhXCIsXG4gIFwiJTI0XCI6IFwiJFwiLFxuICBcIiUyNlwiOiBcIiZcIixcbiAgXCIlMjdcIjogXCInXCIsXG4gIFwiJTI4XCI6IFwiKFwiLFxuICBcIiUyOVwiOiBcIilcIixcbiAgXCIlMkFcIjogXCIqXCIsXG4gIFwiJTJCXCI6IFwiK1wiLFxuICBcIiUyQ1wiOiBcIixcIixcbiAgXCIlM0JcIjogXCI7XCJcbn07XG52YXIgZGlkV2FybiA9IHt9O1xudmFyIHdhcm5PbmNlID0gKG1lc3NhZ2UpID0+IHtcbiAgaWYgKGRpZFdhcm5bbWVzc2FnZV0pIHtcbiAgICByZXR1cm47XG4gIH1cbiAgY29uc29sZS53YXJuKG1lc3NhZ2UpO1xuICBkaWRXYXJuW21lc3NhZ2VdID0gdHJ1ZTtcbn07XG52YXIgaW5jbHVkZXNIZXhPZlVuc2FmZUNoYXIgPSAocGF0aCkgPT4ge1xuICBmb3IgKGNvbnN0IGtleSBvZiBPYmplY3Qua2V5cyhwcm9ibGVtYXRpY0NoYXJhY3RlcnMpKSB7XG4gICAgaWYgKHBhdGguaW5jbHVkZXMoa2V5KSkge1xuICAgICAgcmV0dXJuIHsgY29udGFpbnNIZXg6IHRydWUsIGhleENvZGU6IGtleSB9O1xuICAgIH1cbiAgfVxuICByZXR1cm4geyBjb250YWluc0hleDogZmFsc2UgfTtcbn07XG52YXIgdHJpbUxlYWRpbmdTbGFzaCA9IChwYXRoKSA9PiB7XG4gIGlmIChwYXRoLnN0YXJ0c1dpdGgoXCIvXCIpKSB7XG4gICAgcmV0dXJuIHRyaW1MZWFkaW5nU2xhc2gocGF0aC5zdWJzdHJpbmcoMSkpO1xuICB9XG4gIHJldHVybiBwYXRoO1xufTtcbnZhciBpbm5lciA9IChwYXRoKSA9PiB7XG4gIGlmICh0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiICYmIHdpbmRvdy5yZW1vdGlvbl9zdGF0aWNCYXNlKSB7XG4gICAgaWYgKHBhdGguc3RhcnRzV2l0aCh3aW5kb3cucmVtb3Rpb25fc3RhdGljQmFzZSkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgVGhlIHZhbHVlIFwiJHtwYXRofVwiIGlzIGFscmVhZHkgcHJlZml4ZWQgd2l0aCB0aGUgc3RhdGljIGJhc2UgJHt3aW5kb3cucmVtb3Rpb25fc3RhdGljQmFzZX0uIFlvdSBkb24ndCBuZWVkIHRvIGNhbGwgc3RhdGljRmlsZSgpIG9uIGl0LmApO1xuICAgIH1cbiAgICByZXR1cm4gYCR7d2luZG93LnJlbW90aW9uX3N0YXRpY0Jhc2V9LyR7dHJpbUxlYWRpbmdTbGFzaChwYXRoKX1gO1xuICB9XG4gIHJldHVybiBgLyR7dHJpbUxlYWRpbmdTbGFzaChwYXRoKX1gO1xufTtcbnZhciBlbmNvZGVCeVNwbGl0dGluZyA9IChwYXRoKSA9PiB7XG4gIGNvbnN0IHNwbGl0QnlTbGFzaCA9IHBhdGguc3BsaXQoXCIvXCIpO1xuICBjb25zdCBlbmNvZGVkQXJyYXkgPSBzcGxpdEJ5U2xhc2gubWFwKChlbGVtZW50KSA9PiB7XG4gICAgcmV0dXJuIGVuY29kZVVSSUNvbXBvbmVudChlbGVtZW50KTtcbiAgfSk7XG4gIGNvbnN0IG1lcmdlZCA9IGVuY29kZWRBcnJheS5qb2luKFwiL1wiKTtcbiAgcmV0dXJuIG1lcmdlZDtcbn07XG52YXIgc3RhdGljRmlsZSA9IChwYXRoKSA9PiB7XG4gIGlmIChwYXRoID09PSBudWxsKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIm51bGwgd2FzIHBhc3NlZCB0byBzdGF0aWNGaWxlKClcIik7XG4gIH1cbiAgaWYgKHR5cGVvZiBwYXRoID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcInVuZGVmaW5lZCB3YXMgcGFzc2VkIHRvIHN0YXRpY0ZpbGUoKVwiKTtcbiAgfVxuICBpZiAocGF0aC5zdGFydHNXaXRoKFwiaHR0cDovL1wiKSB8fCBwYXRoLnN0YXJ0c1dpdGgoXCJodHRwczovL1wiKSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYHN0YXRpY0ZpbGUoKSBkb2VzIG5vdCBzdXBwb3J0IHJlbW90ZSBVUkxzIC0gZ290IFwiJHtwYXRofVwiLiBJbnN0ZWFkLCBwYXNzIHRoZSBVUkwgd2l0aG91dCB3cmFwcGluZyBpdCBpbiBzdGF0aWNGaWxlKCkuIFNlZTogaHR0cHM6Ly9yZW1vdGlvbi5kZXYvZG9jcy9zdGF0aWNmaWxlLXJlbW90ZS11cmxzYCk7XG4gIH1cbiAgaWYgKHBhdGguc3RhcnRzV2l0aChcIi4uXCIpIHx8IHBhdGguc3RhcnRzV2l0aChcIi4vXCIpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgc3RhdGljRmlsZSgpIGRvZXMgbm90IHN1cHBvcnQgcmVsYXRpdmUgcGF0aHMgLSBnb3QgXCIke3BhdGh9XCIuIEluc3RlYWQsIHBhc3MgdGhlIG5hbWUgb2YgYSBmaWxlIHRoYXQgaXMgaW5zaWRlIHRoZSBwdWJsaWMvIGZvbGRlci4gU2VlOiBodHRwczovL3JlbW90aW9uLmRldi9kb2NzL3N0YXRpY2ZpbGUtcmVsYXRpdmUtcGF0aHNgKTtcbiAgfVxuICBpZiAocGF0aC5zdGFydHNXaXRoKFwiL1VzZXJzXCIpIHx8IHBhdGguc3RhcnRzV2l0aChcIi9ob21lXCIpIHx8IHBhdGguc3RhcnRzV2l0aChcIi90bXBcIikgfHwgcGF0aC5zdGFydHNXaXRoKFwiL2V0Y1wiKSB8fCBwYXRoLnN0YXJ0c1dpdGgoXCIvb3B0XCIpIHx8IHBhdGguc3RhcnRzV2l0aChcIi92YXJcIikgfHwgcGF0aC5zdGFydHNXaXRoKFwiQzpcIikgfHwgcGF0aC5zdGFydHNXaXRoKFwiRDpcIikgfHwgcGF0aC5zdGFydHNXaXRoKFwiRTpcIikpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBzdGF0aWNGaWxlKCkgZG9lcyBub3Qgc3VwcG9ydCBhYnNvbHV0ZSBwYXRocyAtIGdvdCBcIiR7cGF0aH1cIi4gSW5zdGVhZCwgcGFzcyB0aGUgbmFtZSBvZiBhIGZpbGUgdGhhdCBpcyBpbnNpZGUgdGhlIHB1YmxpYy8gZm9sZGVyLiBTZWU6IGh0dHBzOi8vcmVtb3Rpb24uZGV2L2RvY3Mvc3RhdGljZmlsZS1yZWxhdGl2ZS1wYXRoc2ApO1xuICB9XG4gIGlmIChwYXRoLnN0YXJ0c1dpdGgoXCJwdWJsaWMvXCIpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgRG8gbm90IGluY2x1ZGUgdGhlIHB1YmxpYy8gcHJlZml4IHdoZW4gdXNpbmcgc3RhdGljRmlsZSgpIC0gZ290IFwiJHtwYXRofVwiLiBTZWU6IGh0dHBzOi8vcmVtb3Rpb24uZGV2L2RvY3Mvc3RhdGljZmlsZS1yZWxhdGl2ZS1wYXRoc2ApO1xuICB9XG4gIGNvbnN0IGluY2x1ZGVzSGV4ID0gaW5jbHVkZXNIZXhPZlVuc2FmZUNoYXIocGF0aCk7XG4gIGlmIChpbmNsdWRlc0hleC5jb250YWluc0hleCkge1xuICAgIHdhcm5PbmNlKGBXQVJOSU5HOiBZb3Ugc2VlbSB0byBwYXNzIGFuIGFscmVhZHkgZW5jb2RlZCBwYXRoIChwYXRoIGNvbnRhaW5zICR7aW5jbHVkZXNIZXguaGV4Q29kZX0pLiBTaW5jZSBSZW1vdGlvbiA0LjAsIHRoZSBlbmNvZGluZyBpcyBkb25lIGJ5IHN0YXRpY0ZpbGUoKSBpdHNlbGYuIFlvdSBtYXkgd2FudCB0byByZW1vdmUgYSBlbmNvZGVVUklDb21wb25lbnQoKSB3cmFwcGluZy5gKTtcbiAgfVxuICBjb25zdCBwcmVwcm9jZXNzZWQgPSBlbmNvZGVCeVNwbGl0dGluZyhwYXRoKTtcbiAgY29uc3QgcHJlcGFyc2VkID0gaW5uZXIocHJlcHJvY2Vzc2VkKTtcbiAgaWYgKCFwcmVwYXJzZWQuc3RhcnRzV2l0aChcIi9cIikpIHtcbiAgICByZXR1cm4gYC8ke3ByZXBhcnNlZH1gO1xuICB9XG4gIHJldHVybiBwcmVwYXJzZWQ7XG59O1xuXG4vLyBzcmMvaW5wdXQtcHJvcHMtc2VyaWFsaXphdGlvbi50c1xudmFyIERBVEVfVE9LRU4gPSBcInJlbW90aW9uLWRhdGU6XCI7XG52YXIgRklMRV9UT0tFTiA9IFwicmVtb3Rpb24tZmlsZTpcIjtcbnZhciBzZXJpYWxpemVKU09OV2l0aERhdGUgPSAoe1xuICBkYXRhLFxuICBpbmRlbnQsXG4gIHN0YXRpY0Jhc2Vcbn0pID0+IHtcbiAgbGV0IGN1c3RvbURhdGVVc2VkID0gZmFsc2U7XG4gIGxldCBjdXN0b21GaWxlVXNlZCA9IGZhbHNlO1xuICBsZXQgbWFwVXNlZCA9IGZhbHNlO1xuICBsZXQgc2V0VXNlZCA9IGZhbHNlO1xuICB0cnkge1xuICAgIGNvbnN0IHNlcmlhbGl6ZWRTdHJpbmcgPSBKU09OLnN0cmluZ2lmeShkYXRhLCBmdW5jdGlvbihrZXksIHZhbHVlKSB7XG4gICAgICBjb25zdCBpdGVtID0gdGhpc1trZXldO1xuICAgICAgaWYgKGl0ZW0gaW5zdGFuY2VvZiBEYXRlKSB7XG4gICAgICAgIGN1c3RvbURhdGVVc2VkID0gdHJ1ZTtcbiAgICAgICAgcmV0dXJuIGAke0RBVEVfVE9LRU59JHtpdGVtLnRvSVNPU3RyaW5nKCl9YDtcbiAgICAgIH1cbiAgICAgIGlmIChpdGVtIGluc3RhbmNlb2YgTWFwKSB7XG4gICAgICAgIG1hcFVzZWQgPSB0cnVlO1xuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICB9XG4gICAgICBpZiAoaXRlbSBpbnN0YW5jZW9mIFNldCkge1xuICAgICAgICBzZXRVc2VkID0gdHJ1ZTtcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgfVxuICAgICAgaWYgKHR5cGVvZiBpdGVtID09PSBcInN0cmluZ1wiICYmIHN0YXRpY0Jhc2UgIT09IG51bGwgJiYgaXRlbS5zdGFydHNXaXRoKHN0YXRpY0Jhc2UpKSB7XG4gICAgICAgIGN1c3RvbUZpbGVVc2VkID0gdHJ1ZTtcbiAgICAgICAgcmV0dXJuIGAke0ZJTEVfVE9LRU59JHtpdGVtLnJlcGxhY2Uoc3RhdGljQmFzZSArIFwiL1wiLCBcIlwiKX1gO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH0sIGluZGVudCk7XG4gICAgcmV0dXJuIHsgc2VyaWFsaXplZFN0cmluZywgY3VzdG9tRGF0ZVVzZWQsIGN1c3RvbUZpbGVVc2VkLCBtYXBVc2VkLCBzZXRVc2VkIH07XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIHRocm93IG5ldyBFcnJvcihcIkNvdWxkIG5vdCBzZXJpYWxpemUgdGhlIHBhc3NlZCBpbnB1dCBwcm9wcyB0byBKU09OOiBcIiArIGVyci5tZXNzYWdlKTtcbiAgfVxufTtcbnZhciBkZXNlcmlhbGl6ZUpTT05XaXRoQ3VzdG9tRmllbGRzID0gKGRhdGEpID0+IHtcbiAgcmV0dXJuIEpTT04ucGFyc2UoZGF0YSwgKF8sIHZhbHVlKSA9PiB7XG4gICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gXCJzdHJpbmdcIiAmJiB2YWx1ZS5zdGFydHNXaXRoKERBVEVfVE9LRU4pKSB7XG4gICAgICByZXR1cm4gbmV3IERhdGUodmFsdWUucmVwbGFjZShEQVRFX1RPS0VOLCBcIlwiKSk7XG4gICAgfVxuICAgIGlmICh0eXBlb2YgdmFsdWUgPT09IFwic3RyaW5nXCIgJiYgdmFsdWUuc3RhcnRzV2l0aChGSUxFX1RPS0VOKSkge1xuICAgICAgcmV0dXJuIHN0YXRpY0ZpbGUodmFsdWUucmVwbGFjZShGSUxFX1RPS0VOLCBcIlwiKSk7XG4gICAgfVxuICAgIHJldHVybiB2YWx1ZTtcbiAgfSk7XG59O1xudmFyIHNlcmlhbGl6ZVRoZW5EZXNlcmlhbGl6ZUluU3R1ZGlvID0gKHByb3BzKSA9PiB7XG4gIGlmIChnZXRSZW1vdGlvbkVudmlyb25tZW50KCkuaXNTdHVkaW8pIHtcbiAgICByZXR1cm4gZGVzZXJpYWxpemVKU09OV2l0aEN1c3RvbUZpZWxkcyhzZXJpYWxpemVKU09OV2l0aERhdGUoe1xuICAgICAgZGF0YTogcHJvcHMsXG4gICAgICBpbmRlbnQ6IDIsXG4gICAgICBzdGF0aWNCYXNlOiB3aW5kb3cucmVtb3Rpb25fc3RhdGljQmFzZVxuICAgIH0pLnNlcmlhbGl6ZWRTdHJpbmcpO1xuICB9XG4gIHJldHVybiBwcm9wcztcbn07XG5cbi8vIHNyYy9jb25maWcvaW5wdXQtcHJvcHMudHNcbnZhciBkaWRXYXJuU1NSSW1wb3J0ID0gZmFsc2U7XG52YXIgd2Fybk9uY2VTU1JJbXBvcnQgPSAoKSA9PiB7XG4gIGlmIChkaWRXYXJuU1NSSW1wb3J0KSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGRpZFdhcm5TU1JJbXBvcnQgPSB0cnVlO1xuICBjb25zb2xlLndhcm4oXCJDYWxsZWQgYGdldElucHV0UHJvcHMoKWAgb24gdGhlIHNlcnZlci4gVGhpcyBmdW5jdGlvbiBpcyBub3QgYXZhaWxhYmxlIHNlcnZlci1zaWRlIGFuZCBoYXMgcmV0dXJuZWQgYW4gZW1wdHkgb2JqZWN0LlwiKTtcbiAgY29uc29sZS53YXJuKFwiVG8gaGlkZSB0aGlzIHdhcm5pbmcsIGRvbid0IGNhbGwgdGhpcyBmdW5jdGlvbiBvbiB0aGUgc2VydmVyOlwiKTtcbiAgY29uc29sZS53YXJuKFwiICB0eXBlb2Ygd2luZG93ID09PSAndW5kZWZpbmVkJyA/IHt9IDogZ2V0SW5wdXRQcm9wcygpXCIpO1xufTtcbnZhciBnZXRJbnB1dFByb3BzID0gKCkgPT4ge1xuICBpZiAodHlwZW9mIHdpbmRvdyA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgIHdhcm5PbmNlU1NSSW1wb3J0KCk7XG4gICAgcmV0dXJuIHt9O1xuICB9XG4gIGlmIChnZXRSZW1vdGlvbkVudmlyb25tZW50KCkuaXNQbGF5ZXIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJZb3UgY2Fubm90IGNhbGwgYGdldElucHV0UHJvcHMoKWAgZnJvbSBhIDxQbGF5ZXI+LiBJbnN0ZWFkLCB0aGUgcHJvcHMgYXJlIGF2YWlsYWJsZSBhcyBSZWFjdCBwcm9wcyBmcm9tIGNvbXBvbmVudCB0aGF0IHlvdSBwYXNzZWQgYXMgYGNvbXBvbmVudGAgcHJvcC5cIik7XG4gIH1cbiAgY29uc3QgcGFyYW0gPSB3aW5kb3cucmVtb3Rpb25faW5wdXRQcm9wcztcbiAgaWYgKCFwYXJhbSkge1xuICAgIHJldHVybiB7fTtcbiAgfVxuICBjb25zdCBwYXJzZWQgPSBkZXNlcmlhbGl6ZUpTT05XaXRoQ3VzdG9tRmllbGRzKHBhcmFtKTtcbiAgcmV0dXJuIHBhcnNlZDtcbn07XG5cbi8vIHNyYy9jb2RlYy50c1xudmFyIHZhbGlkQ29kZWNzID0gW1xuICBcImgyNjRcIixcbiAgXCJoMjY1XCIsXG4gIFwidnA4XCIsXG4gIFwidnA5XCIsXG4gIFwibXAzXCIsXG4gIFwiYWFjXCIsXG4gIFwid2F2XCIsXG4gIFwicHJvcmVzXCIsXG4gIFwiaDI2NC1ta3ZcIixcbiAgXCJoMjY0LXRzXCIsXG4gIFwiZ2lmXCJcbl07XG5cbi8vIHNyYy92YWxpZGF0aW9uL3ZhbGlkYXRlLWRlZmF1bHQtY29kZWMudHNcbmZ1bmN0aW9uIHZhbGlkYXRlRGVmYXVsdENvZGVjKGRlZmF1bHRDb2RlYywgbG9jYXRpb24pIHtcbiAgaWYgKHR5cGVvZiBkZWZhdWx0Q29kZWMgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgaWYgKHR5cGVvZiBkZWZhdWx0Q29kZWMgIT09IFwic3RyaW5nXCIpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBUaGUgXCJkZWZhdWx0Q29kZWNcIiBwcm9wICR7bG9jYXRpb259IG11c3QgYmUgYSBzdHJpbmcsIGJ1dCB5b3UgcGFzc2VkIGEgdmFsdWUgb2YgdHlwZSAke3R5cGVvZiBkZWZhdWx0Q29kZWN9LmApO1xuICB9XG4gIGlmICghdmFsaWRDb2RlY3MuaW5jbHVkZXMoZGVmYXVsdENvZGVjKSkge1xuICAgIHRocm93IG5ldyBFcnJvcihgVGhlIFwiZGVmYXVsdENvZGVjXCIgcHJvcCAke2xvY2F0aW9ufSBtdXN0IGJlIG9uZSBvZiAke3ZhbGlkQ29kZWNzLmpvaW4oXCIsIFwiKX0sIGJ1dCB5b3UgcGFzc2VkICR7ZGVmYXVsdENvZGVjfS5gKTtcbiAgfVxufVxuXG4vLyBzcmMvdmFsaWRhdGlvbi92YWxpZGF0ZS1kaW1lbnNpb25zLnRzXG5mdW5jdGlvbiB2YWxpZGF0ZURpbWVuc2lvbihhbW91bnQsIG5hbWVPZlByb3AsIGxvY2F0aW9uKSB7XG4gIGlmICh0eXBlb2YgYW1vdW50ICE9PSBcIm51bWJlclwiKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBUaGUgXCIke25hbWVPZlByb3B9XCIgcHJvcCAke2xvY2F0aW9ufSBtdXN0IGJlIGEgbnVtYmVyLCBidXQgeW91IHBhc3NlZCBhIHZhbHVlIG9mIHR5cGUgJHt0eXBlb2YgYW1vdW50fWApO1xuICB9XG4gIGlmIChpc05hTihhbW91bnQpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgVGhlIFwiJHtuYW1lT2ZQcm9wfVwiIHByb3AgJHtsb2NhdGlvbn0gbXVzdCBub3QgYmUgTmFOLCBidXQgaXMgTmFOLmApO1xuICB9XG4gIGlmICghTnVtYmVyLmlzRmluaXRlKGFtb3VudCkpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBUaGUgXCIke25hbWVPZlByb3B9XCIgcHJvcCAke2xvY2F0aW9ufSBtdXN0IGJlIGZpbml0ZSwgYnV0IGlzICR7YW1vdW50fS5gKTtcbiAgfVxuICBpZiAoYW1vdW50ICUgMSAhPT0gMCkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYFRoZSBcIiR7bmFtZU9mUHJvcH1cIiBwcm9wICR7bG9jYXRpb259IG11c3QgYmUgYW4gaW50ZWdlciwgYnV0IGlzICR7YW1vdW50fS5gKTtcbiAgfVxuICBpZiAoYW1vdW50IDw9IDApIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBUaGUgXCIke25hbWVPZlByb3B9XCIgcHJvcCAke2xvY2F0aW9ufSBtdXN0IGJlIHBvc2l0aXZlLCBidXQgZ290ICR7YW1vdW50fS5gKTtcbiAgfVxufVxuXG4vLyBzcmMvdmFsaWRhdGlvbi92YWxpZGF0ZS1kdXJhdGlvbi1pbi1mcmFtZXMudHNcbmZ1bmN0aW9uIHZhbGlkYXRlRHVyYXRpb25JbkZyYW1lcyhkdXJhdGlvbkluRnJhbWVzLCBvcHRpb25zKSB7XG4gIGNvbnN0IHsgYWxsb3dGbG9hdHMsIGNvbXBvbmVudCB9ID0gb3B0aW9ucztcbiAgaWYgKHR5cGVvZiBkdXJhdGlvbkluRnJhbWVzID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBUaGUgXCJkdXJhdGlvbkluRnJhbWVzXCIgcHJvcCAke2NvbXBvbmVudH0gaXMgbWlzc2luZy5gKTtcbiAgfVxuICBpZiAodHlwZW9mIGR1cmF0aW9uSW5GcmFtZXMgIT09IFwibnVtYmVyXCIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYFRoZSBcImR1cmF0aW9uSW5GcmFtZXNcIiBwcm9wICR7Y29tcG9uZW50fSBtdXN0IGJlIGEgbnVtYmVyLCBidXQgeW91IHBhc3NlZCBhIHZhbHVlIG9mIHR5cGUgJHt0eXBlb2YgZHVyYXRpb25JbkZyYW1lc31gKTtcbiAgfVxuICBpZiAoZHVyYXRpb25JbkZyYW1lcyA8PSAwKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgVGhlIFwiZHVyYXRpb25JbkZyYW1lc1wiIHByb3AgJHtjb21wb25lbnR9IG11c3QgYmUgcG9zaXRpdmUsIGJ1dCBnb3QgJHtkdXJhdGlvbkluRnJhbWVzfS5gKTtcbiAgfVxuICBpZiAoIWFsbG93RmxvYXRzICYmIGR1cmF0aW9uSW5GcmFtZXMgJSAxICE9PSAwKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgVGhlIFwiZHVyYXRpb25JbkZyYW1lc1wiIHByb3AgJHtjb21wb25lbnR9IG11c3QgYmUgYW4gaW50ZWdlciwgYnV0IGdvdCAke2R1cmF0aW9uSW5GcmFtZXN9LmApO1xuICB9XG4gIGlmICghTnVtYmVyLmlzRmluaXRlKGR1cmF0aW9uSW5GcmFtZXMpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgVGhlIFwiZHVyYXRpb25JbkZyYW1lc1wiIHByb3AgJHtjb21wb25lbnR9IG11c3QgYmUgZmluaXRlLCBidXQgZ290ICR7ZHVyYXRpb25JbkZyYW1lc30uYCk7XG4gIH1cbn1cblxuLy8gc3JjL3ZhbGlkYXRpb24vdmFsaWRhdGUtZnBzLnRzXG5mdW5jdGlvbiB2YWxpZGF0ZUZwcyhmcHMsIGxvY2F0aW9uLCBpc0dpZikge1xuICBpZiAodHlwZW9mIGZwcyAhPT0gXCJudW1iZXJcIikge1xuICAgIHRocm93IG5ldyBFcnJvcihgXCJmcHNcIiBtdXN0IGJlIGEgbnVtYmVyLCBidXQgeW91IHBhc3NlZCBhIHZhbHVlIG9mIHR5cGUgJHt0eXBlb2YgZnBzfSAke2xvY2F0aW9ufWApO1xuICB9XG4gIGlmICghTnVtYmVyLmlzRmluaXRlKGZwcykpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYFwiZnBzXCIgbXVzdCBiZSBhIGZpbml0ZSwgYnV0IHlvdSBwYXNzZWQgJHtmcHN9ICR7bG9jYXRpb259YCk7XG4gIH1cbiAgaWYgKGlzTmFOKGZwcykpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYFwiZnBzXCIgbXVzdCBub3QgYmUgTmFOLCBidXQgZ290ICR7ZnBzfSAke2xvY2F0aW9ufWApO1xuICB9XG4gIGlmIChmcHMgPD0gMCkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYFwiZnBzXCIgbXVzdCBiZSBwb3NpdGl2ZSwgYnV0IGdvdCAke2Zwc30gJHtsb2NhdGlvbn1gKTtcbiAgfVxuICBpZiAoaXNHaWYgJiYgZnBzID4gNTApIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBUaGUgRlBTIGZvciBhIEdJRiBjYW5ub3QgYmUgaGlnaGVyIHRoYW4gNTAuIFVzZSB0aGUgLS1ldmVyeS1udGgtZnJhbWUgb3B0aW9uIHRvIGxvd2VyIHRoZSBGUFM6IGh0dHBzOi8vcmVtb3Rpb24uZGV2L2RvY3MvcmVuZGVyLWFzLWdpZmApO1xuICB9XG59XG5cbi8vIHNyYy9yZXNvbHZlLXZpZGVvLWNvbmZpZy50c1xudmFyIHZhbGlkYXRlQ2FsY3VsYXRlZCA9ICh7XG4gIGNhbGN1bGF0ZWQsXG4gIGNvbXBvc2l0aW9uSWQsXG4gIGNvbXBvc2l0aW9uRnBzLFxuICBjb21wb3NpdGlvbkhlaWdodCxcbiAgY29tcG9zaXRpb25XaWR0aCxcbiAgY29tcG9zaXRpb25EdXJhdGlvbkluRnJhbWVzXG59KSA9PiB7XG4gIGNvbnN0IGNhbGN1bGF0ZU1ldGFkYXRhRXJyb3JMb2NhdGlvbiA9IGBjYWxjdWxhdGVkIGJ5IGNhbGN1bGF0ZU1ldGFkYXRhKCkgZm9yIHRoZSBjb21wb3NpdGlvbiBcIiR7Y29tcG9zaXRpb25JZH1cImA7XG4gIGNvbnN0IGRlZmF1bHRFcnJvckxvY2F0aW9uID0gYG9mIHRoZSBcIjxDb21wb3NpdGlvbiAvPlwiIGNvbXBvbmVudCB3aXRoIHRoZSBpZCBcIiR7Y29tcG9zaXRpb25JZH1cImA7XG4gIGNvbnN0IHdpZHRoID0gY2FsY3VsYXRlZD8ud2lkdGggPz8gY29tcG9zaXRpb25XaWR0aCA/PyB1bmRlZmluZWQ7XG4gIHZhbGlkYXRlRGltZW5zaW9uKHdpZHRoLCBcIndpZHRoXCIsIGNhbGN1bGF0ZWQ/LndpZHRoID8gY2FsY3VsYXRlTWV0YWRhdGFFcnJvckxvY2F0aW9uIDogZGVmYXVsdEVycm9yTG9jYXRpb24pO1xuICBjb25zdCBoZWlnaHQgPSBjYWxjdWxhdGVkPy5oZWlnaHQgPz8gY29tcG9zaXRpb25IZWlnaHQgPz8gdW5kZWZpbmVkO1xuICB2YWxpZGF0ZURpbWVuc2lvbihoZWlnaHQsIFwiaGVpZ2h0XCIsIGNhbGN1bGF0ZWQ/LmhlaWdodCA/IGNhbGN1bGF0ZU1ldGFkYXRhRXJyb3JMb2NhdGlvbiA6IGRlZmF1bHRFcnJvckxvY2F0aW9uKTtcbiAgY29uc3QgZnBzID0gY2FsY3VsYXRlZD8uZnBzID8/IGNvbXBvc2l0aW9uRnBzID8/IG51bGw7XG4gIHZhbGlkYXRlRnBzKGZwcywgY2FsY3VsYXRlZD8uZnBzID8gY2FsY3VsYXRlTWV0YWRhdGFFcnJvckxvY2F0aW9uIDogZGVmYXVsdEVycm9yTG9jYXRpb24sIGZhbHNlKTtcbiAgY29uc3QgZHVyYXRpb25JbkZyYW1lcyA9IGNhbGN1bGF0ZWQ/LmR1cmF0aW9uSW5GcmFtZXMgPz8gY29tcG9zaXRpb25EdXJhdGlvbkluRnJhbWVzID8/IG51bGw7XG4gIHZhbGlkYXRlRHVyYXRpb25JbkZyYW1lcyhkdXJhdGlvbkluRnJhbWVzLCB7XG4gICAgYWxsb3dGbG9hdHM6IGZhbHNlLFxuICAgIGNvbXBvbmVudDogYG9mIHRoZSBcIjxDb21wb3NpdGlvbiAvPlwiIGNvbXBvbmVudCB3aXRoIHRoZSBpZCBcIiR7Y29tcG9zaXRpb25JZH1cImBcbiAgfSk7XG4gIGNvbnN0IGRlZmF1bHRDb2RlYyA9IGNhbGN1bGF0ZWQ/LmRlZmF1bHRDb2RlYztcbiAgdmFsaWRhdGVEZWZhdWx0Q29kZWMoZGVmYXVsdENvZGVjLCBjYWxjdWxhdGVNZXRhZGF0YUVycm9yTG9jYXRpb24pO1xuICByZXR1cm4geyB3aWR0aCwgaGVpZ2h0LCBmcHMsIGR1cmF0aW9uSW5GcmFtZXMsIGRlZmF1bHRDb2RlYyB9O1xufTtcbnZhciByZXNvbHZlVmlkZW9Db25maWcgPSAoe1xuICBjYWxjdWxhdGVNZXRhZGF0YSxcbiAgc2lnbmFsLFxuICBkZWZhdWx0UHJvcHMsXG4gIG9yaWdpbmFsUHJvcHMsXG4gIGNvbXBvc2l0aW9uSWQsXG4gIGNvbXBvc2l0aW9uRHVyYXRpb25JbkZyYW1lcyxcbiAgY29tcG9zaXRpb25GcHMsXG4gIGNvbXBvc2l0aW9uSGVpZ2h0LFxuICBjb21wb3NpdGlvbldpZHRoXG59KSA9PiB7XG4gIGNvbnN0IGNhbGN1bGF0ZWRQcm9tID0gY2FsY3VsYXRlTWV0YWRhdGEgPyBjYWxjdWxhdGVNZXRhZGF0YSh7XG4gICAgZGVmYXVsdFByb3BzLFxuICAgIHByb3BzOiBvcmlnaW5hbFByb3BzLFxuICAgIGFib3J0U2lnbmFsOiBzaWduYWwsXG4gICAgY29tcG9zaXRpb25JZFxuICB9KSA6IG51bGw7XG4gIGlmIChjYWxjdWxhdGVkUHJvbSAhPT0gbnVsbCAmJiB0eXBlb2YgY2FsY3VsYXRlZFByb20gPT09IFwib2JqZWN0XCIgJiYgXCJ0aGVuXCIgaW4gY2FsY3VsYXRlZFByb20pIHtcbiAgICByZXR1cm4gY2FsY3VsYXRlZFByb20udGhlbigoYykgPT4ge1xuICAgICAgY29uc3QgeyBoZWlnaHQsIHdpZHRoLCBkdXJhdGlvbkluRnJhbWVzLCBmcHMsIGRlZmF1bHRDb2RlYyB9ID0gdmFsaWRhdGVDYWxjdWxhdGVkKHtcbiAgICAgICAgY2FsY3VsYXRlZDogYyxcbiAgICAgICAgY29tcG9zaXRpb25EdXJhdGlvbkluRnJhbWVzLFxuICAgICAgICBjb21wb3NpdGlvbkZwcyxcbiAgICAgICAgY29tcG9zaXRpb25IZWlnaHQsXG4gICAgICAgIGNvbXBvc2l0aW9uV2lkdGgsXG4gICAgICAgIGNvbXBvc2l0aW9uSWRcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgd2lkdGgsXG4gICAgICAgIGhlaWdodCxcbiAgICAgICAgZnBzLFxuICAgICAgICBkdXJhdGlvbkluRnJhbWVzLFxuICAgICAgICBpZDogY29tcG9zaXRpb25JZCxcbiAgICAgICAgZGVmYXVsdFByb3BzOiBzZXJpYWxpemVUaGVuRGVzZXJpYWxpemVJblN0dWRpbyhkZWZhdWx0UHJvcHMpLFxuICAgICAgICBwcm9wczogc2VyaWFsaXplVGhlbkRlc2VyaWFsaXplSW5TdHVkaW8oYy5wcm9wcyA/PyBvcmlnaW5hbFByb3BzKSxcbiAgICAgICAgZGVmYXVsdENvZGVjOiBkZWZhdWx0Q29kZWMgPz8gbnVsbFxuICAgICAgfTtcbiAgICB9KTtcbiAgfVxuICBjb25zdCBkYXRhID0gdmFsaWRhdGVDYWxjdWxhdGVkKHtcbiAgICBjYWxjdWxhdGVkOiBjYWxjdWxhdGVkUHJvbSxcbiAgICBjb21wb3NpdGlvbkR1cmF0aW9uSW5GcmFtZXMsXG4gICAgY29tcG9zaXRpb25GcHMsXG4gICAgY29tcG9zaXRpb25IZWlnaHQsXG4gICAgY29tcG9zaXRpb25XaWR0aCxcbiAgICBjb21wb3NpdGlvbklkXG4gIH0pO1xuICBpZiAoY2FsY3VsYXRlZFByb20gPT09IG51bGwpIHtcbiAgICByZXR1cm4ge1xuICAgICAgLi4uZGF0YSxcbiAgICAgIGlkOiBjb21wb3NpdGlvbklkLFxuICAgICAgZGVmYXVsdFByb3BzOiBzZXJpYWxpemVUaGVuRGVzZXJpYWxpemVJblN0dWRpbyhkZWZhdWx0UHJvcHMgPz8ge30pLFxuICAgICAgcHJvcHM6IHNlcmlhbGl6ZVRoZW5EZXNlcmlhbGl6ZUluU3R1ZGlvKG9yaWdpbmFsUHJvcHMpLFxuICAgICAgZGVmYXVsdENvZGVjOiBudWxsXG4gICAgfTtcbiAgfVxuICByZXR1cm4ge1xuICAgIC4uLmRhdGEsXG4gICAgaWQ6IGNvbXBvc2l0aW9uSWQsXG4gICAgZGVmYXVsdFByb3BzOiBzZXJpYWxpemVUaGVuRGVzZXJpYWxpemVJblN0dWRpbyhkZWZhdWx0UHJvcHMgPz8ge30pLFxuICAgIHByb3BzOiBzZXJpYWxpemVUaGVuRGVzZXJpYWxpemVJblN0dWRpbyhjYWxjdWxhdGVkUHJvbS5wcm9wcyA/PyBvcmlnaW5hbFByb3BzKSxcbiAgICBkZWZhdWx0Q29kZWM6IGNhbGN1bGF0ZWRQcm9tLmRlZmF1bHRDb2RlYyA/PyBudWxsXG4gIH07XG59O1xudmFyIHJlc29sdmVWaWRlb0NvbmZpZ09yQ2F0Y2ggPSAocGFyYW1zKSA9PiB7XG4gIHRyeSB7XG4gICAgY29uc3QgcHJvbWlzZU9yUmV0dXJuVmFsdWUgPSByZXNvbHZlVmlkZW9Db25maWcocGFyYW1zKTtcbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogXCJzdWNjZXNzXCIsXG4gICAgICByZXN1bHQ6IHByb21pc2VPclJldHVyblZhbHVlXG4gICAgfTtcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6IFwiZXJyb3JcIixcbiAgICAgIGVycm9yOiBlcnJcbiAgICB9O1xuICB9XG59O1xuXG4vLyBzcmMvUmVzb2x2ZUNvbXBvc2l0aW9uQ29uZmlnLnRzeFxuaW1wb3J0IHsganN4IGFzIGpzeDYgfSBmcm9tIFwicmVhY3QvanN4LXJ1bnRpbWVcIjtcbnZhciBSZXNvbHZlQ29tcG9zaXRpb25Db250ZXh0ID0gY3JlYXRlQ29udGV4dDgobnVsbCk7XG52YXIgcmVzb2x2ZUNvbXBvc2l0aW9uc1JlZiA9IGNyZWF0ZVJlZigpO1xudmFyIG5lZWRzUmVzb2x1dGlvbiA9IChjb21wb3NpdGlvbikgPT4ge1xuICByZXR1cm4gQm9vbGVhbihjb21wb3NpdGlvbi5jYWxjdWxhdGVNZXRhZGF0YSk7XG59O1xudmFyIFBST1BTX1VQREFURURfRVhURVJOQUxMWSA9IFwicmVtb3Rpb24ucHJvcHNVcGRhdGVkRXh0ZXJuYWxseVwiO1xudmFyIFJlc29sdmVDb21wb3NpdGlvbkNvbmZpZyA9ICh7IGNoaWxkcmVuIH0pID0+IHtcbiAgY29uc3QgW2N1cnJlbnRSZW5kZXJNb2RhbENvbXBvc2l0aW9uLCBzZXRDdXJyZW50UmVuZGVyTW9kYWxDb21wb3NpdGlvbl0gPSB1c2VTdGF0ZTQobnVsbCk7XG4gIGNvbnN0IHsgY29tcG9zaXRpb25zLCBjYW52YXNDb250ZW50LCBjdXJyZW50Q29tcG9zaXRpb25NZXRhZGF0YSB9ID0gdXNlQ29udGV4dDUoQ29tcG9zaXRpb25NYW5hZ2VyKTtcbiAgY29uc3QgeyBmYXN0UmVmcmVzaGVzIH0gPSB1c2VDb250ZXh0NShOb25jZUNvbnRleHQpO1xuICBjb25zdCBzZWxlY3RlZENvbXBvc2l0aW9uID0gdXNlTWVtbzUoKCkgPT4ge1xuICAgIHJldHVybiBjb21wb3NpdGlvbnMuZmluZCgoYykgPT4gY2FudmFzQ29udGVudCAmJiBjYW52YXNDb250ZW50LnR5cGUgPT09IFwiY29tcG9zaXRpb25cIiAmJiBjYW52YXNDb250ZW50LmNvbXBvc2l0aW9uSWQgPT09IGMuaWQpO1xuICB9LCBbY2FudmFzQ29udGVudCwgY29tcG9zaXRpb25zXSk7XG4gIGNvbnN0IHJlbmRlck1vZGFsQ29tcG9zaXRpb24gPSBjb21wb3NpdGlvbnMuZmluZCgoYykgPT4gYy5pZCA9PT0gY3VycmVudFJlbmRlck1vZGFsQ29tcG9zaXRpb24pO1xuICBjb25zdCB7IHByb3BzOiBhbGxFZGl0b3JQcm9wcyB9ID0gdXNlQ29udGV4dDUoRWRpdG9yUHJvcHNDb250ZXh0KTtcbiAgY29uc3QgaW5wdXRQcm9wcyA9IHVzZU1lbW81KCgpID0+IHtcbiAgICByZXR1cm4gdHlwZW9mIHdpbmRvdyA9PT0gXCJ1bmRlZmluZWRcIiB8fCBnZXRSZW1vdGlvbkVudmlyb25tZW50KCkuaXNQbGF5ZXIgPyB7fSA6IGdldElucHV0UHJvcHMoKSA/PyB7fTtcbiAgfSwgW10pO1xuICBjb25zdCBbcmVzb2x2ZWRDb25maWdzLCBzZXRSZXNvbHZlZENvbmZpZ3NdID0gdXNlU3RhdGU0KHt9KTtcbiAgY29uc3Qgc2VsZWN0ZWRFZGl0b3JQcm9wcyA9IHVzZU1lbW81KCgpID0+IHtcbiAgICByZXR1cm4gc2VsZWN0ZWRDb21wb3NpdGlvbiA/IGFsbEVkaXRvclByb3BzW3NlbGVjdGVkQ29tcG9zaXRpb24uaWRdID8/IHt9IDoge307XG4gIH0sIFthbGxFZGl0b3JQcm9wcywgc2VsZWN0ZWRDb21wb3NpdGlvbl0pO1xuICBjb25zdCByZW5kZXJNb2RhbFByb3BzID0gdXNlTWVtbzUoKCkgPT4ge1xuICAgIHJldHVybiByZW5kZXJNb2RhbENvbXBvc2l0aW9uID8gYWxsRWRpdG9yUHJvcHNbcmVuZGVyTW9kYWxDb21wb3NpdGlvbi5pZF0gPz8ge30gOiB7fTtcbiAgfSwgW2FsbEVkaXRvclByb3BzLCByZW5kZXJNb2RhbENvbXBvc2l0aW9uXSk7XG4gIGNvbnN0IGhhc1Jlc29sdXRpb24gPSBCb29sZWFuKGN1cnJlbnRDb21wb3NpdGlvbk1ldGFkYXRhKTtcbiAgY29uc3QgZG9SZXNvbHV0aW9uID0gdXNlQ2FsbGJhY2szKCh7XG4gICAgY2FsY3VsYXRlTWV0YWRhdGEsXG4gICAgY29tYmluZWRQcm9wcyxcbiAgICBjb21wb3NpdGlvbkR1cmF0aW9uSW5GcmFtZXMsXG4gICAgY29tcG9zaXRpb25GcHMsXG4gICAgY29tcG9zaXRpb25IZWlnaHQsXG4gICAgY29tcG9zaXRpb25JZCxcbiAgICBjb21wb3NpdGlvbldpZHRoLFxuICAgIGRlZmF1bHRQcm9wc1xuICB9KSA9PiB7XG4gICAgY29uc3QgY29udHJvbGxlciA9IG5ldyBBYm9ydENvbnRyb2xsZXI7XG4gICAgaWYgKGhhc1Jlc29sdXRpb24pIHtcbiAgICAgIHJldHVybiBjb250cm9sbGVyO1xuICAgIH1cbiAgICBjb25zdCB7IHNpZ25hbCB9ID0gY29udHJvbGxlcjtcbiAgICBjb25zdCByZXN1bHQgPSByZXNvbHZlVmlkZW9Db25maWdPckNhdGNoKHtcbiAgICAgIGNvbXBvc2l0aW9uSWQsXG4gICAgICBjYWxjdWxhdGVNZXRhZGF0YSxcbiAgICAgIG9yaWdpbmFsUHJvcHM6IGNvbWJpbmVkUHJvcHMsXG4gICAgICBzaWduYWwsXG4gICAgICBkZWZhdWx0UHJvcHMsXG4gICAgICBjb21wb3NpdGlvbkR1cmF0aW9uSW5GcmFtZXMsXG4gICAgICBjb21wb3NpdGlvbkZwcyxcbiAgICAgIGNvbXBvc2l0aW9uSGVpZ2h0LFxuICAgICAgY29tcG9zaXRpb25XaWR0aFxuICAgIH0pO1xuICAgIGlmIChyZXN1bHQudHlwZSA9PT0gXCJlcnJvclwiKSB7XG4gICAgICBzZXRSZXNvbHZlZENvbmZpZ3MoKHIpID0+ICh7XG4gICAgICAgIC4uLnIsXG4gICAgICAgIFtjb21wb3NpdGlvbklkXToge1xuICAgICAgICAgIHR5cGU6IFwiZXJyb3JcIixcbiAgICAgICAgICBlcnJvcjogcmVzdWx0LmVycm9yXG4gICAgICAgIH1cbiAgICAgIH0pKTtcbiAgICAgIHJldHVybiBjb250cm9sbGVyO1xuICAgIH1cbiAgICBjb25zdCBwcm9tT3JOb3QgPSByZXN1bHQucmVzdWx0O1xuICAgIGlmICh0eXBlb2YgcHJvbU9yTm90ID09PSBcIm9iamVjdFwiICYmIFwidGhlblwiIGluIHByb21Pck5vdCkge1xuICAgICAgc2V0UmVzb2x2ZWRDb25maWdzKChyKSA9PiB7XG4gICAgICAgIGNvbnN0IHByZXYgPSByW2NvbXBvc2l0aW9uSWRdO1xuICAgICAgICBpZiAocHJldj8udHlwZSA9PT0gXCJzdWNjZXNzXCIgfHwgcHJldj8udHlwZSA9PT0gXCJzdWNjZXNzLWFuZC1yZWZyZXNoaW5nXCIpIHtcbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgLi4ucixcbiAgICAgICAgICAgIFtjb21wb3NpdGlvbklkXToge1xuICAgICAgICAgICAgICB0eXBlOiBcInN1Y2Nlc3MtYW5kLXJlZnJlc2hpbmdcIixcbiAgICAgICAgICAgICAgcmVzdWx0OiBwcmV2LnJlc3VsdFxuICAgICAgICAgICAgfVxuICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAuLi5yLFxuICAgICAgICAgIFtjb21wb3NpdGlvbklkXToge1xuICAgICAgICAgICAgdHlwZTogXCJsb2FkaW5nXCJcbiAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICB9KTtcbiAgICAgIHByb21Pck5vdC50aGVuKChjKSA9PiB7XG4gICAgICAgIGlmIChjb250cm9sbGVyLnNpZ25hbC5hYm9ydGVkKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHNldFJlc29sdmVkQ29uZmlncygocikgPT4gKHtcbiAgICAgICAgICAuLi5yLFxuICAgICAgICAgIFtjb21wb3NpdGlvbklkXToge1xuICAgICAgICAgICAgdHlwZTogXCJzdWNjZXNzXCIsXG4gICAgICAgICAgICByZXN1bHQ6IGNcbiAgICAgICAgICB9XG4gICAgICAgIH0pKTtcbiAgICAgIH0pLmNhdGNoKChlcnIpID0+IHtcbiAgICAgICAgaWYgKGNvbnRyb2xsZXIuc2lnbmFsLmFib3J0ZWQpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgc2V0UmVzb2x2ZWRDb25maWdzKChyKSA9PiAoe1xuICAgICAgICAgIC4uLnIsXG4gICAgICAgICAgW2NvbXBvc2l0aW9uSWRdOiB7XG4gICAgICAgICAgICB0eXBlOiBcImVycm9yXCIsXG4gICAgICAgICAgICBlcnJvcjogZXJyXG4gICAgICAgICAgfVxuICAgICAgICB9KSk7XG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgc2V0UmVzb2x2ZWRDb25maWdzKChyKSA9PiAoe1xuICAgICAgICAuLi5yLFxuICAgICAgICBbY29tcG9zaXRpb25JZF06IHtcbiAgICAgICAgICB0eXBlOiBcInN1Y2Nlc3NcIixcbiAgICAgICAgICByZXN1bHQ6IHByb21Pck5vdFxuICAgICAgICB9XG4gICAgICB9KSk7XG4gICAgfVxuICAgIHJldHVybiBjb250cm9sbGVyO1xuICB9LCBbaGFzUmVzb2x1dGlvbl0pO1xuICBjb25zdCBjdXJyZW50Q29tcG9zaXRpb24gPSBjYW52YXNDb250ZW50Py50eXBlID09PSBcImNvbXBvc2l0aW9uXCIgPyBjYW52YXNDb250ZW50LmNvbXBvc2l0aW9uSWQgOiBudWxsO1xuICB1c2VJbXBlcmF0aXZlSGFuZGxlMihyZXNvbHZlQ29tcG9zaXRpb25zUmVmLCAoKSA9PiB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHNldEN1cnJlbnRSZW5kZXJNb2RhbENvbXBvc2l0aW9uOiAoaWQpID0+IHtcbiAgICAgICAgc2V0Q3VycmVudFJlbmRlck1vZGFsQ29tcG9zaXRpb24oaWQpO1xuICAgICAgfSxcbiAgICAgIHJlbG9hZEN1cnJlbnRseVNlbGVjdGVkQ29tcG9zaXRpb246ICgpID0+IHtcbiAgICAgICAgaWYgKCFjdXJyZW50Q29tcG9zaXRpb24pIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgY29tcG9zaXRpb24gPSBjb21wb3NpdGlvbnMuZmluZCgoYykgPT4gYy5pZCA9PT0gY3VycmVudENvbXBvc2l0aW9uKTtcbiAgICAgICAgaWYgKCFjb21wb3NpdGlvbikge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgQ291bGQgbm90IGZpbmQgY29tcG9zaXRpb24gd2l0aCBpZCAke2N1cnJlbnRDb21wb3NpdGlvbn1gKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBlZGl0b3JQcm9wcyA9IGFsbEVkaXRvclByb3BzW2N1cnJlbnRDb21wb3NpdGlvbl0gPz8ge307XG4gICAgICAgIGNvbnN0IGRlZmF1bHRQcm9wcyA9IHtcbiAgICAgICAgICAuLi5jb21wb3NpdGlvbi5kZWZhdWx0UHJvcHMgPz8ge30sXG4gICAgICAgICAgLi4uZWRpdG9yUHJvcHMgPz8ge31cbiAgICAgICAgfTtcbiAgICAgICAgY29uc3QgcHJvcHMgPSB7XG4gICAgICAgICAgLi4uZGVmYXVsdFByb3BzLFxuICAgICAgICAgIC4uLmlucHV0UHJvcHMgPz8ge31cbiAgICAgICAgfTtcbiAgICAgICAgZG9SZXNvbHV0aW9uKHtcbiAgICAgICAgICBkZWZhdWx0UHJvcHMsXG4gICAgICAgICAgY2FsY3VsYXRlTWV0YWRhdGE6IGNvbXBvc2l0aW9uLmNhbGN1bGF0ZU1ldGFkYXRhLFxuICAgICAgICAgIGNvbWJpbmVkUHJvcHM6IHByb3BzLFxuICAgICAgICAgIGNvbXBvc2l0aW9uRHVyYXRpb25JbkZyYW1lczogY29tcG9zaXRpb24uZHVyYXRpb25JbkZyYW1lcyA/PyBudWxsLFxuICAgICAgICAgIGNvbXBvc2l0aW9uRnBzOiBjb21wb3NpdGlvbi5mcHMgPz8gbnVsbCxcbiAgICAgICAgICBjb21wb3NpdGlvbkhlaWdodDogY29tcG9zaXRpb24uaGVpZ2h0ID8/IG51bGwsXG4gICAgICAgICAgY29tcG9zaXRpb25XaWR0aDogY29tcG9zaXRpb24ud2lkdGggPz8gbnVsbCxcbiAgICAgICAgICBjb21wb3NpdGlvbklkOiBjb21wb3NpdGlvbi5pZFxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9O1xuICB9LCBbXG4gICAgYWxsRWRpdG9yUHJvcHMsXG4gICAgY29tcG9zaXRpb25zLFxuICAgIGN1cnJlbnRDb21wb3NpdGlvbixcbiAgICBkb1Jlc29sdXRpb24sXG4gICAgaW5wdXRQcm9wc1xuICBdKTtcbiAgY29uc3QgaXNUaGVTYW1lID0gc2VsZWN0ZWRDb21wb3NpdGlvbj8uaWQgPT09IHJlbmRlck1vZGFsQ29tcG9zaXRpb24/LmlkO1xuICBjb25zdCBjdXJyZW50RGVmYXVsdFByb3BzID0gdXNlTWVtbzUoKCkgPT4ge1xuICAgIHJldHVybiB7XG4gICAgICAuLi5zZWxlY3RlZENvbXBvc2l0aW9uPy5kZWZhdWx0UHJvcHMgPz8ge30sXG4gICAgICAuLi5zZWxlY3RlZEVkaXRvclByb3BzID8/IHt9XG4gICAgfTtcbiAgfSwgW3NlbGVjdGVkQ29tcG9zaXRpb24/LmRlZmF1bHRQcm9wcywgc2VsZWN0ZWRFZGl0b3JQcm9wc10pO1xuICBjb25zdCBvcmlnaW5hbFByb3BzID0gdXNlTWVtbzUoKCkgPT4ge1xuICAgIHJldHVybiB7XG4gICAgICAuLi5jdXJyZW50RGVmYXVsdFByb3BzLFxuICAgICAgLi4uaW5wdXRQcm9wcyA/PyB7fVxuICAgIH07XG4gIH0sIFtjdXJyZW50RGVmYXVsdFByb3BzLCBpbnB1dFByb3BzXSk7XG4gIGNvbnN0IGNhblJlc29sdmUgPSBzZWxlY3RlZENvbXBvc2l0aW9uICYmIG5lZWRzUmVzb2x1dGlvbihzZWxlY3RlZENvbXBvc2l0aW9uKTtcbiAgY29uc3Qgc2hvdWxkSWdub3JlVXBkYXRlID0gdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiAmJiB3aW5kb3cucmVtb3Rpb25faWdub3JlRmFzdFJlZnJlc2hVcGRhdGUgJiYgZmFzdFJlZnJlc2hlcyA8PSB3aW5kb3cucmVtb3Rpb25faWdub3JlRmFzdFJlZnJlc2hVcGRhdGU7XG4gIHVzZUVmZmVjdDQoKCkgPT4ge1xuICAgIGlmIChzaG91bGRJZ25vcmVVcGRhdGUpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKGNhblJlc29sdmUpIHtcbiAgICAgIGNvbnN0IGNvbnRyb2xsZXIgPSBkb1Jlc29sdXRpb24oe1xuICAgICAgICBjYWxjdWxhdGVNZXRhZGF0YTogc2VsZWN0ZWRDb21wb3NpdGlvbi5jYWxjdWxhdGVNZXRhZGF0YSxcbiAgICAgICAgY29tYmluZWRQcm9wczogb3JpZ2luYWxQcm9wcyxcbiAgICAgICAgY29tcG9zaXRpb25EdXJhdGlvbkluRnJhbWVzOiBzZWxlY3RlZENvbXBvc2l0aW9uLmR1cmF0aW9uSW5GcmFtZXMgPz8gbnVsbCxcbiAgICAgICAgY29tcG9zaXRpb25GcHM6IHNlbGVjdGVkQ29tcG9zaXRpb24uZnBzID8/IG51bGwsXG4gICAgICAgIGNvbXBvc2l0aW9uSGVpZ2h0OiBzZWxlY3RlZENvbXBvc2l0aW9uLmhlaWdodCA/PyBudWxsLFxuICAgICAgICBjb21wb3NpdGlvbldpZHRoOiBzZWxlY3RlZENvbXBvc2l0aW9uLndpZHRoID8/IG51bGwsXG4gICAgICAgIGRlZmF1bHRQcm9wczogY3VycmVudERlZmF1bHRQcm9wcyxcbiAgICAgICAgY29tcG9zaXRpb25JZDogc2VsZWN0ZWRDb21wb3NpdGlvbi5pZFxuICAgICAgfSk7XG4gICAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgICBjb250cm9sbGVyLmFib3J0KCk7XG4gICAgICB9O1xuICAgIH1cbiAgfSwgW1xuICAgIGNhblJlc29sdmUsXG4gICAgY3VycmVudERlZmF1bHRQcm9wcyxcbiAgICBkb1Jlc29sdXRpb24sXG4gICAgb3JpZ2luYWxQcm9wcyxcbiAgICBzZWxlY3RlZENvbXBvc2l0aW9uPy5jYWxjdWxhdGVNZXRhZGF0YSxcbiAgICBzZWxlY3RlZENvbXBvc2l0aW9uPy5kdXJhdGlvbkluRnJhbWVzLFxuICAgIHNlbGVjdGVkQ29tcG9zaXRpb24/LmZwcyxcbiAgICBzZWxlY3RlZENvbXBvc2l0aW9uPy5oZWlnaHQsXG4gICAgc2VsZWN0ZWRDb21wb3NpdGlvbj8uaWQsXG4gICAgc2VsZWN0ZWRDb21wb3NpdGlvbj8ud2lkdGgsXG4gICAgc2hvdWxkSWdub3JlVXBkYXRlXG4gIF0pO1xuICB1c2VFZmZlY3Q0KCgpID0+IHtcbiAgICBpZiAoc2hvdWxkSWdub3JlVXBkYXRlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHdpbmRvdy5kaXNwYXRjaEV2ZW50KG5ldyBDdXN0b21FdmVudChcInJlbW90aW9uLnByb3BzVXBkYXRlZEV4dGVybmFsbHlcIikpO1xuICB9LCBbZmFzdFJlZnJlc2hlc10pO1xuICB1c2VFZmZlY3Q0KCgpID0+IHtcbiAgICBpZiAocmVuZGVyTW9kYWxDb21wb3NpdGlvbiAmJiAhaXNUaGVTYW1lKSB7XG4gICAgICBjb25zdCBjb21iaW5lZFByb3BzID0ge1xuICAgICAgICAuLi5yZW5kZXJNb2RhbENvbXBvc2l0aW9uLmRlZmF1bHRQcm9wcyA/PyB7fSxcbiAgICAgICAgLi4ucmVuZGVyTW9kYWxQcm9wcyA/PyB7fSxcbiAgICAgICAgLi4uaW5wdXRQcm9wcyA/PyB7fVxuICAgICAgfTtcbiAgICAgIGNvbnN0IGNvbnRyb2xsZXIgPSBkb1Jlc29sdXRpb24oe1xuICAgICAgICBjYWxjdWxhdGVNZXRhZGF0YTogcmVuZGVyTW9kYWxDb21wb3NpdGlvbi5jYWxjdWxhdGVNZXRhZGF0YSxcbiAgICAgICAgY29tcG9zaXRpb25EdXJhdGlvbkluRnJhbWVzOiByZW5kZXJNb2RhbENvbXBvc2l0aW9uLmR1cmF0aW9uSW5GcmFtZXMgPz8gbnVsbCxcbiAgICAgICAgY29tcG9zaXRpb25GcHM6IHJlbmRlck1vZGFsQ29tcG9zaXRpb24uZnBzID8/IG51bGwsXG4gICAgICAgIGNvbXBvc2l0aW9uSGVpZ2h0OiByZW5kZXJNb2RhbENvbXBvc2l0aW9uLmhlaWdodCA/PyBudWxsLFxuICAgICAgICBjb21wb3NpdGlvbklkOiByZW5kZXJNb2RhbENvbXBvc2l0aW9uLmlkLFxuICAgICAgICBjb21wb3NpdGlvbldpZHRoOiByZW5kZXJNb2RhbENvbXBvc2l0aW9uLndpZHRoID8/IG51bGwsXG4gICAgICAgIGRlZmF1bHRQcm9wczogY3VycmVudERlZmF1bHRQcm9wcyxcbiAgICAgICAgY29tYmluZWRQcm9wc1xuICAgICAgfSk7XG4gICAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgICBjb250cm9sbGVyLmFib3J0KCk7XG4gICAgICB9O1xuICAgIH1cbiAgfSwgW1xuICAgIGN1cnJlbnREZWZhdWx0UHJvcHMsXG4gICAgZG9SZXNvbHV0aW9uLFxuICAgIGlucHV0UHJvcHMsXG4gICAgaXNUaGVTYW1lLFxuICAgIHJlbmRlck1vZGFsQ29tcG9zaXRpb24sXG4gICAgcmVuZGVyTW9kYWxQcm9wc1xuICBdKTtcbiAgY29uc3QgcmVzb2x2ZWRDb25maWdzSW5jbHVkaW5nU3RhdGljT25lcyA9IHVzZU1lbW81KCgpID0+IHtcbiAgICBjb25zdCBzdGF0aWNDb21wcyA9IGNvbXBvc2l0aW9ucy5maWx0ZXIoKGMpID0+IHtcbiAgICAgIHJldHVybiBjLmNhbGN1bGF0ZU1ldGFkYXRhID09PSBudWxsO1xuICAgIH0pO1xuICAgIHJldHVybiB7XG4gICAgICAuLi5yZXNvbHZlZENvbmZpZ3MsXG4gICAgICAuLi5zdGF0aWNDb21wcy5yZWR1Y2UoKGFjYywgY3VycikgPT4ge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIC4uLmFjYyxcbiAgICAgICAgICBbY3Vyci5pZF06IHtcbiAgICAgICAgICAgIHR5cGU6IFwic3VjY2Vzc1wiLFxuICAgICAgICAgICAgcmVzdWx0OiB7IC4uLmN1cnIsIGRlZmF1bHRQcm9wczogY3Vyci5kZWZhdWx0UHJvcHMgPz8ge30gfVxuICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgIH0sIHt9KVxuICAgIH07XG4gIH0sIFtjb21wb3NpdGlvbnMsIHJlc29sdmVkQ29uZmlnc10pO1xuICByZXR1cm4gLyogQF9fUFVSRV9fICovIGpzeDYoUmVzb2x2ZUNvbXBvc2l0aW9uQ29udGV4dC5Qcm92aWRlciwge1xuICAgIHZhbHVlOiByZXNvbHZlZENvbmZpZ3NJbmNsdWRpbmdTdGF0aWNPbmVzLFxuICAgIGNoaWxkcmVuXG4gIH0pO1xufTtcbnZhciB1c2VSZXNvbHZlZFZpZGVvQ29uZmlnID0gKHByZWZlcnJlZENvbXBvc2l0aW9uSWQpID0+IHtcbiAgY29uc3QgY29udGV4dCA9IHVzZUNvbnRleHQ1KFJlc29sdmVDb21wb3NpdGlvbkNvbnRleHQpO1xuICBjb25zdCB7IHByb3BzOiBhbGxFZGl0b3JQcm9wcyB9ID0gdXNlQ29udGV4dDUoRWRpdG9yUHJvcHNDb250ZXh0KTtcbiAgY29uc3QgeyBjb21wb3NpdGlvbnMsIGNhbnZhc0NvbnRlbnQsIGN1cnJlbnRDb21wb3NpdGlvbk1ldGFkYXRhIH0gPSB1c2VDb250ZXh0NShDb21wb3NpdGlvbk1hbmFnZXIpO1xuICBjb25zdCBjdXJyZW50Q29tcG9zaXRpb24gPSBjYW52YXNDb250ZW50Py50eXBlID09PSBcImNvbXBvc2l0aW9uXCIgPyBjYW52YXNDb250ZW50LmNvbXBvc2l0aW9uSWQgOiBudWxsO1xuICBjb25zdCBjb21wb3NpdGlvbklkID0gcHJlZmVycmVkQ29tcG9zaXRpb25JZCA/PyBjdXJyZW50Q29tcG9zaXRpb247XG4gIGNvbnN0IGNvbXBvc2l0aW9uID0gY29tcG9zaXRpb25zLmZpbmQoKGMpID0+IGMuaWQgPT09IGNvbXBvc2l0aW9uSWQpO1xuICBjb25zdCBzZWxlY3RlZEVkaXRvclByb3BzID0gdXNlTWVtbzUoKCkgPT4ge1xuICAgIHJldHVybiBjb21wb3NpdGlvbiA/IGFsbEVkaXRvclByb3BzW2NvbXBvc2l0aW9uLmlkXSA/PyB7fSA6IHt9O1xuICB9LCBbYWxsRWRpdG9yUHJvcHMsIGNvbXBvc2l0aW9uXSk7XG4gIHJldHVybiB1c2VNZW1vNSgoKSA9PiB7XG4gICAgaWYgKCFjb21wb3NpdGlvbikge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGlmIChjdXJyZW50Q29tcG9zaXRpb25NZXRhZGF0YSkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdHlwZTogXCJzdWNjZXNzXCIsXG4gICAgICAgIHJlc3VsdDoge1xuICAgICAgICAgIC4uLmN1cnJlbnRDb21wb3NpdGlvbk1ldGFkYXRhLFxuICAgICAgICAgIGlkOiBjb21wb3NpdGlvbi5pZCxcbiAgICAgICAgICBwcm9wczogY3VycmVudENvbXBvc2l0aW9uTWV0YWRhdGEucHJvcHMsXG4gICAgICAgICAgZGVmYXVsdFByb3BzOiBjb21wb3NpdGlvbi5kZWZhdWx0UHJvcHMgPz8ge30sXG4gICAgICAgICAgZGVmYXVsdENvZGVjOiBjdXJyZW50Q29tcG9zaXRpb25NZXRhZGF0YS5kZWZhdWx0Q29kZWNcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9XG4gICAgaWYgKCFuZWVkc1Jlc29sdXRpb24oY29tcG9zaXRpb24pKSB7XG4gICAgICB2YWxpZGF0ZUR1cmF0aW9uSW5GcmFtZXMoY29tcG9zaXRpb24uZHVyYXRpb25JbkZyYW1lcywge1xuICAgICAgICBhbGxvd0Zsb2F0czogZmFsc2UsXG4gICAgICAgIGNvbXBvbmVudDogYGluIDxDb21wb3NpdGlvbiBpZD1cIiR7Y29tcG9zaXRpb24uaWR9XCI+YFxuICAgICAgfSk7XG4gICAgICB2YWxpZGF0ZUZwcyhjb21wb3NpdGlvbi5mcHMsIGBpbiA8Q29tcG9zaXRpb24gaWQ9XCIke2NvbXBvc2l0aW9uLmlkfVwiPmAsIGZhbHNlKTtcbiAgICAgIHZhbGlkYXRlRGltZW5zaW9uKGNvbXBvc2l0aW9uLndpZHRoLCBcIndpZHRoXCIsIGBpbiA8Q29tcG9zaXRpb24gaWQ9XCIke2NvbXBvc2l0aW9uLmlkfVwiPmApO1xuICAgICAgdmFsaWRhdGVEaW1lbnNpb24oY29tcG9zaXRpb24uaGVpZ2h0LCBcImhlaWdodFwiLCBgaW4gPENvbXBvc2l0aW9uIGlkPVwiJHtjb21wb3NpdGlvbi5pZH1cIj5gKTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHR5cGU6IFwic3VjY2Vzc1wiLFxuICAgICAgICByZXN1bHQ6IHtcbiAgICAgICAgICB3aWR0aDogY29tcG9zaXRpb24ud2lkdGgsXG4gICAgICAgICAgaGVpZ2h0OiBjb21wb3NpdGlvbi5oZWlnaHQsXG4gICAgICAgICAgZnBzOiBjb21wb3NpdGlvbi5mcHMsXG4gICAgICAgICAgaWQ6IGNvbXBvc2l0aW9uLmlkLFxuICAgICAgICAgIGR1cmF0aW9uSW5GcmFtZXM6IGNvbXBvc2l0aW9uLmR1cmF0aW9uSW5GcmFtZXMsXG4gICAgICAgICAgZGVmYXVsdFByb3BzOiBjb21wb3NpdGlvbi5kZWZhdWx0UHJvcHMgPz8ge30sXG4gICAgICAgICAgcHJvcHM6IHtcbiAgICAgICAgICAgIC4uLmNvbXBvc2l0aW9uLmRlZmF1bHRQcm9wcyA/PyB7fSxcbiAgICAgICAgICAgIC4uLnNlbGVjdGVkRWRpdG9yUHJvcHMgPz8ge30sXG4gICAgICAgICAgICAuLi50eXBlb2Ygd2luZG93ID09PSBcInVuZGVmaW5lZFwiIHx8IGdldFJlbW90aW9uRW52aXJvbm1lbnQoKS5pc1BsYXllciA/IHt9IDogZ2V0SW5wdXRQcm9wcygpID8/IHt9XG4gICAgICAgICAgfSxcbiAgICAgICAgICBkZWZhdWx0Q29kZWM6IG51bGxcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9XG4gICAgaWYgKCFjb250ZXh0W2NvbXBvc2l0aW9uLmlkXSkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHJldHVybiBjb250ZXh0W2NvbXBvc2l0aW9uLmlkXTtcbiAgfSwgW2NvbXBvc2l0aW9uLCBjb250ZXh0LCBjdXJyZW50Q29tcG9zaXRpb25NZXRhZGF0YSwgc2VsZWN0ZWRFZGl0b3JQcm9wc10pO1xufTtcblxuLy8gc3JjL3VzZS12aWRlby50c1xudmFyIHVzZVZpZGVvID0gKCkgPT4ge1xuICBjb25zdCB7IGNhbnZhc0NvbnRlbnQsIGNvbXBvc2l0aW9ucywgY3VycmVudENvbXBvc2l0aW9uTWV0YWRhdGEgfSA9IHVzZUNvbnRleHQ2KENvbXBvc2l0aW9uTWFuYWdlcik7XG4gIGNvbnN0IHNlbGVjdGVkID0gY29tcG9zaXRpb25zLmZpbmQoKGMpID0+IHtcbiAgICByZXR1cm4gY2FudmFzQ29udGVudD8udHlwZSA9PT0gXCJjb21wb3NpdGlvblwiICYmIGMuaWQgPT09IGNhbnZhc0NvbnRlbnQuY29tcG9zaXRpb25JZDtcbiAgfSk7XG4gIGNvbnN0IHJlc29sdmVkID0gdXNlUmVzb2x2ZWRWaWRlb0NvbmZpZyhzZWxlY3RlZD8uaWQgPz8gbnVsbCk7XG4gIHJldHVybiB1c2VNZW1vNigoKSA9PiB7XG4gICAgaWYgKCFyZXNvbHZlZCkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGlmIChyZXNvbHZlZC50eXBlID09PSBcImVycm9yXCIpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBpZiAocmVzb2x2ZWQudHlwZSA9PT0gXCJsb2FkaW5nXCIpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBpZiAoIXNlbGVjdGVkKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgIC4uLnJlc29sdmVkLnJlc3VsdCxcbiAgICAgIGRlZmF1bHRQcm9wczogc2VsZWN0ZWQuZGVmYXVsdFByb3BzID8/IHt9LFxuICAgICAgaWQ6IHNlbGVjdGVkLmlkLFxuICAgICAgLi4uY3VycmVudENvbXBvc2l0aW9uTWV0YWRhdGEgPz8ge30sXG4gICAgICBjb21wb25lbnQ6IHNlbGVjdGVkLmNvbXBvbmVudFxuICAgIH07XG4gIH0sIFtjdXJyZW50Q29tcG9zaXRpb25NZXRhZGF0YSwgcmVzb2x2ZWQsIHNlbGVjdGVkXSk7XG59O1xuXG4vLyBzcmMvdGltZWxpbmUtcG9zaXRpb24tc3RhdGUudHNcbnZhciBUaW1lbGluZUNvbnRleHQgPSBjcmVhdGVDb250ZXh0OSh7XG4gIGZyYW1lOiB7fSxcbiAgcGxheWluZzogZmFsc2UsXG4gIHBsYXliYWNrUmF0ZTogMSxcbiAgcm9vdElkOiBcIlwiLFxuICBpbXBlcmF0aXZlUGxheWluZzoge1xuICAgIGN1cnJlbnQ6IGZhbHNlXG4gIH0sXG4gIHNldFBsYXliYWNrUmF0ZTogKCkgPT4ge1xuICAgIHRocm93IG5ldyBFcnJvcihcImRlZmF1bHRcIik7XG4gIH0sXG4gIGF1ZGlvQW5kVmlkZW9UYWdzOiB7IGN1cnJlbnQ6IFtdIH1cbn0pO1xudmFyIFNldFRpbWVsaW5lQ29udGV4dCA9IGNyZWF0ZUNvbnRleHQ5KHtcbiAgc2V0RnJhbWU6ICgpID0+IHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJkZWZhdWx0XCIpO1xuICB9LFxuICBzZXRQbGF5aW5nOiAoKSA9PiB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiZGVmYXVsdFwiKTtcbiAgfVxufSk7XG52YXIgbWFrZUtleSA9ICgpID0+IHtcbiAgcmV0dXJuIGByZW1vdGlvbi50aW1lLWFsbGA7XG59O1xudmFyIHBlcnNpc3RDdXJyZW50RnJhbWUgPSAodGltZSkgPT4ge1xuICBsb2NhbFN0b3JhZ2Uuc2V0SXRlbShtYWtlS2V5KCksIEpTT04uc3RyaW5naWZ5KHRpbWUpKTtcbn07XG52YXIgZ2V0SW5pdGlhbEZyYW1lU3RhdGUgPSAoKSA9PiB7XG4gIGNvbnN0IGl0ZW0gPSBsb2NhbFN0b3JhZ2UuZ2V0SXRlbShtYWtlS2V5KCkpID8/IFwie31cIjtcbiAgY29uc3Qgb2JqID0gSlNPTi5wYXJzZShpdGVtKTtcbiAgcmV0dXJuIG9iajtcbn07XG52YXIgZ2V0RnJhbWVGb3JDb21wb3NpdGlvbiA9IChjb21wb3NpdGlvbikgPT4ge1xuICBjb25zdCBpdGVtID0gbG9jYWxTdG9yYWdlLmdldEl0ZW0obWFrZUtleSgpKSA/PyBcInt9XCI7XG4gIGNvbnN0IG9iaiA9IEpTT04ucGFyc2UoaXRlbSk7XG4gIGlmIChvYmpbY29tcG9zaXRpb25dICE9PSB1bmRlZmluZWQpIHtcbiAgICByZXR1cm4gTnVtYmVyKG9ialtjb21wb3NpdGlvbl0pO1xuICB9XG4gIGlmICh0eXBlb2Ygd2luZG93ID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgcmV0dXJuIDA7XG4gIH1cbiAgcmV0dXJuIHdpbmRvdy5yZW1vdGlvbl9pbml0aWFsRnJhbWUgPz8gMDtcbn07XG52YXIgdXNlVGltZWxpbmVQb3NpdGlvbiA9ICgpID0+IHtcbiAgY29uc3QgdmlkZW9Db25maWcgPSB1c2VWaWRlbygpO1xuICBjb25zdCBzdGF0ZSA9IHVzZUNvbnRleHQ3KFRpbWVsaW5lQ29udGV4dCk7XG4gIGlmICghdmlkZW9Db25maWcpIHtcbiAgICByZXR1cm4gdHlwZW9mIHdpbmRvdyA9PT0gXCJ1bmRlZmluZWRcIiA/IDAgOiB3aW5kb3cucmVtb3Rpb25faW5pdGlhbEZyYW1lID8/IDA7XG4gIH1cbiAgY29uc3QgdW5jbGFtcGVkID0gc3RhdGUuZnJhbWVbdmlkZW9Db25maWcuaWRdID8/IChnZXRSZW1vdGlvbkVudmlyb25tZW50KCkuaXNQbGF5ZXIgPyAwIDogZ2V0RnJhbWVGb3JDb21wb3NpdGlvbih2aWRlb0NvbmZpZy5pZCkpO1xuICByZXR1cm4gTWF0aC5taW4odmlkZW9Db25maWcuZHVyYXRpb25JbkZyYW1lcyAtIDEsIHVuY2xhbXBlZCk7XG59O1xudmFyIHVzZVRpbWVsaW5lU2V0RnJhbWUgPSAoKSA9PiB7XG4gIGNvbnN0IHsgc2V0RnJhbWUgfSA9IHVzZUNvbnRleHQ3KFNldFRpbWVsaW5lQ29udGV4dCk7XG4gIHJldHVybiBzZXRGcmFtZTtcbn07XG52YXIgdXNlUGxheWluZ1N0YXRlID0gKCkgPT4ge1xuICBjb25zdCB7IHBsYXlpbmcsIGltcGVyYXRpdmVQbGF5aW5nIH0gPSB1c2VDb250ZXh0NyhUaW1lbGluZUNvbnRleHQpO1xuICBjb25zdCB7IHNldFBsYXlpbmcgfSA9IHVzZUNvbnRleHQ3KFNldFRpbWVsaW5lQ29udGV4dCk7XG4gIHJldHVybiB1c2VNZW1vNygoKSA9PiBbcGxheWluZywgc2V0UGxheWluZywgaW1wZXJhdGl2ZVBsYXlpbmddLCBbaW1wZXJhdGl2ZVBsYXlpbmcsIHBsYXlpbmcsIHNldFBsYXlpbmddKTtcbn07XG5cbi8vIHNyYy91c2UtdmlkZW8tY29uZmlnLnRzXG5pbXBvcnQgeyB1c2VDb250ZXh0IGFzIHVzZUNvbnRleHQ5IH0gZnJvbSBcInJlYWN0XCI7XG5cbi8vIHNyYy9DYW5Vc2VSZW1vdGlvbkhvb2tzLnRzeFxuaW1wb3J0IHsgY3JlYXRlQ29udGV4dCBhcyBjcmVhdGVDb250ZXh0MTAgfSBmcm9tIFwicmVhY3RcIjtcbmltcG9ydCB7IGpzeCBhcyBqc3g3IH0gZnJvbSBcInJlYWN0L2pzeC1ydW50aW1lXCI7XG52YXIgQ2FuVXNlUmVtb3Rpb25Ib29rcyA9IGNyZWF0ZUNvbnRleHQxMChmYWxzZSk7XG52YXIgQ2FuVXNlUmVtb3Rpb25Ib29rc1Byb3ZpZGVyID0gKHsgY2hpbGRyZW4gfSkgPT4ge1xuICByZXR1cm4gLyogQF9fUFVSRV9fICovIGpzeDcoQ2FuVXNlUmVtb3Rpb25Ib29rcy5Qcm92aWRlciwge1xuICAgIHZhbHVlOiB0cnVlLFxuICAgIGNoaWxkcmVuXG4gIH0pO1xufTtcblxuLy8gc3JjL3VzZS11bnNhZmUtdmlkZW8tY29uZmlnLnRzXG5pbXBvcnQgeyB1c2VDb250ZXh0IGFzIHVzZUNvbnRleHQ4LCB1c2VNZW1vIGFzIHVzZU1lbW84IH0gZnJvbSBcInJlYWN0XCI7XG52YXIgdXNlVW5zYWZlVmlkZW9Db25maWcgPSAoKSA9PiB7XG4gIGNvbnN0IGNvbnRleHQgPSB1c2VDb250ZXh0OChTZXF1ZW5jZUNvbnRleHQpO1xuICBjb25zdCBjdHhXaWR0aCA9IGNvbnRleHQ/LndpZHRoID8/IG51bGw7XG4gIGNvbnN0IGN0eEhlaWdodCA9IGNvbnRleHQ/LmhlaWdodCA/PyBudWxsO1xuICBjb25zdCBjdHhEdXJhdGlvbiA9IGNvbnRleHQ/LmR1cmF0aW9uSW5GcmFtZXMgPz8gbnVsbDtcbiAgY29uc3QgdmlkZW8gPSB1c2VWaWRlbygpO1xuICByZXR1cm4gdXNlTWVtbzgoKCkgPT4ge1xuICAgIGlmICghdmlkZW8pIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBjb25zdCB7XG4gICAgICBpZCxcbiAgICAgIGR1cmF0aW9uSW5GcmFtZXMsXG4gICAgICBmcHMsXG4gICAgICBoZWlnaHQsXG4gICAgICB3aWR0aCxcbiAgICAgIGRlZmF1bHRQcm9wcyxcbiAgICAgIHByb3BzLFxuICAgICAgZGVmYXVsdENvZGVjXG4gICAgfSA9IHZpZGVvO1xuICAgIHJldHVybiB7XG4gICAgICBpZCxcbiAgICAgIHdpZHRoOiBjdHhXaWR0aCA/PyB3aWR0aCxcbiAgICAgIGhlaWdodDogY3R4SGVpZ2h0ID8/IGhlaWdodCxcbiAgICAgIGZwcyxcbiAgICAgIGR1cmF0aW9uSW5GcmFtZXM6IGN0eER1cmF0aW9uID8/IGR1cmF0aW9uSW5GcmFtZXMsXG4gICAgICBkZWZhdWx0UHJvcHMsXG4gICAgICBwcm9wcyxcbiAgICAgIGRlZmF1bHRDb2RlY1xuICAgIH07XG4gIH0sIFtjdHhEdXJhdGlvbiwgY3R4SGVpZ2h0LCBjdHhXaWR0aCwgdmlkZW9dKTtcbn07XG5cbi8vIHNyYy91c2UtdmlkZW8tY29uZmlnLnRzXG52YXIgdXNlVmlkZW9Db25maWcgPSAoKSA9PiB7XG4gIGNvbnN0IHZpZGVvQ29uZmlnID0gdXNlVW5zYWZlVmlkZW9Db25maWcoKTtcbiAgY29uc3QgY29udGV4dCA9IHVzZUNvbnRleHQ5KENhblVzZVJlbW90aW9uSG9va3MpO1xuICBjb25zdCBpc1BsYXllciA9IHVzZUlzUGxheWVyKCk7XG4gIGlmICghdmlkZW9Db25maWcpIHtcbiAgICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiAmJiB3aW5kb3cucmVtb3Rpb25faXNQbGF5ZXIgfHwgaXNQbGF5ZXIpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihbXG4gICAgICAgIFwiTm8gdmlkZW8gY29uZmlnIGZvdW5kLiBMaWtlbHkgcmVhc29uczpcIixcbiAgICAgICAgXCItIFlvdSBhcmUgcHJvYmFibHkgY2FsbGluZyB1c2VWaWRlb0NvbmZpZygpIGZyb20gb3V0c2lkZSB0aGUgY29tcG9uZW50IHBhc3NlZCB0byA8UGxheWVyIC8+LiBTZWUgaHR0cHM6Ly93d3cucmVtb3Rpb24uZGV2L2RvY3MvcGxheWVyL2V4YW1wbGVzIGZvciBob3cgdG8gc2V0IHVwIHRoZSBQbGF5ZXIgY29ycmVjdGx5LlwiLFxuICAgICAgICBcIi0gWW91IGhhdmUgbXVsdGlwbGUgdmVyc2lvbnMgb2YgUmVtb3Rpb24gaW5zdGFsbGVkIHdoaWNoIGNhdXNlcyB0aGUgUmVhY3QgY29udGV4dCB0byBnZXQgbG9zdC5cIlxuICAgICAgXS5qb2luKFwiLVwiKSk7XG4gICAgfVxuICAgIHRocm93IG5ldyBFcnJvcihcIk5vIHZpZGVvIGNvbmZpZyBmb3VuZC4gWW91IGFyZSBwcm9iYWJseSBjYWxsaW5nIHVzZVZpZGVvQ29uZmlnKCkgZnJvbSBhIGNvbXBvbmVudCB3aGljaCBoYXMgbm90IGJlZW4gcmVnaXN0ZXJlZCBhcyBhIDxDb21wb3NpdGlvbiAvPi4gU2VlIGh0dHBzOi8vd3d3LnJlbW90aW9uLmRldi9kb2NzL3RoZS1mdW5kYW1lbnRhbHMjZGVmaW5pbmctY29tcG9zaXRpb25zIGZvciBtb3JlIGluZm9ybWF0aW9uLlwiKTtcbiAgfVxuICBpZiAoIWNvbnRleHQpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYWxsZWQgdXNlVmlkZW9Db25maWcoKSBvdXRzaWRlIGEgUmVtb3Rpb24gY29tcG9zaXRpb24uXCIpO1xuICB9XG4gIHJldHVybiB2aWRlb0NvbmZpZztcbn07XG5cbi8vIHNyYy9mcmVlemUudHN4XG5pbXBvcnQgeyB1c2VDb250ZXh0IGFzIHVzZUNvbnRleHQxMSwgdXNlTWVtbyBhcyB1c2VNZW1vOSB9IGZyb20gXCJyZWFjdFwiO1xuXG4vLyBzcmMvdXNlLWN1cnJlbnQtZnJhbWUudHNcbmltcG9ydCB7IHVzZUNvbnRleHQgYXMgdXNlQ29udGV4dDEwIH0gZnJvbSBcInJlYWN0XCI7XG52YXIgdXNlQ3VycmVudEZyYW1lID0gKCkgPT4ge1xuICBjb25zdCBjYW5Vc2VSZW1vdGlvbkhvb2tzID0gdXNlQ29udGV4dDEwKENhblVzZVJlbW90aW9uSG9va3MpO1xuICBpZiAoIWNhblVzZVJlbW90aW9uSG9va3MpIHtcbiAgICBpZiAoZ2V0UmVtb3Rpb25FbnZpcm9ubWVudCgpLmlzUGxheWVyKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYHVzZUN1cnJlbnRGcmFtZSBjYW4gb25seSBiZSBjYWxsZWQgaW5zaWRlIGEgY29tcG9uZW50IHRoYXQgd2FzIHBhc3NlZCB0byA8UGxheWVyPi4gU2VlOiBodHRwczovL3d3dy5yZW1vdGlvbi5kZXYvZG9jcy9wbGF5ZXIvZXhhbXBsZXNgKTtcbiAgICB9XG4gICAgdGhyb3cgbmV3IEVycm9yKGB1c2VDdXJyZW50RnJhbWUoKSBjYW4gb25seSBiZSBjYWxsZWQgaW5zaWRlIGEgY29tcG9uZW50IHRoYXQgd2FzIHJlZ2lzdGVyZWQgYXMgYSBjb21wb3NpdGlvbi4gU2VlIGh0dHBzOi8vd3d3LnJlbW90aW9uLmRldi9kb2NzL3RoZS1mdW5kYW1lbnRhbHMjZGVmaW5pbmctY29tcG9zaXRpb25zYCk7XG4gIH1cbiAgY29uc3QgZnJhbWUgPSB1c2VUaW1lbGluZVBvc2l0aW9uKCk7XG4gIGNvbnN0IGNvbnRleHQgPSB1c2VDb250ZXh0MTAoU2VxdWVuY2VDb250ZXh0KTtcbiAgY29uc3QgY29udGV4dE9mZnNldCA9IGNvbnRleHQgPyBjb250ZXh0LmN1bXVsYXRlZEZyb20gKyBjb250ZXh0LnJlbGF0aXZlRnJvbSA6IDA7XG4gIHJldHVybiBmcmFtZSAtIGNvbnRleHRPZmZzZXQ7XG59O1xuXG4vLyBzcmMvZnJlZXplLnRzeFxuaW1wb3J0IHsganN4IGFzIGpzeDggfSBmcm9tIFwicmVhY3QvanN4LXJ1bnRpbWVcIjtcbnZhciBGcmVlemUgPSAoe1xuICBmcmFtZTogZnJhbWVUb0ZyZWV6ZSxcbiAgY2hpbGRyZW4sXG4gIGFjdGl2ZSA9IHRydWVcbn0pID0+IHtcbiAgY29uc3QgZnJhbWUgPSB1c2VDdXJyZW50RnJhbWUoKTtcbiAgY29uc3QgdmlkZW9Db25maWcgPSB1c2VWaWRlb0NvbmZpZygpO1xuICBpZiAodHlwZW9mIGZyYW1lVG9GcmVlemUgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYFRoZSA8RnJlZXplIC8+IGNvbXBvbmVudCByZXF1aXJlcyBhICdmcmFtZScgcHJvcCwgYnV0IG5vbmUgd2FzIHBhc3NlZC5gKTtcbiAgfVxuICBpZiAodHlwZW9mIGZyYW1lVG9GcmVlemUgIT09IFwibnVtYmVyXCIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYFRoZSAnZnJhbWUnIHByb3Agb2YgPEZyZWV6ZSAvPiBtdXN0IGJlIGEgbnVtYmVyLCBidXQgaXMgb2YgdHlwZSAke3R5cGVvZiBmcmFtZVRvRnJlZXplfWApO1xuICB9XG4gIGlmIChOdW1iZXIuaXNOYU4oZnJhbWVUb0ZyZWV6ZSkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYFRoZSAnZnJhbWUnIHByb3Agb2YgPEZyZWV6ZSAvPiBtdXN0IGJlIGEgcmVhbCBudW1iZXIsIGJ1dCBpdCBpcyBOYU4uYCk7XG4gIH1cbiAgaWYgKCFOdW1iZXIuaXNGaW5pdGUoZnJhbWVUb0ZyZWV6ZSkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYFRoZSAnZnJhbWUnIHByb3Agb2YgPEZyZWV6ZSAvPiBtdXN0IGJlIGEgZmluaXRlIG51bWJlciwgYnV0IGl0IGlzICR7ZnJhbWVUb0ZyZWV6ZX0uYCk7XG4gIH1cbiAgY29uc3QgaXNBY3RpdmUgPSB1c2VNZW1vOSgoKSA9PiB7XG4gICAgaWYgKHR5cGVvZiBhY3RpdmUgPT09IFwiYm9vbGVhblwiKSB7XG4gICAgICByZXR1cm4gYWN0aXZlO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIGFjdGl2ZSA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICByZXR1cm4gYWN0aXZlKGZyYW1lKTtcbiAgICB9XG4gIH0sIFthY3RpdmUsIGZyYW1lXSk7XG4gIGNvbnN0IHRpbWVsaW5lQ29udGV4dCA9IHVzZUNvbnRleHQxMShUaW1lbGluZUNvbnRleHQpO1xuICBjb25zdCBzZXF1ZW5jZUNvbnRleHQgPSB1c2VDb250ZXh0MTEoU2VxdWVuY2VDb250ZXh0KTtcbiAgY29uc3QgcmVsYXRpdmVGcm9tID0gc2VxdWVuY2VDb250ZXh0Py5yZWxhdGl2ZUZyb20gPz8gMDtcbiAgY29uc3QgdGltZWxpbmVWYWx1ZSA9IHVzZU1lbW85KCgpID0+IHtcbiAgICBpZiAoIWlzQWN0aXZlKSB7XG4gICAgICByZXR1cm4gdGltZWxpbmVDb250ZXh0O1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgLi4udGltZWxpbmVDb250ZXh0LFxuICAgICAgcGxheWluZzogZmFsc2UsXG4gICAgICBpbXBlcmF0aXZlUGxheWluZzoge1xuICAgICAgICBjdXJyZW50OiBmYWxzZVxuICAgICAgfSxcbiAgICAgIGZyYW1lOiB7XG4gICAgICAgIFt2aWRlb0NvbmZpZy5pZF06IGZyYW1lVG9GcmVlemUgKyByZWxhdGl2ZUZyb21cbiAgICAgIH1cbiAgICB9O1xuICB9LCBbaXNBY3RpdmUsIHRpbWVsaW5lQ29udGV4dCwgdmlkZW9Db25maWcuaWQsIGZyYW1lVG9GcmVlemUsIHJlbGF0aXZlRnJvbV0pO1xuICByZXR1cm4gLyogQF9fUFVSRV9fICovIGpzeDgoVGltZWxpbmVDb250ZXh0LlByb3ZpZGVyLCB7XG4gICAgdmFsdWU6IHRpbWVsaW5lVmFsdWUsXG4gICAgY2hpbGRyZW5cbiAgfSk7XG59O1xuXG4vLyBzcmMvU2VxdWVuY2UudHN4XG5pbXBvcnQgeyBqc3ggYXMganN4OSB9IGZyb20gXCJyZWFjdC9qc3gtcnVudGltZVwiO1xudmFyIFJlZ3VsYXJTZXF1ZW5jZVJlZkZvcndhcmRpbmdGdW5jdGlvbiA9ICh7XG4gIGZyb20gPSAwLFxuICBkdXJhdGlvbkluRnJhbWVzID0gSW5maW5pdHksXG4gIGNoaWxkcmVuLFxuICBuYW1lLFxuICBoZWlnaHQsXG4gIHdpZHRoLFxuICBzaG93SW5UaW1lbGluZSA9IHRydWUsXG4gIF9yZW1vdGlvbkludGVybmFsTG9vcERpc3BsYXk6IGxvb3BEaXNwbGF5LFxuICBfcmVtb3Rpb25JbnRlcm5hbFN0YWNrOiBzdGFjayxcbiAgX3JlbW90aW9uSW50ZXJuYWxQcmVtb3VudERpc3BsYXk6IHByZW1vdW50RGlzcGxheSxcbiAgLi4ub3RoZXJcbn0sIHJlZikgPT4ge1xuICBjb25zdCB7IGxheW91dCA9IFwiYWJzb2x1dGUtZmlsbFwiIH0gPSBvdGhlcjtcbiAgY29uc3QgW2lkXSA9IHVzZVN0YXRlNSgoKSA9PiBTdHJpbmcoTWF0aC5yYW5kb20oKSkpO1xuICBjb25zdCBwYXJlbnRTZXF1ZW5jZSA9IHVzZUNvbnRleHQxMihTZXF1ZW5jZUNvbnRleHQpO1xuICBjb25zdCB7IHJvb3RJZCB9ID0gdXNlQ29udGV4dDEyKFRpbWVsaW5lQ29udGV4dCk7XG4gIGNvbnN0IGN1bXVsYXRlZEZyb20gPSBwYXJlbnRTZXF1ZW5jZSA/IHBhcmVudFNlcXVlbmNlLmN1bXVsYXRlZEZyb20gKyBwYXJlbnRTZXF1ZW5jZS5yZWxhdGl2ZUZyb20gOiAwO1xuICBjb25zdCBub25jZSA9IHVzZU5vbmNlKCk7XG4gIGlmIChsYXlvdXQgIT09IFwiYWJzb2x1dGUtZmlsbFwiICYmIGxheW91dCAhPT0gXCJub25lXCIpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBUaGUgbGF5b3V0IHByb3Agb2YgPFNlcXVlbmNlIC8+IGV4cGVjdHMgZWl0aGVyIFwiYWJzb2x1dGUtZmlsbFwiIG9yIFwibm9uZVwiLCBidXQgeW91IHBhc3NlZDogJHtsYXlvdXR9YCk7XG4gIH1cbiAgaWYgKGxheW91dCA9PT0gXCJub25lXCIgJiYgdHlwZW9mIG90aGVyLnN0eWxlICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignSWYgbGF5b3V0PVwibm9uZVwiLCB5b3UgbWF5IG5vdCBwYXNzIGEgc3R5bGUuJyk7XG4gIH1cbiAgaWYgKHR5cGVvZiBkdXJhdGlvbkluRnJhbWVzICE9PSBcIm51bWJlclwiKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgWW91IHBhc3NlZCB0byBkdXJhdGlvbkluRnJhbWVzIGFuIGFyZ3VtZW50IG9mIHR5cGUgJHt0eXBlb2YgZHVyYXRpb25JbkZyYW1lc30sIGJ1dCBpdCBtdXN0IGJlIGEgbnVtYmVyLmApO1xuICB9XG4gIGlmIChkdXJhdGlvbkluRnJhbWVzIDw9IDApIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBkdXJhdGlvbkluRnJhbWVzIG11c3QgYmUgcG9zaXRpdmUsIGJ1dCBnb3QgJHtkdXJhdGlvbkluRnJhbWVzfWApO1xuICB9XG4gIGlmICh0eXBlb2YgZnJvbSAhPT0gXCJudW1iZXJcIikge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYFlvdSBwYXNzZWQgdG8gdGhlIFwiZnJvbVwiIHByb3BzIG9mIHlvdXIgPFNlcXVlbmNlPiBhbiBhcmd1bWVudCBvZiB0eXBlICR7dHlwZW9mIGZyb219LCBidXQgaXQgbXVzdCBiZSBhIG51bWJlci5gKTtcbiAgfVxuICBpZiAoIU51bWJlci5pc0Zpbml0ZShmcm9tKSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYFRoZSBcImZyb21cIiBwcm9wIG9mIGEgc2VxdWVuY2UgbXVzdCBiZSBmaW5pdGUsIGJ1dCBnb3QgJHtmcm9tfS5gKTtcbiAgfVxuICBjb25zdCBhYnNvbHV0ZUZyYW1lID0gdXNlVGltZWxpbmVQb3NpdGlvbigpO1xuICBjb25zdCB2aWRlb0NvbmZpZyA9IHVzZVZpZGVvQ29uZmlnKCk7XG4gIGNvbnN0IHBhcmVudFNlcXVlbmNlRHVyYXRpb24gPSBwYXJlbnRTZXF1ZW5jZSA/IE1hdGgubWluKHBhcmVudFNlcXVlbmNlLmR1cmF0aW9uSW5GcmFtZXMgLSBmcm9tLCBkdXJhdGlvbkluRnJhbWVzKSA6IGR1cmF0aW9uSW5GcmFtZXM7XG4gIGNvbnN0IGFjdHVhbER1cmF0aW9uSW5GcmFtZXMgPSBNYXRoLm1heCgwLCBNYXRoLm1pbih2aWRlb0NvbmZpZy5kdXJhdGlvbkluRnJhbWVzIC0gZnJvbSwgcGFyZW50U2VxdWVuY2VEdXJhdGlvbikpO1xuICBjb25zdCB7IHJlZ2lzdGVyU2VxdWVuY2UsIHVucmVnaXN0ZXJTZXF1ZW5jZSB9ID0gdXNlQ29udGV4dDEyKFNlcXVlbmNlTWFuYWdlcik7XG4gIGNvbnN0IHsgaGlkZGVuIH0gPSB1c2VDb250ZXh0MTIoU2VxdWVuY2VWaXNpYmlsaXR5VG9nZ2xlQ29udGV4dCk7XG4gIGNvbnN0IHByZW1vdW50aW5nID0gdXNlTWVtbzEwKCgpID0+IHtcbiAgICByZXR1cm4gcGFyZW50U2VxdWVuY2U/LnByZW1vdW50aW5nID8/IEJvb2xlYW4ob3RoZXIuX3JlbW90aW9uSW50ZXJuYWxJc1ByZW1vdW50aW5nKTtcbiAgfSwgW290aGVyLl9yZW1vdGlvbkludGVybmFsSXNQcmVtb3VudGluZywgcGFyZW50U2VxdWVuY2U/LnByZW1vdW50aW5nXSk7XG4gIGNvbnN0IGNvbnRleHRWYWx1ZSA9IHVzZU1lbW8xMCgoKSA9PiB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGN1bXVsYXRlZEZyb20sXG4gICAgICByZWxhdGl2ZUZyb206IGZyb20sXG4gICAgICBkdXJhdGlvbkluRnJhbWVzOiBhY3R1YWxEdXJhdGlvbkluRnJhbWVzLFxuICAgICAgcGFyZW50RnJvbTogcGFyZW50U2VxdWVuY2U/LnJlbGF0aXZlRnJvbSA/PyAwLFxuICAgICAgaWQsXG4gICAgICBoZWlnaHQ6IGhlaWdodCA/PyBwYXJlbnRTZXF1ZW5jZT8uaGVpZ2h0ID8/IG51bGwsXG4gICAgICB3aWR0aDogd2lkdGggPz8gcGFyZW50U2VxdWVuY2U/LndpZHRoID8/IG51bGwsXG4gICAgICBwcmVtb3VudGluZ1xuICAgIH07XG4gIH0sIFtcbiAgICBjdW11bGF0ZWRGcm9tLFxuICAgIGZyb20sXG4gICAgYWN0dWFsRHVyYXRpb25JbkZyYW1lcyxcbiAgICBwYXJlbnRTZXF1ZW5jZSxcbiAgICBpZCxcbiAgICBoZWlnaHQsXG4gICAgd2lkdGgsXG4gICAgcHJlbW91bnRpbmdcbiAgXSk7XG4gIGNvbnN0IHRpbWVsaW5lQ2xpcE5hbWUgPSB1c2VNZW1vMTAoKCkgPT4ge1xuICAgIHJldHVybiBuYW1lID8/IFwiXCI7XG4gIH0sIFtuYW1lXSk7XG4gIHVzZUVmZmVjdDUoKCkgPT4ge1xuICAgIGlmICghZ2V0UmVtb3Rpb25FbnZpcm9ubWVudCgpLmlzU3R1ZGlvKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHJlZ2lzdGVyU2VxdWVuY2Uoe1xuICAgICAgZnJvbSxcbiAgICAgIGR1cmF0aW9uOiBhY3R1YWxEdXJhdGlvbkluRnJhbWVzLFxuICAgICAgaWQsXG4gICAgICBkaXNwbGF5TmFtZTogdGltZWxpbmVDbGlwTmFtZSxcbiAgICAgIHBhcmVudDogcGFyZW50U2VxdWVuY2U/LmlkID8/IG51bGwsXG4gICAgICB0eXBlOiBcInNlcXVlbmNlXCIsXG4gICAgICByb290SWQsXG4gICAgICBzaG93SW5UaW1lbGluZSxcbiAgICAgIG5vbmNlLFxuICAgICAgbG9vcERpc3BsYXksXG4gICAgICBzdGFjazogc3RhY2sgPz8gbnVsbCxcbiAgICAgIHByZW1vdW50RGlzcGxheTogcHJlbW91bnREaXNwbGF5ID8/IG51bGxcbiAgICB9KTtcbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgdW5yZWdpc3RlclNlcXVlbmNlKGlkKTtcbiAgICB9O1xuICB9LCBbXG4gICAgZHVyYXRpb25JbkZyYW1lcyxcbiAgICBpZCxcbiAgICBuYW1lLFxuICAgIHJlZ2lzdGVyU2VxdWVuY2UsXG4gICAgdGltZWxpbmVDbGlwTmFtZSxcbiAgICB1bnJlZ2lzdGVyU2VxdWVuY2UsXG4gICAgcGFyZW50U2VxdWVuY2U/LmlkLFxuICAgIGFjdHVhbER1cmF0aW9uSW5GcmFtZXMsXG4gICAgcm9vdElkLFxuICAgIGZyb20sXG4gICAgc2hvd0luVGltZWxpbmUsXG4gICAgbm9uY2UsXG4gICAgbG9vcERpc3BsYXksXG4gICAgc3RhY2ssXG4gICAgcHJlbW91bnREaXNwbGF5XG4gIF0pO1xuICBjb25zdCBlbmRUaHJlc2hvbGQgPSBNYXRoLmNlaWwoY3VtdWxhdGVkRnJvbSArIGZyb20gKyBkdXJhdGlvbkluRnJhbWVzIC0gMSk7XG4gIGNvbnN0IGNvbnRlbnQgPSBhYnNvbHV0ZUZyYW1lIDwgY3VtdWxhdGVkRnJvbSArIGZyb20gPyBudWxsIDogYWJzb2x1dGVGcmFtZSA+IGVuZFRocmVzaG9sZCA/IG51bGwgOiBjaGlsZHJlbjtcbiAgY29uc3Qgc3R5bGVJZlRoZXJlID0gb3RoZXIubGF5b3V0ID09PSBcIm5vbmVcIiA/IHVuZGVmaW5lZCA6IG90aGVyLnN0eWxlO1xuICBjb25zdCBkZWZhdWx0U3R5bGUgPSB1c2VNZW1vMTAoKCkgPT4ge1xuICAgIHJldHVybiB7XG4gICAgICBmbGV4RGlyZWN0aW9uOiB1bmRlZmluZWQsXG4gICAgICAuLi53aWR0aCA/IHsgd2lkdGggfSA6IHt9LFxuICAgICAgLi4uaGVpZ2h0ID8geyBoZWlnaHQgfSA6IHt9LFxuICAgICAgLi4uc3R5bGVJZlRoZXJlID8/IHt9XG4gICAgfTtcbiAgfSwgW2hlaWdodCwgc3R5bGVJZlRoZXJlLCB3aWR0aF0pO1xuICBpZiAocmVmICE9PSBudWxsICYmIGxheW91dCA9PT0gXCJub25lXCIpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdJdCBpcyBub3Qgc3VwcG9ydGVkIHRvIHBhc3MgYm90aCBhIGByZWZgIGFuZCBgbGF5b3V0PVwibm9uZVwiYCB0byA8U2VxdWVuY2UgLz4uJyk7XG4gIH1cbiAgY29uc3QgaXNTZXF1ZW5jZUhpZGRlbiA9IGhpZGRlbltpZF0gPz8gZmFsc2U7XG4gIGlmIChpc1NlcXVlbmNlSGlkZGVuKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqLyBqc3g5KFNlcXVlbmNlQ29udGV4dC5Qcm92aWRlciwge1xuICAgIHZhbHVlOiBjb250ZXh0VmFsdWUsXG4gICAgY2hpbGRyZW46IGNvbnRlbnQgPT09IG51bGwgPyBudWxsIDogb3RoZXIubGF5b3V0ID09PSBcIm5vbmVcIiA/IGNvbnRlbnQgOiAvKiBAX19QVVJFX18gKi8ganN4OShBYnNvbHV0ZUZpbGwsIHtcbiAgICAgIHJlZixcbiAgICAgIHN0eWxlOiBkZWZhdWx0U3R5bGUsXG4gICAgICBjbGFzc05hbWU6IG90aGVyLmNsYXNzTmFtZSxcbiAgICAgIGNoaWxkcmVuOiBjb250ZW50XG4gICAgfSlcbiAgfSk7XG59O1xudmFyIFJlZ3VsYXJTZXF1ZW5jZSA9IGZvcndhcmRSZWYyKFJlZ3VsYXJTZXF1ZW5jZVJlZkZvcndhcmRpbmdGdW5jdGlvbik7XG52YXIgUHJlbW91bnRlZFNlcXVlbmNlUmVmRm9yd2FyZGluZ0Z1bmN0aW9uID0gKHByb3BzLCByZWYpID0+IHtcbiAgY29uc3QgZnJhbWUgPSB1c2VDdXJyZW50RnJhbWUoKTtcbiAgaWYgKHByb3BzLmxheW91dCA9PT0gXCJub25lXCIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2A8U2VxdWVuY2U+YCB3aXRoIGBwcmVtb3VudEZvcmAgcHJvcCBkb2VzIG5vdCBzdXBwb3J0IGxheW91dD1cIm5vbmVcIicpO1xuICB9XG4gIGNvbnN0IHsgc3R5bGU6IHBhc3NlZFN0eWxlLCBmcm9tID0gMCwgcHJlbW91bnRGb3IgPSAwLCAuLi5vdGhlclByb3BzIH0gPSBwcm9wcztcbiAgY29uc3QgcHJlbW91bnRpbmdBY3RpdmUgPSBmcmFtZSA8IGZyb20gJiYgZnJhbWUgPj0gZnJvbSAtIHByZW1vdW50Rm9yO1xuICBjb25zdCBzdHlsZSA9IHVzZU1lbW8xMCgoKSA9PiB7XG4gICAgcmV0dXJuIHtcbiAgICAgIC4uLnBhc3NlZFN0eWxlLFxuICAgICAgb3BhY2l0eTogcHJlbW91bnRpbmdBY3RpdmUgPyAwIDogMSxcbiAgICAgIHBvaW50ZXJFdmVudHM6IHByZW1vdW50aW5nQWN0aXZlID8gXCJub25lXCIgOiBwYXNzZWRTdHlsZT8ucG9pbnRlckV2ZW50cyA/PyB1bmRlZmluZWRcbiAgICB9O1xuICB9LCBbcHJlbW91bnRpbmdBY3RpdmUsIHBhc3NlZFN0eWxlXSk7XG4gIHJldHVybiAvKiBAX19QVVJFX18gKi8ganN4OShGcmVlemUsIHtcbiAgICBmcmFtZTogZnJvbSxcbiAgICBhY3RpdmU6IHByZW1vdW50aW5nQWN0aXZlLFxuICAgIGNoaWxkcmVuOiAvKiBAX19QVVJFX18gKi8ganN4OShTZXF1ZW5jZSwge1xuICAgICAgcmVmLFxuICAgICAgZnJvbSxcbiAgICAgIHN0eWxlLFxuICAgICAgX3JlbW90aW9uSW50ZXJuYWxQcmVtb3VudERpc3BsYXk6IHByZW1vdW50Rm9yLFxuICAgICAgX3JlbW90aW9uSW50ZXJuYWxJc1ByZW1vdW50aW5nOiBwcmVtb3VudGluZ0FjdGl2ZSxcbiAgICAgIC4uLm90aGVyUHJvcHNcbiAgICB9KVxuICB9KTtcbn07XG52YXIgUHJlbW91bnRlZFNlcXVlbmNlID0gZm9yd2FyZFJlZjIoUHJlbW91bnRlZFNlcXVlbmNlUmVmRm9yd2FyZGluZ0Z1bmN0aW9uKTtcbnZhciBTZXF1ZW5jZVJlZkZvcndhcmRpbmdGdW5jdGlvbiA9IChwcm9wcywgcmVmKSA9PiB7XG4gIGlmIChwcm9wcy5sYXlvdXQgIT09IFwibm9uZVwiICYmIHByb3BzLnByZW1vdW50Rm9yICYmICFnZXRSZW1vdGlvbkVudmlyb25tZW50KCkuaXNSZW5kZXJpbmcpIHtcbiAgICByZXR1cm4gLyogQF9fUFVSRV9fICovIGpzeDkoUHJlbW91bnRlZFNlcXVlbmNlLCB7XG4gICAgICAuLi5wcm9wcyxcbiAgICAgIHJlZlxuICAgIH0pO1xuICB9XG4gIHJldHVybiAvKiBAX19QVVJFX18gKi8ganN4OShSZWd1bGFyU2VxdWVuY2UsIHtcbiAgICAuLi5wcm9wcyxcbiAgICByZWZcbiAgfSk7XG59O1xudmFyIFNlcXVlbmNlID0gZm9yd2FyZFJlZjIoU2VxdWVuY2VSZWZGb3J3YXJkaW5nRnVuY3Rpb24pO1xuLy8gc3JjL0FydGlmYWN0LnRzeFxuaW1wb3J0IHsgdXNlQ29udGV4dCBhcyB1c2VDb250ZXh0MTMsIHVzZUVmZmVjdCBhcyB1c2VFZmZlY3Q2LCB1c2VTdGF0ZSBhcyB1c2VTdGF0ZTcgfSBmcm9tIFwicmVhY3RcIjtcblxuLy8gc3JjL1JlbmRlckFzc2V0TWFuYWdlci50c3hcbmltcG9ydCB7XG4gIGNyZWF0ZUNvbnRleHQgYXMgY3JlYXRlQ29udGV4dDExLFxuICB1c2VDYWxsYmFjayBhcyB1c2VDYWxsYmFjazQsXG4gIHVzZUxheW91dEVmZmVjdCBhcyB1c2VMYXlvdXRFZmZlY3QyLFxuICB1c2VNZW1vIGFzIHVzZU1lbW8xMSxcbiAgdXNlU3RhdGUgYXMgdXNlU3RhdGU2XG59IGZyb20gXCJyZWFjdFwiO1xuXG4vLyBzcmMvdmFsaWRhdGlvbi92YWxpZGF0ZS1hcnRpZmFjdC50c1xudmFyIHZhbGlkYXRlQXJ0aWZhY3RGaWxlbmFtZSA9IChmaWxlbmFtZSkgPT4ge1xuICBpZiAodHlwZW9mIGZpbGVuYW1lICE9PSBcInN0cmluZ1wiKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgVGhlIFwiZmlsZW5hbWVcIiBtdXN0IGJlIGEgc3RyaW5nLCBidXQgeW91IHBhc3NlZCBhIHZhbHVlIG9mIHR5cGUgJHt0eXBlb2YgZmlsZW5hbWV9YCk7XG4gIH1cbiAgaWYgKGZpbGVuYW1lLnRyaW0oKSA9PT0gXCJcIikge1xuICAgIHRocm93IG5ldyBFcnJvcihcIlRoZSBgZmlsZW5hbWVgIG11c3Qgbm90IGJlIGVtcHR5XCIpO1xuICB9XG4gIGlmICghZmlsZW5hbWUubWF0Y2goL14oWzAtOWEtekEtWi0hXy4qJygpLzomJEA9OyssP10rKS9nKSkge1xuICAgIHRocm93IG5ldyBFcnJvcignVGhlIGBmaWxlbmFtZWAgbXVzdCBtYXRjaCBcIi9eKFswLTlhLXpBLVotIV8uKlxcJygpLzomJEA9OyssP10rKS9nXCIuIFVzZSBmb3J3YXJkIHNsYXNoZXMgb25seSwgZXZlbiBvbiBXaW5kb3dzLicpO1xuICB9XG59O1xudmFyIHZhbGlkYXRlQ29udGVudCA9IChjb250ZW50KSA9PiB7XG4gIGlmICh0eXBlb2YgY29udGVudCAhPT0gXCJzdHJpbmdcIiAmJiAhKGNvbnRlbnQgaW5zdGFuY2VvZiBVaW50OEFycmF5KSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYFRoZSBcImNvbnRlbnRcIiBtdXN0IGJlIGEgc3RyaW5nIG9yIFVpbnQ4QXJyYXksIGJ1dCB5b3UgcGFzc2VkIGEgdmFsdWUgb2YgdHlwZSAke3R5cGVvZiBjb250ZW50fWApO1xuICB9XG4gIGlmICh0eXBlb2YgY29udGVudCA9PT0gXCJzdHJpbmdcIiAmJiBjb250ZW50LnRyaW0oKSA9PT0gXCJcIikge1xuICAgIHRocm93IG5ldyBFcnJvcihcIlRoZSBgY29udGVudGAgbXVzdCBub3QgYmUgZW1wdHlcIik7XG4gIH1cbn07XG52YXIgdmFsaWRhdGVSZW5kZXJBc3NldCA9IChhcnRpZmFjdCkgPT4ge1xuICBpZiAoYXJ0aWZhY3QudHlwZSAhPT0gXCJhcnRpZmFjdFwiKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIHZhbGlkYXRlQXJ0aWZhY3RGaWxlbmFtZShhcnRpZmFjdC5maWxlbmFtZSk7XG4gIHZhbGlkYXRlQ29udGVudChhcnRpZmFjdC5jb250ZW50KTtcbn07XG5cbi8vIHNyYy9SZW5kZXJBc3NldE1hbmFnZXIudHN4XG5pbXBvcnQgeyBqc3ggYXMganN4MTAgfSBmcm9tIFwicmVhY3QvanN4LXJ1bnRpbWVcIjtcbnZhciBSZW5kZXJBc3NldE1hbmFnZXIgPSBjcmVhdGVDb250ZXh0MTEoe1xuICByZWdpc3RlclJlbmRlckFzc2V0OiAoKSA9PiB7XG4gICAgcmV0dXJuO1xuICB9LFxuICB1bnJlZ2lzdGVyUmVuZGVyQXNzZXQ6ICgpID0+IHtcbiAgICByZXR1cm47XG4gIH0sXG4gIHJlbmRlckFzc2V0czogW11cbn0pO1xudmFyIFJlbmRlckFzc2V0TWFuYWdlclByb3ZpZGVyID0gKHsgY2hpbGRyZW4gfSkgPT4ge1xuICBjb25zdCBbcmVuZGVyQXNzZXRzLCBzZXRSZW5kZXJBc3NldHNdID0gdXNlU3RhdGU2KFtdKTtcbiAgY29uc3QgcmVnaXN0ZXJSZW5kZXJBc3NldCA9IHVzZUNhbGxiYWNrNCgocmVuZGVyQXNzZXQpID0+IHtcbiAgICB2YWxpZGF0ZVJlbmRlckFzc2V0KHJlbmRlckFzc2V0KTtcbiAgICBzZXRSZW5kZXJBc3NldHMoKGFzc2V0cykgPT4ge1xuICAgICAgcmV0dXJuIFsuLi5hc3NldHMsIHJlbmRlckFzc2V0XTtcbiAgICB9KTtcbiAgfSwgW10pO1xuICBjb25zdCB1bnJlZ2lzdGVyUmVuZGVyQXNzZXQgPSB1c2VDYWxsYmFjazQoKGlkKSA9PiB7XG4gICAgc2V0UmVuZGVyQXNzZXRzKChhc3N0cykgPT4ge1xuICAgICAgcmV0dXJuIGFzc3RzLmZpbHRlcigoYSkgPT4gYS5pZCAhPT0gaWQpO1xuICAgIH0pO1xuICB9LCBbXSk7XG4gIHVzZUxheW91dEVmZmVjdDIoKCkgPT4ge1xuICAgIGlmICh0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICB3aW5kb3cucmVtb3Rpb25fY29sbGVjdEFzc2V0cyA9ICgpID0+IHtcbiAgICAgICAgc2V0UmVuZGVyQXNzZXRzKFtdKTtcbiAgICAgICAgcmV0dXJuIHJlbmRlckFzc2V0cztcbiAgICAgIH07XG4gICAgfVxuICB9LCBbcmVuZGVyQXNzZXRzXSk7XG4gIGNvbnN0IGNvbnRleHRWYWx1ZSA9IHVzZU1lbW8xMSgoKSA9PiB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHJlZ2lzdGVyUmVuZGVyQXNzZXQsXG4gICAgICB1bnJlZ2lzdGVyUmVuZGVyQXNzZXQsXG4gICAgICByZW5kZXJBc3NldHNcbiAgICB9O1xuICB9LCBbcmVuZGVyQXNzZXRzLCByZWdpc3RlclJlbmRlckFzc2V0LCB1bnJlZ2lzdGVyUmVuZGVyQXNzZXRdKTtcbiAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqLyBqc3gxMChSZW5kZXJBc3NldE1hbmFnZXIuUHJvdmlkZXIsIHtcbiAgICB2YWx1ZTogY29udGV4dFZhbHVlLFxuICAgIGNoaWxkcmVuXG4gIH0pO1xufTtcblxuLy8gc3JjL0FydGlmYWN0LnRzeFxudmFyIEFydGlmYWN0ID0gKHsgZmlsZW5hbWUsIGNvbnRlbnQgfSkgPT4ge1xuICBjb25zdCB7IHJlZ2lzdGVyUmVuZGVyQXNzZXQsIHVucmVnaXN0ZXJSZW5kZXJBc3NldCB9ID0gdXNlQ29udGV4dDEzKFJlbmRlckFzc2V0TWFuYWdlcik7XG4gIGNvbnN0IFtlbnZdID0gdXNlU3RhdGU3KCgpID0+IGdldFJlbW90aW9uRW52aXJvbm1lbnQoKSk7XG4gIGNvbnN0IGZyYW1lID0gdXNlQ3VycmVudEZyYW1lKCk7XG4gIGNvbnN0IFtpZF0gPSB1c2VTdGF0ZTcoKCkgPT4ge1xuICAgIHJldHVybiBTdHJpbmcoTWF0aC5yYW5kb20oKSk7XG4gIH0pO1xuICB1c2VFZmZlY3Q2KCgpID0+IHtcbiAgICBpZiAoIWVudi5pc1JlbmRlcmluZykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoY29udGVudCBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkpIHtcbiAgICAgIHJlZ2lzdGVyUmVuZGVyQXNzZXQoe1xuICAgICAgICB0eXBlOiBcImFydGlmYWN0XCIsXG4gICAgICAgIGlkLFxuICAgICAgICBjb250ZW50OiBidG9hKG5ldyBUZXh0RGVjb2RlcihcInV0ZjhcIikuZGVjb2RlKGNvbnRlbnQpKSxcbiAgICAgICAgZmlsZW5hbWUsXG4gICAgICAgIGZyYW1lLFxuICAgICAgICBiaW5hcnk6IHRydWVcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICByZWdpc3RlclJlbmRlckFzc2V0KHtcbiAgICAgICAgdHlwZTogXCJhcnRpZmFjdFwiLFxuICAgICAgICBpZCxcbiAgICAgICAgY29udGVudCxcbiAgICAgICAgZmlsZW5hbWUsXG4gICAgICAgIGZyYW1lLFxuICAgICAgICBiaW5hcnk6IGZhbHNlXG4gICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgIHJldHVybiB1bnJlZ2lzdGVyUmVuZGVyQXNzZXQoaWQpO1xuICAgIH07XG4gIH0sIFtcbiAgICBjb250ZW50LFxuICAgIGVudi5pc1JlbmRlcmluZyxcbiAgICBmaWxlbmFtZSxcbiAgICBmcmFtZSxcbiAgICBpZCxcbiAgICByZWdpc3RlclJlbmRlckFzc2V0LFxuICAgIHVucmVnaXN0ZXJSZW5kZXJBc3NldFxuICBdKTtcbiAgcmV0dXJuIG51bGw7XG59O1xuLy8gc3JjL2F1ZGlvL0F1ZGlvLnRzeFxuaW1wb3J0IHsgZm9yd2FyZFJlZiBhcyBmb3J3YXJkUmVmNSwgdXNlQ2FsbGJhY2sgYXMgdXNlQ2FsbGJhY2s5LCB1c2VDb250ZXh0IGFzIHVzZUNvbnRleHQyMyB9IGZyb20gXCJyZWFjdFwiO1xuXG4vLyBzcmMvYWJzb2x1dGUtc3JjLnRzXG52YXIgZ2V0QWJzb2x1dGVTcmMgPSAocmVsYXRpdmVTcmMpID0+IHtcbiAgaWYgKHR5cGVvZiB3aW5kb3cgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICByZXR1cm4gcmVsYXRpdmVTcmM7XG4gIH1cbiAgcmV0dXJuIG5ldyBVUkwocmVsYXRpdmVTcmMsIHdpbmRvdy5vcmlnaW4pLmhyZWY7XG59O1xuXG4vLyBzcmMvY2FsY3VsYXRlLWxvb3AudHNcbnZhciBjYWxjdWxhdGVMb29wRHVyYXRpb24gPSAoe1xuICBlbmRBdCxcbiAgbWVkaWFEdXJhdGlvbixcbiAgcGxheWJhY2tSYXRlLFxuICBzdGFydEZyb21cbn0pID0+IHtcbiAgbGV0IGR1cmF0aW9uID0gbWVkaWFEdXJhdGlvbjtcbiAgaWYgKHR5cGVvZiBlbmRBdCAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgIGR1cmF0aW9uID0gZW5kQXQ7XG4gIH1cbiAgaWYgKHR5cGVvZiBzdGFydEZyb20gIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICBkdXJhdGlvbiAtPSBzdGFydEZyb207XG4gIH1cbiAgY29uc3QgYWN0dWFsRHVyYXRpb24gPSBkdXJhdGlvbiAvIHBsYXliYWNrUmF0ZTtcbiAgcmV0dXJuIE1hdGguZmxvb3IoYWN0dWFsRHVyYXRpb24pO1xufTtcblxuLy8gc3JjL2NhbmNlbC1yZW5kZXIudHNcbmZ1bmN0aW9uIGNhbmNlbFJlbmRlcihlcnIpIHtcbiAgbGV0IGVycm9yO1xuICBpZiAoaXNFcnJvckxpa2UoZXJyKSkge1xuICAgIGVycm9yID0gZXJyO1xuICAgIGlmICghZXJyb3Iuc3RhY2spIHtcbiAgICAgIGVycm9yLnN0YWNrID0gbmV3IEVycm9yKGVycm9yLm1lc3NhZ2UpLnN0YWNrO1xuICAgIH1cbiAgfSBlbHNlIGlmICh0eXBlb2YgZXJyID09PSBcInN0cmluZ1wiKSB7XG4gICAgZXJyb3IgPSBFcnJvcihlcnIpO1xuICB9IGVsc2Uge1xuICAgIGVycm9yID0gRXJyb3IoXCJSZW5kZXJpbmcgd2FzIGNhbmNlbGxlZFwiKTtcbiAgfVxuICB3aW5kb3cucmVtb3Rpb25fY2FuY2VsbGVkRXJyb3IgPSBlcnJvci5zdGFjaztcbiAgdGhyb3cgZXJyb3I7XG59XG52YXIgaXNFcnJvckxpa2UgPSAoZXJyKSA9PiB7XG4gIGlmIChlcnIgaW5zdGFuY2VvZiBFcnJvcikge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIGlmIChlcnIgPT09IG51bGwpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgaWYgKHR5cGVvZiBlcnIgIT09IFwib2JqZWN0XCIpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgaWYgKCEoXCJzdGFja1wiIGluIGVycikpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgaWYgKHR5cGVvZiBlcnIuc3RhY2sgIT09IFwic3RyaW5nXCIpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgaWYgKCEoXCJtZXNzYWdlXCIgaW4gZXJyKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBpZiAodHlwZW9mIGVyci5tZXNzYWdlICE9PSBcInN0cmluZ1wiKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHJldHVybiB0cnVlO1xufTtcblxuLy8gc3JjL2xvb3AvaW5kZXgudHN4XG5pbXBvcnQgUmVhY3Q4LCB7IGNyZWF0ZUNvbnRleHQgYXMgY3JlYXRlQ29udGV4dDEyLCB1c2VNZW1vIGFzIHVzZU1lbW8xMiB9IGZyb20gXCJyZWFjdFwiO1xuaW1wb3J0IHsganN4IGFzIGpzeDExIH0gZnJvbSBcInJlYWN0L2pzeC1ydW50aW1lXCI7XG52YXIgTG9vcENvbnRleHQgPSBjcmVhdGVDb250ZXh0MTIobnVsbCk7XG52YXIgdXNlTG9vcCA9ICgpID0+IHtcbiAgcmV0dXJuIFJlYWN0OC51c2VDb250ZXh0KExvb3BDb250ZXh0KTtcbn07XG52YXIgTG9vcCA9ICh7IGR1cmF0aW9uSW5GcmFtZXMsIHRpbWVzID0gSW5maW5pdHksIGNoaWxkcmVuLCBuYW1lLCAuLi5wcm9wcyB9KSA9PiB7XG4gIGNvbnN0IGN1cnJlbnRGcmFtZSA9IHVzZUN1cnJlbnRGcmFtZSgpO1xuICBjb25zdCB7IGR1cmF0aW9uSW5GcmFtZXM6IGNvbXBEdXJhdGlvbiB9ID0gdXNlVmlkZW9Db25maWcoKTtcbiAgdmFsaWRhdGVEdXJhdGlvbkluRnJhbWVzKGR1cmF0aW9uSW5GcmFtZXMsIHtcbiAgICBjb21wb25lbnQ6IFwib2YgdGhlIDxMb29wIC8+IGNvbXBvbmVudFwiLFxuICAgIGFsbG93RmxvYXRzOiB0cnVlXG4gIH0pO1xuICBpZiAodHlwZW9mIHRpbWVzICE9PSBcIm51bWJlclwiKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgWW91IHBhc3NlZCB0byBcInRpbWVzXCIgYW4gYXJndW1lbnQgb2YgdHlwZSAke3R5cGVvZiB0aW1lc30sIGJ1dCBpdCBtdXN0IGJlIGEgbnVtYmVyLmApO1xuICB9XG4gIGlmICh0aW1lcyAhPT0gSW5maW5pdHkgJiYgdGltZXMgJSAxICE9PSAwKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgVGhlIFwidGltZXNcIiBwcm9wIG9mIGEgbG9vcCBtdXN0IGJlIGFuIGludGVnZXIsIGJ1dCBnb3QgJHt0aW1lc30uYCk7XG4gIH1cbiAgaWYgKHRpbWVzIDwgMCkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYFRoZSBcInRpbWVzXCIgcHJvcCBvZiBhIGxvb3AgbXVzdCBiZSBhdCBsZWFzdCAwLCBidXQgZ290ICR7dGltZXN9YCk7XG4gIH1cbiAgY29uc3QgbWF4VGltZXMgPSBNYXRoLmNlaWwoY29tcER1cmF0aW9uIC8gZHVyYXRpb25JbkZyYW1lcyk7XG4gIGNvbnN0IGFjdHVhbFRpbWVzID0gTWF0aC5taW4obWF4VGltZXMsIHRpbWVzKTtcbiAgY29uc3Qgc3R5bGUgPSBwcm9wcy5sYXlvdXQgPT09IFwibm9uZVwiID8gdW5kZWZpbmVkIDogcHJvcHMuc3R5bGU7XG4gIGNvbnN0IG1heEZyYW1lID0gZHVyYXRpb25JbkZyYW1lcyAqIChhY3R1YWxUaW1lcyAtIDEpO1xuICBjb25zdCBpdGVyYXRpb24gPSBNYXRoLmZsb29yKGN1cnJlbnRGcmFtZSAvIGR1cmF0aW9uSW5GcmFtZXMpO1xuICBjb25zdCBzdGFydCA9IGl0ZXJhdGlvbiAqIGR1cmF0aW9uSW5GcmFtZXM7XG4gIGNvbnN0IGZyb20gPSBNYXRoLm1pbihzdGFydCwgbWF4RnJhbWUpO1xuICBjb25zdCBsb29wRGlzcGxheSA9IHVzZU1lbW8xMigoKSA9PiB7XG4gICAgcmV0dXJuIHtcbiAgICAgIG51bWJlck9mVGltZXM6IGFjdHVhbFRpbWVzLFxuICAgICAgc3RhcnRPZmZzZXQ6IC1mcm9tLFxuICAgICAgZHVyYXRpb25JbkZyYW1lc1xuICAgIH07XG4gIH0sIFthY3R1YWxUaW1lcywgZHVyYXRpb25JbkZyYW1lcywgZnJvbV0pO1xuICBjb25zdCBsb29wQ29udGV4dCA9IHVzZU1lbW8xMigoKSA9PiB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGl0ZXJhdGlvbjogTWF0aC5mbG9vcihjdXJyZW50RnJhbWUgLyBkdXJhdGlvbkluRnJhbWVzKSxcbiAgICAgIGR1cmF0aW9uSW5GcmFtZXNcbiAgICB9O1xuICB9LCBbY3VycmVudEZyYW1lLCBkdXJhdGlvbkluRnJhbWVzXSk7XG4gIHJldHVybiAvKiBAX19QVVJFX18gKi8ganN4MTEoTG9vcENvbnRleHQuUHJvdmlkZXIsIHtcbiAgICB2YWx1ZTogbG9vcENvbnRleHQsXG4gICAgY2hpbGRyZW46IC8qIEBfX1BVUkVfXyAqLyBqc3gxMShTZXF1ZW5jZSwge1xuICAgICAgZHVyYXRpb25JbkZyYW1lcyxcbiAgICAgIGZyb20sXG4gICAgICBuYW1lOiBuYW1lID8/IFwiPExvb3A+XCIsXG4gICAgICBfcmVtb3Rpb25JbnRlcm5hbExvb3BEaXNwbGF5OiBsb29wRGlzcGxheSxcbiAgICAgIGxheW91dDogcHJvcHMubGF5b3V0LFxuICAgICAgc3R5bGUsXG4gICAgICBjaGlsZHJlblxuICAgIH0pXG4gIH0pO1xufTtcbkxvb3AudXNlTG9vcCA9IHVzZUxvb3A7XG5cbi8vIHNyYy9wcmVmZXRjaC50c1xuaW1wb3J0IHsgdXNlQ29udGV4dCBhcyB1c2VDb250ZXh0MTQgfSBmcm9tIFwicmVhY3RcIjtcblxuLy8gc3JjL3ByZWZldGNoLXN0YXRlLnRzeFxuaW1wb3J0IHsgY3JlYXRlQ29udGV4dCBhcyBjcmVhdGVDb250ZXh0MTMsIHVzZUVmZmVjdCBhcyB1c2VFZmZlY3Q3LCB1c2VTdGF0ZSBhcyB1c2VTdGF0ZTggfSBmcm9tIFwicmVhY3RcIjtcbmltcG9ydCB7IGpzeCBhcyBqc3gxMiB9IGZyb20gXCJyZWFjdC9qc3gtcnVudGltZVwiO1xudmFyIFByZWxvYWRDb250ZXh0ID0gY3JlYXRlQ29udGV4dDEzKHt9KTtcbnZhciBwcmVsb2FkcyA9IHt9O1xudmFyIHVwZGF0ZXJzID0gW107XG52YXIgc2V0UHJlbG9hZHMgPSAodXBkYXRlcikgPT4ge1xuICBwcmVsb2FkcyA9IHVwZGF0ZXIocHJlbG9hZHMpO1xuICB1cGRhdGVycy5mb3JFYWNoKCh1KSA9PiB1KCkpO1xufTtcbnZhciBQcmVmZXRjaFByb3ZpZGVyID0gKHsgY2hpbGRyZW4gfSkgPT4ge1xuICBjb25zdCBbX3ByZWxvYWRzLCBfc2V0UHJlbG9hZHNdID0gdXNlU3RhdGU4KCgpID0+IHByZWxvYWRzKTtcbiAgdXNlRWZmZWN0NygoKSA9PiB7XG4gICAgY29uc3QgdXBkYXRlckZ1bmN0aW9uID0gKCkgPT4ge1xuICAgICAgX3NldFByZWxvYWRzKHByZWxvYWRzKTtcbiAgICB9O1xuICAgIHVwZGF0ZXJzLnB1c2godXBkYXRlckZ1bmN0aW9uKTtcbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgdXBkYXRlcnMgPSB1cGRhdGVycy5maWx0ZXIoKHUpID0+IHUgIT09IHVwZGF0ZXJGdW5jdGlvbik7XG4gICAgfTtcbiAgfSwgW10pO1xuICByZXR1cm4gLyogQF9fUFVSRV9fICovIGpzeDEyKFByZWxvYWRDb250ZXh0LlByb3ZpZGVyLCB7XG4gICAgdmFsdWU6IF9wcmVsb2FkcyxcbiAgICBjaGlsZHJlblxuICB9KTtcbn07XG5cbi8vIHNyYy9wcmVmZXRjaC50c1xudmFyIHVzZVByZWxvYWQgPSAoc3JjKSA9PiB7XG4gIGNvbnN0IHByZWxvYWRzMiA9IHVzZUNvbnRleHQxNChQcmVsb2FkQ29udGV4dCk7XG4gIHJldHVybiBwcmVsb2FkczJbc3JjXSA/PyBzcmM7XG59O1xudmFyIGJsb2JUb0Jhc2U2NCA9IGZ1bmN0aW9uKGJsb2IpIHtcbiAgY29uc3QgcmVhZGVyID0gbmV3IEZpbGVSZWFkZXI7XG4gIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgcmVhZGVyLm9ubG9hZCA9IGZ1bmN0aW9uKCkge1xuICAgICAgY29uc3QgZGF0YVVybCA9IHJlYWRlci5yZXN1bHQ7XG4gICAgICByZXNvbHZlKGRhdGFVcmwpO1xuICAgIH07XG4gICAgcmVhZGVyLm9uZXJyb3IgPSAoZXJyKSA9PiB7XG4gICAgICByZXR1cm4gcmVqZWN0KGVycik7XG4gICAgfTtcbiAgICByZWFkZXIucmVhZEFzRGF0YVVSTChibG9iKTtcbiAgfSk7XG59O1xudmFyIGdldEJsb2JGcm9tUmVhZGVyID0gYXN5bmMgKHtcbiAgcmVhZGVyLFxuICBjb250ZW50VHlwZSxcbiAgY29udGVudExlbmd0aCxcbiAgb25Qcm9ncmVzc1xufSkgPT4ge1xuICBsZXQgcmVjZWl2ZWRMZW5ndGggPSAwO1xuICBjb25zdCBjaHVua3MgPSBbXTtcbiAgd2hpbGUgKHRydWUpIHtcbiAgICBjb25zdCB7IGRvbmUsIHZhbHVlIH0gPSBhd2FpdCByZWFkZXIucmVhZCgpO1xuICAgIGlmIChkb25lKSB7XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgY2h1bmtzLnB1c2godmFsdWUpO1xuICAgIHJlY2VpdmVkTGVuZ3RoICs9IHZhbHVlLmxlbmd0aDtcbiAgICBpZiAob25Qcm9ncmVzcykge1xuICAgICAgb25Qcm9ncmVzcyh7IGxvYWRlZEJ5dGVzOiByZWNlaXZlZExlbmd0aCwgdG90YWxCeXRlczogY29udGVudExlbmd0aCB9KTtcbiAgICB9XG4gIH1cbiAgY29uc3QgY2h1bmtzQWxsID0gbmV3IFVpbnQ4QXJyYXkocmVjZWl2ZWRMZW5ndGgpO1xuICBsZXQgcG9zaXRpb24gPSAwO1xuICBmb3IgKGNvbnN0IGNodW5rIG9mIGNodW5rcykge1xuICAgIGNodW5rc0FsbC5zZXQoY2h1bmssIHBvc2l0aW9uKTtcbiAgICBwb3NpdGlvbiArPSBjaHVuay5sZW5ndGg7XG4gIH1cbiAgcmV0dXJuIG5ldyBCbG9iKFtjaHVua3NBbGxdLCB7XG4gICAgdHlwZTogY29udGVudFR5cGUgPz8gdW5kZWZpbmVkXG4gIH0pO1xufTtcbnZhciBwcmVmZXRjaCA9IChzcmMsIG9wdGlvbnMpID0+IHtcbiAgY29uc3QgbWV0aG9kID0gb3B0aW9ucz8ubWV0aG9kID8/IFwiYmxvYi11cmxcIjtcbiAgaWYgKGdldFJlbW90aW9uRW52aXJvbm1lbnQoKS5pc1JlbmRlcmluZykge1xuICAgIHJldHVybiB7XG4gICAgICBmcmVlOiAoKSA9PiB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH0sXG4gICAgICB3YWl0VW50aWxEb25lOiAoKSA9PiBQcm9taXNlLnJlc29sdmUoc3JjKVxuICAgIH07XG4gIH1cbiAgbGV0IGNhbmNlbGVkID0gZmFsc2U7XG4gIGxldCBvYmplY3RVcmwgPSBudWxsO1xuICBsZXQgcmVzb2x2ZSA9ICgpID0+IHtcbiAgICByZXR1cm47XG4gIH07XG4gIGxldCByZWplY3QgPSAoKSA9PiB7XG4gICAgcmV0dXJuO1xuICB9O1xuICBjb25zdCB3YWl0VW50aWxEb25lID0gbmV3IFByb21pc2UoKHJlcywgcmVqKSA9PiB7XG4gICAgcmVzb2x2ZSA9IHJlcztcbiAgICByZWplY3QgPSByZWo7XG4gIH0pO1xuICBjb25zdCBjb250cm9sbGVyID0gbmV3IEFib3J0Q29udHJvbGxlcjtcbiAgbGV0IGNhbkJlQWJvcnRlZCA9IHRydWU7XG4gIGZldGNoKHNyYywge1xuICAgIHNpZ25hbDogY29udHJvbGxlci5zaWduYWxcbiAgfSkudGhlbigocmVzKSA9PiB7XG4gICAgY2FuQmVBYm9ydGVkID0gZmFsc2U7XG4gICAgaWYgKGNhbmNlbGVkKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgaWYgKCFyZXMub2spIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgSFRUUCBlcnJvciwgc3RhdHVzID0gJHtyZXMuc3RhdHVzfWApO1xuICAgIH1cbiAgICBjb25zdCBoZWFkZXJDb250ZW50VHlwZSA9IHJlcy5oZWFkZXJzLmdldChcIkNvbnRlbnQtVHlwZVwiKTtcbiAgICBjb25zdCBjb250ZW50VHlwZSA9IG9wdGlvbnM/LmNvbnRlbnRUeXBlID8/IGhlYWRlckNvbnRlbnRUeXBlO1xuICAgIGNvbnN0IGhhc1Byb3BlckNvbnRlbnRUeXBlID0gY29udGVudFR5cGUgJiYgKGNvbnRlbnRUeXBlLnN0YXJ0c1dpdGgoXCJ2aWRlby9cIikgfHwgY29udGVudFR5cGUuc3RhcnRzV2l0aChcImF1ZGlvL1wiKSB8fCBjb250ZW50VHlwZS5zdGFydHNXaXRoKFwiaW1hZ2UvXCIpKTtcbiAgICBpZiAoIWhhc1Byb3BlckNvbnRlbnRUeXBlKSB7XG4gICAgICBjb25zb2xlLndhcm4oYENhbGxlZCBwcmVmZXRjaCgpIG9uICR7c3JjfSB3aGljaCByZXR1cm5lZCBhIFwiQ29udGVudC1UeXBlXCIgb2YgJHtoZWFkZXJDb250ZW50VHlwZX0uIFByZWZldGNoZWQgY29udGVudCBzaG91bGQgaGF2ZSBhIHByb3BlciBjb250ZW50IHR5cGUgKHZpZGVvLy4uLiBvciBhdWRpby8uLi4pIG9yIGEgY29udGVudFR5cGUgcGFzc2VkIHRoZSBvcHRpb25zIG9mIHByZWZldGNoKCkuIE90aGVyd2lzZSwgcHJlZmV0Y2hpbmcgd2lsbCBub3Qgd29yayBwcm9wZXJseSBpbiBhbGwgYnJvd3NlcnMuYCk7XG4gICAgfVxuICAgIGlmICghcmVzLmJvZHkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgSFRUUCByZXNwb25zZSBvZiAke3NyY30gaGFzIG5vIGJvZHlgKTtcbiAgICB9XG4gICAgY29uc3QgcmVhZGVyID0gcmVzLmJvZHkuZ2V0UmVhZGVyKCk7XG4gICAgcmV0dXJuIGdldEJsb2JGcm9tUmVhZGVyKHtcbiAgICAgIHJlYWRlcixcbiAgICAgIGNvbnRlbnRUeXBlOiBvcHRpb25zPy5jb250ZW50VHlwZSA/PyBoZWFkZXJDb250ZW50VHlwZSA/PyBudWxsLFxuICAgICAgY29udGVudExlbmd0aDogcmVzLmhlYWRlcnMuZ2V0KFwiQ29udGVudC1MZW5ndGhcIikgPyBwYXJzZUludChyZXMuaGVhZGVycy5nZXQoXCJDb250ZW50LUxlbmd0aFwiKSwgMTApIDogbnVsbCxcbiAgICAgIG9uUHJvZ3Jlc3M6IG9wdGlvbnM/Lm9uUHJvZ3Jlc3NcbiAgICB9KTtcbiAgfSkudGhlbigoYnVmKSA9PiB7XG4gICAgaWYgKCFidWYpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgYWN0dWFsQmxvYiA9IG9wdGlvbnM/LmNvbnRlbnRUeXBlID8gbmV3IEJsb2IoW2J1Zl0sIHsgdHlwZTogb3B0aW9ucy5jb250ZW50VHlwZSB9KSA6IGJ1ZjtcbiAgICBpZiAobWV0aG9kID09PSBcImJhc2U2NFwiKSB7XG4gICAgICByZXR1cm4gYmxvYlRvQmFzZTY0KGFjdHVhbEJsb2IpO1xuICAgIH1cbiAgICByZXR1cm4gVVJMLmNyZWF0ZU9iamVjdFVSTChhY3R1YWxCbG9iKTtcbiAgfSkudGhlbigodXJsKSA9PiB7XG4gICAgaWYgKGNhbmNlbGVkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIG9iamVjdFVybCA9IHVybDtcbiAgICBzZXRQcmVsb2FkcygocCkgPT4gKHtcbiAgICAgIC4uLnAsXG4gICAgICBbc3JjXTogb2JqZWN0VXJsXG4gICAgfSkpO1xuICAgIHJlc29sdmUob2JqZWN0VXJsKTtcbiAgfSkuY2F0Y2goKGVycikgPT4ge1xuICAgIHJlamVjdChlcnIpO1xuICB9KTtcbiAgcmV0dXJuIHtcbiAgICBmcmVlOiAoKSA9PiB7XG4gICAgICBpZiAob2JqZWN0VXJsKSB7XG4gICAgICAgIGlmIChtZXRob2QgPT09IFwiYmxvYi11cmxcIikge1xuICAgICAgICAgIFVSTC5yZXZva2VPYmplY3RVUkwob2JqZWN0VXJsKTtcbiAgICAgICAgfVxuICAgICAgICBzZXRQcmVsb2FkcygocCkgPT4ge1xuICAgICAgICAgIGNvbnN0IGNvcHkgPSB7IC4uLnAgfTtcbiAgICAgICAgICBkZWxldGUgY29weVtzcmNdO1xuICAgICAgICAgIHJldHVybiBjb3B5O1xuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNhbmNlbGVkID0gdHJ1ZTtcbiAgICAgICAgaWYgKGNhbkJlQWJvcnRlZCkge1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb250cm9sbGVyLmFib3J0KG5ldyBFcnJvcihcImZyZWUoKSBjYWxsZWRcIikpO1xuICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuICAgIHdhaXRVbnRpbERvbmU6ICgpID0+IHtcbiAgICAgIHJldHVybiB3YWl0VW50aWxEb25lO1xuICAgIH1cbiAgfTtcbn07XG5cbi8vIHNyYy92YWxpZGF0ZS1tZWRpYS1wcm9wcy50c1xudmFyIHZhbGlkYXRlTWVkaWFQcm9wcyA9IChwcm9wcywgY29tcG9uZW50KSA9PiB7XG4gIGlmICh0eXBlb2YgcHJvcHMudm9sdW1lICE9PSBcIm51bWJlclwiICYmIHR5cGVvZiBwcm9wcy52b2x1bWUgIT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2YgcHJvcHMudm9sdW1lICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgWW91IGhhdmUgcGFzc2VkIGEgdm9sdW1lIG9mIHR5cGUgJHt0eXBlb2YgcHJvcHMudm9sdW1lfSB0byB5b3VyIDwke2NvbXBvbmVudH0gLz4gY29tcG9uZW50LiBWb2x1bWUgbXVzdCBiZSBhIG51bWJlciBvciBhIGZ1bmN0aW9uIHdpdGggdGhlIHNpZ25hdHVyZSAnKGZyYW1lOiBudW1iZXIpID0+IG51bWJlcicgdW5kZWZpbmVkLmApO1xuICB9XG4gIGlmICh0eXBlb2YgcHJvcHMudm9sdW1lID09PSBcIm51bWJlclwiICYmIHByb3BzLnZvbHVtZSA8IDApIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBZb3UgaGF2ZSBwYXNzZWQgYSB2b2x1bWUgYmVsb3cgMCB0byB5b3VyIDwke2NvbXBvbmVudH0gLz4gY29tcG9uZW50LiBWb2x1bWUgbXVzdCBiZSBiZXR3ZWVuIDAgYW5kIDFgKTtcbiAgfVxuICBpZiAodHlwZW9mIHByb3BzLnBsYXliYWNrUmF0ZSAhPT0gXCJudW1iZXJcIiAmJiB0eXBlb2YgcHJvcHMucGxheWJhY2tSYXRlICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgWW91IGhhdmUgcGFzc2VkIGEgcGxheWJhY2tSYXRlIG9mIHR5cGUgJHt0eXBlb2YgcHJvcHMucGxheWJhY2tSYXRlfSB0byB5b3VyIDwke2NvbXBvbmVudH0gLz4gY29tcG9uZW50LiBQbGF5YmFjayByYXRlIG11c3QgYSByZWFsIG51bWJlciBvciB1bmRlZmluZWQuYCk7XG4gIH1cbiAgaWYgKHR5cGVvZiBwcm9wcy5wbGF5YmFja1JhdGUgPT09IFwibnVtYmVyXCIgJiYgKGlzTmFOKHByb3BzLnBsYXliYWNrUmF0ZSkgfHwgIU51bWJlci5pc0Zpbml0ZShwcm9wcy5wbGF5YmFja1JhdGUpIHx8IHByb3BzLnBsYXliYWNrUmF0ZSA8PSAwKSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYFlvdSBoYXZlIHBhc3NlZCBhIHBsYXliYWNrUmF0ZSBvZiAke3Byb3BzLnBsYXliYWNrUmF0ZX0gdG8geW91ciA8JHtjb21wb25lbnR9IC8+IGNvbXBvbmVudC4gUGxheWJhY2sgcmF0ZSBtdXN0IGJlIGEgcmVhbCBudW1iZXIgYWJvdmUgMC5gKTtcbiAgfVxufTtcblxuLy8gc3JjL3ZhbGlkYXRlLXN0YXJ0LWZyb20tcHJvcHMudHNcbnZhciB2YWxpZGF0ZVN0YXJ0RnJvbVByb3BzID0gKHN0YXJ0RnJvbSwgZW5kQXQpID0+IHtcbiAgaWYgKHR5cGVvZiBzdGFydEZyb20gIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICBpZiAodHlwZW9mIHN0YXJ0RnJvbSAhPT0gXCJudW1iZXJcIikge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgdHlwZSBvZiBzdGFydEZyb20gcHJvcCBtdXN0IGJlIGEgbnVtYmVyLCBpbnN0ZWFkIGdvdCB0eXBlICR7dHlwZW9mIHN0YXJ0RnJvbX0uYCk7XG4gICAgfVxuICAgIGlmIChpc05hTihzdGFydEZyb20pIHx8IHN0YXJ0RnJvbSA9PT0gSW5maW5pdHkpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJzdGFydEZyb20gcHJvcCBjYW4gbm90IGJlIE5hTiBvciBJbmZpbml0eS5cIik7XG4gICAgfVxuICAgIGlmIChzdGFydEZyb20gPCAwKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBzdGFydEZyb20gbXVzdCBiZSBncmVhdGVyIHRoYW4gZXF1YWwgdG8gMCBpbnN0ZWFkIGdvdCAke3N0YXJ0RnJvbX0uYCk7XG4gICAgfVxuICB9XG4gIGlmICh0eXBlb2YgZW5kQXQgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICBpZiAodHlwZW9mIGVuZEF0ICE9PSBcIm51bWJlclwiKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGB0eXBlIG9mIGVuZEF0IHByb3AgbXVzdCBiZSBhIG51bWJlciwgaW5zdGVhZCBnb3QgdHlwZSAke3R5cGVvZiBlbmRBdH0uYCk7XG4gICAgfVxuICAgIGlmIChpc05hTihlbmRBdCkpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJlbmRBdCBwcm9wIGNhbiBub3QgYmUgTmFOLlwiKTtcbiAgICB9XG4gICAgaWYgKGVuZEF0IDw9IDApIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYGVuZEF0IG11c3QgYmUgYSBwb3NpdGl2ZSBudW1iZXIsIGluc3RlYWQgZ290ICR7ZW5kQXR9LmApO1xuICAgIH1cbiAgfVxuICBpZiAoZW5kQXQgPCBzdGFydEZyb20pIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiZW5kQXQgcHJvcCBtdXN0IGJlIGdyZWF0ZXIgdGhhbiBzdGFydEZyb20gcHJvcC5cIik7XG4gIH1cbn07XG5cbi8vIHNyYy92aWRlby9kdXJhdGlvbi1zdGF0ZS50c3hcbmltcG9ydCB7IGNyZWF0ZUNvbnRleHQgYXMgY3JlYXRlQ29udGV4dDE0LCB1c2VNZW1vIGFzIHVzZU1lbW8xMywgdXNlUmVkdWNlciB9IGZyb20gXCJyZWFjdFwiO1xuaW1wb3J0IHsganN4IGFzIGpzeDEzIH0gZnJvbSBcInJlYWN0L2pzeC1ydW50aW1lXCI7XG52YXIgZHVyYXRpb25SZWR1Y2VyID0gKHN0YXRlLCBhY3Rpb24pID0+IHtcbiAgc3dpdGNoIChhY3Rpb24udHlwZSkge1xuICAgIGNhc2UgXCJnb3QtZHVyYXRpb25cIjoge1xuICAgICAgY29uc3QgYWJzb2x1dGVTcmMgPSBnZXRBYnNvbHV0ZVNyYyhhY3Rpb24uc3JjKTtcbiAgICAgIGlmIChzdGF0ZVthYnNvbHV0ZVNyY10gPT09IGFjdGlvbi5kdXJhdGlvbkluU2Vjb25kcykge1xuICAgICAgICByZXR1cm4gc3RhdGU7XG4gICAgICB9XG4gICAgICByZXR1cm4ge1xuICAgICAgICAuLi5zdGF0ZSxcbiAgICAgICAgW2Fic29sdXRlU3JjXTogYWN0aW9uLmR1cmF0aW9uSW5TZWNvbmRzXG4gICAgICB9O1xuICAgIH1cbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIHN0YXRlO1xuICB9XG59O1xudmFyIER1cmF0aW9uc0NvbnRleHQgPSBjcmVhdGVDb250ZXh0MTQoe1xuICBkdXJhdGlvbnM6IHt9LFxuICBzZXREdXJhdGlvbnM6ICgpID0+IHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJjb250ZXh0IG1pc3NpbmdcIik7XG4gIH1cbn0pO1xudmFyIER1cmF0aW9uc0NvbnRleHRQcm92aWRlciA9ICh7IGNoaWxkcmVuIH0pID0+IHtcbiAgY29uc3QgW2R1cmF0aW9ucywgc2V0RHVyYXRpb25zXSA9IHVzZVJlZHVjZXIoZHVyYXRpb25SZWR1Y2VyLCB7fSk7XG4gIGNvbnN0IHZhbHVlID0gdXNlTWVtbzEzKCgpID0+IHtcbiAgICByZXR1cm4ge1xuICAgICAgZHVyYXRpb25zLFxuICAgICAgc2V0RHVyYXRpb25zXG4gICAgfTtcbiAgfSwgW2R1cmF0aW9uc10pO1xuICByZXR1cm4gLyogQF9fUFVSRV9fICovIGpzeDEzKER1cmF0aW9uc0NvbnRleHQuUHJvdmlkZXIsIHtcbiAgICB2YWx1ZSxcbiAgICBjaGlsZHJlblxuICB9KTtcbn07XG5cbi8vIHNyYy9hdWRpby9BdWRpb0ZvclByZXZpZXcudHN4XG5pbXBvcnQge1xuICBmb3J3YXJkUmVmIGFzIGZvcndhcmRSZWYzLFxuICB1c2VDb250ZXh0IGFzIHVzZUNvbnRleHQyMSxcbiAgdXNlRWZmZWN0IGFzIHVzZUVmZmVjdDE2LFxuICB1c2VJbXBlcmF0aXZlSGFuZGxlIGFzIHVzZUltcGVyYXRpdmVIYW5kbGUzLFxuICB1c2VNZW1vIGFzIHVzZU1lbW8yMCxcbiAgdXNlUmVmIGFzIHVzZVJlZjgsXG4gIHVzZVN0YXRlIGFzIHVzZVN0YXRlMTRcbn0gZnJvbSBcInJlYWN0XCI7XG5cbi8vIHNyYy9yYW5kb20udHNcbmZ1bmN0aW9uIG11bGJlcnJ5MzIoYSkge1xuICBsZXQgdCA9IGEgKyAxODMxNTY1ODEzO1xuICB0ID0gTWF0aC5pbXVsKHQgXiB0ID4+PiAxNSwgdCB8IDEpO1xuICB0IF49IHQgKyBNYXRoLmltdWwodCBeIHQgPj4+IDcsIHQgfCA2MSk7XG4gIHJldHVybiAoKHQgXiB0ID4+PiAxNCkgPj4+IDApIC8gNDI5NDk2NzI5Njtcbn1cbmZ1bmN0aW9uIGhhc2hDb2RlKHN0cikge1xuICBsZXQgaSA9IDA7XG4gIGxldCBjaHIgPSAwO1xuICBsZXQgaGFzaCA9IDA7XG4gIGZvciAoaSA9IDA7aSA8IHN0ci5sZW5ndGg7IGkrKykge1xuICAgIGNociA9IHN0ci5jaGFyQ29kZUF0KGkpO1xuICAgIGhhc2ggPSAoaGFzaCA8PCA1KSAtIGhhc2ggKyBjaHI7XG4gICAgaGFzaCB8PSAwO1xuICB9XG4gIHJldHVybiBoYXNoO1xufVxudmFyIHJhbmRvbSA9IChzZWVkLCBkdW1teSkgPT4ge1xuICBpZiAoZHVtbXkgIT09IHVuZGVmaW5lZCkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJyYW5kb20oKSB0YWtlcyBvbmx5IG9uZSBhcmd1bWVudFwiKTtcbiAgfVxuICBpZiAoc2VlZCA9PT0gbnVsbCkge1xuICAgIHJldHVybiBNYXRoLnJhbmRvbSgpO1xuICB9XG4gIGlmICh0eXBlb2Ygc2VlZCA9PT0gXCJzdHJpbmdcIikge1xuICAgIHJldHVybiBtdWxiZXJyeTMyKGhhc2hDb2RlKHNlZWQpKTtcbiAgfVxuICBpZiAodHlwZW9mIHNlZWQgPT09IFwibnVtYmVyXCIpIHtcbiAgICByZXR1cm4gbXVsYmVycnkzMihzZWVkICogMTAwMDAwMDAwMDApO1xuICB9XG4gIHRocm93IG5ldyBFcnJvcihcInJhbmRvbSgpIGFyZ3VtZW50IG11c3QgYmUgYSBudW1iZXIgb3IgYSBzdHJpbmdcIik7XG59O1xuXG4vLyBzcmMvdXNlLW1lZGlhLWluLXRpbWVsaW5lLnRzXG5pbXBvcnQgeyB1c2VDb250ZXh0IGFzIHVzZUNvbnRleHQxNiwgdXNlRWZmZWN0IGFzIHVzZUVmZmVjdDgsIHVzZU1lbW8gYXMgdXNlTWVtbzE0LCB1c2VTdGF0ZSBhcyB1c2VTdGF0ZTkgfSBmcm9tIFwicmVhY3RcIjtcblxuLy8gc3JjL2F1ZGlvL3VzZS1hdWRpby1mcmFtZS50c1xuaW1wb3J0IHsgdXNlQ29udGV4dCBhcyB1c2VDb250ZXh0MTUgfSBmcm9tIFwicmVhY3RcIjtcbnZhciB1c2VNZWRpYVN0YXJ0c0F0ID0gKCkgPT4ge1xuICBjb25zdCBwYXJlbnRTZXF1ZW5jZSA9IHVzZUNvbnRleHQxNShTZXF1ZW5jZUNvbnRleHQpO1xuICBjb25zdCBzdGFydHNBdCA9IE1hdGgubWluKDAsIHBhcmVudFNlcXVlbmNlPy5yZWxhdGl2ZUZyb20gPz8gMCk7XG4gIHJldHVybiBzdGFydHNBdDtcbn07XG52YXIgdXNlRnJhbWVGb3JWb2x1bWVQcm9wID0gKGJlaGF2aW9yKSA9PiB7XG4gIGNvbnN0IGxvb3AgPSBMb29wLnVzZUxvb3AoKTtcbiAgY29uc3QgZnJhbWUgPSB1c2VDdXJyZW50RnJhbWUoKTtcbiAgY29uc3Qgc3RhcnRzQXQgPSB1c2VNZWRpYVN0YXJ0c0F0KCk7XG4gIGlmIChiZWhhdmlvciA9PT0gXCJyZXBlYXRcIiB8fCBsb29wID09PSBudWxsKSB7XG4gICAgcmV0dXJuIGZyYW1lICsgc3RhcnRzQXQ7XG4gIH1cbiAgcmV0dXJuIGZyYW1lICsgc3RhcnRzQXQgKyBsb29wLmR1cmF0aW9uSW5GcmFtZXMgKiBsb29wLml0ZXJhdGlvbjtcbn07XG5cbi8vIHNyYy9nZXQtYXNzZXQtZmlsZS1uYW1lLnRzXG52YXIgZ2V0QXNzZXREaXNwbGF5TmFtZSA9IChmaWxlbmFtZSkgPT4ge1xuICBpZiAoL2RhdGE6fGJsb2I6Ly50ZXN0KGZpbGVuYW1lLnN1YnN0cmluZygwLCA1KSkpIHtcbiAgICByZXR1cm4gXCJEYXRhIFVSTFwiO1xuICB9XG4gIGNvbnN0IHNwbGl0dGVkID0gZmlsZW5hbWUuc3BsaXQoXCIvXCIpLm1hcCgocykgPT4gcy5zcGxpdChcIlxcXFxcIikpLmZsYXQoMSk7XG4gIHJldHVybiBzcGxpdHRlZFtzcGxpdHRlZC5sZW5ndGggLSAxXTtcbn07XG5cbi8vIHNyYy9wbGF5LWFuZC1oYW5kbGUtbm90LWFsbG93ZWQtZXJyb3IudHNcbnZhciBwbGF5QW5kSGFuZGxlTm90QWxsb3dlZEVycm9yID0gKG1lZGlhUmVmLCBtZWRpYVR5cGUsIG9uQXV0b1BsYXlFcnJvcikgPT4ge1xuICBjb25zdCB7IGN1cnJlbnQgfSA9IG1lZGlhUmVmO1xuICBpZiAoIWN1cnJlbnQpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgY29uc3QgcHJvbSA9IGN1cnJlbnQucGxheSgpO1xuICBpZiAocHJvbS5jYXRjaCkge1xuICAgIHByb20uY2F0Y2goKGVycikgPT4ge1xuICAgICAgaWYgKCFjdXJyZW50KSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmIChlcnIubWVzc2FnZS5pbmNsdWRlcyhcInJlcXVlc3Qgd2FzIGludGVycnVwdGVkIGJ5IGEgY2FsbCB0byBwYXVzZVwiKSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAoZXJyLm1lc3NhZ2UuaW5jbHVkZXMoXCJUaGUgb3BlcmF0aW9uIHdhcyBhYm9ydGVkLlwiKSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAoZXJyLm1lc3NhZ2UuaW5jbHVkZXMoXCJUaGUgZmV0Y2hpbmcgcHJvY2VzcyBmb3IgdGhlIG1lZGlhIHJlc291cmNlIHdhcyBhYm9ydGVkIGJ5IHRoZSB1c2VyIGFnZW50XCIpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmIChlcnIubWVzc2FnZS5pbmNsdWRlcyhcInJlcXVlc3Qgd2FzIGludGVycnVwdGVkIGJ5IGEgbmV3IGxvYWQgcmVxdWVzdFwiKSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAoZXJyLm1lc3NhZ2UuaW5jbHVkZXMoXCJiZWNhdXNlIHRoZSBtZWRpYSB3YXMgcmVtb3ZlZCBmcm9tIHRoZSBkb2N1bWVudFwiKSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBjb25zb2xlLmxvZyhgQ291bGQgbm90IHBsYXkgJHttZWRpYVR5cGV9IGR1ZSB0byBmb2xsb3dpbmcgZXJyb3I6IGAsIGVycik7XG4gICAgICBpZiAoIWN1cnJlbnQubXV0ZWQpIHtcbiAgICAgICAgaWYgKG9uQXV0b1BsYXlFcnJvcikge1xuICAgICAgICAgIG9uQXV0b1BsYXlFcnJvcigpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zb2xlLmxvZyhgVGhlIHZpZGVvIHdpbGwgYmUgbXV0ZWQgYW5kIHdlJ2xsIHJldHJ5IHBsYXlpbmcgaXQuYCk7XG4gICAgICAgIGlmIChtZWRpYVR5cGUgPT09IFwidmlkZW9cIiAmJiBnZXRSZW1vdGlvbkVudmlyb25tZW50KCkuaXNQbGF5ZXIpIHtcbiAgICAgICAgICBjb25zb2xlLmxvZyhcIlVzZSBvbkF1dG9QbGF5RXJyb3IoKSB0byBoYW5kbGUgdGhpcyBlcnJvciB5b3Vyc2VsZi5cIik7XG4gICAgICAgIH1cbiAgICAgICAgY3VycmVudC5tdXRlZCA9IHRydWU7XG4gICAgICAgIGN1cnJlbnQucGxheSgpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG59O1xuXG4vLyBzcmMvdm9sdW1lLXByb3AudHNcbnZhciBldmFsdWF0ZVZvbHVtZSA9ICh7XG4gIGZyYW1lLFxuICB2b2x1bWUsXG4gIG1lZGlhVm9sdW1lID0gMSxcbiAgYWxsb3dBbXBsaWZpY2F0aW9uRHVyaW5nUmVuZGVyXG59KSA9PiB7XG4gIGNvbnN0IG1heFZvbHVtZSA9IGFsbG93QW1wbGlmaWNhdGlvbkR1cmluZ1JlbmRlciA/IEluZmluaXR5IDogMTtcbiAgaWYgKHR5cGVvZiB2b2x1bWUgPT09IFwibnVtYmVyXCIpIHtcbiAgICByZXR1cm4gTWF0aC5taW4obWF4Vm9sdW1lLCB2b2x1bWUgKiBtZWRpYVZvbHVtZSk7XG4gIH1cbiAgaWYgKHR5cGVvZiB2b2x1bWUgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICByZXR1cm4gTnVtYmVyKG1lZGlhVm9sdW1lKTtcbiAgfVxuICBjb25zdCBldmFsdWF0ZWQgPSB2b2x1bWUoZnJhbWUpICogbWVkaWFWb2x1bWU7XG4gIGlmICh0eXBlb2YgZXZhbHVhdGVkICE9PSBcIm51bWJlclwiKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgWW91IHBhc3NlZCBpbiBhIGEgZnVuY3Rpb24gdG8gdGhlIHZvbHVtZSBwcm9wIGJ1dCBpdCBkaWQgbm90IHJldHVybiBhIG51bWJlciBidXQgYSB2YWx1ZSBvZiB0eXBlICR7dHlwZW9mIGV2YWx1YXRlZH0gZm9yIGZyYW1lICR7ZnJhbWV9YCk7XG4gIH1cbiAgaWYgKE51bWJlci5pc05hTihldmFsdWF0ZWQpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgWW91IHBhc3NlZCBpbiBhIGZ1bmN0aW9uIHRvIHRoZSB2b2x1bWUgcHJvcCBidXQgaXQgcmV0dXJuZWQgTmFOIGZvciBmcmFtZSAke2ZyYW1lfS5gKTtcbiAgfVxuICBpZiAoIU51bWJlci5pc0Zpbml0ZShldmFsdWF0ZWQpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgWW91IHBhc3NlZCBpbiBhIGZ1bmN0aW9uIHRvIHRoZSB2b2x1bWUgcHJvcCBidXQgaXQgcmV0dXJuZWQgYSBub24tZmluaXRlIG51bWJlciBmb3IgZnJhbWUgJHtmcmFtZX0uYCk7XG4gIH1cbiAgcmV0dXJuIE1hdGgubWF4KDAsIE1hdGgubWluKG1heFZvbHVtZSwgZXZhbHVhdGVkKSk7XG59O1xuXG4vLyBzcmMvdXNlLW1lZGlhLWluLXRpbWVsaW5lLnRzXG52YXIgZGlkV2FybjIgPSB7fTtcbnZhciB3YXJuT25jZTIgPSAobWVzc2FnZSkgPT4ge1xuICBpZiAoZGlkV2FybjJbbWVzc2FnZV0pIHtcbiAgICByZXR1cm47XG4gIH1cbiAgY29uc29sZS53YXJuKG1lc3NhZ2UpO1xuICBkaWRXYXJuMlttZXNzYWdlXSA9IHRydWU7XG59O1xudmFyIHVzZU1lZGlhSW5UaW1lbGluZSA9ICh7XG4gIHZvbHVtZSxcbiAgbWVkaWFWb2x1bWUsXG4gIG1lZGlhUmVmLFxuICBzcmMsXG4gIG1lZGlhVHlwZSxcbiAgcGxheWJhY2tSYXRlLFxuICBkaXNwbGF5TmFtZSxcbiAgaWQsXG4gIHN0YWNrLFxuICBzaG93SW5UaW1lbGluZSxcbiAgcHJlbW91bnREaXNwbGF5LFxuICBvbkF1dG9QbGF5RXJyb3Jcbn0pID0+IHtcbiAgY29uc3QgdmlkZW9Db25maWcgPSB1c2VWaWRlb0NvbmZpZygpO1xuICBjb25zdCB7IHJvb3RJZCwgYXVkaW9BbmRWaWRlb1RhZ3MgfSA9IHVzZUNvbnRleHQxNihUaW1lbGluZUNvbnRleHQpO1xuICBjb25zdCBwYXJlbnRTZXF1ZW5jZSA9IHVzZUNvbnRleHQxNihTZXF1ZW5jZUNvbnRleHQpO1xuICBjb25zdCBhY3R1YWxGcm9tID0gcGFyZW50U2VxdWVuY2UgPyBwYXJlbnRTZXF1ZW5jZS5yZWxhdGl2ZUZyb20gKyBwYXJlbnRTZXF1ZW5jZS5jdW11bGF0ZWRGcm9tIDogMDtcbiAgY29uc3QgW3BsYXlpbmddID0gdXNlUGxheWluZ1N0YXRlKCk7XG4gIGNvbnN0IHN0YXJ0c0F0ID0gdXNlTWVkaWFTdGFydHNBdCgpO1xuICBjb25zdCB7IHJlZ2lzdGVyU2VxdWVuY2UsIHVucmVnaXN0ZXJTZXF1ZW5jZSB9ID0gdXNlQ29udGV4dDE2KFNlcXVlbmNlTWFuYWdlcik7XG4gIGNvbnN0IFtpbml0aWFsVm9sdW1lXSA9IHVzZVN0YXRlOSgoKSA9PiB2b2x1bWUpO1xuICBjb25zdCBub25jZSA9IHVzZU5vbmNlKCk7XG4gIGNvbnN0IGR1cmF0aW9uID0gcGFyZW50U2VxdWVuY2UgPyBNYXRoLm1pbihwYXJlbnRTZXF1ZW5jZS5kdXJhdGlvbkluRnJhbWVzLCB2aWRlb0NvbmZpZy5kdXJhdGlvbkluRnJhbWVzKSA6IHZpZGVvQ29uZmlnLmR1cmF0aW9uSW5GcmFtZXM7XG4gIGNvbnN0IGRvZXNWb2x1bWVDaGFuZ2UgPSB0eXBlb2Ygdm9sdW1lID09PSBcImZ1bmN0aW9uXCI7XG4gIGNvbnN0IHZvbHVtZXMgPSB1c2VNZW1vMTQoKCkgPT4ge1xuICAgIGlmICh0eXBlb2Ygdm9sdW1lID09PSBcIm51bWJlclwiKSB7XG4gICAgICByZXR1cm4gdm9sdW1lO1xuICAgIH1cbiAgICByZXR1cm4gbmV3IEFycmF5KE1hdGguZmxvb3IoTWF0aC5tYXgoMCwgZHVyYXRpb24gKyBzdGFydHNBdCkpKS5maWxsKHRydWUpLm1hcCgoXywgaSkgPT4ge1xuICAgICAgcmV0dXJuIGV2YWx1YXRlVm9sdW1lKHtcbiAgICAgICAgZnJhbWU6IGkgKyBzdGFydHNBdCxcbiAgICAgICAgdm9sdW1lLFxuICAgICAgICBtZWRpYVZvbHVtZSxcbiAgICAgICAgYWxsb3dBbXBsaWZpY2F0aW9uRHVyaW5nUmVuZGVyOiBmYWxzZVxuICAgICAgfSk7XG4gICAgfSkuam9pbihcIixcIik7XG4gIH0sIFtkdXJhdGlvbiwgc3RhcnRzQXQsIHZvbHVtZSwgbWVkaWFWb2x1bWVdKTtcbiAgdXNlRWZmZWN0OCgoKSA9PiB7XG4gICAgaWYgKHR5cGVvZiB2b2x1bWUgPT09IFwibnVtYmVyXCIgJiYgdm9sdW1lICE9PSBpbml0aWFsVm9sdW1lKSB7XG4gICAgICB3YXJuT25jZTIoYFJlbW90aW9uOiBUaGUgJHttZWRpYVR5cGV9IHdpdGggc3JjICR7c3JjfSBoYXMgY2hhbmdlZCBpdCdzIHZvbHVtZS4gUHJlZmVyIHRoZSBjYWxsYmFjayBzeW50YXggZm9yIHNldHRpbmcgdm9sdW1lIHRvIGdldCBiZXR0ZXIgdGltZWxpbmUgZGlzcGxheTogaHR0cHM6Ly93d3cucmVtb3Rpb24uZGV2L2RvY3MvdXNpbmctYXVkaW8vI2NvbnRyb2xsaW5nLXZvbHVtZWApO1xuICAgIH1cbiAgfSwgW2luaXRpYWxWb2x1bWUsIG1lZGlhVHlwZSwgc3JjLCB2b2x1bWVdKTtcbiAgdXNlRWZmZWN0OCgoKSA9PiB7XG4gICAgaWYgKCFtZWRpYVJlZi5jdXJyZW50KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICghc3JjKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJObyBzcmMgcGFzc2VkXCIpO1xuICAgIH1cbiAgICBpZiAoIWdldFJlbW90aW9uRW52aXJvbm1lbnQoKS5pc1N0dWRpbyAmJiB3aW5kb3cucHJvY2Vzcz8uZW52Py5OT0RFX0VOViAhPT0gXCJ0ZXN0XCIpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKCFzaG93SW5UaW1lbGluZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICByZWdpc3RlclNlcXVlbmNlKHtcbiAgICAgIHR5cGU6IG1lZGlhVHlwZSxcbiAgICAgIHNyYyxcbiAgICAgIGlkLFxuICAgICAgZHVyYXRpb24sXG4gICAgICBmcm9tOiAwLFxuICAgICAgcGFyZW50OiBwYXJlbnRTZXF1ZW5jZT8uaWQgPz8gbnVsbCxcbiAgICAgIGRpc3BsYXlOYW1lOiBkaXNwbGF5TmFtZSA/PyBnZXRBc3NldERpc3BsYXlOYW1lKHNyYyksXG4gICAgICByb290SWQsXG4gICAgICB2b2x1bWU6IHZvbHVtZXMsXG4gICAgICBzaG93SW5UaW1lbGluZTogdHJ1ZSxcbiAgICAgIG5vbmNlLFxuICAgICAgc3RhcnRNZWRpYUZyb206IDAgLSBzdGFydHNBdCxcbiAgICAgIGRvZXNWb2x1bWVDaGFuZ2UsXG4gICAgICBsb29wRGlzcGxheTogdW5kZWZpbmVkLFxuICAgICAgcGxheWJhY2tSYXRlLFxuICAgICAgc3RhY2ssXG4gICAgICBwcmVtb3VudERpc3BsYXlcbiAgICB9KTtcbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgdW5yZWdpc3RlclNlcXVlbmNlKGlkKTtcbiAgICB9O1xuICB9LCBbXG4gICAgYWN0dWFsRnJvbSxcbiAgICBkdXJhdGlvbixcbiAgICBpZCxcbiAgICBwYXJlbnRTZXF1ZW5jZSxcbiAgICBzcmMsXG4gICAgcmVnaXN0ZXJTZXF1ZW5jZSxcbiAgICByb290SWQsXG4gICAgdW5yZWdpc3RlclNlcXVlbmNlLFxuICAgIHZpZGVvQ29uZmlnLFxuICAgIHZvbHVtZXMsXG4gICAgZG9lc1ZvbHVtZUNoYW5nZSxcbiAgICBub25jZSxcbiAgICBtZWRpYVJlZixcbiAgICBtZWRpYVR5cGUsXG4gICAgc3RhcnRzQXQsXG4gICAgcGxheWJhY2tSYXRlLFxuICAgIGRpc3BsYXlOYW1lLFxuICAgIHN0YWNrLFxuICAgIHNob3dJblRpbWVsaW5lLFxuICAgIHByZW1vdW50RGlzcGxheVxuICBdKTtcbiAgdXNlRWZmZWN0OCgoKSA9PiB7XG4gICAgY29uc3QgdGFnID0ge1xuICAgICAgaWQsXG4gICAgICBwbGF5OiAoKSA9PiB7XG4gICAgICAgIGlmICghcGxheWluZykge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcGxheUFuZEhhbmRsZU5vdEFsbG93ZWRFcnJvcihtZWRpYVJlZiwgbWVkaWFUeXBlLCBvbkF1dG9QbGF5RXJyb3IpO1xuICAgICAgfVxuICAgIH07XG4gICAgYXVkaW9BbmRWaWRlb1RhZ3MuY3VycmVudC5wdXNoKHRhZyk7XG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgIGF1ZGlvQW5kVmlkZW9UYWdzLmN1cnJlbnQgPSBhdWRpb0FuZFZpZGVvVGFncy5jdXJyZW50LmZpbHRlcigoYSkgPT4gYS5pZCAhPT0gaWQpO1xuICAgIH07XG4gIH0sIFthdWRpb0FuZFZpZGVvVGFncywgaWQsIG1lZGlhUmVmLCBtZWRpYVR5cGUsIG9uQXV0b1BsYXlFcnJvciwgcGxheWluZ10pO1xufTtcblxuLy8gc3JjL3VzZS1tZWRpYS1wbGF5YmFjay50c1xuaW1wb3J0IHsgdXNlQ2FsbGJhY2sgYXMgdXNlQ2FsbGJhY2s3LCB1c2VDb250ZXh0IGFzIHVzZUNvbnRleHQxOCwgdXNlRWZmZWN0IGFzIHVzZUVmZmVjdDEyLCB1c2VSZWYgYXMgdXNlUmVmNiB9IGZyb20gXCJyZWFjdFwiO1xuXG4vLyBzcmMvYnVmZmVyLXVudGlsLWZpcnN0LWZyYW1lLnRzXG5pbXBvcnQgeyB1c2VDYWxsYmFjayBhcyB1c2VDYWxsYmFjazYsIHVzZU1lbW8gYXMgdXNlTWVtbzE3LCB1c2VSZWYgYXMgdXNlUmVmMyB9IGZyb20gXCJyZWFjdFwiO1xuXG4vLyBzcmMvdXNlLWJ1ZmZlci1zdGF0ZS50c1xuaW1wb3J0IHsgdXNlQ29udGV4dCBhcyB1c2VDb250ZXh0MTcsIHVzZU1lbW8gYXMgdXNlTWVtbzE2IH0gZnJvbSBcInJlYWN0XCI7XG5cbi8vIHNyYy9idWZmZXJpbmcudHN4XG5pbXBvcnQgUmVhY3QxMSwgeyB1c2VDYWxsYmFjayBhcyB1c2VDYWxsYmFjazUsIHVzZUVmZmVjdCBhcyB1c2VFZmZlY3Q5LCB1c2VNZW1vIGFzIHVzZU1lbW8xNSwgdXNlUmVmIGFzIHVzZVJlZjIsIHVzZVN0YXRlIGFzIHVzZVN0YXRlMTAgfSBmcm9tIFwicmVhY3RcIjtcbmltcG9ydCB7IGpzeCBhcyBqc3gxNCB9IGZyb20gXCJyZWFjdC9qc3gtcnVudGltZVwiO1xudmFyIHVzZUJ1ZmZlck1hbmFnZXIgPSAoKSA9PiB7XG4gIGNvbnN0IFtibG9ja3MsIHNldEJsb2Nrc10gPSB1c2VTdGF0ZTEwKFtdKTtcbiAgY29uc3QgW29uQnVmZmVyaW5nQ2FsbGJhY2tzLCBzZXRPbkJ1ZmZlcmluZ0NhbGxiYWNrc10gPSB1c2VTdGF0ZTEwKFtdKTtcbiAgY29uc3QgW29uUmVzdW1lQ2FsbGJhY2tzLCBzZXRPblJlc3VtZUNhbGxiYWNrc10gPSB1c2VTdGF0ZTEwKFtdKTtcbiAgY29uc3QgYnVmZmVyaW5nID0gdXNlUmVmMihmYWxzZSk7XG4gIGNvbnN0IGFkZEJsb2NrID0gdXNlQ2FsbGJhY2s1KChibG9jaykgPT4ge1xuICAgIHNldEJsb2NrcygoYikgPT4gWy4uLmIsIGJsb2NrXSk7XG4gICAgcmV0dXJuIHtcbiAgICAgIHVuYmxvY2s6ICgpID0+IHtcbiAgICAgICAgc2V0QmxvY2tzKChiKSA9PiB7XG4gICAgICAgICAgY29uc3QgbmV3QXJyID0gYi5maWx0ZXIoKGJ4KSA9PiBieCAhPT0gYmxvY2spO1xuICAgICAgICAgIGlmIChuZXdBcnIubGVuZ3RoID09PSBiLmxlbmd0aCkge1xuICAgICAgICAgICAgcmV0dXJuIGI7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBuZXdBcnI7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH07XG4gIH0sIFtdKTtcbiAgY29uc3QgbGlzdGVuRm9yQnVmZmVyaW5nID0gdXNlQ2FsbGJhY2s1KChjYWxsYmFjaykgPT4ge1xuICAgIHNldE9uQnVmZmVyaW5nQ2FsbGJhY2tzKChjKSA9PiBbLi4uYywgY2FsbGJhY2tdKTtcbiAgICByZXR1cm4ge1xuICAgICAgcmVtb3ZlOiAoKSA9PiB7XG4gICAgICAgIHNldE9uQnVmZmVyaW5nQ2FsbGJhY2tzKChjKSA9PiBjLmZpbHRlcigoY2IpID0+IGNiICE9PSBjYWxsYmFjaykpO1xuICAgICAgfVxuICAgIH07XG4gIH0sIFtdKTtcbiAgY29uc3QgbGlzdGVuRm9yUmVzdW1lID0gdXNlQ2FsbGJhY2s1KChjYWxsYmFjaykgPT4ge1xuICAgIHNldE9uUmVzdW1lQ2FsbGJhY2tzKChjKSA9PiBbLi4uYywgY2FsbGJhY2tdKTtcbiAgICByZXR1cm4ge1xuICAgICAgcmVtb3ZlOiAoKSA9PiB7XG4gICAgICAgIHNldE9uUmVzdW1lQ2FsbGJhY2tzKChjKSA9PiBjLmZpbHRlcigoY2IpID0+IGNiICE9PSBjYWxsYmFjaykpO1xuICAgICAgfVxuICAgIH07XG4gIH0sIFtdKTtcbiAgdXNlRWZmZWN0OSgoKSA9PiB7XG4gICAgaWYgKGJsb2Nrcy5sZW5ndGggPiAwKSB7XG4gICAgICBvbkJ1ZmZlcmluZ0NhbGxiYWNrcy5mb3JFYWNoKChjKSA9PiBjKCkpO1xuICAgIH1cbiAgfSwgW2Jsb2Nrc10pO1xuICB1c2VFZmZlY3Q5KCgpID0+IHtcbiAgICBpZiAoYmxvY2tzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgb25SZXN1bWVDYWxsYmFja3MuZm9yRWFjaCgoYykgPT4gYygpKTtcbiAgICB9XG4gIH0sIFtibG9ja3NdKTtcbiAgcmV0dXJuIHVzZU1lbW8xNSgoKSA9PiB7XG4gICAgcmV0dXJuIHsgYWRkQmxvY2ssIGxpc3RlbkZvckJ1ZmZlcmluZywgbGlzdGVuRm9yUmVzdW1lLCBidWZmZXJpbmcgfTtcbiAgfSwgW2FkZEJsb2NrLCBidWZmZXJpbmcsIGxpc3RlbkZvckJ1ZmZlcmluZywgbGlzdGVuRm9yUmVzdW1lXSk7XG59O1xudmFyIEJ1ZmZlcmluZ0NvbnRleHRSZWFjdCA9IFJlYWN0MTEuY3JlYXRlQ29udGV4dChudWxsKTtcbnZhciBCdWZmZXJpbmdQcm92aWRlciA9ICh7IGNoaWxkcmVuIH0pID0+IHtcbiAgY29uc3QgYnVmZmVyTWFuYWdlciA9IHVzZUJ1ZmZlck1hbmFnZXIoKTtcbiAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqLyBqc3gxNChCdWZmZXJpbmdDb250ZXh0UmVhY3QuUHJvdmlkZXIsIHtcbiAgICB2YWx1ZTogYnVmZmVyTWFuYWdlcixcbiAgICBjaGlsZHJlblxuICB9KTtcbn07XG52YXIgdXNlSXNQbGF5ZXJCdWZmZXJpbmcgPSAoYnVmZmVyTWFuYWdlcikgPT4ge1xuICBjb25zdCBbaXNCdWZmZXJpbmcsIHNldElzQnVmZmVyaW5nXSA9IHVzZVN0YXRlMTAoYnVmZmVyTWFuYWdlci5idWZmZXJpbmcuY3VycmVudCk7XG4gIHVzZUVmZmVjdDkoKCkgPT4ge1xuICAgIGNvbnN0IG9uQnVmZmVyID0gKCkgPT4ge1xuICAgICAgc2V0SXNCdWZmZXJpbmcodHJ1ZSk7XG4gICAgfTtcbiAgICBjb25zdCBvblJlc3VtZSA9ICgpID0+IHtcbiAgICAgIHNldElzQnVmZmVyaW5nKGZhbHNlKTtcbiAgICB9O1xuICAgIGJ1ZmZlck1hbmFnZXIubGlzdGVuRm9yQnVmZmVyaW5nKG9uQnVmZmVyKTtcbiAgICBidWZmZXJNYW5hZ2VyLmxpc3RlbkZvclJlc3VtZShvblJlc3VtZSk7XG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgIGJ1ZmZlck1hbmFnZXIubGlzdGVuRm9yQnVmZmVyaW5nKCgpID0+IHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfSk7XG4gICAgICBidWZmZXJNYW5hZ2VyLmxpc3RlbkZvclJlc3VtZSgoKSA9PiB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH0pO1xuICAgIH07XG4gIH0sIFtidWZmZXJNYW5hZ2VyXSk7XG4gIHJldHVybiBpc0J1ZmZlcmluZztcbn07XG5cbi8vIHNyYy91c2UtYnVmZmVyLXN0YXRlLnRzXG52YXIgdXNlQnVmZmVyU3RhdGUgPSAoKSA9PiB7XG4gIGNvbnN0IGJ1ZmZlciA9IHVzZUNvbnRleHQxNyhCdWZmZXJpbmdDb250ZXh0UmVhY3QpO1xuICBjb25zdCBhZGRCbG9jayA9IGJ1ZmZlciA/IGJ1ZmZlci5hZGRCbG9jayA6IG51bGw7XG4gIHJldHVybiB1c2VNZW1vMTYoKCkgPT4gKHtcbiAgICBkZWxheVBsYXliYWNrOiAoKSA9PiB7XG4gICAgICBpZiAoIWFkZEJsb2NrKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIlRyaWVkIHRvIGVuYWJsZSB0aGUgYnVmZmVyaW5nIHN0YXRlLCBidXQgYSBSZW1vdGlvbiBjb250ZXh0IHdhcyBub3QgZm91bmQuIFRoaXMgQVBJIGNhbiBvbmx5IGJlIGNhbGxlZCBpbiBhIGNvbXBvbmVudCB0aGF0IHdhcyBwYXNzZWQgdG8gdGhlIFJlbW90aW9uIFBsYXllciBvciBhIDxDb21wb3NpdGlvbj4uIE9yIHlvdSBtaWdodCBoYXZlIGV4cGVyaWVuY2VkIGEgdmVyc2lvbiBtaXNtYXRjaCAtIHJ1biBgbnB4IHJlbW90aW9uIHZlcnNpb25zYCBhbmQgZW5zdXJlIGFsbCBwYWNrYWdlcyBoYXZlIHRoZSBzYW1lIHZlcnNpb24uIFRoaXMgZXJyb3IgaXMgdGhyb3duIGJ5IHRoZSBidWZmZXIgc3RhdGUgaHR0cHM6Ly9yZW1vdGlvbi5kZXYvZG9jcy9wbGF5ZXIvYnVmZmVyLXN0YXRlXCIpO1xuICAgICAgfVxuICAgICAgY29uc3QgeyB1bmJsb2NrIH0gPSBhZGRCbG9jayh7XG4gICAgICAgIGlkOiBTdHJpbmcoTWF0aC5yYW5kb20oKSlcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIHsgdW5ibG9jayB9O1xuICAgIH1cbiAgfSksIFthZGRCbG9ja10pO1xufTtcblxuLy8gc3JjL2J1ZmZlci11bnRpbC1maXJzdC1mcmFtZS50c1xudmFyIHVzZUJ1ZmZlclVudGlsRmlyc3RGcmFtZSA9ICh7XG4gIG1lZGlhUmVmLFxuICBtZWRpYVR5cGUsXG4gIG9uVmFyaWFibGVGcHNWaWRlb0RldGVjdGVkLFxuICBwYXVzZVdoZW5CdWZmZXJpbmdcbn0pID0+IHtcbiAgY29uc3QgYnVmZmVyaW5nUmVmID0gdXNlUmVmMyhmYWxzZSk7XG4gIGNvbnN0IHsgZGVsYXlQbGF5YmFjayB9ID0gdXNlQnVmZmVyU3RhdGUoKTtcbiAgY29uc3QgYnVmZmVyVW50aWxGaXJzdEZyYW1lID0gdXNlQ2FsbGJhY2s2KChyZXF1ZXN0ZWRUaW1lKSA9PiB7XG4gICAgaWYgKG1lZGlhVHlwZSAhPT0gXCJ2aWRlb1wiKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICghcGF1c2VXaGVuQnVmZmVyaW5nKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IGN1cnJlbnQgPSBtZWRpYVJlZi5jdXJyZW50O1xuICAgIGlmICghY3VycmVudCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoIWN1cnJlbnQucmVxdWVzdFZpZGVvRnJhbWVDYWxsYmFjaykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBidWZmZXJpbmdSZWYuY3VycmVudCA9IHRydWU7XG4gICAgY29uc3QgcGxheWJhY2sgPSBkZWxheVBsYXliYWNrKCk7XG4gICAgY29uc3QgdW5ibG9jayA9ICgpID0+IHtcbiAgICAgIHBsYXliYWNrLnVuYmxvY2soKTtcbiAgICAgIGN1cnJlbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImVuZGVkXCIsIHVuYmxvY2ssIHtcbiAgICAgICAgb25jZTogdHJ1ZVxuICAgICAgfSk7XG4gICAgICBjdXJyZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJwYXVzZVwiLCB1bmJsb2NrLCB7XG4gICAgICAgIG9uY2U6IHRydWVcbiAgICAgIH0pO1xuICAgICAgYnVmZmVyaW5nUmVmLmN1cnJlbnQgPSBmYWxzZTtcbiAgICB9O1xuICAgIGNvbnN0IG9uRW5kZWRPclBhdXNlT3JDYW5QbGF5ID0gKCkgPT4ge1xuICAgICAgdW5ibG9jaygpO1xuICAgIH07XG4gICAgY3VycmVudC5yZXF1ZXN0VmlkZW9GcmFtZUNhbGxiYWNrKChfLCBpbmZvKSA9PiB7XG4gICAgICBjb25zdCBkaWZmZXJlbmNlRnJvbVJlcXVlc3RlZCA9IE1hdGguYWJzKGluZm8ubWVkaWFUaW1lIC0gcmVxdWVzdGVkVGltZSk7XG4gICAgICBpZiAoZGlmZmVyZW5jZUZyb21SZXF1ZXN0ZWQgPiAwLjUpIHtcbiAgICAgICAgb25WYXJpYWJsZUZwc1ZpZGVvRGV0ZWN0ZWQoKTtcbiAgICAgIH1cbiAgICAgIHVuYmxvY2soKTtcbiAgICB9KTtcbiAgICBjdXJyZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJlbmRlZFwiLCBvbkVuZGVkT3JQYXVzZU9yQ2FuUGxheSwgeyBvbmNlOiB0cnVlIH0pO1xuICAgIGN1cnJlbnQuYWRkRXZlbnRMaXN0ZW5lcihcInBhdXNlXCIsIG9uRW5kZWRPclBhdXNlT3JDYW5QbGF5LCB7IG9uY2U6IHRydWUgfSk7XG4gICAgY3VycmVudC5hZGRFdmVudExpc3RlbmVyKFwiY2FucGxheVwiLCBvbkVuZGVkT3JQYXVzZU9yQ2FuUGxheSwge1xuICAgICAgb25jZTogdHJ1ZVxuICAgIH0pO1xuICB9LCBbXG4gICAgZGVsYXlQbGF5YmFjayxcbiAgICBtZWRpYVJlZixcbiAgICBtZWRpYVR5cGUsXG4gICAgb25WYXJpYWJsZUZwc1ZpZGVvRGV0ZWN0ZWQsXG4gICAgcGF1c2VXaGVuQnVmZmVyaW5nXG4gIF0pO1xuICByZXR1cm4gdXNlTWVtbzE3KCgpID0+IHtcbiAgICByZXR1cm4ge1xuICAgICAgaXNCdWZmZXJpbmc6ICgpID0+IGJ1ZmZlcmluZ1JlZi5jdXJyZW50LFxuICAgICAgYnVmZmVyVW50aWxGaXJzdEZyYW1lXG4gICAgfTtcbiAgfSwgW2J1ZmZlclVudGlsRmlyc3RGcmFtZV0pO1xufTtcblxuLy8gc3JjL3VzZS1tZWRpYS1idWZmZXJpbmcudHNcbmltcG9ydCB7IHVzZUVmZmVjdCBhcyB1c2VFZmZlY3QxMCwgdXNlU3RhdGUgYXMgdXNlU3RhdGUxMSB9IGZyb20gXCJyZWFjdFwiO1xudmFyIHVzZU1lZGlhQnVmZmVyaW5nID0gKHtcbiAgZWxlbWVudCxcbiAgc2hvdWxkQnVmZmVyLFxuICBpc1ByZW1vdW50aW5nXG59KSA9PiB7XG4gIGNvbnN0IGJ1ZmZlciA9IHVzZUJ1ZmZlclN0YXRlKCk7XG4gIGNvbnN0IFtpc0J1ZmZlcmluZywgc2V0SXNCdWZmZXJpbmddID0gdXNlU3RhdGUxMShmYWxzZSk7XG4gIHVzZUVmZmVjdDEwKCgpID0+IHtcbiAgICBsZXQgY2xlYW51cEZucyA9IFtdO1xuICAgIGNvbnN0IHsgY3VycmVudCB9ID0gZWxlbWVudDtcbiAgICBpZiAoIWN1cnJlbnQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKCFzaG91bGRCdWZmZXIpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKGlzUHJlbW91bnRpbmcpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgY2xlYW51cCA9ICgpID0+IHtcbiAgICAgIGNsZWFudXBGbnMuZm9yRWFjaCgoZm4pID0+IGZuKCkpO1xuICAgICAgY2xlYW51cEZucyA9IFtdO1xuICAgICAgc2V0SXNCdWZmZXJpbmcoZmFsc2UpO1xuICAgIH07XG4gICAgY29uc3Qgb25XYWl0aW5nID0gKCkgPT4ge1xuICAgICAgc2V0SXNCdWZmZXJpbmcodHJ1ZSk7XG4gICAgICBjb25zdCB7IHVuYmxvY2sgfSA9IGJ1ZmZlci5kZWxheVBsYXliYWNrKCk7XG4gICAgICBjb25zdCBvbkNhblBsYXkgPSAoKSA9PiB7XG4gICAgICAgIGNsZWFudXAoKTtcbiAgICAgICAgaW5pdCgpO1xuICAgICAgfTtcbiAgICAgIGNvbnN0IG9uRXJyb3IgPSAoKSA9PiB7XG4gICAgICAgIGNsZWFudXAoKTtcbiAgICAgICAgaW5pdCgpO1xuICAgICAgfTtcbiAgICAgIGN1cnJlbnQuYWRkRXZlbnRMaXN0ZW5lcihcImNhbnBsYXlcIiwgb25DYW5QbGF5LCB7XG4gICAgICAgIG9uY2U6IHRydWVcbiAgICAgIH0pO1xuICAgICAgY2xlYW51cEZucy5wdXNoKCgpID0+IHtcbiAgICAgICAgY3VycmVudC5yZW1vdmVFdmVudExpc3RlbmVyKFwiY2FucGxheVwiLCBvbkNhblBsYXkpO1xuICAgICAgfSk7XG4gICAgICBjdXJyZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJlcnJvclwiLCBvbkVycm9yLCB7XG4gICAgICAgIG9uY2U6IHRydWVcbiAgICAgIH0pO1xuICAgICAgY2xlYW51cEZucy5wdXNoKCgpID0+IHtcbiAgICAgICAgY3VycmVudC5yZW1vdmVFdmVudExpc3RlbmVyKFwiZXJyb3JcIiwgb25FcnJvcik7XG4gICAgICB9KTtcbiAgICAgIGNsZWFudXBGbnMucHVzaCgoKSA9PiB7XG4gICAgICAgIHVuYmxvY2soKTtcbiAgICAgIH0pO1xuICAgIH07XG4gICAgY29uc3QgaW5pdCA9ICgpID0+IHtcbiAgICAgIGlmIChjdXJyZW50LnJlYWR5U3RhdGUgPCBjdXJyZW50LkhBVkVfRlVUVVJFX0RBVEEpIHtcbiAgICAgICAgb25XYWl0aW5nKCk7XG4gICAgICAgIGlmICghbmF2aWdhdG9yLnVzZXJBZ2VudC5pbmNsdWRlcyhcIkZpcmVmb3gvXCIpKSB7XG4gICAgICAgICAgY3VycmVudC5sb2FkKCk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGN1cnJlbnQuYWRkRXZlbnRMaXN0ZW5lcihcIndhaXRpbmdcIiwgb25XYWl0aW5nKTtcbiAgICAgICAgY2xlYW51cEZucy5wdXNoKCgpID0+IHtcbiAgICAgICAgICBjdXJyZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJ3YWl0aW5nXCIsIG9uV2FpdGluZyk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH07XG4gICAgaW5pdCgpO1xuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICBjbGVhbnVwKCk7XG4gICAgfTtcbiAgfSwgW2J1ZmZlciwgZWxlbWVudCwgaXNQcmVtb3VudGluZywgc2hvdWxkQnVmZmVyXSk7XG4gIHJldHVybiBpc0J1ZmZlcmluZztcbn07XG5cbi8vIHNyYy91c2UtcmVxdWVzdC12aWRlby1jYWxsYmFjay10aW1lLnRzXG5pbXBvcnQgeyB1c2VFZmZlY3QgYXMgdXNlRWZmZWN0MTEsIHVzZVJlZiBhcyB1c2VSZWY0IH0gZnJvbSBcInJlYWN0XCI7XG52YXIgdXNlUmVxdWVzdFZpZGVvQ2FsbGJhY2tUaW1lID0gKHtcbiAgbWVkaWFSZWYsXG4gIG1lZGlhVHlwZSxcbiAgbGFzdFNlZWssXG4gIG9uVmFyaWFibGVGcHNWaWRlb0RldGVjdGVkXG59KSA9PiB7XG4gIGNvbnN0IGN1cnJlbnRUaW1lID0gdXNlUmVmNChudWxsKTtcbiAgdXNlRWZmZWN0MTEoKCkgPT4ge1xuICAgIGNvbnN0IHsgY3VycmVudCB9ID0gbWVkaWFSZWY7XG4gICAgaWYgKGN1cnJlbnQpIHtcbiAgICAgIGN1cnJlbnRUaW1lLmN1cnJlbnQgPSBjdXJyZW50LmN1cnJlbnRUaW1lO1xuICAgIH0gZWxzZSB7XG4gICAgICBjdXJyZW50VGltZS5jdXJyZW50ID0gbnVsbDtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKG1lZGlhVHlwZSAhPT0gXCJ2aWRlb1wiKSB7XG4gICAgICBjdXJyZW50VGltZS5jdXJyZW50ID0gbnVsbDtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgdmlkZW9UYWcgPSBjdXJyZW50O1xuICAgIGlmICghdmlkZW9UYWcucmVxdWVzdFZpZGVvRnJhbWVDYWxsYmFjaykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBsZXQgY2FuY2VsID0gKCkgPT4ge1xuICAgICAgcmV0dXJuO1xuICAgIH07XG4gICAgY29uc3QgcmVxdWVzdCA9ICgpID0+IHtcbiAgICAgIGlmICghdmlkZW9UYWcpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgY29uc3QgY2IgPSB2aWRlb1RhZy5yZXF1ZXN0VmlkZW9GcmFtZUNhbGxiYWNrKChfLCBpbmZvKSA9PiB7XG4gICAgICAgIGlmIChjdXJyZW50VGltZS5jdXJyZW50ICE9PSBudWxsKSB7XG4gICAgICAgICAgY29uc3QgZGlmZmVyZW5jZSA9IE1hdGguYWJzKGN1cnJlbnRUaW1lLmN1cnJlbnQgLSBpbmZvLm1lZGlhVGltZSk7XG4gICAgICAgICAgY29uc3QgZGlmZmVyZW5jZVRvTGFzdFNlZWsgPSBNYXRoLmFicyhsYXN0U2Vlay5jdXJyZW50ID09PSBudWxsID8gSW5maW5pdHkgOiBpbmZvLm1lZGlhVGltZSAtIGxhc3RTZWVrLmN1cnJlbnQpO1xuICAgICAgICAgIGlmIChkaWZmZXJlbmNlID4gMC41ICYmIGRpZmZlcmVuY2VUb0xhc3RTZWVrID4gMC41ICYmIGluZm8ubWVkaWFUaW1lID4gY3VycmVudFRpbWUuY3VycmVudCkge1xuICAgICAgICAgICAgb25WYXJpYWJsZUZwc1ZpZGVvRGV0ZWN0ZWQoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY3VycmVudFRpbWUuY3VycmVudCA9IGluZm8ubWVkaWFUaW1lO1xuICAgICAgICByZXF1ZXN0KCk7XG4gICAgICB9KTtcbiAgICAgIGNhbmNlbCA9ICgpID0+IHtcbiAgICAgICAgdmlkZW9UYWcuY2FuY2VsVmlkZW9GcmFtZUNhbGxiYWNrKGNiKTtcbiAgICAgICAgY2FuY2VsID0gKCkgPT4ge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfTtcbiAgICAgIH07XG4gICAgfTtcbiAgICByZXF1ZXN0KCk7XG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgIGNhbmNlbCgpO1xuICAgIH07XG4gIH0sIFtsYXN0U2VlaywgbWVkaWFSZWYsIG1lZGlhVHlwZSwgb25WYXJpYWJsZUZwc1ZpZGVvRGV0ZWN0ZWRdKTtcbiAgcmV0dXJuIGN1cnJlbnRUaW1lO1xufTtcblxuLy8gc3JjL2ludGVycG9sYXRlLnRzXG5mdW5jdGlvbiBpbnRlcnBvbGF0ZUZ1bmN0aW9uKGlucHV0LCBpbnB1dFJhbmdlLCBvdXRwdXRSYW5nZSwgb3B0aW9ucykge1xuICBjb25zdCB7IGV4dHJhcG9sYXRlTGVmdCwgZXh0cmFwb2xhdGVSaWdodCwgZWFzaW5nIH0gPSBvcHRpb25zO1xuICBsZXQgcmVzdWx0ID0gaW5wdXQ7XG4gIGNvbnN0IFtpbnB1dE1pbiwgaW5wdXRNYXhdID0gaW5wdXRSYW5nZTtcbiAgY29uc3QgW291dHB1dE1pbiwgb3V0cHV0TWF4XSA9IG91dHB1dFJhbmdlO1xuICBpZiAocmVzdWx0IDwgaW5wdXRNaW4pIHtcbiAgICBpZiAoZXh0cmFwb2xhdGVMZWZ0ID09PSBcImlkZW50aXR5XCIpIHtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIGlmIChleHRyYXBvbGF0ZUxlZnQgPT09IFwiY2xhbXBcIikge1xuICAgICAgcmVzdWx0ID0gaW5wdXRNaW47XG4gICAgfSBlbHNlIGlmIChleHRyYXBvbGF0ZUxlZnQgPT09IFwid3JhcFwiKSB7XG4gICAgICBjb25zdCByYW5nZSA9IGlucHV0TWF4IC0gaW5wdXRNaW47XG4gICAgICByZXN1bHQgPSAoKHJlc3VsdCAtIGlucHV0TWluKSAlIHJhbmdlICsgcmFuZ2UpICUgcmFuZ2UgKyBpbnB1dE1pbjtcbiAgICB9IGVsc2UgaWYgKGV4dHJhcG9sYXRlTGVmdCA9PT0gXCJleHRlbmRcIikge1xuICAgIH1cbiAgfVxuICBpZiAocmVzdWx0ID4gaW5wdXRNYXgpIHtcbiAgICBpZiAoZXh0cmFwb2xhdGVSaWdodCA9PT0gXCJpZGVudGl0eVwiKSB7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICBpZiAoZXh0cmFwb2xhdGVSaWdodCA9PT0gXCJjbGFtcFwiKSB7XG4gICAgICByZXN1bHQgPSBpbnB1dE1heDtcbiAgICB9IGVsc2UgaWYgKGV4dHJhcG9sYXRlUmlnaHQgPT09IFwid3JhcFwiKSB7XG4gICAgICBjb25zdCByYW5nZSA9IGlucHV0TWF4IC0gaW5wdXRNaW47XG4gICAgICByZXN1bHQgPSAoKHJlc3VsdCAtIGlucHV0TWluKSAlIHJhbmdlICsgcmFuZ2UpICUgcmFuZ2UgKyBpbnB1dE1pbjtcbiAgICB9IGVsc2UgaWYgKGV4dHJhcG9sYXRlUmlnaHQgPT09IFwiZXh0ZW5kXCIpIHtcbiAgICB9XG4gIH1cbiAgaWYgKG91dHB1dE1pbiA9PT0gb3V0cHV0TWF4KSB7XG4gICAgcmV0dXJuIG91dHB1dE1pbjtcbiAgfVxuICByZXN1bHQgPSAocmVzdWx0IC0gaW5wdXRNaW4pIC8gKGlucHV0TWF4IC0gaW5wdXRNaW4pO1xuICByZXN1bHQgPSBlYXNpbmcocmVzdWx0KTtcbiAgcmVzdWx0ID0gcmVzdWx0ICogKG91dHB1dE1heCAtIG91dHB1dE1pbikgKyBvdXRwdXRNaW47XG4gIHJldHVybiByZXN1bHQ7XG59XG5mdW5jdGlvbiBmaW5kUmFuZ2UoaW5wdXQsIGlucHV0UmFuZ2UpIHtcbiAgbGV0IGk7XG4gIGZvciAoaSA9IDE7aSA8IGlucHV0UmFuZ2UubGVuZ3RoIC0gMTsgKytpKSB7XG4gICAgaWYgKGlucHV0UmFuZ2VbaV0gPj0gaW5wdXQpIHtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuICByZXR1cm4gaSAtIDE7XG59XG5mdW5jdGlvbiBjaGVja1ZhbGlkSW5wdXRSYW5nZShhcnIpIHtcbiAgZm9yIChsZXQgaSA9IDE7aSA8IGFyci5sZW5ndGg7ICsraSkge1xuICAgIGlmICghKGFycltpXSA+IGFycltpIC0gMV0pKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYGlucHV0UmFuZ2UgbXVzdCBiZSBzdHJpY3RseSBtb25vdG9uaWNhbGx5IGluY3JlYXNpbmcgYnV0IGdvdCBbJHthcnIuam9pbihcIixcIil9XWApO1xuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gY2hlY2tJbmZpbml0ZVJhbmdlKG5hbWUsIGFycikge1xuICBpZiAoYXJyLmxlbmd0aCA8IDIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IobmFtZSArIFwiIG11c3QgaGF2ZSBhdCBsZWFzdCAyIGVsZW1lbnRzXCIpO1xuICB9XG4gIGZvciAoY29uc3QgZWxlbWVudCBvZiBhcnIpIHtcbiAgICBpZiAodHlwZW9mIGVsZW1lbnQgIT09IFwibnVtYmVyXCIpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgJHtuYW1lfSBtdXN0IGNvbnRhaW4gb25seSBudW1iZXJzYCk7XG4gICAgfVxuICAgIGlmICghTnVtYmVyLmlzRmluaXRlKGVsZW1lbnQpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYCR7bmFtZX0gbXVzdCBjb250YWluIG9ubHkgZmluaXRlIG51bWJlcnMsIGJ1dCBnb3QgWyR7YXJyLmpvaW4oXCIsXCIpfV1gKTtcbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIGludGVycG9sYXRlKGlucHV0LCBpbnB1dFJhbmdlLCBvdXRwdXRSYW5nZSwgb3B0aW9ucykge1xuICBpZiAodHlwZW9mIGlucHV0ID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiaW5wdXQgY2FuIG5vdCBiZSB1bmRlZmluZWRcIik7XG4gIH1cbiAgaWYgKHR5cGVvZiBpbnB1dFJhbmdlID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiaW5wdXRSYW5nZSBjYW4gbm90IGJlIHVuZGVmaW5lZFwiKTtcbiAgfVxuICBpZiAodHlwZW9mIG91dHB1dFJhbmdlID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwib3V0cHV0UmFuZ2UgY2FuIG5vdCBiZSB1bmRlZmluZWRcIik7XG4gIH1cbiAgaWYgKGlucHV0UmFuZ2UubGVuZ3RoICE9PSBvdXRwdXRSYW5nZS5sZW5ndGgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJpbnB1dFJhbmdlIChcIiArIGlucHV0UmFuZ2UubGVuZ3RoICsgXCIpIGFuZCBvdXRwdXRSYW5nZSAoXCIgKyBvdXRwdXRSYW5nZS5sZW5ndGggKyBcIikgbXVzdCBoYXZlIHRoZSBzYW1lIGxlbmd0aFwiKTtcbiAgfVxuICBjaGVja0luZmluaXRlUmFuZ2UoXCJpbnB1dFJhbmdlXCIsIGlucHV0UmFuZ2UpO1xuICBjaGVja0luZmluaXRlUmFuZ2UoXCJvdXRwdXRSYW5nZVwiLCBvdXRwdXRSYW5nZSk7XG4gIGNoZWNrVmFsaWRJbnB1dFJhbmdlKGlucHV0UmFuZ2UpO1xuICBjb25zdCBlYXNpbmcgPSBvcHRpb25zPy5lYXNpbmcgPz8gKChudW0pID0+IG51bSk7XG4gIGxldCBleHRyYXBvbGF0ZUxlZnQgPSBcImV4dGVuZFwiO1xuICBpZiAob3B0aW9ucz8uZXh0cmFwb2xhdGVMZWZ0ICE9PSB1bmRlZmluZWQpIHtcbiAgICBleHRyYXBvbGF0ZUxlZnQgPSBvcHRpb25zLmV4dHJhcG9sYXRlTGVmdDtcbiAgfVxuICBsZXQgZXh0cmFwb2xhdGVSaWdodCA9IFwiZXh0ZW5kXCI7XG4gIGlmIChvcHRpb25zPy5leHRyYXBvbGF0ZVJpZ2h0ICE9PSB1bmRlZmluZWQpIHtcbiAgICBleHRyYXBvbGF0ZVJpZ2h0ID0gb3B0aW9ucy5leHRyYXBvbGF0ZVJpZ2h0O1xuICB9XG4gIGlmICh0eXBlb2YgaW5wdXQgIT09IFwibnVtYmVyXCIpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGludGVycG9sYXRlIGFuIGlucHV0IHdoaWNoIGlzIG5vdCBhIG51bWJlclwiKTtcbiAgfVxuICBjb25zdCByYW5nZSA9IGZpbmRSYW5nZShpbnB1dCwgaW5wdXRSYW5nZSk7XG4gIHJldHVybiBpbnRlcnBvbGF0ZUZ1bmN0aW9uKGlucHV0LCBbaW5wdXRSYW5nZVtyYW5nZV0sIGlucHV0UmFuZ2VbcmFuZ2UgKyAxXV0sIFtvdXRwdXRSYW5nZVtyYW5nZV0sIG91dHB1dFJhbmdlW3JhbmdlICsgMV1dLCB7XG4gICAgZWFzaW5nLFxuICAgIGV4dHJhcG9sYXRlTGVmdCxcbiAgICBleHRyYXBvbGF0ZVJpZ2h0XG4gIH0pO1xufVxuXG4vLyBzcmMvdmlkZW8vZ2V0LWN1cnJlbnQtdGltZS50c1xudmFyIGdldEV4cGVjdGVkTWVkaWFGcmFtZVVuY29ycmVjdGVkID0gKHtcbiAgZnJhbWUsXG4gIHBsYXliYWNrUmF0ZSxcbiAgc3RhcnRGcm9tXG59KSA9PiB7XG4gIHJldHVybiBpbnRlcnBvbGF0ZShmcmFtZSwgWy0xLCBzdGFydEZyb20sIHN0YXJ0RnJvbSArIDFdLCBbLTEsIHN0YXJ0RnJvbSwgc3RhcnRGcm9tICsgcGxheWJhY2tSYXRlXSk7XG59O1xudmFyIGdldE1lZGlhVGltZSA9ICh7XG4gIGZwcyxcbiAgZnJhbWUsXG4gIHBsYXliYWNrUmF0ZSxcbiAgc3RhcnRGcm9tXG59KSA9PiB7XG4gIGNvbnN0IGV4cGVjdGVkRnJhbWUgPSBnZXRFeHBlY3RlZE1lZGlhRnJhbWVVbmNvcnJlY3RlZCh7XG4gICAgZnJhbWUsXG4gICAgcGxheWJhY2tSYXRlLFxuICAgIHN0YXJ0RnJvbVxuICB9KTtcbiAgY29uc3QgbXNQZXJGcmFtZSA9IDEwMDAgLyBmcHM7XG4gIHJldHVybiBleHBlY3RlZEZyYW1lICogbXNQZXJGcmFtZSAvIDEwMDA7XG59O1xuXG4vLyBzcmMvdmlkZW8vdmlkZW8tZnJhZ21lbnQudHNcbmltcG9ydCB7IHVzZVJlZiBhcyB1c2VSZWY1IH0gZnJvbSBcInJlYWN0XCI7XG52YXIgdG9TZWNvbmRzID0gKHRpbWUsIGZwcykgPT4ge1xuICByZXR1cm4gTWF0aC5yb3VuZCh0aW1lIC8gZnBzICogMTAwKSAvIDEwMDtcbn07XG52YXIgaXNJb3NTYWZhcmkgPSAoKSA9PiB7XG4gIGlmICh0eXBlb2Ygd2luZG93ID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGNvbnN0IGlzSXBhZElQb2RJUGhvbmUgPSAvaVAoYWR8b2R8aG9uZSkvaS50ZXN0KHdpbmRvdy5uYXZpZ2F0b3IudXNlckFnZW50KTtcbiAgY29uc3QgaXNBcHBsZVdlYktpdCA9IC9BcHBsZVdlYktpdC8udGVzdCh3aW5kb3cubmF2aWdhdG9yLnVzZXJBZ2VudCk7XG4gIHJldHVybiBpc0lwYWRJUG9kSVBob25lICYmIGlzQXBwbGVXZWJLaXQ7XG59O1xudmFyIGlzSU9TU2FmYXJpQW5kQmxvYiA9IChhY3R1YWxTcmMpID0+IHtcbiAgcmV0dXJuIGlzSW9zU2FmYXJpKCkgJiYgYWN0dWFsU3JjLnN0YXJ0c1dpdGgoXCJibG9iOlwiKTtcbn07XG52YXIgZ2V0VmlkZW9GcmFnbWVudFN0YXJ0ID0gKHtcbiAgYWN0dWFsRnJvbSxcbiAgZnBzXG59KSA9PiB7XG4gIHJldHVybiB0b1NlY29uZHMoTWF0aC5tYXgoMCwgLWFjdHVhbEZyb20pLCBmcHMpO1xufTtcbnZhciBnZXRWaWRlb0ZyYWdtZW50RW5kID0gKHtcbiAgZHVyYXRpb24sXG4gIGZwc1xufSkgPT4ge1xuICByZXR1cm4gdG9TZWNvbmRzKGR1cmF0aW9uLCBmcHMpO1xufTtcbnZhciBhcHBlbmRWaWRlb0ZyYWdtZW50ID0gKHtcbiAgYWN0dWFsU3JjLFxuICBhY3R1YWxGcm9tLFxuICBkdXJhdGlvbixcbiAgZnBzXG59KSA9PiB7XG4gIGlmIChpc0lPU1NhZmFyaUFuZEJsb2IoYWN0dWFsU3JjKSkge1xuICAgIHJldHVybiBhY3R1YWxTcmM7XG4gIH1cbiAgaWYgKGFjdHVhbFNyYy5zdGFydHNXaXRoKFwiZGF0YTpcIikpIHtcbiAgICByZXR1cm4gYWN0dWFsU3JjO1xuICB9XG4gIGNvbnN0IGV4aXN0aW5nSGFzaCA9IEJvb2xlYW4obmV3IFVSTChhY3R1YWxTcmMsICh0eXBlb2Ygd2luZG93ID09PSBcInVuZGVmaW5lZFwiID8gbnVsbCA6IHdpbmRvdy5sb2NhdGlvbi5ocmVmKSA/PyBcImh0dHA6Ly9sb2NhbGhvc3Q6MzAwMFwiKS5oYXNoKTtcbiAgaWYgKGV4aXN0aW5nSGFzaCkge1xuICAgIHJldHVybiBhY3R1YWxTcmM7XG4gIH1cbiAgaWYgKCFOdW1iZXIuaXNGaW5pdGUoYWN0dWFsRnJvbSkpIHtcbiAgICByZXR1cm4gYWN0dWFsU3JjO1xuICB9XG4gIGNvbnN0IHdpdGhTdGFydEhhc2ggPSBgJHthY3R1YWxTcmN9I3Q9JHtnZXRWaWRlb0ZyYWdtZW50U3RhcnQoeyBhY3R1YWxGcm9tLCBmcHMgfSl9YDtcbiAgaWYgKCFOdW1iZXIuaXNGaW5pdGUoZHVyYXRpb24pKSB7XG4gICAgcmV0dXJuIHdpdGhTdGFydEhhc2g7XG4gIH1cbiAgcmV0dXJuIGAke3dpdGhTdGFydEhhc2h9LCR7Z2V0VmlkZW9GcmFnbWVudEVuZCh7IGR1cmF0aW9uLCBmcHMgfSl9YDtcbn07XG52YXIgaXNTdWJzZXRPZkR1cmF0aW9uID0gKHtcbiAgcHJldlN0YXJ0RnJvbSxcbiAgbmV3U3RhcnRGcm9tLFxuICBwcmV2RHVyYXRpb24sXG4gIG5ld0R1cmF0aW9uLFxuICBmcHNcbn0pID0+IHtcbiAgY29uc3QgcHJldmlvdXNGcm9tID0gZ2V0VmlkZW9GcmFnbWVudFN0YXJ0KHsgYWN0dWFsRnJvbTogcHJldlN0YXJ0RnJvbSwgZnBzIH0pO1xuICBjb25zdCBuZXdGcm9tID0gZ2V0VmlkZW9GcmFnbWVudFN0YXJ0KHsgYWN0dWFsRnJvbTogbmV3U3RhcnRGcm9tLCBmcHMgfSk7XG4gIGNvbnN0IHByZXZpb3VzRW5kID0gZ2V0VmlkZW9GcmFnbWVudEVuZCh7IGR1cmF0aW9uOiBwcmV2RHVyYXRpb24sIGZwcyB9KTtcbiAgY29uc3QgbmV3RW5kID0gZ2V0VmlkZW9GcmFnbWVudEVuZCh7IGR1cmF0aW9uOiBuZXdEdXJhdGlvbiwgZnBzIH0pO1xuICBpZiAobmV3RnJvbSA8IHByZXZpb3VzRnJvbSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBpZiAobmV3RW5kID4gcHJldmlvdXNFbmQpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgcmV0dXJuIHRydWU7XG59O1xudmFyIHVzZUFwcGVuZFZpZGVvRnJhZ21lbnQgPSAoe1xuICBhY3R1YWxTcmM6IGluaXRpYWxBY3R1YWxTcmMsXG4gIGFjdHVhbEZyb206IGluaXRpYWxBY3R1YWxGcm9tLFxuICBkdXJhdGlvbjogaW5pdGlhbER1cmF0aW9uLFxuICBmcHNcbn0pID0+IHtcbiAgY29uc3QgYWN0dWFsRnJvbVJlZiA9IHVzZVJlZjUoaW5pdGlhbEFjdHVhbEZyb20pO1xuICBjb25zdCBhY3R1YWxEdXJhdGlvbiA9IHVzZVJlZjUoaW5pdGlhbER1cmF0aW9uKTtcbiAgY29uc3QgYWN0dWFsU3JjID0gdXNlUmVmNShpbml0aWFsQWN0dWFsU3JjKTtcbiAgaWYgKCFpc1N1YnNldE9mRHVyYXRpb24oe1xuICAgIHByZXZTdGFydEZyb206IGFjdHVhbEZyb21SZWYuY3VycmVudCxcbiAgICBuZXdTdGFydEZyb206IGluaXRpYWxBY3R1YWxGcm9tLFxuICAgIHByZXZEdXJhdGlvbjogYWN0dWFsRHVyYXRpb24uY3VycmVudCxcbiAgICBuZXdEdXJhdGlvbjogaW5pdGlhbER1cmF0aW9uLFxuICAgIGZwc1xuICB9KSB8fCBpbml0aWFsQWN0dWFsU3JjICE9PSBhY3R1YWxTcmMuY3VycmVudCkge1xuICAgIGFjdHVhbEZyb21SZWYuY3VycmVudCA9IGluaXRpYWxBY3R1YWxGcm9tO1xuICAgIGFjdHVhbER1cmF0aW9uLmN1cnJlbnQgPSBpbml0aWFsRHVyYXRpb247XG4gICAgYWN0dWFsU3JjLmN1cnJlbnQgPSBpbml0aWFsQWN0dWFsU3JjO1xuICB9XG4gIGNvbnN0IGFwcGVuZGVkID0gYXBwZW5kVmlkZW9GcmFnbWVudCh7XG4gICAgYWN0dWFsU3JjOiBhY3R1YWxTcmMuY3VycmVudCxcbiAgICBhY3R1YWxGcm9tOiBhY3R1YWxGcm9tUmVmLmN1cnJlbnQsXG4gICAgZHVyYXRpb246IGFjdHVhbER1cmF0aW9uLmN1cnJlbnQsXG4gICAgZnBzXG4gIH0pO1xuICByZXR1cm4gYXBwZW5kZWQ7XG59O1xuXG4vLyBzcmMvd2Fybi1hYm91dC1ub24tc2Vla2FibGUtbWVkaWEudHNcbnZhciBhbHJlYWR5V2FybmVkID0ge307XG52YXIgd2FybkFib3V0Tm9uU2Vla2FibGVNZWRpYSA9IChyZWYsIHR5cGUpID0+IHtcbiAgaWYgKHJlZiA9PT0gbnVsbCkge1xuICAgIHJldHVybjtcbiAgfVxuICBpZiAocmVmLnNlZWthYmxlLmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybjtcbiAgfVxuICBpZiAocmVmLnNlZWthYmxlLmxlbmd0aCA+IDEpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgaWYgKGFscmVhZHlXYXJuZWRbcmVmLnNyY10pIHtcbiAgICByZXR1cm47XG4gIH1cbiAgY29uc3QgcmFuZ2UgPSB7IHN0YXJ0OiByZWYuc2Vla2FibGUuc3RhcnQoMCksIGVuZDogcmVmLnNlZWthYmxlLmVuZCgwKSB9O1xuICBpZiAocmFuZ2Uuc3RhcnQgPT09IDAgJiYgcmFuZ2UuZW5kID09PSAwKSB7XG4gICAgY29uc3QgbXNnID0gW1xuICAgICAgYFRoZSBtZWRpYSAke3JlZi5zcmN9IGNhbm5vdCBiZSBzZWVrZWQuIFRoaXMgY291bGQgYmUgb25lIG9mIGZldyByZWFzb25zOmAsXG4gICAgICBcIjEpIFRoZSBtZWRpYSByZXNvdXJjZSB3YXMgcmVwbGFjZWQgd2hpbGUgdGhlIHZpZGVvIGlzIHBsYXlpbmcgYnV0IGl0IHdhcyBub3QgbG9hZGVkIHlldC5cIixcbiAgICAgIFwiMikgVGhlIG1lZGlhIGRvZXMgbm90IHN1cHBvcnQgc2Vla2luZy5cIixcbiAgICAgIFwiMykgVGhlIG1lZGlhIHdhcyBsb2FkZWQgd2l0aCBzZWN1cml0eSBoZWFkZXJzIHBydmVudGluZyBpdCBmcm9tIGJlaW5nIGluY2x1ZGVkLlwiLFxuICAgICAgXCJQbGVhc2Ugc2VlIGh0dHBzOi8vcmVtb3Rpb24uZGV2L2RvY3Mvbm9uLXNlZWthYmxlLW1lZGlhIGZvciBhc3Npc3RhbmNlLlwiXG4gICAgXS5qb2luKFwiXFxuXCIpO1xuICAgIGlmICh0eXBlID09PSBcImNvbnNvbGUtZXJyb3JcIikge1xuICAgICAgY29uc29sZS5lcnJvcihtc2cpO1xuICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gXCJjb25zb2xlLXdhcm5pbmdcIikge1xuICAgICAgY29uc29sZS53YXJuKGBUaGUgbWVkaWEgJHtyZWYuc3JjfSBkb2VzIG5vdCBzdXBwb3J0IHNlZWtpbmcuIFRoZSB2aWRlbyB3aWxsIHJlbmRlciBmaW5lLCBidXQgbWF5IG5vdCBwbGF5IGNvcnJlY3RseSBpbiB0aGUgUmVtb3Rpb24gU3R1ZGlvIGFuZCBpbiB0aGUgPFBsYXllcj4uIFNlZSBodHRwczovL3JlbW90aW9uLmRldi9kb2NzL25vbi1zZWVrYWJsZS1tZWRpYSBmb3IgYW4gZXhwbGFuYXRpb24uYCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihtc2cpO1xuICAgIH1cbiAgICBhbHJlYWR5V2FybmVkW3JlZi5zcmNdID0gdHJ1ZTtcbiAgfVxufTtcblxuLy8gc3JjL3VzZS1tZWRpYS1wbGF5YmFjay50c1xudmFyIERFRkFVTFRfQUNDRVBUQUJMRV9USU1FU0hJRlQgPSAwLjQ1O1xudmFyIHNlZWsgPSAobWVkaWFSZWYsIHRpbWUpID0+IHtcbiAgaWYgKCFtZWRpYVJlZi5jdXJyZW50KSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGNvbnN0IHRpbWVUb1NldCA9IGlzSW9zU2FmYXJpKCkgPyBOdW1iZXIodGltZS50b0ZpeGVkKDEpKSA6IHRpbWU7XG4gIG1lZGlhUmVmLmN1cnJlbnQuY3VycmVudFRpbWUgPSB0aW1lVG9TZXQ7XG59O1xudmFyIHVzZU1lZGlhUGxheWJhY2sgPSAoe1xuICBtZWRpYVJlZixcbiAgc3JjLFxuICBtZWRpYVR5cGUsXG4gIHBsYXliYWNrUmF0ZTogbG9jYWxQbGF5YmFja1JhdGUsXG4gIG9ubHlXYXJuRm9yTWVkaWFTZWVraW5nRXJyb3IsXG4gIGFjY2VwdGFibGVUaW1lc2hpZnQsXG4gIHBhdXNlV2hlbkJ1ZmZlcmluZyxcbiAgaXNQcmVtb3VudGluZyxcbiAgZGVidWdTZWVraW5nLFxuICBvbkF1dG9QbGF5RXJyb3Jcbn0pID0+IHtcbiAgY29uc3QgeyBwbGF5YmFja1JhdGU6IGdsb2JhbFBsYXliYWNrUmF0ZSB9ID0gdXNlQ29udGV4dDE4KFRpbWVsaW5lQ29udGV4dCk7XG4gIGNvbnN0IGZyYW1lID0gdXNlQ3VycmVudEZyYW1lKCk7XG4gIGNvbnN0IGFic29sdXRlRnJhbWUgPSB1c2VUaW1lbGluZVBvc2l0aW9uKCk7XG4gIGNvbnN0IFtwbGF5aW5nXSA9IHVzZVBsYXlpbmdTdGF0ZSgpO1xuICBjb25zdCBidWZmZXJpbmcgPSB1c2VDb250ZXh0MTgoQnVmZmVyaW5nQ29udGV4dFJlYWN0KTtcbiAgY29uc3QgeyBmcHMgfSA9IHVzZVZpZGVvQ29uZmlnKCk7XG4gIGNvbnN0IG1lZGlhU3RhcnRzQXQgPSB1c2VNZWRpYVN0YXJ0c0F0KCk7XG4gIGNvbnN0IGxhc3RTZWVrRHVlVG9TaGlmdCA9IHVzZVJlZjYobnVsbCk7XG4gIGNvbnN0IGxhc3RTZWVrID0gdXNlUmVmNihudWxsKTtcbiAgaWYgKCFidWZmZXJpbmcpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJ1c2VNZWRpYVBsYXliYWNrIG11c3QgYmUgdXNlZCBpbnNpZGUgYSA8QnVmZmVyaW5nQ29udGV4dD5cIik7XG4gIH1cbiAgY29uc3QgaXNWYXJpYWJsZUZwc1ZpZGVvTWFwID0gdXNlUmVmNih7fSk7XG4gIGNvbnN0IG9uVmFyaWFibGVGcHNWaWRlb0RldGVjdGVkID0gdXNlQ2FsbGJhY2s3KCgpID0+IHtcbiAgICBpZiAoIXNyYykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoZGVidWdTZWVraW5nKSB7XG4gICAgICBjb25zb2xlLmxvZyhgRGV0ZWN0ZWQgJHtzcmN9IGFzIGEgdmFyaWFibGUgRlBTIHZpZGVvLiBEaXNhYmxpbmcgYnVmZmVyaW5nIHdoaWxlIHNlZWtpbmcuYCk7XG4gICAgfVxuICAgIGlzVmFyaWFibGVGcHNWaWRlb01hcC5jdXJyZW50W3NyY10gPSB0cnVlO1xuICB9LCBbZGVidWdTZWVraW5nLCBzcmNdKTtcbiAgY29uc3QgY3VycmVudFRpbWUgPSB1c2VSZXF1ZXN0VmlkZW9DYWxsYmFja1RpbWUoe1xuICAgIG1lZGlhUmVmLFxuICAgIG1lZGlhVHlwZSxcbiAgICBsYXN0U2VlayxcbiAgICBvblZhcmlhYmxlRnBzVmlkZW9EZXRlY3RlZFxuICB9KTtcbiAgY29uc3QgZGVzaXJlZFVuY2xhbXBlZFRpbWUgPSBnZXRNZWRpYVRpbWUoe1xuICAgIGZyYW1lLFxuICAgIHBsYXliYWNrUmF0ZTogbG9jYWxQbGF5YmFja1JhdGUsXG4gICAgc3RhcnRGcm9tOiAtbWVkaWFTdGFydHNBdCxcbiAgICBmcHNcbiAgfSk7XG4gIGNvbnN0IGlzTWVkaWFUYWdCdWZmZXJpbmcgPSB1c2VNZWRpYUJ1ZmZlcmluZyh7XG4gICAgZWxlbWVudDogbWVkaWFSZWYsXG4gICAgc2hvdWxkQnVmZmVyOiBwYXVzZVdoZW5CdWZmZXJpbmcsXG4gICAgaXNQcmVtb3VudGluZ1xuICB9KTtcbiAgY29uc3QgeyBidWZmZXJVbnRpbEZpcnN0RnJhbWUsIGlzQnVmZmVyaW5nIH0gPSB1c2VCdWZmZXJVbnRpbEZpcnN0RnJhbWUoe1xuICAgIG1lZGlhUmVmLFxuICAgIG1lZGlhVHlwZSxcbiAgICBvblZhcmlhYmxlRnBzVmlkZW9EZXRlY3RlZCxcbiAgICBwYXVzZVdoZW5CdWZmZXJpbmdcbiAgfSk7XG4gIGNvbnN0IHBsYXliYWNrUmF0ZSA9IGxvY2FsUGxheWJhY2tSYXRlICogZ2xvYmFsUGxheWJhY2tSYXRlO1xuICBjb25zdCBhY2NlcHRhYmxlVGltZVNoaWZ0QnV0TGVzc1RoYW5EdXJhdGlvbiA9ICgoKSA9PiB7XG4gICAgaWYgKG1lZGlhUmVmLmN1cnJlbnQ/LmR1cmF0aW9uKSB7XG4gICAgICByZXR1cm4gTWF0aC5taW4obWVkaWFSZWYuY3VycmVudC5kdXJhdGlvbiwgYWNjZXB0YWJsZVRpbWVzaGlmdCA/PyBERUZBVUxUX0FDQ0VQVEFCTEVfVElNRVNISUZUKTtcbiAgICB9XG4gICAgcmV0dXJuIGFjY2VwdGFibGVUaW1lc2hpZnQ7XG4gIH0pKCk7XG4gIGNvbnN0IGlzUGxheWVyQnVmZmVyaW5nID0gdXNlSXNQbGF5ZXJCdWZmZXJpbmcoYnVmZmVyaW5nKTtcbiAgdXNlRWZmZWN0MTIoKCkgPT4ge1xuICAgIGlmICghcGxheWluZykge1xuICAgICAgbWVkaWFSZWYuY3VycmVudD8ucGF1c2UoKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgaXNNZWRpYVRhZ0J1ZmZlcmluZ09yU3RhbGxlZCA9IGlzTWVkaWFUYWdCdWZmZXJpbmcgfHwgaXNCdWZmZXJpbmcoKTtcbiAgICBpZiAoaXNQbGF5ZXJCdWZmZXJpbmcgJiYgIWlzTWVkaWFUYWdCdWZmZXJpbmdPclN0YWxsZWQpIHtcbiAgICAgIG1lZGlhUmVmLmN1cnJlbnQ/LnBhdXNlKCk7XG4gICAgfVxuICB9LCBbaXNCdWZmZXJpbmcsIGlzTWVkaWFUYWdCdWZmZXJpbmcsIGlzUGxheWVyQnVmZmVyaW5nLCBtZWRpYVJlZiwgcGxheWluZ10pO1xuICB1c2VFZmZlY3QxMigoKSA9PiB7XG4gICAgY29uc3QgdGFnTmFtZSA9IG1lZGlhVHlwZSA9PT0gXCJhdWRpb1wiID8gXCI8QXVkaW8+XCIgOiBcIjxWaWRlbz5cIjtcbiAgICBpZiAoIW1lZGlhUmVmLmN1cnJlbnQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgTm8gJHttZWRpYVR5cGV9IHJlZiBmb3VuZGApO1xuICAgIH1cbiAgICBpZiAoIXNyYykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBObyAnc3JjJyBhdHRyaWJ1dGUgd2FzIHBhc3NlZCB0byB0aGUgJHt0YWdOYW1lfSBlbGVtZW50LmApO1xuICAgIH1cbiAgICBjb25zdCBwbGF5YmFja1JhdGVUb1NldCA9IE1hdGgubWF4KDAsIHBsYXliYWNrUmF0ZSk7XG4gICAgaWYgKG1lZGlhUmVmLmN1cnJlbnQucGxheWJhY2tSYXRlICE9PSBwbGF5YmFja1JhdGVUb1NldCkge1xuICAgICAgbWVkaWFSZWYuY3VycmVudC5wbGF5YmFja1JhdGUgPSBwbGF5YmFja1JhdGVUb1NldDtcbiAgICB9XG4gICAgY29uc3QgeyBkdXJhdGlvbiB9ID0gbWVkaWFSZWYuY3VycmVudDtcbiAgICBjb25zdCBzaG91bGRCZVRpbWUgPSAhTnVtYmVyLmlzTmFOKGR1cmF0aW9uKSAmJiBOdW1iZXIuaXNGaW5pdGUoZHVyYXRpb24pID8gTWF0aC5taW4oZHVyYXRpb24sIGRlc2lyZWRVbmNsYW1wZWRUaW1lKSA6IGRlc2lyZWRVbmNsYW1wZWRUaW1lO1xuICAgIGNvbnN0IG1lZGlhVGFnVGltZSA9IG1lZGlhUmVmLmN1cnJlbnQuY3VycmVudFRpbWU7XG4gICAgY29uc3QgcnZjVGltZSA9IGN1cnJlbnRUaW1lLmN1cnJlbnQgPz8gbnVsbDtcbiAgICBjb25zdCBpc1ZhcmlhYmxlRnBzVmlkZW8gPSBpc1ZhcmlhYmxlRnBzVmlkZW9NYXAuY3VycmVudFtzcmNdO1xuICAgIGNvbnN0IHRpbWVTaGlmdE1lZGlhVGFnID0gTWF0aC5hYnMoc2hvdWxkQmVUaW1lIC0gbWVkaWFUYWdUaW1lKTtcbiAgICBjb25zdCB0aW1lU2hpZnRSdmNUYWcgPSBydmNUaW1lID8gTWF0aC5hYnMoc2hvdWxkQmVUaW1lIC0gcnZjVGltZSkgOiBudWxsO1xuICAgIGNvbnN0IHRpbWVTaGlmdCA9IHRpbWVTaGlmdFJ2Y1RhZyAmJiAhaXNWYXJpYWJsZUZwc1ZpZGVvID8gdGltZVNoaWZ0UnZjVGFnIDogdGltZVNoaWZ0TWVkaWFUYWc7XG4gICAgaWYgKGRlYnVnU2Vla2luZykge1xuICAgICAgY29uc29sZS5sb2coe1xuICAgICAgICBtZWRpYVRhZ1RpbWUsXG4gICAgICAgIHJ2Y1RpbWUsXG4gICAgICAgIHNob3VsZEJlVGltZSxcbiAgICAgICAgc3RhdGU6IG1lZGlhUmVmLmN1cnJlbnQucmVhZHlTdGF0ZSxcbiAgICAgICAgcGxheWluZzogIW1lZGlhUmVmLmN1cnJlbnQucGF1c2VkLFxuICAgICAgICBpc1ZhcmlhYmxlRnBzVmlkZW9cbiAgICAgIH0pO1xuICAgIH1cbiAgICBpZiAodGltZVNoaWZ0ID4gYWNjZXB0YWJsZVRpbWVTaGlmdEJ1dExlc3NUaGFuRHVyYXRpb24gJiYgbGFzdFNlZWtEdWVUb1NoaWZ0LmN1cnJlbnQgIT09IHNob3VsZEJlVGltZSkge1xuICAgICAgaWYgKGRlYnVnU2Vla2luZykge1xuICAgICAgICBjb25zb2xlLmxvZyhcIlNlZWtpbmdcIiwge1xuICAgICAgICAgIHNob3VsZEJlVGltZSxcbiAgICAgICAgICBpc1RpbWU6IG1lZGlhVGFnVGltZSxcbiAgICAgICAgICBydmNUaW1lLFxuICAgICAgICAgIHRpbWVTaGlmdCxcbiAgICAgICAgICBpc1ZhcmlhYmxlRnBzVmlkZW9cbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICBzZWVrKG1lZGlhUmVmLCBzaG91bGRCZVRpbWUpO1xuICAgICAgbGFzdFNlZWsuY3VycmVudCA9IHNob3VsZEJlVGltZTtcbiAgICAgIGxhc3RTZWVrRHVlVG9TaGlmdC5jdXJyZW50ID0gc2hvdWxkQmVUaW1lO1xuICAgICAgaWYgKHBsYXlpbmcgJiYgIWlzVmFyaWFibGVGcHNWaWRlbykge1xuICAgICAgICBpZiAocGxheWJhY2tSYXRlID4gMCkge1xuICAgICAgICAgIGJ1ZmZlclVudGlsRmlyc3RGcmFtZShzaG91bGRCZVRpbWUpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChtZWRpYVJlZi5jdXJyZW50LnBhdXNlZCkge1xuICAgICAgICAgIHBsYXlBbmRIYW5kbGVOb3RBbGxvd2VkRXJyb3IobWVkaWFSZWYsIG1lZGlhVHlwZSwgb25BdXRvUGxheUVycm9yKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKCFvbmx5V2FybkZvck1lZGlhU2Vla2luZ0Vycm9yKSB7XG4gICAgICAgIHdhcm5BYm91dE5vblNlZWthYmxlTWVkaWEobWVkaWFSZWYuY3VycmVudCwgb25seVdhcm5Gb3JNZWRpYVNlZWtpbmdFcnJvciA/IFwiY29uc29sZS13YXJuaW5nXCIgOiBcImNvbnNvbGUtZXJyb3JcIik7XG4gICAgICB9XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHNlZWtUaHJlc2hvbGQgPSBwbGF5aW5nID8gMC4xNSA6IDAuMDAwMDE7XG4gICAgY29uc3QgbWFrZXNTZW5zZVRvU2VlayA9IE1hdGguYWJzKG1lZGlhUmVmLmN1cnJlbnQuY3VycmVudFRpbWUgLSBzaG91bGRCZVRpbWUpID4gc2Vla1RocmVzaG9sZDtcbiAgICBjb25zdCBpc01lZGlhVGFnQnVmZmVyaW5nT3JTdGFsbGVkID0gaXNNZWRpYVRhZ0J1ZmZlcmluZyB8fCBpc0J1ZmZlcmluZygpO1xuICAgIGNvbnN0IGlzU29tZXRoaW5nRWxzZUJ1ZmZlcmluZyA9IGJ1ZmZlcmluZy5idWZmZXJpbmcuY3VycmVudCAmJiAhaXNNZWRpYVRhZ0J1ZmZlcmluZ09yU3RhbGxlZDtcbiAgICBpZiAoIXBsYXlpbmcgfHwgaXNTb21ldGhpbmdFbHNlQnVmZmVyaW5nKSB7XG4gICAgICBpZiAobWFrZXNTZW5zZVRvU2Vlaykge1xuICAgICAgICBzZWVrKG1lZGlhUmVmLCBzaG91bGRCZVRpbWUpO1xuICAgICAgICBsYXN0U2Vlay5jdXJyZW50ID0gc2hvdWxkQmVUaW1lO1xuICAgICAgfVxuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAobWVkaWFSZWYuY3VycmVudC5wYXVzZWQgJiYgIW1lZGlhUmVmLmN1cnJlbnQuZW5kZWQgfHwgYWJzb2x1dGVGcmFtZSA9PT0gMCkge1xuICAgICAgaWYgKG1ha2VzU2Vuc2VUb1NlZWspIHtcbiAgICAgICAgc2VlayhtZWRpYVJlZiwgc2hvdWxkQmVUaW1lKTtcbiAgICAgICAgbGFzdFNlZWsuY3VycmVudCA9IHNob3VsZEJlVGltZTtcbiAgICAgIH1cbiAgICAgIHBsYXlBbmRIYW5kbGVOb3RBbGxvd2VkRXJyb3IobWVkaWFSZWYsIG1lZGlhVHlwZSwgb25BdXRvUGxheUVycm9yKTtcbiAgICAgIGlmICghaXNWYXJpYWJsZUZwc1ZpZGVvKSB7XG4gICAgICAgIGlmIChwbGF5YmFja1JhdGUgPiAwKSB7XG4gICAgICAgICAgYnVmZmVyVW50aWxGaXJzdEZyYW1lKHNob3VsZEJlVGltZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH0sIFtcbiAgICBhYnNvbHV0ZUZyYW1lLFxuICAgIGFjY2VwdGFibGVUaW1lU2hpZnRCdXRMZXNzVGhhbkR1cmF0aW9uLFxuICAgIGJ1ZmZlclVudGlsRmlyc3RGcmFtZSxcbiAgICBidWZmZXJpbmcuYnVmZmVyaW5nLFxuICAgIGN1cnJlbnRUaW1lLFxuICAgIGRlYnVnU2Vla2luZyxcbiAgICBkZXNpcmVkVW5jbGFtcGVkVGltZSxcbiAgICBpc0J1ZmZlcmluZyxcbiAgICBpc01lZGlhVGFnQnVmZmVyaW5nLFxuICAgIG1lZGlhUmVmLFxuICAgIG1lZGlhVHlwZSxcbiAgICBvbmx5V2FybkZvck1lZGlhU2Vla2luZ0Vycm9yLFxuICAgIHBsYXliYWNrUmF0ZSxcbiAgICBwbGF5aW5nLFxuICAgIHNyYyxcbiAgICBvbkF1dG9QbGF5RXJyb3JcbiAgXSk7XG59O1xuXG4vLyBzcmMvdXNlLW1lZGlhLXRhZy12b2x1bWUudHNcbmltcG9ydCB7IHVzZUVmZmVjdCBhcyB1c2VFZmZlY3QxMywgdXNlU3RhdGUgYXMgdXNlU3RhdGUxMiB9IGZyb20gXCJyZWFjdFwiO1xudmFyIHVzZU1lZGlhVGFnVm9sdW1lID0gKG1lZGlhUmVmKSA9PiB7XG4gIGNvbnN0IFthY3R1YWxWb2x1bWUsIHNldEFjdHVhbFZvbHVtZV0gPSB1c2VTdGF0ZTEyKDEpO1xuICB1c2VFZmZlY3QxMygoKSA9PiB7XG4gICAgY29uc3QgcmVmID0gbWVkaWFSZWYuY3VycmVudDtcbiAgICBpZiAoIXJlZikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBvbkNoYW5nZSA9ICgpID0+IHtcbiAgICAgIHNldEFjdHVhbFZvbHVtZShyZWYudm9sdW1lKTtcbiAgICB9O1xuICAgIHJlZi5hZGRFdmVudExpc3RlbmVyKFwidm9sdW1lY2hhbmdlXCIsIG9uQ2hhbmdlKTtcbiAgICByZXR1cm4gKCkgPT4gcmVmLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJ2b2x1bWVjaGFuZ2VcIiwgb25DaGFuZ2UpO1xuICB9LCBbbWVkaWFSZWZdKTtcbiAgdXNlRWZmZWN0MTMoKCkgPT4ge1xuICAgIGNvbnN0IHJlZiA9IG1lZGlhUmVmLmN1cnJlbnQ7XG4gICAgaWYgKCFyZWYpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKHJlZi52b2x1bWUgIT09IGFjdHVhbFZvbHVtZSkge1xuICAgICAgc2V0QWN0dWFsVm9sdW1lKHJlZi52b2x1bWUpO1xuICAgIH1cbiAgfSwgW2FjdHVhbFZvbHVtZSwgbWVkaWFSZWZdKTtcbiAgcmV0dXJuIGFjdHVhbFZvbHVtZTtcbn07XG5cbi8vIHNyYy91c2Utc3luYy12b2x1bWUtd2l0aC1tZWRpYS10YWcudHNcbmltcG9ydCB7IHVzZUVmZmVjdCBhcyB1c2VFZmZlY3QxNCB9IGZyb20gXCJyZWFjdFwiO1xuXG4vLyBzcmMvaXMtYXBwcm94aW1hdGVseS10aGUtc2FtZS50c1xudmFyIEZMT0FUSU5HX1BPSU5UX0VSUk9SX1RIUkVTSE9MRCA9IDAuMDAwMDE7XG52YXIgaXNBcHByb3hpbWF0ZWx5VGhlU2FtZSA9IChudW0xLCBudW0yKSA9PiB7XG4gIHJldHVybiBNYXRoLmFicyhudW0xIC0gbnVtMikgPCBGTE9BVElOR19QT0lOVF9FUlJPUl9USFJFU0hPTEQ7XG59O1xuXG4vLyBzcmMvdXNlLXN5bmMtdm9sdW1lLXdpdGgtbWVkaWEtdGFnLnRzXG52YXIgdXNlU3luY1ZvbHVtZVdpdGhNZWRpYVRhZyA9ICh7XG4gIHZvbHVtZVByb3BGcmFtZSxcbiAgYWN0dWFsVm9sdW1lLFxuICB2b2x1bWUsXG4gIG1lZGlhVm9sdW1lLFxuICBtZWRpYVJlZlxufSkgPT4ge1xuICB1c2VFZmZlY3QxNCgoKSA9PiB7XG4gICAgY29uc3QgdXNlclByZWZlcnJlZFZvbHVtZSA9IGV2YWx1YXRlVm9sdW1lKHtcbiAgICAgIGZyYW1lOiB2b2x1bWVQcm9wRnJhbWUsXG4gICAgICB2b2x1bWUsXG4gICAgICBtZWRpYVZvbHVtZSxcbiAgICAgIGFsbG93QW1wbGlmaWNhdGlvbkR1cmluZ1JlbmRlcjogZmFsc2VcbiAgICB9KTtcbiAgICBpZiAoIWlzQXBwcm94aW1hdGVseVRoZVNhbWUodXNlclByZWZlcnJlZFZvbHVtZSwgYWN0dWFsVm9sdW1lKSAmJiBtZWRpYVJlZi5jdXJyZW50KSB7XG4gICAgICBtZWRpYVJlZi5jdXJyZW50LnZvbHVtZSA9IHVzZXJQcmVmZXJyZWRWb2x1bWU7XG4gICAgfVxuICB9LCBbYWN0dWFsVm9sdW1lLCB2b2x1bWVQcm9wRnJhbWUsIG1lZGlhUmVmLCB2b2x1bWUsIG1lZGlhVm9sdW1lXSk7XG59O1xuXG4vLyBzcmMvdm9sdW1lLXBvc2l0aW9uLXN0YXRlLnRzXG5pbXBvcnQgeyBjcmVhdGVDb250ZXh0IGFzIGNyZWF0ZUNvbnRleHQxNSwgdXNlQ29udGV4dCBhcyB1c2VDb250ZXh0MTksIHVzZU1lbW8gYXMgdXNlTWVtbzE4IH0gZnJvbSBcInJlYWN0XCI7XG52YXIgTWVkaWFWb2x1bWVDb250ZXh0ID0gY3JlYXRlQ29udGV4dDE1KHtcbiAgbWVkaWFNdXRlZDogZmFsc2UsXG4gIG1lZGlhVm9sdW1lOiAxXG59KTtcbnZhciBTZXRNZWRpYVZvbHVtZUNvbnRleHQgPSBjcmVhdGVDb250ZXh0MTUoe1xuICBzZXRNZWRpYU11dGVkOiAoKSA9PiB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiZGVmYXVsdFwiKTtcbiAgfSxcbiAgc2V0TWVkaWFWb2x1bWU6ICgpID0+IHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJkZWZhdWx0XCIpO1xuICB9XG59KTtcbnZhciB1c2VNZWRpYVZvbHVtZVN0YXRlID0gKCkgPT4ge1xuICBjb25zdCB7IG1lZGlhVm9sdW1lIH0gPSB1c2VDb250ZXh0MTkoTWVkaWFWb2x1bWVDb250ZXh0KTtcbiAgY29uc3QgeyBzZXRNZWRpYVZvbHVtZSB9ID0gdXNlQ29udGV4dDE5KFNldE1lZGlhVm9sdW1lQ29udGV4dCk7XG4gIHJldHVybiB1c2VNZW1vMTgoKCkgPT4ge1xuICAgIHJldHVybiBbbWVkaWFWb2x1bWUsIHNldE1lZGlhVm9sdW1lXTtcbiAgfSwgW21lZGlhVm9sdW1lLCBzZXRNZWRpYVZvbHVtZV0pO1xufTtcbnZhciB1c2VNZWRpYU11dGVkU3RhdGUgPSAoKSA9PiB7XG4gIGNvbnN0IHsgbWVkaWFNdXRlZCB9ID0gdXNlQ29udGV4dDE5KE1lZGlhVm9sdW1lQ29udGV4dCk7XG4gIGNvbnN0IHsgc2V0TWVkaWFNdXRlZCB9ID0gdXNlQ29udGV4dDE5KFNldE1lZGlhVm9sdW1lQ29udGV4dCk7XG4gIHJldHVybiB1c2VNZW1vMTgoKCkgPT4ge1xuICAgIHJldHVybiBbbWVkaWFNdXRlZCwgc2V0TWVkaWFNdXRlZF07XG4gIH0sIFttZWRpYU11dGVkLCBzZXRNZWRpYU11dGVkXSk7XG59O1xuXG4vLyBzcmMvYXVkaW8vc2hhcmVkLWF1ZGlvLXRhZ3MudHN4XG5pbXBvcnQgUmVhY3QxMiwge1xuICBjcmVhdGVDb250ZXh0IGFzIGNyZWF0ZUNvbnRleHQxNixcbiAgY3JlYXRlUmVmIGFzIGNyZWF0ZVJlZjIsXG4gIHVzZUNhbGxiYWNrIGFzIHVzZUNhbGxiYWNrOCxcbiAgdXNlQ29udGV4dCBhcyB1c2VDb250ZXh0MjAsXG4gIHVzZUVmZmVjdCBhcyB1c2VFZmZlY3QxNSxcbiAgdXNlTWVtbyBhcyB1c2VNZW1vMTksXG4gIHVzZVJlZiBhcyB1c2VSZWY3LFxuICB1c2VTdGF0ZSBhcyB1c2VTdGF0ZTEzXG59IGZyb20gXCJyZWFjdFwiO1xuaW1wb3J0IHsganN4IGFzIGpzeDE1LCBqc3hzIH0gZnJvbSBcInJlYWN0L2pzeC1ydW50aW1lXCI7XG52YXIgRU1QVFlfQVVESU8gPSBcImRhdGE6YXVkaW8vbXAzO2Jhc2U2NCwvK01ZeEFBSmNBVjhBQWdBQUJuLy8vLy8vKy9nUTVCQU1BK0Q0UGcrQkFRQkFFQXdENFBnK0Q0RUJBRUFRREFQZysraFlCSC8vL2hVRlFWQlVGUkVEUU5IbWYvLy8vLy8vK01ZeEJVR2tBR0lNQUFBQVAvMjlYdDZsVXhCVFVVekxqRXdNRlZWVlZWVlZWVlZWVlZWVlZWVlZWVlZWVlZWVlZWVlZWVlZWVlZWVlZWVlZWVlZWVlZWVlZWVlZWVlYvK01ZeERVQUFBTklBQUFBQUZWVlZWVlZWVlZWVlZWVlZWVlZWVlZWVlZWVlZWVlZWVlZWVlZWVlZWVlZWVlZWVlZWVlZWVlZWVlZWVlZWVlZWVlZWVlZWVlZWVlZWVlZcIjtcbnZhciBjb21wYXJlUHJvcHMgPSAob2JqMSwgb2JqMikgPT4ge1xuICBjb25zdCBrZXlzQSA9IE9iamVjdC5rZXlzKG9iajEpLnNvcnQoKTtcbiAgY29uc3Qga2V5c0IgPSBPYmplY3Qua2V5cyhvYmoyKS5zb3J0KCk7XG4gIGlmIChrZXlzQS5sZW5ndGggIT09IGtleXNCLmxlbmd0aCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBmb3IgKGxldCBpID0gMDtpIDwga2V5c0EubGVuZ3RoOyBpKyspIHtcbiAgICBpZiAoa2V5c0FbaV0gIT09IGtleXNCW2ldKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGlmIChvYmoxW2tleXNBW2ldXSAhPT0gb2JqMltrZXlzQltpXV0pIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRydWU7XG59O1xudmFyIGRpZFByb3BDaGFuZ2UgPSAoa2V5LCBuZXdQcm9wLCBwcmV2UHJvcCkgPT4ge1xuICBpZiAoa2V5ID09PSBcInNyY1wiICYmICFwcmV2UHJvcC5zdGFydHNXaXRoKFwiZGF0YTpcIikgJiYgIW5ld1Byb3Auc3RhcnRzV2l0aChcImRhdGE6XCIpKSB7XG4gICAgcmV0dXJuIG5ldyBVUkwocHJldlByb3AsIHdpbmRvdy5vcmlnaW4pLnRvU3RyaW5nKCkgIT09IG5ldyBVUkwobmV3UHJvcCwgd2luZG93Lm9yaWdpbikudG9TdHJpbmcoKTtcbiAgfVxuICBpZiAocHJldlByb3AgPT09IG5ld1Byb3ApIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgcmV0dXJuIHRydWU7XG59O1xudmFyIFNoYXJlZEF1ZGlvQ29udGV4dCA9IGNyZWF0ZUNvbnRleHQxNihudWxsKTtcbnZhciBTaGFyZWRBdWRpb0NvbnRleHRQcm92aWRlciA9ICh7IGNoaWxkcmVuLCBudW1iZXJPZkF1ZGlvVGFncywgY29tcG9uZW50IH0pID0+IHtcbiAgY29uc3QgYXVkaW9zID0gdXNlUmVmNyhbXSk7XG4gIGNvbnN0IFtpbml0aWFsTnVtYmVyT2ZBdWRpb1RhZ3NdID0gdXNlU3RhdGUxMyhudW1iZXJPZkF1ZGlvVGFncyk7XG4gIGlmIChudW1iZXJPZkF1ZGlvVGFncyAhPT0gaW5pdGlhbE51bWJlck9mQXVkaW9UYWdzKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiVGhlIG51bWJlciBvZiBzaGFyZWQgYXVkaW8gdGFncyBoYXMgY2hhbmdlZCBkeW5hbWljYWxseS4gT25jZSB5b3UgaGF2ZSBzZXQgdGhpcyBwcm9wZXJ0eSwgeW91IGNhbm5vdCBjaGFuZ2UgaXQgYWZ0ZXJ3YXJkcy5cIik7XG4gIH1cbiAgY29uc3QgcmVmcyA9IHVzZU1lbW8xOSgoKSA9PiB7XG4gICAgcmV0dXJuIG5ldyBBcnJheShudW1iZXJPZkF1ZGlvVGFncykuZmlsbCh0cnVlKS5tYXAoKCkgPT4ge1xuICAgICAgcmV0dXJuIHsgaWQ6IE1hdGgucmFuZG9tKCksIHJlZjogY3JlYXRlUmVmMigpIH07XG4gICAgfSk7XG4gIH0sIFtudW1iZXJPZkF1ZGlvVGFnc10pO1xuICBjb25zdCB0YWtlbkF1ZGlvcyA9IHVzZVJlZjcobmV3IEFycmF5KG51bWJlck9mQXVkaW9UYWdzKS5maWxsKGZhbHNlKSk7XG4gIGNvbnN0IHJlcmVuZGVyQXVkaW9zID0gdXNlQ2FsbGJhY2s4KCgpID0+IHtcbiAgICByZWZzLmZvckVhY2goKHsgcmVmLCBpZCB9KSA9PiB7XG4gICAgICBjb25zdCBkYXRhID0gYXVkaW9zLmN1cnJlbnQ/LmZpbmQoKGEpID0+IGEuaWQgPT09IGlkKTtcbiAgICAgIGNvbnN0IHsgY3VycmVudCB9ID0gcmVmO1xuICAgICAgaWYgKCFjdXJyZW50KSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmIChkYXRhID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgY3VycmVudC5zcmMgPSBFTVBUWV9BVURJTztcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKCFkYXRhKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJFeHBlY3RlZCBhdWRpbyBkYXRhIHRvIGJlIHRoZXJlXCIpO1xuICAgICAgfVxuICAgICAgT2JqZWN0LmtleXMoZGF0YS5wcm9wcykuZm9yRWFjaCgoa2V5KSA9PiB7XG4gICAgICAgIGlmIChkaWRQcm9wQ2hhbmdlKGtleSwgZGF0YS5wcm9wc1trZXldLCBjdXJyZW50W2tleV0pKSB7XG4gICAgICAgICAgY3VycmVudFtrZXldID0gZGF0YS5wcm9wc1trZXldO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfSwgW3JlZnNdKTtcbiAgY29uc3QgcmVnaXN0ZXJBdWRpbyA9IHVzZUNhbGxiYWNrOCgoYXVkLCBhdWRpb0lkKSA9PiB7XG4gICAgY29uc3QgZm91bmQgPSBhdWRpb3MuY3VycmVudD8uZmluZCgoYSkgPT4gYS5hdWRpb0lkID09PSBhdWRpb0lkKTtcbiAgICBpZiAoZm91bmQpIHtcbiAgICAgIHJldHVybiBmb3VuZDtcbiAgICB9XG4gICAgY29uc3QgZmlyc3RGcmVlQXVkaW8gPSB0YWtlbkF1ZGlvcy5jdXJyZW50LmZpbmRJbmRleCgoYSkgPT4gYSA9PT0gZmFsc2UpO1xuICAgIGlmIChmaXJzdEZyZWVBdWRpbyA9PT0gLTEpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgVHJpZWQgdG8gc2ltdWx0YW5lb3VzbHkgbW91bnQgJHtudW1iZXJPZkF1ZGlvVGFncyArIDF9IDxBdWRpbyAvPiB0YWdzIGF0IHRoZSBzYW1lIHRpbWUuIFdpdGggdGhlIGN1cnJlbnQgc2V0dGluZ3MsIHRoZSBtYXhpbXVtIGFtb3VudCBvZiA8QXVkaW8gLz4gdGFncyBpcyBsaW1pdGVkIHRvICR7bnVtYmVyT2ZBdWRpb1RhZ3N9IGF0IHRoZSBzYW1lIHRpbWUuIFJlbW90aW9uIHByZS1tb3VudHMgc2lsZW50IGF1ZGlvIHRhZ3MgdG8gaGVscCBhdm9pZCBicm93c2VyIGF1dG9wbGF5IHJlc3RyaWN0aW9ucy4gU2VlIGh0dHBzOi8vcmVtb3Rpb24uZGV2L2RvY3MvcGxheWVyL2F1dG9wbGF5I3VzZS10aGUtbnVtYmVyb2ZzaGFyZWRhdWRpb3RhZ3MtcHJvcGVydHkgZm9yIG1vcmUgaW5mb3JtYXRpb24gb24gaG93IHRvIGluY3JlYXNlIHRoaXMgbGltaXQuYCk7XG4gICAgfVxuICAgIGNvbnN0IHsgaWQsIHJlZiB9ID0gcmVmc1tmaXJzdEZyZWVBdWRpb107XG4gICAgY29uc3QgY2xvbmVkID0gWy4uLnRha2VuQXVkaW9zLmN1cnJlbnRdO1xuICAgIGNsb25lZFtmaXJzdEZyZWVBdWRpb10gPSBpZDtcbiAgICB0YWtlbkF1ZGlvcy5jdXJyZW50ID0gY2xvbmVkO1xuICAgIGNvbnN0IG5ld0VsZW0gPSB7XG4gICAgICBwcm9wczogYXVkLFxuICAgICAgaWQsXG4gICAgICBlbDogcmVmLFxuICAgICAgYXVkaW9JZFxuICAgIH07XG4gICAgYXVkaW9zLmN1cnJlbnQ/LnB1c2gobmV3RWxlbSk7XG4gICAgcmVyZW5kZXJBdWRpb3MoKTtcbiAgICByZXR1cm4gbmV3RWxlbTtcbiAgfSwgW251bWJlck9mQXVkaW9UYWdzLCByZWZzLCByZXJlbmRlckF1ZGlvc10pO1xuICBjb25zdCB1bnJlZ2lzdGVyQXVkaW8gPSB1c2VDYWxsYmFjazgoKGlkKSA9PiB7XG4gICAgY29uc3QgY2xvbmVkID0gWy4uLnRha2VuQXVkaW9zLmN1cnJlbnRdO1xuICAgIGNvbnN0IGluZGV4ID0gcmVmcy5maW5kSW5kZXgoKHIpID0+IHIuaWQgPT09IGlkKTtcbiAgICBpZiAoaW5kZXggPT09IC0xKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiRXJyb3Igb2NjdXJlZCBpbiBcIik7XG4gICAgfVxuICAgIGNsb25lZFtpbmRleF0gPSBmYWxzZTtcbiAgICB0YWtlbkF1ZGlvcy5jdXJyZW50ID0gY2xvbmVkO1xuICAgIGF1ZGlvcy5jdXJyZW50ID0gYXVkaW9zLmN1cnJlbnQ/LmZpbHRlcigoYSkgPT4gYS5pZCAhPT0gaWQpO1xuICAgIHJlcmVuZGVyQXVkaW9zKCk7XG4gIH0sIFtyZWZzLCByZXJlbmRlckF1ZGlvc10pO1xuICBjb25zdCB1cGRhdGVBdWRpbyA9IHVzZUNhbGxiYWNrOCgoe1xuICAgIGF1ZCxcbiAgICBhdWRpb0lkLFxuICAgIGlkXG4gIH0pID0+IHtcbiAgICBsZXQgY2hhbmdlZCA9IGZhbHNlO1xuICAgIGF1ZGlvcy5jdXJyZW50ID0gYXVkaW9zLmN1cnJlbnQ/Lm1hcCgocHJldkEpID0+IHtcbiAgICAgIGlmIChwcmV2QS5pZCA9PT0gaWQpIHtcbiAgICAgICAgY29uc3QgaXNUaGVTYW1lID0gY29tcGFyZVByb3BzKGF1ZCwgcHJldkEucHJvcHMpO1xuICAgICAgICBpZiAoaXNUaGVTYW1lKSB7XG4gICAgICAgICAgcmV0dXJuIHByZXZBO1xuICAgICAgICB9XG4gICAgICAgIGNoYW5nZWQgPSB0cnVlO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIC4uLnByZXZBLFxuICAgICAgICAgIHByb3BzOiBhdWQsXG4gICAgICAgICAgYXVkaW9JZFxuICAgICAgICB9O1xuICAgICAgfVxuICAgICAgcmV0dXJuIHByZXZBO1xuICAgIH0pO1xuICAgIGlmIChjaGFuZ2VkKSB7XG4gICAgICByZXJlbmRlckF1ZGlvcygpO1xuICAgIH1cbiAgfSwgW3JlcmVuZGVyQXVkaW9zXSk7XG4gIGNvbnN0IHBsYXlBbGxBdWRpb3MgPSB1c2VDYWxsYmFjazgoKCkgPT4ge1xuICAgIHJlZnMuZm9yRWFjaCgocmVmKSA9PiB7XG4gICAgICBwbGF5QW5kSGFuZGxlTm90QWxsb3dlZEVycm9yKHJlZi5yZWYsIFwiYXVkaW9cIiwgbnVsbCk7XG4gICAgfSk7XG4gIH0sIFtyZWZzXSk7XG4gIGNvbnN0IHZhbHVlID0gdXNlTWVtbzE5KCgpID0+IHtcbiAgICByZXR1cm4ge1xuICAgICAgcmVnaXN0ZXJBdWRpbyxcbiAgICAgIHVucmVnaXN0ZXJBdWRpbyxcbiAgICAgIHVwZGF0ZUF1ZGlvLFxuICAgICAgcGxheUFsbEF1ZGlvcyxcbiAgICAgIG51bWJlck9mQXVkaW9UYWdzXG4gICAgfTtcbiAgfSwgW1xuICAgIG51bWJlck9mQXVkaW9UYWdzLFxuICAgIHBsYXlBbGxBdWRpb3MsXG4gICAgcmVnaXN0ZXJBdWRpbyxcbiAgICB1bnJlZ2lzdGVyQXVkaW8sXG4gICAgdXBkYXRlQXVkaW9cbiAgXSk7XG4gIGNvbnN0IHJlc2V0QXVkaW8gPSB1c2VDYWxsYmFjazgoKCkgPT4ge1xuICAgIHRha2VuQXVkaW9zLmN1cnJlbnQgPSBuZXcgQXJyYXkobnVtYmVyT2ZBdWRpb1RhZ3MpLmZpbGwoZmFsc2UpO1xuICAgIGF1ZGlvcy5jdXJyZW50ID0gW107XG4gICAgcmVyZW5kZXJBdWRpb3MoKTtcbiAgfSwgW251bWJlck9mQXVkaW9UYWdzLCByZXJlbmRlckF1ZGlvc10pO1xuICB1c2VFZmZlY3QxNSgoKSA9PiB7XG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgIHJlc2V0QXVkaW8oKTtcbiAgICB9O1xuICB9LCBbY29tcG9uZW50LCByZXNldEF1ZGlvXSk7XG4gIHJldHVybiAvKiBAX19QVVJFX18gKi8ganN4cyhTaGFyZWRBdWRpb0NvbnRleHQuUHJvdmlkZXIsIHtcbiAgICB2YWx1ZSxcbiAgICBjaGlsZHJlbjogW1xuICAgICAgcmVmcy5tYXAoKHsgaWQsIHJlZiB9KSA9PiB7XG4gICAgICAgIHJldHVybiAvKiBAX19QVVJFX18gKi8ganN4MTUoXCJhdWRpb1wiLCB7XG4gICAgICAgICAgcmVmLFxuICAgICAgICAgIHByZWxvYWQ6IFwibWV0YWRhdGFcIixcbiAgICAgICAgICBzcmM6IEVNUFRZX0FVRElPXG4gICAgICAgIH0sIGlkKTtcbiAgICAgIH0pLFxuICAgICAgY2hpbGRyZW5cbiAgICBdXG4gIH0pO1xufTtcbnZhciB1c2VTaGFyZWRBdWRpbyA9IChhdWQsIGF1ZGlvSWQpID0+IHtcbiAgY29uc3QgY3R4ID0gdXNlQ29udGV4dDIwKFNoYXJlZEF1ZGlvQ29udGV4dCk7XG4gIGNvbnN0IFtlbGVtXSA9IHVzZVN0YXRlMTMoKCkgPT4ge1xuICAgIGlmIChjdHggJiYgY3R4Lm51bWJlck9mQXVkaW9UYWdzID4gMCkge1xuICAgICAgcmV0dXJuIGN0eC5yZWdpc3RlckF1ZGlvKGF1ZCwgYXVkaW9JZCk7XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICBlbDogUmVhY3QxMi5jcmVhdGVSZWYoKSxcbiAgICAgIGlkOiBNYXRoLnJhbmRvbSgpLFxuICAgICAgcHJvcHM6IGF1ZCxcbiAgICAgIGF1ZGlvSWRcbiAgICB9O1xuICB9KTtcbiAgY29uc3QgZWZmZWN0VG9Vc2UgPSBSZWFjdDEyLnVzZUluc2VydGlvbkVmZmVjdCA/PyBSZWFjdDEyLnVzZUxheW91dEVmZmVjdDtcbiAgaWYgKHR5cGVvZiBkb2N1bWVudCAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgIGVmZmVjdFRvVXNlKCgpID0+IHtcbiAgICAgIGlmIChjdHggJiYgY3R4Lm51bWJlck9mQXVkaW9UYWdzID4gMCkge1xuICAgICAgICBjdHgudXBkYXRlQXVkaW8oeyBpZDogZWxlbS5pZCwgYXVkLCBhdWRpb0lkIH0pO1xuICAgICAgfVxuICAgIH0sIFthdWQsIGN0eCwgZWxlbS5pZCwgYXVkaW9JZF0pO1xuICAgIGVmZmVjdFRvVXNlKCgpID0+IHtcbiAgICAgIHJldHVybiAoKSA9PiB7XG4gICAgICAgIGlmIChjdHggJiYgY3R4Lm51bWJlck9mQXVkaW9UYWdzID4gMCkge1xuICAgICAgICAgIGN0eC51bnJlZ2lzdGVyQXVkaW8oZWxlbS5pZCk7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfSwgW2N0eCwgZWxlbS5pZF0pO1xuICB9XG4gIHJldHVybiBlbGVtO1xufTtcblxuLy8gc3JjL2F1ZGlvL0F1ZGlvRm9yUHJldmlldy50c3hcbmltcG9ydCB7IGpzeCBhcyBqc3gxNiB9IGZyb20gXCJyZWFjdC9qc3gtcnVudGltZVwiO1xudmFyIEF1ZGlvRm9yRGV2ZWxvcG1lbnRGb3J3YXJkUmVmRnVuY3Rpb24gPSAocHJvcHMsIHJlZikgPT4ge1xuICBjb25zdCBbaW5pdGlhbFNob3VsZFByZU1vdW50QXVkaW9FbGVtZW50c10gPSB1c2VTdGF0ZTE0KHByb3BzLnNob3VsZFByZU1vdW50QXVkaW9UYWdzKTtcbiAgaWYgKHByb3BzLnNob3VsZFByZU1vdW50QXVkaW9UYWdzICE9PSBpbml0aWFsU2hvdWxkUHJlTW91bnRBdWRpb0VsZW1lbnRzKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IGNoYW5nZSB0aGUgYmVoYXZpb3IgZm9yIHByZS1tb3VudGluZyBhdWRpbyB0YWdzIGR5bmFtaWNhbGx5LlwiKTtcbiAgfVxuICBjb25zdCB7XG4gICAgdm9sdW1lLFxuICAgIG11dGVkLFxuICAgIHBsYXliYWNrUmF0ZSxcbiAgICBzaG91bGRQcmVNb3VudEF1ZGlvVGFncyxcbiAgICBzcmMsXG4gICAgb25EdXJhdGlvbixcbiAgICBhY2NlcHRhYmxlVGltZVNoaWZ0SW5TZWNvbmRzLFxuICAgIF9yZW1vdGlvbkludGVybmFsTmVlZHNEdXJhdGlvbkNhbGN1bGF0aW9uLFxuICAgIF9yZW1vdGlvbkludGVybmFsTmF0aXZlTG9vcFBhc3NlZCxcbiAgICBfcmVtb3Rpb25JbnRlcm5hbFN0YWNrLFxuICAgIF9yZW1vdGlvbkRlYnVnU2Vla2luZyxcbiAgICBhbGxvd0FtcGxpZmljYXRpb25EdXJpbmdSZW5kZXIsXG4gICAgbmFtZSxcbiAgICBwYXVzZVdoZW5CdWZmZXJpbmcsXG4gICAgc2hvd0luVGltZWxpbmUsXG4gICAgbG9vcFZvbHVtZUN1cnZlQmVoYXZpb3IsXG4gICAgc3RhY2ssXG4gICAgLi4ubmF0aXZlUHJvcHNcbiAgfSA9IHByb3BzO1xuICBjb25zdCBbbWVkaWFWb2x1bWVdID0gdXNlTWVkaWFWb2x1bWVTdGF0ZSgpO1xuICBjb25zdCBbbWVkaWFNdXRlZF0gPSB1c2VNZWRpYU11dGVkU3RhdGUoKTtcbiAgY29uc3Qgdm9sdW1lUHJvcEZyYW1lID0gdXNlRnJhbWVGb3JWb2x1bWVQcm9wKGxvb3BWb2x1bWVDdXJ2ZUJlaGF2aW9yID8/IFwicmVwZWF0XCIpO1xuICBjb25zdCB7IGhpZGRlbiB9ID0gdXNlQ29udGV4dDIxKFNlcXVlbmNlVmlzaWJpbGl0eVRvZ2dsZUNvbnRleHQpO1xuICBpZiAoIXNyYykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJObyAnc3JjJyB3YXMgcGFzc2VkIHRvIDxBdWRpbz4uXCIpO1xuICB9XG4gIGNvbnN0IHByZWxvYWRlZFNyYyA9IHVzZVByZWxvYWQoc3JjKTtcbiAgY29uc3Qgc2VxdWVuY2VDb250ZXh0ID0gdXNlQ29udGV4dDIxKFNlcXVlbmNlQ29udGV4dCk7XG4gIGNvbnN0IFt0aW1lbGluZUlkXSA9IHVzZVN0YXRlMTQoKCkgPT4gU3RyaW5nKE1hdGgucmFuZG9tKCkpKTtcbiAgY29uc3QgaXNTZXF1ZW5jZUhpZGRlbiA9IGhpZGRlblt0aW1lbGluZUlkXSA/PyBmYWxzZTtcbiAgY29uc3QgdXNlclByZWZlcnJlZFZvbHVtZSA9IGV2YWx1YXRlVm9sdW1lKHtcbiAgICBmcmFtZTogdm9sdW1lUHJvcEZyYW1lLFxuICAgIHZvbHVtZSxcbiAgICBtZWRpYVZvbHVtZSxcbiAgICBhbGxvd0FtcGxpZmljYXRpb25EdXJpbmdSZW5kZXI6IGZhbHNlXG4gIH0pO1xuICBjb25zdCBwcm9wc1RvUGFzcyA9IHVzZU1lbW8yMCgoKSA9PiB7XG4gICAgcmV0dXJuIHtcbiAgICAgIG11dGVkOiBtdXRlZCB8fCBtZWRpYU11dGVkIHx8IGlzU2VxdWVuY2VIaWRkZW4gfHwgdXNlclByZWZlcnJlZFZvbHVtZSA8PSAwLFxuICAgICAgc3JjOiBwcmVsb2FkZWRTcmMsXG4gICAgICBsb29wOiBfcmVtb3Rpb25JbnRlcm5hbE5hdGl2ZUxvb3BQYXNzZWQsXG4gICAgICAuLi5uYXRpdmVQcm9wc1xuICAgIH07XG4gIH0sIFtcbiAgICBfcmVtb3Rpb25JbnRlcm5hbE5hdGl2ZUxvb3BQYXNzZWQsXG4gICAgaXNTZXF1ZW5jZUhpZGRlbixcbiAgICBtZWRpYU11dGVkLFxuICAgIG11dGVkLFxuICAgIG5hdGl2ZVByb3BzLFxuICAgIHByZWxvYWRlZFNyYyxcbiAgICB1c2VyUHJlZmVycmVkVm9sdW1lXG4gIF0pO1xuICBjb25zdCBpZCA9IHVzZU1lbW8yMCgoKSA9PiBgYXVkaW8tJHtyYW5kb20oc3JjID8/IFwiXCIpfS0ke3NlcXVlbmNlQ29udGV4dD8ucmVsYXRpdmVGcm9tfS0ke3NlcXVlbmNlQ29udGV4dD8uY3VtdWxhdGVkRnJvbX0tJHtzZXF1ZW5jZUNvbnRleHQ/LmR1cmF0aW9uSW5GcmFtZXN9LW11dGVkOiR7cHJvcHMubXV0ZWR9LWxvb3A6JHtwcm9wcy5sb29wfWAsIFtcbiAgICBzcmMsXG4gICAgc2VxdWVuY2VDb250ZXh0Py5yZWxhdGl2ZUZyb20sXG4gICAgc2VxdWVuY2VDb250ZXh0Py5jdW11bGF0ZWRGcm9tLFxuICAgIHNlcXVlbmNlQ29udGV4dD8uZHVyYXRpb25JbkZyYW1lcyxcbiAgICBwcm9wcy5tdXRlZCxcbiAgICBwcm9wcy5sb29wXG4gIF0pO1xuICBjb25zdCBhdWRpb1JlZiA9IHVzZVNoYXJlZEF1ZGlvKHByb3BzVG9QYXNzLCBpZCkuZWw7XG4gIGNvbnN0IGFjdHVhbFZvbHVtZSA9IHVzZU1lZGlhVGFnVm9sdW1lKGF1ZGlvUmVmKTtcbiAgdXNlU3luY1ZvbHVtZVdpdGhNZWRpYVRhZyh7XG4gICAgdm9sdW1lUHJvcEZyYW1lLFxuICAgIGFjdHVhbFZvbHVtZSxcbiAgICB2b2x1bWUsXG4gICAgbWVkaWFWb2x1bWUsXG4gICAgbWVkaWFSZWY6IGF1ZGlvUmVmXG4gIH0pO1xuICB1c2VNZWRpYUluVGltZWxpbmUoe1xuICAgIHZvbHVtZSxcbiAgICBtZWRpYVZvbHVtZSxcbiAgICBtZWRpYVJlZjogYXVkaW9SZWYsXG4gICAgc3JjLFxuICAgIG1lZGlhVHlwZTogXCJhdWRpb1wiLFxuICAgIHBsYXliYWNrUmF0ZTogcGxheWJhY2tSYXRlID8/IDEsXG4gICAgZGlzcGxheU5hbWU6IG5hbWUgPz8gbnVsbCxcbiAgICBpZDogdGltZWxpbmVJZCxcbiAgICBzdGFjazogX3JlbW90aW9uSW50ZXJuYWxTdGFjayxcbiAgICBzaG93SW5UaW1lbGluZSxcbiAgICBwcmVtb3VudERpc3BsYXk6IG51bGwsXG4gICAgb25BdXRvUGxheUVycm9yOiBudWxsXG4gIH0pO1xuICB1c2VNZWRpYVBsYXliYWNrKHtcbiAgICBtZWRpYVJlZjogYXVkaW9SZWYsXG4gICAgc3JjLFxuICAgIG1lZGlhVHlwZTogXCJhdWRpb1wiLFxuICAgIHBsYXliYWNrUmF0ZTogcGxheWJhY2tSYXRlID8/IDEsXG4gICAgb25seVdhcm5Gb3JNZWRpYVNlZWtpbmdFcnJvcjogZmFsc2UsXG4gICAgYWNjZXB0YWJsZVRpbWVzaGlmdDogYWNjZXB0YWJsZVRpbWVTaGlmdEluU2Vjb25kcyA/PyBERUZBVUxUX0FDQ0VQVEFCTEVfVElNRVNISUZULFxuICAgIGlzUHJlbW91bnRpbmc6IEJvb2xlYW4oc2VxdWVuY2VDb250ZXh0Py5wcmVtb3VudGluZyksXG4gICAgcGF1c2VXaGVuQnVmZmVyaW5nLFxuICAgIGRlYnVnU2Vla2luZzogX3JlbW90aW9uRGVidWdTZWVraW5nLFxuICAgIG9uQXV0b1BsYXlFcnJvcjogbnVsbFxuICB9KTtcbiAgdXNlSW1wZXJhdGl2ZUhhbmRsZTMocmVmLCAoKSA9PiB7XG4gICAgcmV0dXJuIGF1ZGlvUmVmLmN1cnJlbnQ7XG4gIH0sIFthdWRpb1JlZl0pO1xuICBjb25zdCBjdXJyZW50T25EdXJhdGlvbkNhbGxiYWNrID0gdXNlUmVmOCgpO1xuICBjdXJyZW50T25EdXJhdGlvbkNhbGxiYWNrLmN1cnJlbnQgPSBvbkR1cmF0aW9uO1xuICB1c2VFZmZlY3QxNigoKSA9PiB7XG4gICAgY29uc3QgeyBjdXJyZW50IH0gPSBhdWRpb1JlZjtcbiAgICBpZiAoIWN1cnJlbnQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKGN1cnJlbnQuZHVyYXRpb24pIHtcbiAgICAgIGN1cnJlbnRPbkR1cmF0aW9uQ2FsbGJhY2suY3VycmVudD8uKGN1cnJlbnQuc3JjLCBjdXJyZW50LmR1cmF0aW9uKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3Qgb25Mb2FkZWRNZXRhZGF0YSA9ICgpID0+IHtcbiAgICAgIGN1cnJlbnRPbkR1cmF0aW9uQ2FsbGJhY2suY3VycmVudD8uKGN1cnJlbnQuc3JjLCBjdXJyZW50LmR1cmF0aW9uKTtcbiAgICB9O1xuICAgIGN1cnJlbnQuYWRkRXZlbnRMaXN0ZW5lcihcImxvYWRlZG1ldGFkYXRhXCIsIG9uTG9hZGVkTWV0YWRhdGEpO1xuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICBjdXJyZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJsb2FkZWRtZXRhZGF0YVwiLCBvbkxvYWRlZE1ldGFkYXRhKTtcbiAgICB9O1xuICB9LCBbYXVkaW9SZWYsIHNyY10pO1xuICBpZiAoaW5pdGlhbFNob3VsZFByZU1vdW50QXVkaW9FbGVtZW50cykge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIHJldHVybiAvKiBAX19QVVJFX18gKi8ganN4MTYoXCJhdWRpb1wiLCB7XG4gICAgcmVmOiBhdWRpb1JlZixcbiAgICBwcmVsb2FkOiBcIm1ldGFkYXRhXCIsXG4gICAgLi4ucHJvcHNUb1Bhc3NcbiAgfSk7XG59O1xudmFyIEF1ZGlvRm9yUHJldmlldyA9IGZvcndhcmRSZWYzKEF1ZGlvRm9yRGV2ZWxvcG1lbnRGb3J3YXJkUmVmRnVuY3Rpb24pO1xuXG4vLyBzcmMvYXVkaW8vQXVkaW9Gb3JSZW5kZXJpbmcudHN4XG5pbXBvcnQge1xuICBmb3J3YXJkUmVmIGFzIGZvcndhcmRSZWY0LFxuICB1c2VDb250ZXh0IGFzIHVzZUNvbnRleHQyMixcbiAgdXNlRWZmZWN0IGFzIHVzZUVmZmVjdDE3LFxuICB1c2VJbXBlcmF0aXZlSGFuZGxlIGFzIHVzZUltcGVyYXRpdmVIYW5kbGU0LFxuICB1c2VMYXlvdXRFZmZlY3QgYXMgdXNlTGF5b3V0RWZmZWN0MyxcbiAgdXNlTWVtbyBhcyB1c2VNZW1vMjEsXG4gIHVzZVJlZiBhcyB1c2VSZWY5XG59IGZyb20gXCJyZWFjdFwiO1xuXG4vLyBzcmMvZGVsYXktcmVuZGVyLnRzXG5pZiAodHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIikge1xuICB3aW5kb3cucmVtb3Rpb25fcmVuZGVyUmVhZHkgPSBmYWxzZTtcbn1cbnZhciBoYW5kbGVzID0gW107XG5pZiAodHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIikge1xuICB3aW5kb3cucmVtb3Rpb25fZGVsYXlSZW5kZXJUaW1lb3V0cyA9IHt9O1xufVxudmFyIERFTEFZX1JFTkRFUl9DQUxMU1RBQ0tfVE9LRU4gPSBcIlRoZSBkZWxheVJlbmRlciB3YXMgY2FsbGVkOlwiO1xudmFyIERFTEFZX1JFTkRFUl9SRVRSSUVTX0xFRlQgPSBcIlJldHJpZXMgbGVmdDogXCI7XG52YXIgREVMQVlfUkVOREVSX1JFVFJZX1RPS0VOID0gXCItIFJlbmRlcmluZyB0aGUgZnJhbWUgd2lsbCBiZSByZXRyaWVkLlwiO1xudmFyIGRlZmF1bHRUaW1lb3V0ID0gMzAwMDA7XG52YXIgZGVsYXlSZW5kZXIgPSAobGFiZWwsIG9wdGlvbnMpID0+IHtcbiAgaWYgKHR5cGVvZiBsYWJlbCAhPT0gXCJzdHJpbmdcIiAmJiB0eXBlb2YgbGFiZWwgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJUaGUgbGFiZWwgcGFyYW1ldGVyIG9mIGRlbGF5UmVuZGVyKCkgbXVzdCBiZSBhIHN0cmluZyBvciB1bmRlZmluZWQsIGdvdDogXCIgKyBKU09OLnN0cmluZ2lmeShsYWJlbCkpO1xuICB9XG4gIGNvbnN0IGhhbmRsZSA9IE1hdGgucmFuZG9tKCk7XG4gIGhhbmRsZXMucHVzaChoYW5kbGUpO1xuICBjb25zdCBjYWxsZWQgPSBFcnJvcigpLnN0YWNrPy5yZXBsYWNlKC9eRXJyb3IvZywgXCJcIikgPz8gXCJcIjtcbiAgaWYgKGdldFJlbW90aW9uRW52aXJvbm1lbnQoKS5pc1JlbmRlcmluZykge1xuICAgIGNvbnN0IHRpbWVvdXRUb1VzZSA9IChvcHRpb25zPy50aW1lb3V0SW5NaWxsaXNlY29uZHMgPz8gKHR5cGVvZiB3aW5kb3cgPT09IFwidW5kZWZpbmVkXCIgPyBkZWZhdWx0VGltZW91dCA6IHdpbmRvdy5yZW1vdGlvbl9wdXBwZXRlZXJUaW1lb3V0ID8/IGRlZmF1bHRUaW1lb3V0KSkgLSAyMDAwO1xuICAgIGlmICh0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICBjb25zdCByZXRyaWVzTGVmdCA9IChvcHRpb25zPy5yZXRyaWVzID8/IDApIC0gKHdpbmRvdy5yZW1vdGlvbl9hdHRlbXB0IC0gMSk7XG4gICAgICB3aW5kb3cucmVtb3Rpb25fZGVsYXlSZW5kZXJUaW1lb3V0c1toYW5kbGVdID0ge1xuICAgICAgICBsYWJlbDogbGFiZWwgPz8gbnVsbCxcbiAgICAgICAgdGltZW91dDogc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgY29uc3QgbWVzc2FnZSA9IFtcbiAgICAgICAgICAgIGBBIGRlbGF5UmVuZGVyKClgLFxuICAgICAgICAgICAgbGFiZWwgPyBgXCIke2xhYmVsfVwiYCA6IG51bGwsXG4gICAgICAgICAgICBgd2FzIGNhbGxlZCBidXQgbm90IGNsZWFyZWQgYWZ0ZXIgJHt0aW1lb3V0VG9Vc2V9bXMuIFNlZSBodHRwczovL3JlbW90aW9uLmRldi9kb2NzL3RpbWVvdXQgZm9yIGhlbHAuYCxcbiAgICAgICAgICAgIHJldHJpZXNMZWZ0ID4gMCA/IERFTEFZX1JFTkRFUl9SRVRSSUVTX0xFRlQgKyByZXRyaWVzTGVmdCA6IG51bGwsXG4gICAgICAgICAgICByZXRyaWVzTGVmdCA+IDAgPyBERUxBWV9SRU5ERVJfUkVUUllfVE9LRU4gOiBudWxsLFxuICAgICAgICAgICAgREVMQVlfUkVOREVSX0NBTExTVEFDS19UT0tFTixcbiAgICAgICAgICAgIGNhbGxlZFxuICAgICAgICAgIF0uZmlsdGVyKHRydXRoeSkuam9pbihcIiBcIik7XG4gICAgICAgICAgY2FuY2VsUmVuZGVyKEVycm9yKG1lc3NhZ2UpKTtcbiAgICAgICAgfSwgdGltZW91dFRvVXNlKVxuICAgICAgfTtcbiAgICB9XG4gIH1cbiAgaWYgKHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICB3aW5kb3cucmVtb3Rpb25fcmVuZGVyUmVhZHkgPSBmYWxzZTtcbiAgfVxuICByZXR1cm4gaGFuZGxlO1xufTtcbnZhciBjb250aW51ZVJlbmRlciA9IChoYW5kbGUpID0+IHtcbiAgaWYgKHR5cGVvZiBoYW5kbGUgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiVGhlIGNvbnRpbnVlUmVuZGVyKCkgbWV0aG9kIG11c3QgYmUgY2FsbGVkIHdpdGggYSBwYXJhbWV0ZXIgdGhhdCBpcyB0aGUgcmV0dXJuIHZhbHVlIG9mIGRlbGF5UmVuZGVyKCkuIE5vIHZhbHVlIHdhcyBwYXNzZWQuXCIpO1xuICB9XG4gIGlmICh0eXBlb2YgaGFuZGxlICE9PSBcIm51bWJlclwiKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlRoZSBwYXJhbWV0ZXIgcGFzc2VkIGludG8gY29udGludWVSZW5kZXIoKSBtdXN0IGJlIHRoZSByZXR1cm4gdmFsdWUgb2YgZGVsYXlSZW5kZXIoKSB3aGljaCBpcyBhIG51bWJlci4gR290OiBcIiArIEpTT04uc3RyaW5naWZ5KGhhbmRsZSkpO1xuICB9XG4gIGhhbmRsZXMgPSBoYW5kbGVzLmZpbHRlcigoaCkgPT4ge1xuICAgIGlmIChoID09PSBoYW5kbGUpIHtcbiAgICAgIGlmIChnZXRSZW1vdGlvbkVudmlyb25tZW50KCkuaXNSZW5kZXJpbmcpIHtcbiAgICAgICAgY2xlYXJUaW1lb3V0KHdpbmRvdy5yZW1vdGlvbl9kZWxheVJlbmRlclRpbWVvdXRzW2hhbmRsZV0udGltZW91dCk7XG4gICAgICAgIGRlbGV0ZSB3aW5kb3cucmVtb3Rpb25fZGVsYXlSZW5kZXJUaW1lb3V0c1toYW5kbGVdO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSk7XG4gIGlmIChoYW5kbGVzLmxlbmd0aCA9PT0gMCAmJiB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgd2luZG93LnJlbW90aW9uX3JlbmRlclJlYWR5ID0gdHJ1ZTtcbiAgfVxufTtcblxuLy8gc3JjL2F1ZGlvL0F1ZGlvRm9yUmVuZGVyaW5nLnRzeFxuaW1wb3J0IHsganN4IGFzIGpzeDE3IH0gZnJvbSBcInJlYWN0L2pzeC1ydW50aW1lXCI7XG52YXIgQXVkaW9Gb3JSZW5kZXJpbmdSZWZGb3J3YXJkaW5nRnVuY3Rpb24gPSAocHJvcHMsIHJlZikgPT4ge1xuICBjb25zdCBhdWRpb1JlZiA9IHVzZVJlZjkobnVsbCk7XG4gIGNvbnN0IHtcbiAgICB2b2x1bWU6IHZvbHVtZVByb3AsXG4gICAgcGxheWJhY2tSYXRlLFxuICAgIGFsbG93QW1wbGlmaWNhdGlvbkR1cmluZ1JlbmRlcixcbiAgICBvbkR1cmF0aW9uLFxuICAgIHRvbmVGcmVxdWVuY3ksXG4gICAgX3JlbW90aW9uSW50ZXJuYWxOZWVkc0R1cmF0aW9uQ2FsY3VsYXRpb24sXG4gICAgX3JlbW90aW9uSW50ZXJuYWxOYXRpdmVMb29wUGFzc2VkLFxuICAgIGFjY2VwdGFibGVUaW1lU2hpZnRJblNlY29uZHMsXG4gICAgbmFtZSxcbiAgICBvbkVycm9yLFxuICAgIGRlbGF5UmVuZGVyUmV0cmllcyxcbiAgICBkZWxheVJlbmRlclRpbWVvdXRJbk1pbGxpc2Vjb25kcyxcbiAgICBsb29wVm9sdW1lQ3VydmVCZWhhdmlvcixcbiAgICBwYXVzZVdoZW5CdWZmZXJpbmcsXG4gICAgLi4ubmF0aXZlUHJvcHNcbiAgfSA9IHByb3BzO1xuICBjb25zdCBhYnNvbHV0ZUZyYW1lID0gdXNlVGltZWxpbmVQb3NpdGlvbigpO1xuICBjb25zdCB2b2x1bWVQcm9wRnJhbWUgPSB1c2VGcmFtZUZvclZvbHVtZVByb3AobG9vcFZvbHVtZUN1cnZlQmVoYXZpb3IgPz8gXCJyZXBlYXRcIik7XG4gIGNvbnN0IGZyYW1lID0gdXNlQ3VycmVudEZyYW1lKCk7XG4gIGNvbnN0IHNlcXVlbmNlQ29udGV4dCA9IHVzZUNvbnRleHQyMihTZXF1ZW5jZUNvbnRleHQpO1xuICBjb25zdCB7IHJlZ2lzdGVyUmVuZGVyQXNzZXQsIHVucmVnaXN0ZXJSZW5kZXJBc3NldCB9ID0gdXNlQ29udGV4dDIyKFJlbmRlckFzc2V0TWFuYWdlcik7XG4gIGNvbnN0IGlkID0gdXNlTWVtbzIxKCgpID0+IGBhdWRpby0ke3JhbmRvbShwcm9wcy5zcmMgPz8gXCJcIil9LSR7c2VxdWVuY2VDb250ZXh0Py5yZWxhdGl2ZUZyb219LSR7c2VxdWVuY2VDb250ZXh0Py5jdW11bGF0ZWRGcm9tfS0ke3NlcXVlbmNlQ29udGV4dD8uZHVyYXRpb25JbkZyYW1lc31gLCBbXG4gICAgcHJvcHMuc3JjLFxuICAgIHNlcXVlbmNlQ29udGV4dD8ucmVsYXRpdmVGcm9tLFxuICAgIHNlcXVlbmNlQ29udGV4dD8uY3VtdWxhdGVkRnJvbSxcbiAgICBzZXF1ZW5jZUNvbnRleHQ/LmR1cmF0aW9uSW5GcmFtZXNcbiAgXSk7XG4gIGNvbnN0IHZvbHVtZSA9IGV2YWx1YXRlVm9sdW1lKHtcbiAgICB2b2x1bWU6IHZvbHVtZVByb3AsXG4gICAgZnJhbWU6IHZvbHVtZVByb3BGcmFtZSxcbiAgICBtZWRpYVZvbHVtZTogMSxcbiAgICBhbGxvd0FtcGxpZmljYXRpb25EdXJpbmdSZW5kZXI6IGFsbG93QW1wbGlmaWNhdGlvbkR1cmluZ1JlbmRlciA/PyBmYWxzZVxuICB9KTtcbiAgdXNlSW1wZXJhdGl2ZUhhbmRsZTQocmVmLCAoKSA9PiB7XG4gICAgcmV0dXJuIGF1ZGlvUmVmLmN1cnJlbnQ7XG4gIH0sIFtdKTtcbiAgdXNlRWZmZWN0MTcoKCkgPT4ge1xuICAgIGlmICghcHJvcHMuc3JjKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJObyBzcmMgcGFzc2VkXCIpO1xuICAgIH1cbiAgICBpZiAoIXdpbmRvdy5yZW1vdGlvbl9hdWRpb0VuYWJsZWQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKHByb3BzLm11dGVkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICh2b2x1bWUgPD0gMCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICByZWdpc3RlclJlbmRlckFzc2V0KHtcbiAgICAgIHR5cGU6IFwiYXVkaW9cIixcbiAgICAgIHNyYzogZ2V0QWJzb2x1dGVTcmMocHJvcHMuc3JjKSxcbiAgICAgIGlkLFxuICAgICAgZnJhbWU6IGFic29sdXRlRnJhbWUsXG4gICAgICB2b2x1bWUsXG4gICAgICBtZWRpYUZyYW1lOiBmcmFtZSxcbiAgICAgIHBsYXliYWNrUmF0ZTogcHJvcHMucGxheWJhY2tSYXRlID8/IDEsXG4gICAgICBhbGxvd0FtcGxpZmljYXRpb25EdXJpbmdSZW5kZXI6IGFsbG93QW1wbGlmaWNhdGlvbkR1cmluZ1JlbmRlciA/PyBmYWxzZSxcbiAgICAgIHRvbmVGcmVxdWVuY3k6IHRvbmVGcmVxdWVuY3kgPz8gbnVsbCxcbiAgICAgIGF1ZGlvU3RhcnRGcmFtZTogTWF0aC5tYXgoMCwgLShzZXF1ZW5jZUNvbnRleHQ/LnJlbGF0aXZlRnJvbSA/PyAwKSlcbiAgICB9KTtcbiAgICByZXR1cm4gKCkgPT4gdW5yZWdpc3RlclJlbmRlckFzc2V0KGlkKTtcbiAgfSwgW1xuICAgIHByb3BzLm11dGVkLFxuICAgIHByb3BzLnNyYyxcbiAgICByZWdpc3RlclJlbmRlckFzc2V0LFxuICAgIGFic29sdXRlRnJhbWUsXG4gICAgaWQsXG4gICAgdW5yZWdpc3RlclJlbmRlckFzc2V0LFxuICAgIHZvbHVtZSxcbiAgICB2b2x1bWVQcm9wRnJhbWUsXG4gICAgZnJhbWUsXG4gICAgcGxheWJhY2tSYXRlLFxuICAgIHByb3BzLnBsYXliYWNrUmF0ZSxcbiAgICBhbGxvd0FtcGxpZmljYXRpb25EdXJpbmdSZW5kZXIsXG4gICAgdG9uZUZyZXF1ZW5jeSxcbiAgICBzZXF1ZW5jZUNvbnRleHQ/LnJlbGF0aXZlRnJvbVxuICBdKTtcbiAgY29uc3QgeyBzcmMgfSA9IHByb3BzO1xuICBjb25zdCBuZWVkc1RvUmVuZGVyQXVkaW9UYWcgPSByZWYgfHwgX3JlbW90aW9uSW50ZXJuYWxOZWVkc0R1cmF0aW9uQ2FsY3VsYXRpb247XG4gIHVzZUxheW91dEVmZmVjdDMoKCkgPT4ge1xuICAgIGlmICh3aW5kb3cucHJvY2Vzcz8uZW52Py5OT0RFX0VOViA9PT0gXCJ0ZXN0XCIpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKCFuZWVkc1RvUmVuZGVyQXVkaW9UYWcpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgbmV3SGFuZGxlID0gZGVsYXlSZW5kZXIoXCJMb2FkaW5nIDxBdWRpbz4gZHVyYXRpb24gd2l0aCBzcmM9XCIgKyBzcmMsIHtcbiAgICAgIHJldHJpZXM6IGRlbGF5UmVuZGVyUmV0cmllcyA/PyB1bmRlZmluZWQsXG4gICAgICB0aW1lb3V0SW5NaWxsaXNlY29uZHM6IGRlbGF5UmVuZGVyVGltZW91dEluTWlsbGlzZWNvbmRzID8/IHVuZGVmaW5lZFxuICAgIH0pO1xuICAgIGNvbnN0IHsgY3VycmVudCB9ID0gYXVkaW9SZWY7XG4gICAgY29uc3QgZGlkTG9hZCA9ICgpID0+IHtcbiAgICAgIGlmIChjdXJyZW50Py5kdXJhdGlvbikge1xuICAgICAgICBvbkR1cmF0aW9uKGN1cnJlbnQuc3JjLCBjdXJyZW50LmR1cmF0aW9uKTtcbiAgICAgIH1cbiAgICAgIGNvbnRpbnVlUmVuZGVyKG5ld0hhbmRsZSk7XG4gICAgfTtcbiAgICBpZiAoY3VycmVudD8uZHVyYXRpb24pIHtcbiAgICAgIG9uRHVyYXRpb24oY3VycmVudC5zcmMsIGN1cnJlbnQuZHVyYXRpb24pO1xuICAgICAgY29udGludWVSZW5kZXIobmV3SGFuZGxlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY3VycmVudD8uYWRkRXZlbnRMaXN0ZW5lcihcImxvYWRlZG1ldGFkYXRhXCIsIGRpZExvYWQsIHsgb25jZTogdHJ1ZSB9KTtcbiAgICB9XG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgIGN1cnJlbnQ/LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJsb2FkZWRtZXRhZGF0YVwiLCBkaWRMb2FkKTtcbiAgICAgIGNvbnRpbnVlUmVuZGVyKG5ld0hhbmRsZSk7XG4gICAgfTtcbiAgfSwgW1xuICAgIHNyYyxcbiAgICBvbkR1cmF0aW9uLFxuICAgIG5lZWRzVG9SZW5kZXJBdWRpb1RhZyxcbiAgICBkZWxheVJlbmRlclJldHJpZXMsXG4gICAgZGVsYXlSZW5kZXJUaW1lb3V0SW5NaWxsaXNlY29uZHNcbiAgXSk7XG4gIGlmICghbmVlZHNUb1JlbmRlckF1ZGlvVGFnKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqLyBqc3gxNyhcImF1ZGlvXCIsIHtcbiAgICByZWY6IGF1ZGlvUmVmLFxuICAgIC4uLm5hdGl2ZVByb3BzXG4gIH0pO1xufTtcbnZhciBBdWRpb0ZvclJlbmRlcmluZyA9IGZvcndhcmRSZWY0KEF1ZGlvRm9yUmVuZGVyaW5nUmVmRm9yd2FyZGluZ0Z1bmN0aW9uKTtcblxuLy8gc3JjL2F1ZGlvL0F1ZGlvLnRzeFxuaW1wb3J0IHsganN4IGFzIGpzeDE4IH0gZnJvbSBcInJlYWN0L2pzeC1ydW50aW1lXCI7XG52YXIgQXVkaW9SZWZGb3J3YXJkaW5nRnVuY3Rpb24gPSAocHJvcHMsIHJlZikgPT4ge1xuICBjb25zdCBhdWRpb0NvbnRleHQgPSB1c2VDb250ZXh0MjMoU2hhcmVkQXVkaW9Db250ZXh0KTtcbiAgY29uc3Qge1xuICAgIHN0YXJ0RnJvbSxcbiAgICBlbmRBdCxcbiAgICBuYW1lLFxuICAgIHN0YWNrLFxuICAgIHBhdXNlV2hlbkJ1ZmZlcmluZyxcbiAgICBzaG93SW5UaW1lbGluZSxcbiAgICBfcmVtb3Rpb25EZWJ1Z1NlZWtpbmcsXG4gICAgLi4ub3RoZXJQcm9wc1xuICB9ID0gcHJvcHM7XG4gIGNvbnN0IHsgbG9vcCwgLi4ucHJvcHNPdGhlclRoYW5Mb29wIH0gPSBwcm9wcztcbiAgY29uc3QgeyBmcHMgfSA9IHVzZVZpZGVvQ29uZmlnKCk7XG4gIGNvbnN0IGVudmlyb25tZW50ID0gZ2V0UmVtb3Rpb25FbnZpcm9ubWVudCgpO1xuICBjb25zdCB7IGR1cmF0aW9ucywgc2V0RHVyYXRpb25zIH0gPSB1c2VDb250ZXh0MjMoRHVyYXRpb25zQ29udGV4dCk7XG4gIGlmICh0eXBlb2YgcHJvcHMuc3JjICE9PSBcInN0cmluZ1wiKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgVGhlIFxcYDxBdWRpbz5cXGAgdGFnIHJlcXVpcmVzIGEgc3RyaW5nIGZvciBcXGBzcmNcXGAsIGJ1dCBnb3QgJHtKU09OLnN0cmluZ2lmeShwcm9wcy5zcmMpfSBpbnN0ZWFkLmApO1xuICB9XG4gIGNvbnN0IHByZWxvYWRlZFNyYyA9IHVzZVByZWxvYWQocHJvcHMuc3JjKTtcbiAgY29uc3Qgb25FcnJvciA9IHVzZUNhbGxiYWNrOSgoZSkgPT4ge1xuICAgIGNvbnNvbGUubG9nKGUuY3VycmVudFRhcmdldC5lcnJvcik7XG4gICAgY29uc3QgZXJyTWVzc2FnZSA9IGBDb3VsZCBub3QgcGxheSBhdWRpbyB3aXRoIHNyYyAke3ByZWxvYWRlZFNyY306ICR7ZS5jdXJyZW50VGFyZ2V0LmVycm9yfS4gU2VlIGh0dHBzOi8vcmVtb3Rpb24uZGV2L2RvY3MvbWVkaWEtcGxheWJhY2stZXJyb3IgZm9yIGhlbHAuYDtcbiAgICBpZiAobG9vcCkge1xuICAgICAgY2FuY2VsUmVuZGVyKG5ldyBFcnJvcihlcnJNZXNzYWdlKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnNvbGUud2FybihlcnJNZXNzYWdlKTtcbiAgICB9XG4gIH0sIFtsb29wLCBwcmVsb2FkZWRTcmNdKTtcbiAgY29uc3Qgb25EdXJhdGlvbiA9IHVzZUNhbGxiYWNrOSgoc3JjLCBkdXJhdGlvbkluU2Vjb25kcykgPT4ge1xuICAgIHNldER1cmF0aW9ucyh7IHR5cGU6IFwiZ290LWR1cmF0aW9uXCIsIGR1cmF0aW9uSW5TZWNvbmRzLCBzcmMgfSk7XG4gIH0sIFtzZXREdXJhdGlvbnNdKTtcbiAgY29uc3QgZHVyYXRpb25GZXRjaGVkID0gZHVyYXRpb25zW2dldEFic29sdXRlU3JjKHByZWxvYWRlZFNyYyldID8/IGR1cmF0aW9uc1tnZXRBYnNvbHV0ZVNyYyhwcm9wcy5zcmMpXTtcbiAgaWYgKGxvb3AgJiYgZHVyYXRpb25GZXRjaGVkICE9PSB1bmRlZmluZWQpIHtcbiAgICBjb25zdCBkdXJhdGlvbiA9IGR1cmF0aW9uRmV0Y2hlZCAqIGZwcztcbiAgICByZXR1cm4gLyogQF9fUFVSRV9fICovIGpzeDE4KExvb3AsIHtcbiAgICAgIGxheW91dDogXCJub25lXCIsXG4gICAgICBkdXJhdGlvbkluRnJhbWVzOiBjYWxjdWxhdGVMb29wRHVyYXRpb24oe1xuICAgICAgICBlbmRBdCxcbiAgICAgICAgbWVkaWFEdXJhdGlvbjogZHVyYXRpb24sXG4gICAgICAgIHBsYXliYWNrUmF0ZTogcHJvcHMucGxheWJhY2tSYXRlID8/IDEsXG4gICAgICAgIHN0YXJ0RnJvbVxuICAgICAgfSksXG4gICAgICBjaGlsZHJlbjogLyogQF9fUFVSRV9fICovIGpzeDE4KEF1ZGlvLCB7XG4gICAgICAgIC4uLnByb3BzT3RoZXJUaGFuTG9vcCxcbiAgICAgICAgcmVmLFxuICAgICAgICBfcmVtb3Rpb25JbnRlcm5hbE5hdGl2ZUxvb3BQYXNzZWQ6IHRydWVcbiAgICAgIH0pXG4gICAgfSk7XG4gIH1cbiAgaWYgKHR5cGVvZiBzdGFydEZyb20gIT09IFwidW5kZWZpbmVkXCIgfHwgdHlwZW9mIGVuZEF0ICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgdmFsaWRhdGVTdGFydEZyb21Qcm9wcyhzdGFydEZyb20sIGVuZEF0KTtcbiAgICBjb25zdCBzdGFydEZyb21GcmFtZU5vID0gc3RhcnRGcm9tID8/IDA7XG4gICAgY29uc3QgZW5kQXRGcmFtZU5vID0gZW5kQXQgPz8gSW5maW5pdHk7XG4gICAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqLyBqc3gxOChTZXF1ZW5jZSwge1xuICAgICAgbGF5b3V0OiBcIm5vbmVcIixcbiAgICAgIGZyb206IDAgLSBzdGFydEZyb21GcmFtZU5vLFxuICAgICAgc2hvd0luVGltZWxpbmU6IGZhbHNlLFxuICAgICAgZHVyYXRpb25JbkZyYW1lczogZW5kQXRGcmFtZU5vLFxuICAgICAgbmFtZSxcbiAgICAgIGNoaWxkcmVuOiAvKiBAX19QVVJFX18gKi8ganN4MTgoQXVkaW8sIHtcbiAgICAgICAgX3JlbW90aW9uSW50ZXJuYWxOZWVkc0R1cmF0aW9uQ2FsY3VsYXRpb246IEJvb2xlYW4obG9vcCksXG4gICAgICAgIHBhdXNlV2hlbkJ1ZmZlcmluZzogcGF1c2VXaGVuQnVmZmVyaW5nID8/IGZhbHNlLFxuICAgICAgICAuLi5vdGhlclByb3BzLFxuICAgICAgICByZWZcbiAgICAgIH0pXG4gICAgfSk7XG4gIH1cbiAgdmFsaWRhdGVNZWRpYVByb3BzKHByb3BzLCBcIkF1ZGlvXCIpO1xuICBpZiAoZW52aXJvbm1lbnQuaXNSZW5kZXJpbmcpIHtcbiAgICByZXR1cm4gLyogQF9fUFVSRV9fICovIGpzeDE4KEF1ZGlvRm9yUmVuZGVyaW5nLCB7XG4gICAgICBvbkR1cmF0aW9uLFxuICAgICAgLi4ucHJvcHMsXG4gICAgICByZWYsXG4gICAgICBvbkVycm9yLFxuICAgICAgX3JlbW90aW9uSW50ZXJuYWxOZWVkc0R1cmF0aW9uQ2FsY3VsYXRpb246IEJvb2xlYW4obG9vcClcbiAgICB9KTtcbiAgfVxuICByZXR1cm4gLyogQF9fUFVSRV9fICovIGpzeDE4KEF1ZGlvRm9yUHJldmlldywge1xuICAgIF9yZW1vdGlvbkludGVybmFsTmF0aXZlTG9vcFBhc3NlZDogcHJvcHMuX3JlbW90aW9uSW50ZXJuYWxOYXRpdmVMb29wUGFzc2VkID8/IGZhbHNlLFxuICAgIF9yZW1vdGlvbkRlYnVnU2Vla2luZzogX3JlbW90aW9uRGVidWdTZWVraW5nID8/IGZhbHNlLFxuICAgIF9yZW1vdGlvbkludGVybmFsU3RhY2s6IHN0YWNrID8/IG51bGwsXG4gICAgc2hvdWxkUHJlTW91bnRBdWRpb1RhZ3M6IGF1ZGlvQ29udGV4dCAhPT0gbnVsbCAmJiBhdWRpb0NvbnRleHQubnVtYmVyT2ZBdWRpb1RhZ3MgPiAwLFxuICAgIC4uLnByb3BzLFxuICAgIHJlZixcbiAgICBvbkVycm9yLFxuICAgIG9uRHVyYXRpb24sXG4gICAgcGF1c2VXaGVuQnVmZmVyaW5nOiBwYXVzZVdoZW5CdWZmZXJpbmcgPz8gZmFsc2UsXG4gICAgX3JlbW90aW9uSW50ZXJuYWxOZWVkc0R1cmF0aW9uQ2FsY3VsYXRpb246IEJvb2xlYW4obG9vcCksXG4gICAgc2hvd0luVGltZWxpbmU6IHNob3dJblRpbWVsaW5lID8/IHRydWVcbiAgfSk7XG59O1xudmFyIEF1ZGlvID0gZm9yd2FyZFJlZjUoQXVkaW9SZWZGb3J3YXJkaW5nRnVuY3Rpb24pO1xuYWRkU2VxdWVuY2VTdGFja1RyYWNlcyhBdWRpbyk7XG4vLyBzcmMvQ29tcG9zaXRpb24udHN4XG5pbXBvcnQgeyBTdXNwZW5zZSwgdXNlQ29udGV4dCBhcyB1c2VDb250ZXh0MjUsIHVzZUVmZmVjdCBhcyB1c2VFZmZlY3QxOSwgdXNlTWVtbyBhcyB1c2VNZW1vMjQgfSBmcm9tIFwicmVhY3RcIjtcbmltcG9ydCB7IGNyZWF0ZVBvcnRhbCB9IGZyb20gXCJyZWFjdC1kb21cIjtcblxuLy8gc3JjL0ZvbGRlci50c3hcbmltcG9ydCB7IGNyZWF0ZUNvbnRleHQgYXMgY3JlYXRlQ29udGV4dDE3LCB1c2VDb250ZXh0IGFzIHVzZUNvbnRleHQyNCwgdXNlRWZmZWN0IGFzIHVzZUVmZmVjdDE4LCB1c2VNZW1vIGFzIHVzZU1lbW8yMiB9IGZyb20gXCJyZWFjdFwiO1xuXG4vLyBzcmMvdmFsaWRhdGlvbi92YWxpZGF0ZS1mb2xkZXItbmFtZS50c1xudmFyIGdldFJlZ2V4ID0gKCkgPT4gL14oW2EtekEtWjAtOS1cXHU0RTAwLVxcdTlGRkZdKSskL2c7XG52YXIgaXNGb2xkZXJOYW1lVmFsaWQgPSAobmFtZSkgPT4gbmFtZS5tYXRjaChnZXRSZWdleCgpKTtcbnZhciB2YWxpZGF0ZUZvbGRlck5hbWUgPSAobmFtZSkgPT4ge1xuICBpZiAobmFtZSA9PT0gdW5kZWZpbmVkIHx8IG5hbWUgPT09IG51bGwpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiWW91IG11c3QgcGFzcyBhIG5hbWUgdG8gYSA8Rm9sZGVyIC8+LlwiKTtcbiAgfVxuICBpZiAodHlwZW9mIG5hbWUgIT09IFwic3RyaW5nXCIpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBUaGUgXCJuYW1lXCIgeW91IHBhc3MgaW50byA8Rm9sZGVyIC8+IG11c3QgYmUgYSBzdHJpbmcuIEdvdDogJHt0eXBlb2YgbmFtZX1gKTtcbiAgfVxuICBpZiAoIWlzRm9sZGVyTmFtZVZhbGlkKG5hbWUpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBGb2xkZXIgbmFtZSBjYW4gb25seSBjb250YWluIGEteiwgQS1aLCAwLTkgYW5kIC0uIFlvdSBwYXNzZWQgJHtuYW1lfWApO1xuICB9XG59O1xudmFyIGludmFsaWRGb2xkZXJOYW1lRXJyb3JNZXNzYWdlID0gYEZvbGRlciBuYW1lIG11c3QgbWF0Y2ggJHtTdHJpbmcoZ2V0UmVnZXgoKSl9YDtcblxuLy8gc3JjL0ZvbGRlci50c3hcbmltcG9ydCB7IGpzeCBhcyBqc3gxOSB9IGZyb20gXCJyZWFjdC9qc3gtcnVudGltZVwiO1xudmFyIEZvbGRlckNvbnRleHQgPSBjcmVhdGVDb250ZXh0MTcoe1xuICBmb2xkZXJOYW1lOiBudWxsLFxuICBwYXJlbnROYW1lOiBudWxsXG59KTtcbnZhciBGb2xkZXIgPSAoe1xuICBuYW1lLFxuICBjaGlsZHJlblxufSkgPT4ge1xuICBjb25zdCBwYXJlbnQgPSB1c2VDb250ZXh0MjQoRm9sZGVyQ29udGV4dCk7XG4gIGNvbnN0IHsgcmVnaXN0ZXJGb2xkZXIsIHVucmVnaXN0ZXJGb2xkZXIgfSA9IHVzZUNvbnRleHQyNChDb21wb3NpdGlvbk1hbmFnZXIpO1xuICB2YWxpZGF0ZUZvbGRlck5hbWUobmFtZSk7XG4gIGNvbnN0IHBhcmVudE5hbWVBcnIgPSBbcGFyZW50LnBhcmVudE5hbWUsIHBhcmVudC5mb2xkZXJOYW1lXS5maWx0ZXIodHJ1dGh5KTtcbiAgY29uc3QgcGFyZW50TmFtZSA9IHBhcmVudE5hbWVBcnIubGVuZ3RoID09PSAwID8gbnVsbCA6IHBhcmVudE5hbWVBcnIuam9pbihcIi9cIik7XG4gIGNvbnN0IHZhbHVlID0gdXNlTWVtbzIyKCgpID0+IHtcbiAgICByZXR1cm4ge1xuICAgICAgZm9sZGVyTmFtZTogbmFtZSxcbiAgICAgIHBhcmVudE5hbWVcbiAgICB9O1xuICB9LCBbbmFtZSwgcGFyZW50TmFtZV0pO1xuICB1c2VFZmZlY3QxOCgoKSA9PiB7XG4gICAgcmVnaXN0ZXJGb2xkZXIobmFtZSwgcGFyZW50TmFtZSk7XG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgIHVucmVnaXN0ZXJGb2xkZXIobmFtZSwgcGFyZW50TmFtZSk7XG4gICAgfTtcbiAgfSwgW25hbWUsIHBhcmVudC5mb2xkZXJOYW1lLCBwYXJlbnROYW1lLCByZWdpc3RlckZvbGRlciwgdW5yZWdpc3RlckZvbGRlcl0pO1xuICByZXR1cm4gLyogQF9fUFVSRV9fICovIGpzeDE5KEZvbGRlckNvbnRleHQuUHJvdmlkZXIsIHtcbiAgICB2YWx1ZSxcbiAgICBjaGlsZHJlblxuICB9KTtcbn07XG5cbi8vIHNyYy9sb2FkaW5nLWluZGljYXRvci50c3hcbmltcG9ydCB7IGpzeCBhcyBqc3gyMCwganN4cyBhcyBqc3hzMiB9IGZyb20gXCJyZWFjdC9qc3gtcnVudGltZVwiO1xudmFyIHJvdGF0ZSA9IHtcbiAgdHJhbnNmb3JtOiBgcm90YXRlKDkwZGVnKWBcbn07XG52YXIgSUNPTl9TSVpFID0gNDA7XG52YXIgbGFiZWwgPSB7XG4gIGNvbG9yOiBcIndoaXRlXCIsXG4gIGZvbnRTaXplOiAxNCxcbiAgZm9udEZhbWlseTogXCJzYW5zLXNlcmlmXCJcbn07XG52YXIgY29udGFpbmVyID0ge1xuICBqdXN0aWZ5Q29udGVudDogXCJjZW50ZXJcIixcbiAgYWxpZ25JdGVtczogXCJjZW50ZXJcIlxufTtcbnZhciBMb2FkaW5nID0gKCkgPT4ge1xuICByZXR1cm4gLyogQF9fUFVSRV9fICovIGpzeHMyKEFic29sdXRlRmlsbCwge1xuICAgIHN0eWxlOiBjb250YWluZXIsXG4gICAgaWQ6IFwicmVtb3Rpb24tY29tcC1sb2FkaW5nXCIsXG4gICAgY2hpbGRyZW46IFtcbiAgICAgIC8qIEBfX1BVUkVfXyAqLyBqc3gyMChcInN0eWxlXCIsIHtcbiAgICAgICAgdHlwZTogXCJ0ZXh0L2Nzc1wiLFxuICAgICAgICBjaGlsZHJlbjogYFxuXHRcdFx0XHRAa2V5ZnJhbWVzIGFuaW0ge1xuXHRcdFx0XHRcdGZyb20ge1xuXHRcdFx0XHRcdFx0b3BhY2l0eTogMFxuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHR0byB7XG5cdFx0XHRcdFx0XHRvcGFjaXR5OiAxXG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHRcdCNyZW1vdGlvbi1jb21wLWxvYWRpbmcge1xuXHRcdFx0XHRcdGFuaW1hdGlvbjogYW5pbSAycztcblx0XHRcdFx0XHRhbmltYXRpb24tZmlsbC1tb2RlOiBmb3J3YXJkcztcblx0XHRcdFx0fVxuXHRcdFx0YFxuICAgICAgfSksXG4gICAgICAvKiBAX19QVVJFX18gKi8ganN4MjAoXCJzdmdcIiwge1xuICAgICAgICB3aWR0aDogSUNPTl9TSVpFLFxuICAgICAgICBoZWlnaHQ6IElDT05fU0laRSxcbiAgICAgICAgdmlld0JveDogXCItMTAwIC0xMDAgNDAwIDQwMFwiLFxuICAgICAgICBzdHlsZTogcm90YXRlLFxuICAgICAgICBjaGlsZHJlbjogLyogQF9fUFVSRV9fICovIGpzeDIwKFwicGF0aFwiLCB7XG4gICAgICAgICAgZmlsbDogXCIjNTU1XCIsXG4gICAgICAgICAgc3Ryb2tlOiBcIiM1NTVcIixcbiAgICAgICAgICBzdHJva2VXaWR0aDogXCIxMDBcIixcbiAgICAgICAgICBzdHJva2VMaW5lam9pbjogXCJyb3VuZFwiLFxuICAgICAgICAgIGQ6IFwiTSAyIDE3MiBhIDE5NiAxMDAgMCAwIDAgMTk1IDUgQSAxOTYgMjQwIDAgMCAwIDEwMCAyLjI1OSBBIDE5NiAyNDAgMCAwIDAgMiAxNzIgelwiXG4gICAgICAgIH0pXG4gICAgICB9KSxcbiAgICAgIC8qIEBfX1BVUkVfXyAqLyBqc3hzMihcInBcIiwge1xuICAgICAgICBzdHlsZTogbGFiZWwsXG4gICAgICAgIGNoaWxkcmVuOiBbXG4gICAgICAgICAgXCJSZXNvbHZpbmcgXCIsXG4gICAgICAgICAgXCI8U3VzcGVuc2U+XCIsXG4gICAgICAgICAgXCIuLi5cIlxuICAgICAgICBdXG4gICAgICB9KVxuICAgIF1cbiAgfSk7XG59O1xuXG4vLyBzcmMvcG9ydGFsLW5vZGUudHNcbnZhciBfcG9ydGFsTm9kZSA9IG51bGw7XG52YXIgcG9ydGFsTm9kZSA9ICgpID0+IHtcbiAgaWYgKCFfcG9ydGFsTm9kZSkge1xuICAgIGlmICh0eXBlb2YgZG9jdW1lbnQgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIlRyaWVkIHRvIGNhbGwgYW4gQVBJIHRoYXQgb25seSB3b3JrcyBpbiB0aGUgYnJvd3NlciBmcm9tIG91dHNpZGUgdGhlIGJyb3dzZXJcIik7XG4gICAgfVxuICAgIF9wb3J0YWxOb2RlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgICBfcG9ydGFsTm9kZS5zdHlsZS5wb3NpdGlvbiA9IFwiYWJzb2x1dGVcIjtcbiAgICBfcG9ydGFsTm9kZS5zdHlsZS50b3AgPSBcIjBweFwiO1xuICAgIF9wb3J0YWxOb2RlLnN0eWxlLmxlZnQgPSBcIjBweFwiO1xuICAgIF9wb3J0YWxOb2RlLnN0eWxlLnJpZ2h0ID0gXCIwcHhcIjtcbiAgICBfcG9ydGFsTm9kZS5zdHlsZS5ib3R0b20gPSBcIjBweFwiO1xuICAgIF9wb3J0YWxOb2RlLnN0eWxlLndpZHRoID0gXCIxMDAlXCI7XG4gICAgX3BvcnRhbE5vZGUuc3R5bGUuaGVpZ2h0ID0gXCIxMDAlXCI7XG4gICAgX3BvcnRhbE5vZGUuc3R5bGUuZGlzcGxheSA9IFwiZmxleFwiO1xuICAgIF9wb3J0YWxOb2RlLnN0eWxlLmZsZXhEaXJlY3Rpb24gPSBcImNvbHVtblwiO1xuICAgIGNvbnN0IGNvbnRhaW5lck5vZGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICAgIGNvbnRhaW5lck5vZGUuc3R5bGUucG9zaXRpb24gPSBcImZpeGVkXCI7XG4gICAgY29udGFpbmVyTm9kZS5zdHlsZS50b3AgPSAtOTk5OTk5ICsgXCJweFwiO1xuICAgIGNvbnRhaW5lck5vZGUuYXBwZW5kQ2hpbGQoX3BvcnRhbE5vZGUpO1xuICAgIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQoY29udGFpbmVyTm9kZSk7XG4gIH1cbiAgcmV0dXJuIF9wb3J0YWxOb2RlO1xufTtcblxuLy8gc3JjL3VzZS1sYXp5LWNvbXBvbmVudC50c1xuaW1wb3J0IFJlYWN0MTYsIHsgdXNlTWVtbyBhcyB1c2VNZW1vMjMgfSBmcm9tIFwicmVhY3RcIjtcbnZhciB1c2VMYXp5Q29tcG9uZW50ID0gKGNvbXBQcm9wcykgPT4ge1xuICBjb25zdCBsYXp5ID0gdXNlTWVtbzIzKCgpID0+IHtcbiAgICBpZiAoXCJsYXp5Q29tcG9uZW50XCIgaW4gY29tcFByb3BzICYmIHR5cGVvZiBjb21wUHJvcHMubGF6eUNvbXBvbmVudCAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgcmV0dXJuIFJlYWN0MTYubGF6eShjb21wUHJvcHMubGF6eUNvbXBvbmVudCk7XG4gICAgfVxuICAgIGlmIChcImNvbXBvbmVudFwiIGluIGNvbXBQcm9wcykge1xuICAgICAgaWYgKHR5cGVvZiBkb2N1bWVudCA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICByZXR1cm4gY29tcFByb3BzLmNvbXBvbmVudDtcbiAgICAgIH1cbiAgICAgIHJldHVybiBSZWFjdDE2LmxhenkoKCkgPT4gUHJvbWlzZS5yZXNvbHZlKHsgZGVmYXVsdDogY29tcFByb3BzLmNvbXBvbmVudCB9KSk7XG4gICAgfVxuICAgIHRocm93IG5ldyBFcnJvcihcIllvdSBtdXN0IHBhc3MgZWl0aGVyICdjb21wb25lbnQnIG9yICdsYXp5Q29tcG9uZW50J1wiKTtcbiAgfSwgW2NvbXBQcm9wcy5jb21wb25lbnQsIGNvbXBQcm9wcy5sYXp5Q29tcG9uZW50XSk7XG4gIHJldHVybiBsYXp5O1xufTtcblxuLy8gc3JjL3ZhbGlkYXRpb24vdmFsaWRhdGUtY29tcG9zaXRpb24taWQudHNcbnZhciBnZXRSZWdleDIgPSAoKSA9PiAvXihbYS16QS1aMC05LVxcdTRFMDAtXFx1OUZGRl0pKyQvZztcbnZhciBpc0NvbXBvc2l0aW9uSWRWYWxpZCA9IChpZCkgPT4gaWQubWF0Y2goZ2V0UmVnZXgyKCkpO1xudmFyIHZhbGlkYXRlQ29tcG9zaXRpb25JZCA9IChpZCkgPT4ge1xuICBpZiAoIWlzQ29tcG9zaXRpb25JZFZhbGlkKGlkKSkge1xuICAgIHRocm93IG5ldyBFcnJvcihgQ29tcG9zaXRpb24gaWQgY2FuIG9ubHkgY29udGFpbiBhLXosIEEtWiwgMC05LCBDSksgY2hhcmFjdGVycyBhbmQgLS4gWW91IHBhc3NlZCAke2lkfWApO1xuICB9XG59O1xudmFyIGludmFsaWRDb21wb3NpdGlvbkVycm9yTWVzc2FnZSA9IGBDb21wb3NpdGlvbiBJRCBtdXN0IG1hdGNoICR7U3RyaW5nKGdldFJlZ2V4MigpKX1gO1xuXG4vLyBzcmMvdmFsaWRhdGlvbi92YWxpZGF0ZS1kZWZhdWx0LXByb3BzLnRzXG52YXIgdmFsaWRhdGVEZWZhdWx0QW5kSW5wdXRQcm9wcyA9IChkZWZhdWx0UHJvcHMsIG5hbWUsIGNvbXBvc2l0aW9uSWQpID0+IHtcbiAgaWYgKCFkZWZhdWx0UHJvcHMpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgaWYgKHR5cGVvZiBkZWZhdWx0UHJvcHMgIT09IFwib2JqZWN0XCIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYFwiJHtuYW1lfVwiIG11c3QgYmUgYW4gb2JqZWN0LCBidXQgeW91IHBhc3NlZCBhIHZhbHVlIG9mIHR5cGUgJHt0eXBlb2YgZGVmYXVsdFByb3BzfWApO1xuICB9XG4gIGlmIChBcnJheS5pc0FycmF5KGRlZmF1bHRQcm9wcykpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYFwiJHtuYW1lfVwiIG11c3QgYmUgYW4gb2JqZWN0LCBhbiBhcnJheSB3YXMgcGFzc2VkICR7Y29tcG9zaXRpb25JZCA/IGBmb3IgY29tcG9zaXRpb24gXCIke2NvbXBvc2l0aW9uSWR9XCJgIDogXCJcIn1gKTtcbiAgfVxufTtcblxuLy8gc3JjL0NvbXBvc2l0aW9uLnRzeFxuaW1wb3J0IHsganN4IGFzIGpzeDIxIH0gZnJvbSBcInJlYWN0L2pzeC1ydW50aW1lXCI7XG52YXIgQ2xpcENvbXBvc2l0aW9uID0gKHsgY2hpbGRyZW4gfSkgPT4ge1xuICBjb25zdCB7IGNsaXBSZWdpb24gfSA9IHVzZUNvbnRleHQyNShOYXRpdmVMYXllcnNDb250ZXh0KTtcbiAgY29uc3Qgc3R5bGUgPSB1c2VNZW1vMjQoKCkgPT4ge1xuICAgIHJldHVybiB7XG4gICAgICBkaXNwbGF5OiBcImZsZXhcIixcbiAgICAgIGZsZXhEaXJlY3Rpb246IFwicm93XCIsXG4gICAgICBvcGFjaXR5OiBjbGlwUmVnaW9uID09PSBcImhpZGVcIiA/IDAgOiAxLFxuICAgICAgY2xpcFBhdGg6IGNsaXBSZWdpb24gJiYgY2xpcFJlZ2lvbiAhPT0gXCJoaWRlXCIgPyBgcG9seWdvbigke2NsaXBSZWdpb24ueH1weCAke2NsaXBSZWdpb24ueX1weCwgJHtjbGlwUmVnaW9uLnh9cHggJHtjbGlwUmVnaW9uLmhlaWdodCArIGNsaXBSZWdpb24ueX1weCwgJHtjbGlwUmVnaW9uLndpZHRoICsgY2xpcFJlZ2lvbi54fXB4ICR7Y2xpcFJlZ2lvbi5oZWlnaHQgKyBjbGlwUmVnaW9uLnl9cHgsICR7Y2xpcFJlZ2lvbi53aWR0aCArIGNsaXBSZWdpb24ueH1weCAke2NsaXBSZWdpb24ueX1weClgIDogdW5kZWZpbmVkXG4gICAgfTtcbiAgfSwgW2NsaXBSZWdpb25dKTtcbiAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqLyBqc3gyMShBYnNvbHV0ZUZpbGwsIHtcbiAgICBzdHlsZSxcbiAgICBjaGlsZHJlblxuICB9KTtcbn07XG52YXIgRmFsbGJhY2sgPSAoKSA9PiB7XG4gIHVzZUVmZmVjdDE5KCgpID0+IHtcbiAgICBjb25zdCBmYWxsYmFjayA9IGRlbGF5UmVuZGVyKFwiV2FpdGluZyBmb3IgUm9vdCBjb21wb25lbnQgdG8gdW5zdXNwZW5kXCIpO1xuICAgIHJldHVybiAoKSA9PiBjb250aW51ZVJlbmRlcihmYWxsYmFjayk7XG4gIH0sIFtdKTtcbiAgcmV0dXJuIG51bGw7XG59O1xudmFyIENvbXBvc2l0aW9uID0gKHtcbiAgd2lkdGgsXG4gIGhlaWdodCxcbiAgZnBzLFxuICBkdXJhdGlvbkluRnJhbWVzLFxuICBpZCxcbiAgZGVmYXVsdFByb3BzLFxuICBzY2hlbWEsXG4gIC4uLmNvbXBQcm9wc1xufSkgPT4ge1xuICBjb25zdCB7IHJlZ2lzdGVyQ29tcG9zaXRpb24sIHVucmVnaXN0ZXJDb21wb3NpdGlvbiB9ID0gdXNlQ29udGV4dDI1KENvbXBvc2l0aW9uTWFuYWdlcik7XG4gIGNvbnN0IHZpZGVvID0gdXNlVmlkZW8oKTtcbiAgY29uc3QgbGF6eSA9IHVzZUxhenlDb21wb25lbnQoY29tcFByb3BzKTtcbiAgY29uc3Qgbm9uY2UgPSB1c2VOb25jZSgpO1xuICBjb25zdCBpc1BsYXllciA9IHVzZUlzUGxheWVyKCk7XG4gIGNvbnN0IGVudmlyb25tZW50ID0gZ2V0UmVtb3Rpb25FbnZpcm9ubWVudCgpO1xuICBjb25zdCBjYW5Vc2VDb21wb3NpdGlvbiA9IHVzZUNvbnRleHQyNShDYW5Vc2VSZW1vdGlvbkhvb2tzKTtcbiAgaWYgKGNhblVzZUNvbXBvc2l0aW9uKSB7XG4gICAgaWYgKGlzUGxheWVyKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCI8Q29tcG9zaXRpb24+IHdhcyBtb3VudGVkIGluc2lkZSB0aGUgYGNvbXBvbmVudGAgdGhhdCB3YXMgcGFzc2VkIHRvIHRoZSA8UGxheWVyPi4gU2VlIGh0dHBzOi8vcmVtb3Rpb24uZGV2L2RvY3Mvd3JvbmctY29tcG9zaXRpb24tbW91bnQgZm9yIGhlbHAuXCIpO1xuICAgIH1cbiAgICB0aHJvdyBuZXcgRXJyb3IoXCI8Q29tcG9zaXRpb24+IG1vdW50ZWQgaW5zaWRlIGFub3RoZXIgY29tcG9zaXRpb24uIFNlZSBodHRwczovL3JlbW90aW9uLmRldi9kb2NzL3dyb25nLWNvbXBvc2l0aW9uLW1vdW50IGZvciBoZWxwLlwiKTtcbiAgfVxuICBjb25zdCB7IGZvbGRlck5hbWUsIHBhcmVudE5hbWUgfSA9IHVzZUNvbnRleHQyNShGb2xkZXJDb250ZXh0KTtcbiAgdXNlRWZmZWN0MTkoKCkgPT4ge1xuICAgIGlmICghaWQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIk5vIGlkIGZvciBjb21wb3NpdGlvbiBwYXNzZWQuXCIpO1xuICAgIH1cbiAgICB2YWxpZGF0ZUNvbXBvc2l0aW9uSWQoaWQpO1xuICAgIHZhbGlkYXRlRGVmYXVsdEFuZElucHV0UHJvcHMoZGVmYXVsdFByb3BzLCBcImRlZmF1bHRQcm9wc1wiLCBpZCk7XG4gICAgcmVnaXN0ZXJDb21wb3NpdGlvbih7XG4gICAgICBkdXJhdGlvbkluRnJhbWVzOiBkdXJhdGlvbkluRnJhbWVzID8/IHVuZGVmaW5lZCxcbiAgICAgIGZwczogZnBzID8/IHVuZGVmaW5lZCxcbiAgICAgIGhlaWdodDogaGVpZ2h0ID8/IHVuZGVmaW5lZCxcbiAgICAgIHdpZHRoOiB3aWR0aCA/PyB1bmRlZmluZWQsXG4gICAgICBpZCxcbiAgICAgIGZvbGRlck5hbWUsXG4gICAgICBjb21wb25lbnQ6IGxhenksXG4gICAgICBkZWZhdWx0UHJvcHM6IHNlcmlhbGl6ZVRoZW5EZXNlcmlhbGl6ZUluU3R1ZGlvKGRlZmF1bHRQcm9wcyA/PyB7fSksXG4gICAgICBub25jZSxcbiAgICAgIHBhcmVudEZvbGRlck5hbWU6IHBhcmVudE5hbWUsXG4gICAgICBzY2hlbWE6IHNjaGVtYSA/PyBudWxsLFxuICAgICAgY2FsY3VsYXRlTWV0YWRhdGE6IGNvbXBQcm9wcy5jYWxjdWxhdGVNZXRhZGF0YSA/PyBudWxsXG4gICAgfSk7XG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgIHVucmVnaXN0ZXJDb21wb3NpdGlvbihpZCk7XG4gICAgfTtcbiAgfSwgW1xuICAgIGR1cmF0aW9uSW5GcmFtZXMsXG4gICAgZnBzLFxuICAgIGhlaWdodCxcbiAgICBsYXp5LFxuICAgIGlkLFxuICAgIGZvbGRlck5hbWUsXG4gICAgZGVmYXVsdFByb3BzLFxuICAgIHJlZ2lzdGVyQ29tcG9zaXRpb24sXG4gICAgdW5yZWdpc3RlckNvbXBvc2l0aW9uLFxuICAgIHdpZHRoLFxuICAgIG5vbmNlLFxuICAgIHBhcmVudE5hbWUsXG4gICAgc2NoZW1hLFxuICAgIGNvbXBQcm9wcy5jYWxjdWxhdGVNZXRhZGF0YVxuICBdKTtcbiAgY29uc3QgcmVzb2x2ZWQgPSB1c2VSZXNvbHZlZFZpZGVvQ29uZmlnKGlkKTtcbiAgaWYgKGVudmlyb25tZW50LmlzU3R1ZGlvICYmIHZpZGVvICYmIHZpZGVvLmNvbXBvbmVudCA9PT0gbGF6eSkge1xuICAgIGNvbnN0IENvbXAgPSBsYXp5O1xuICAgIGlmIChyZXNvbHZlZCA9PT0gbnVsbCB8fCByZXNvbHZlZC50eXBlICE9PSBcInN1Y2Nlc3NcIikge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHJldHVybiBjcmVhdGVQb3J0YWwoLyogQF9fUFVSRV9fICovIGpzeDIxKENsaXBDb21wb3NpdGlvbiwge1xuICAgICAgY2hpbGRyZW46IC8qIEBfX1BVUkVfXyAqLyBqc3gyMShDYW5Vc2VSZW1vdGlvbkhvb2tzUHJvdmlkZXIsIHtcbiAgICAgICAgY2hpbGRyZW46IC8qIEBfX1BVUkVfXyAqLyBqc3gyMShTdXNwZW5zZSwge1xuICAgICAgICAgIGZhbGxiYWNrOiAvKiBAX19QVVJFX18gKi8ganN4MjEoTG9hZGluZywge30pLFxuICAgICAgICAgIGNoaWxkcmVuOiAvKiBAX19QVVJFX18gKi8ganN4MjEoQ29tcCwge1xuICAgICAgICAgICAgLi4ucmVzb2x2ZWQucmVzdWx0LnByb3BzID8/IHt9XG4gICAgICAgICAgfSlcbiAgICAgICAgfSlcbiAgICAgIH0pXG4gICAgfSksIHBvcnRhbE5vZGUoKSk7XG4gIH1cbiAgaWYgKGVudmlyb25tZW50LmlzUmVuZGVyaW5nICYmIHZpZGVvICYmIHZpZGVvLmNvbXBvbmVudCA9PT0gbGF6eSkge1xuICAgIGNvbnN0IENvbXAgPSBsYXp5O1xuICAgIGlmIChyZXNvbHZlZCA9PT0gbnVsbCB8fCByZXNvbHZlZC50eXBlICE9PSBcInN1Y2Nlc3NcIikge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHJldHVybiBjcmVhdGVQb3J0YWwoLyogQF9fUFVSRV9fICovIGpzeDIxKENhblVzZVJlbW90aW9uSG9va3NQcm92aWRlciwge1xuICAgICAgY2hpbGRyZW46IC8qIEBfX1BVUkVfXyAqLyBqc3gyMShTdXNwZW5zZSwge1xuICAgICAgICBmYWxsYmFjazogLyogQF9fUFVSRV9fICovIGpzeDIxKEZhbGxiYWNrLCB7fSksXG4gICAgICAgIGNoaWxkcmVuOiAvKiBAX19QVVJFX18gKi8ganN4MjEoQ29tcCwge1xuICAgICAgICAgIC4uLnJlc29sdmVkLnJlc3VsdC5wcm9wcyA/PyB7fVxuICAgICAgICB9KVxuICAgICAgfSlcbiAgICB9KSwgcG9ydGFsTm9kZSgpKTtcbiAgfVxuICByZXR1cm4gbnVsbDtcbn07XG4vLyBzcmMvQ29tcG9zaXRpb25NYW5hZ2VyLnRzeFxuaW1wb3J0IFJlYWN0MTgsIHtcbiAgdXNlQ2FsbGJhY2sgYXMgdXNlQ2FsbGJhY2sxMCxcbiAgdXNlSW1wZXJhdGl2ZUhhbmRsZSBhcyB1c2VJbXBlcmF0aXZlSGFuZGxlNSxcbiAgdXNlTWVtbyBhcyB1c2VNZW1vMjUsXG4gIHVzZVJlZiBhcyB1c2VSZWYxMCxcbiAgdXNlU3RhdGUgYXMgdXNlU3RhdGUxNVxufSBmcm9tIFwicmVhY3RcIjtcbmltcG9ydCB7IGpzeCBhcyBqc3gyMiB9IGZyb20gXCJyZWFjdC9qc3gtcnVudGltZVwiO1xudmFyIGNvbXBvc2l0aW9uc1JlZiA9IFJlYWN0MTguY3JlYXRlUmVmKCk7XG52YXIgQ29tcG9zaXRpb25NYW5hZ2VyUHJvdmlkZXIgPSAoeyBjaGlsZHJlbiwgbnVtYmVyT2ZBdWRpb1RhZ3MgfSkgPT4ge1xuICBjb25zdCBbY29tcG9zaXRpb25zLCBzZXRDb21wb3NpdGlvbnNdID0gdXNlU3RhdGUxNShbXSk7XG4gIGNvbnN0IGN1cnJlbnRjb21wb3NpdGlvbnNSZWYgPSB1c2VSZWYxMChjb21wb3NpdGlvbnMpO1xuICBjb25zdCBbZm9sZGVycywgc2V0Rm9sZGVyc10gPSB1c2VTdGF0ZTE1KFtdKTtcbiAgY29uc3QgW2NhbnZhc0NvbnRlbnQsIHNldENhbnZhc0NvbnRlbnRdID0gdXNlU3RhdGUxNShudWxsKTtcbiAgY29uc3QgW2N1cnJlbnRDb21wb3NpdGlvbk1ldGFkYXRhLCBzZXRDdXJyZW50Q29tcG9zaXRpb25NZXRhZGF0YV0gPSB1c2VTdGF0ZTE1KG51bGwpO1xuICBjb25zdCB1cGRhdGVDb21wb3NpdGlvbnMgPSB1c2VDYWxsYmFjazEwKCh1cGRhdGVDb21wcykgPT4ge1xuICAgIHNldENvbXBvc2l0aW9ucygoY29tcHMpID0+IHtcbiAgICAgIGNvbnN0IHVwZGF0ZWQgPSB1cGRhdGVDb21wcyhjb21wcyk7XG4gICAgICBjdXJyZW50Y29tcG9zaXRpb25zUmVmLmN1cnJlbnQgPSB1cGRhdGVkO1xuICAgICAgcmV0dXJuIHVwZGF0ZWQ7XG4gICAgfSk7XG4gIH0sIFtdKTtcbiAgY29uc3QgcmVnaXN0ZXJDb21wb3NpdGlvbiA9IHVzZUNhbGxiYWNrMTAoKGNvbXApID0+IHtcbiAgICB1cGRhdGVDb21wb3NpdGlvbnMoKGNvbXBzKSA9PiB7XG4gICAgICBpZiAoY29tcHMuZmluZCgoYykgPT4gYy5pZCA9PT0gY29tcC5pZCkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBNdWx0aXBsZSBjb21wb3NpdGlvbiB3aXRoIGlkICR7Y29tcC5pZH0gYXJlIHJlZ2lzdGVyZWQuYCk7XG4gICAgICB9XG4gICAgICBjb25zdCB2YWx1ZSA9IFsuLi5jb21wcywgY29tcF0uc2xpY2UoKS5zb3J0KChhLCBiKSA9PiBhLm5vbmNlIC0gYi5ub25jZSk7XG4gICAgICByZXR1cm4gdmFsdWU7XG4gICAgfSk7XG4gIH0sIFt1cGRhdGVDb21wb3NpdGlvbnNdKTtcbiAgY29uc3QgdW5yZWdpc3RlckNvbXBvc2l0aW9uID0gdXNlQ2FsbGJhY2sxMCgoaWQpID0+IHtcbiAgICBzZXRDb21wb3NpdGlvbnMoKGNvbXBzKSA9PiB7XG4gICAgICByZXR1cm4gY29tcHMuZmlsdGVyKChjKSA9PiBjLmlkICE9PSBpZCk7XG4gICAgfSk7XG4gIH0sIFtdKTtcbiAgY29uc3QgcmVnaXN0ZXJGb2xkZXIgPSB1c2VDYWxsYmFjazEwKChuYW1lLCBwYXJlbnQpID0+IHtcbiAgICBzZXRGb2xkZXJzKChwcmV2Rm9sZGVycykgPT4ge1xuICAgICAgcmV0dXJuIFtcbiAgICAgICAgLi4ucHJldkZvbGRlcnMsXG4gICAgICAgIHtcbiAgICAgICAgICBuYW1lLFxuICAgICAgICAgIHBhcmVudFxuICAgICAgICB9XG4gICAgICBdO1xuICAgIH0pO1xuICB9LCBbXSk7XG4gIGNvbnN0IHVucmVnaXN0ZXJGb2xkZXIgPSB1c2VDYWxsYmFjazEwKChuYW1lLCBwYXJlbnQpID0+IHtcbiAgICBzZXRGb2xkZXJzKChwcmV2Rm9sZGVycykgPT4ge1xuICAgICAgcmV0dXJuIHByZXZGb2xkZXJzLmZpbHRlcigocCkgPT4gIShwLm5hbWUgPT09IG5hbWUgJiYgcC5wYXJlbnQgPT09IHBhcmVudCkpO1xuICAgIH0pO1xuICB9LCBbXSk7XG4gIHVzZUltcGVyYXRpdmVIYW5kbGU1KGNvbXBvc2l0aW9uc1JlZiwgKCkgPT4ge1xuICAgIHJldHVybiB7XG4gICAgICBnZXRDb21wb3NpdGlvbnM6ICgpID0+IGN1cnJlbnRjb21wb3NpdGlvbnNSZWYuY3VycmVudFxuICAgIH07XG4gIH0sIFtdKTtcbiAgY29uc3QgY29tcG9zaXRpb24gPSBjb21wb3NpdGlvbnMuZmluZCgoYykgPT4gY2FudmFzQ29udGVudD8udHlwZSA9PT0gXCJjb21wb3NpdGlvblwiID8gYy5pZCA9PT0gY2FudmFzQ29udGVudC5jb21wb3NpdGlvbklkIDogbnVsbCk7XG4gIGNvbnN0IHVwZGF0ZUNvbXBvc2l0aW9uRGVmYXVsdFByb3BzID0gdXNlQ2FsbGJhY2sxMCgoaWQsIG5ld0RlZmF1bHRQcm9wcykgPT4ge1xuICAgIHNldENvbXBvc2l0aW9ucygoY29tcHMpID0+IHtcbiAgICAgIGNvbnN0IHVwZGF0ZWQgPSBjb21wcy5tYXAoKGMpID0+IHtcbiAgICAgICAgaWYgKGMuaWQgPT09IGlkKSB7XG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIC4uLmMsXG4gICAgICAgICAgICBkZWZhdWx0UHJvcHM6IG5ld0RlZmF1bHRQcm9wc1xuICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGM7XG4gICAgICB9KTtcbiAgICAgIHJldHVybiB1cGRhdGVkO1xuICAgIH0pO1xuICB9LCBbXSk7XG4gIGNvbnN0IGNvbnRleHRWYWx1ZSA9IHVzZU1lbW8yNSgoKSA9PiB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGNvbXBvc2l0aW9ucyxcbiAgICAgIHJlZ2lzdGVyQ29tcG9zaXRpb24sXG4gICAgICB1bnJlZ2lzdGVyQ29tcG9zaXRpb24sXG4gICAgICBmb2xkZXJzLFxuICAgICAgcmVnaXN0ZXJGb2xkZXIsXG4gICAgICB1bnJlZ2lzdGVyRm9sZGVyLFxuICAgICAgY3VycmVudENvbXBvc2l0aW9uTWV0YWRhdGEsXG4gICAgICBzZXRDdXJyZW50Q29tcG9zaXRpb25NZXRhZGF0YSxcbiAgICAgIGNhbnZhc0NvbnRlbnQsXG4gICAgICBzZXRDYW52YXNDb250ZW50LFxuICAgICAgdXBkYXRlQ29tcG9zaXRpb25EZWZhdWx0UHJvcHNcbiAgICB9O1xuICB9LCBbXG4gICAgY29tcG9zaXRpb25zLFxuICAgIHJlZ2lzdGVyQ29tcG9zaXRpb24sXG4gICAgdW5yZWdpc3RlckNvbXBvc2l0aW9uLFxuICAgIGZvbGRlcnMsXG4gICAgcmVnaXN0ZXJGb2xkZXIsXG4gICAgdW5yZWdpc3RlckZvbGRlcixcbiAgICBjdXJyZW50Q29tcG9zaXRpb25NZXRhZGF0YSxcbiAgICBjYW52YXNDb250ZW50LFxuICAgIHVwZGF0ZUNvbXBvc2l0aW9uRGVmYXVsdFByb3BzXG4gIF0pO1xuICByZXR1cm4gLyogQF9fUFVSRV9fICovIGpzeDIyKENvbXBvc2l0aW9uTWFuYWdlci5Qcm92aWRlciwge1xuICAgIHZhbHVlOiBjb250ZXh0VmFsdWUsXG4gICAgY2hpbGRyZW46IC8qIEBfX1BVUkVfXyAqLyBqc3gyMihTZXF1ZW5jZU1hbmFnZXJQcm92aWRlciwge1xuICAgICAgY2hpbGRyZW46IC8qIEBfX1BVUkVfXyAqLyBqc3gyMihSZW5kZXJBc3NldE1hbmFnZXJQcm92aWRlciwge1xuICAgICAgICBjaGlsZHJlbjogLyogQF9fUFVSRV9fICovIGpzeDIyKFJlc29sdmVDb21wb3NpdGlvbkNvbmZpZywge1xuICAgICAgICAgIGNoaWxkcmVuOiAvKiBAX19QVVJFX18gKi8ganN4MjIoU2hhcmVkQXVkaW9Db250ZXh0UHJvdmlkZXIsIHtcbiAgICAgICAgICAgIG51bWJlck9mQXVkaW9UYWdzLFxuICAgICAgICAgICAgY29tcG9uZW50OiBjb21wb3NpdGlvbj8uY29tcG9uZW50ID8/IG51bGwsXG4gICAgICAgICAgICBjaGlsZHJlblxuICAgICAgICAgIH0pXG4gICAgICAgIH0pXG4gICAgICB9KVxuICAgIH0pXG4gIH0pO1xufTtcbi8vIHNyYy9iZXppZXIudHNcbmZ1bmN0aW9uIGEoYUExLCBhQTIpIHtcbiAgcmV0dXJuIDEgLSAzICogYUEyICsgMyAqIGFBMTtcbn1cbmZ1bmN0aW9uIGIoYUExLCBhQTIpIHtcbiAgcmV0dXJuIDMgKiBhQTIgLSA2ICogYUExO1xufVxuZnVuY3Rpb24gYyhhQTEpIHtcbiAgcmV0dXJuIDMgKiBhQTE7XG59XG5mdW5jdGlvbiBjYWxjQmV6aWVyKGFULCBhQTEsIGFBMikge1xuICByZXR1cm4gKChhKGFBMSwgYUEyKSAqIGFUICsgYihhQTEsIGFBMikpICogYVQgKyBjKGFBMSkpICogYVQ7XG59XG5mdW5jdGlvbiBnZXRTbG9wZShhVCwgYUExLCBhQTIpIHtcbiAgcmV0dXJuIDMgKiBhKGFBMSwgYUEyKSAqIGFUICogYVQgKyAyICogYihhQTEsIGFBMikgKiBhVCArIGMoYUExKTtcbn1cbmZ1bmN0aW9uIGJpbmFyeVN1YmRpdmlkZSh7XG4gIGFYLFxuICBfYUEsXG4gIF9hQixcbiAgbVgxLFxuICBtWDJcbn0pIHtcbiAgbGV0IGN1cnJlbnRYO1xuICBsZXQgY3VycmVudFQ7XG4gIGxldCBpID0gMDtcbiAgbGV0IGFBID0gX2FBO1xuICBsZXQgYUIgPSBfYUI7XG4gIGRvIHtcbiAgICBjdXJyZW50VCA9IGFBICsgKGFCIC0gYUEpIC8gMjtcbiAgICBjdXJyZW50WCA9IGNhbGNCZXppZXIoY3VycmVudFQsIG1YMSwgbVgyKSAtIGFYO1xuICAgIGlmIChjdXJyZW50WCA+IDApIHtcbiAgICAgIGFCID0gY3VycmVudFQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIGFBID0gY3VycmVudFQ7XG4gICAgfVxuICB9IHdoaWxlIChNYXRoLmFicyhjdXJyZW50WCkgPiBTVUJESVZJU0lPTl9QUkVDSVNJT04gJiYgKytpIDwgU1VCRElWSVNJT05fTUFYX0lURVJBVElPTlMpO1xuICByZXR1cm4gY3VycmVudFQ7XG59XG5mdW5jdGlvbiBuZXd0b25SYXBoc29uSXRlcmF0ZShhWCwgX2FHdWVzc1QsIG1YMSwgbVgyKSB7XG4gIGxldCBhR3Vlc3NUID0gX2FHdWVzc1Q7XG4gIGZvciAobGV0IGkgPSAwO2kgPCBORVdUT05fSVRFUkFUSU9OUzsgKytpKSB7XG4gICAgY29uc3QgY3VycmVudFNsb3BlID0gZ2V0U2xvcGUoYUd1ZXNzVCwgbVgxLCBtWDIpO1xuICAgIGlmIChjdXJyZW50U2xvcGUgPT09IDApIHtcbiAgICAgIHJldHVybiBhR3Vlc3NUO1xuICAgIH1cbiAgICBjb25zdCBjdXJyZW50WCA9IGNhbGNCZXppZXIoYUd1ZXNzVCwgbVgxLCBtWDIpIC0gYVg7XG4gICAgYUd1ZXNzVCAtPSBjdXJyZW50WCAvIGN1cnJlbnRTbG9wZTtcbiAgfVxuICByZXR1cm4gYUd1ZXNzVDtcbn1cbmZ1bmN0aW9uIGJlemllcihtWDEsIG1ZMSwgbVgyLCBtWTIpIHtcbiAgaWYgKCEobVgxID49IDAgJiYgbVgxIDw9IDEgJiYgbVgyID49IDAgJiYgbVgyIDw9IDEpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiYmV6aWVyIHggdmFsdWVzIG11c3QgYmUgaW4gWzAsIDFdIHJhbmdlXCIpO1xuICB9XG4gIGNvbnN0IHNhbXBsZVZhbHVlcyA9IGZsb2F0MzJBcnJheVN1cHBvcnRlZCA/IG5ldyBGbG9hdDMyQXJyYXkoa1NwbGluZVRhYmxlU2l6ZSkgOiBuZXcgQXJyYXkoa1NwbGluZVRhYmxlU2l6ZSk7XG4gIGlmIChtWDEgIT09IG1ZMSB8fCBtWDIgIT09IG1ZMikge1xuICAgIGZvciAobGV0IGkgPSAwO2kgPCBrU3BsaW5lVGFibGVTaXplOyArK2kpIHtcbiAgICAgIHNhbXBsZVZhbHVlc1tpXSA9IGNhbGNCZXppZXIoaSAqIGtTYW1wbGVTdGVwU2l6ZSwgbVgxLCBtWDIpO1xuICAgIH1cbiAgfVxuICBmdW5jdGlvbiBnZXRURm9yWChhWCkge1xuICAgIGxldCBpbnRlcnZhbFN0YXJ0ID0gMDtcbiAgICBsZXQgY3VycmVudFNhbXBsZSA9IDE7XG4gICAgY29uc3QgbGFzdFNhbXBsZSA9IGtTcGxpbmVUYWJsZVNpemUgLSAxO1xuICAgIGZvciAoO2N1cnJlbnRTYW1wbGUgIT09IGxhc3RTYW1wbGUgJiYgc2FtcGxlVmFsdWVzW2N1cnJlbnRTYW1wbGVdIDw9IGFYOyArK2N1cnJlbnRTYW1wbGUpIHtcbiAgICAgIGludGVydmFsU3RhcnQgKz0ga1NhbXBsZVN0ZXBTaXplO1xuICAgIH1cbiAgICAtLWN1cnJlbnRTYW1wbGU7XG4gICAgY29uc3QgZGlzdCA9IChhWCAtIHNhbXBsZVZhbHVlc1tjdXJyZW50U2FtcGxlXSkgLyAoc2FtcGxlVmFsdWVzW2N1cnJlbnRTYW1wbGUgKyAxXSAtIHNhbXBsZVZhbHVlc1tjdXJyZW50U2FtcGxlXSk7XG4gICAgY29uc3QgZ3Vlc3NGb3JUID0gaW50ZXJ2YWxTdGFydCArIGRpc3QgKiBrU2FtcGxlU3RlcFNpemU7XG4gICAgY29uc3QgaW5pdGlhbFNsb3BlID0gZ2V0U2xvcGUoZ3Vlc3NGb3JULCBtWDEsIG1YMik7XG4gICAgaWYgKGluaXRpYWxTbG9wZSA+PSBORVdUT05fTUlOX1NMT1BFKSB7XG4gICAgICByZXR1cm4gbmV3dG9uUmFwaHNvbkl0ZXJhdGUoYVgsIGd1ZXNzRm9yVCwgbVgxLCBtWDIpO1xuICAgIH1cbiAgICBpZiAoaW5pdGlhbFNsb3BlID09PSAwKSB7XG4gICAgICByZXR1cm4gZ3Vlc3NGb3JUO1xuICAgIH1cbiAgICByZXR1cm4gYmluYXJ5U3ViZGl2aWRlKHtcbiAgICAgIGFYLFxuICAgICAgX2FBOiBpbnRlcnZhbFN0YXJ0LFxuICAgICAgX2FCOiBpbnRlcnZhbFN0YXJ0ICsga1NhbXBsZVN0ZXBTaXplLFxuICAgICAgbVgxLFxuICAgICAgbVgyXG4gICAgfSk7XG4gIH1cbiAgcmV0dXJuIGZ1bmN0aW9uKHgpIHtcbiAgICBpZiAobVgxID09PSBtWTEgJiYgbVgyID09PSBtWTIpIHtcbiAgICAgIHJldHVybiB4O1xuICAgIH1cbiAgICBpZiAoeCA9PT0gMCkge1xuICAgICAgcmV0dXJuIDA7XG4gICAgfVxuICAgIGlmICh4ID09PSAxKSB7XG4gICAgICByZXR1cm4gMTtcbiAgICB9XG4gICAgcmV0dXJuIGNhbGNCZXppZXIoZ2V0VEZvclgoeCksIG1ZMSwgbVkyKTtcbiAgfTtcbn1cbnZhciBORVdUT05fSVRFUkFUSU9OUyA9IDQ7XG52YXIgTkVXVE9OX01JTl9TTE9QRSA9IDAuMDAxO1xudmFyIFNVQkRJVklTSU9OX1BSRUNJU0lPTiA9IDAuMDAwMDAwMTtcbnZhciBTVUJESVZJU0lPTl9NQVhfSVRFUkFUSU9OUyA9IDEwO1xudmFyIGtTcGxpbmVUYWJsZVNpemUgPSAxMTtcbnZhciBrU2FtcGxlU3RlcFNpemUgPSAxIC8gKGtTcGxpbmVUYWJsZVNpemUgLSAxKTtcbnZhciBmbG9hdDMyQXJyYXlTdXBwb3J0ZWQgPSB0eXBlb2YgRmxvYXQzMkFycmF5ID09PSBcImZ1bmN0aW9uXCI7XG5cbi8vIHNyYy9lYXNpbmcudHNcbmNsYXNzIEVhc2luZyB7XG4gIHN0YXRpYyBzdGVwMChuKSB7XG4gICAgcmV0dXJuIG4gPiAwID8gMSA6IDA7XG4gIH1cbiAgc3RhdGljIHN0ZXAxKG4pIHtcbiAgICByZXR1cm4gbiA+PSAxID8gMSA6IDA7XG4gIH1cbiAgc3RhdGljIGxpbmVhcih0KSB7XG4gICAgcmV0dXJuIHQ7XG4gIH1cbiAgc3RhdGljIGVhc2UodCkge1xuICAgIHJldHVybiBFYXNpbmcuYmV6aWVyKDAuNDIsIDAsIDEsIDEpKHQpO1xuICB9XG4gIHN0YXRpYyBxdWFkKHQpIHtcbiAgICByZXR1cm4gdCAqIHQ7XG4gIH1cbiAgc3RhdGljIGN1YmljKHQpIHtcbiAgICByZXR1cm4gdCAqIHQgKiB0O1xuICB9XG4gIHN0YXRpYyBwb2x5KG4pIHtcbiAgICByZXR1cm4gKHQpID0+IHQgKiogbjtcbiAgfVxuICBzdGF0aWMgc2luKHQpIHtcbiAgICByZXR1cm4gMSAtIE1hdGguY29zKHQgKiBNYXRoLlBJIC8gMik7XG4gIH1cbiAgc3RhdGljIGNpcmNsZSh0KSB7XG4gICAgcmV0dXJuIDEgLSBNYXRoLnNxcnQoMSAtIHQgKiB0KTtcbiAgfVxuICBzdGF0aWMgZXhwKHQpIHtcbiAgICByZXR1cm4gMiAqKiAoMTAgKiAodCAtIDEpKTtcbiAgfVxuICBzdGF0aWMgZWxhc3RpYyhib3VuY2luZXNzID0gMSkge1xuICAgIGNvbnN0IHAgPSBib3VuY2luZXNzICogTWF0aC5QSTtcbiAgICByZXR1cm4gKHQpID0+IDEgLSBNYXRoLmNvcyh0ICogTWF0aC5QSSAvIDIpICoqIDMgKiBNYXRoLmNvcyh0ICogcCk7XG4gIH1cbiAgc3RhdGljIGJhY2socyA9IDEuNzAxNTgpIHtcbiAgICByZXR1cm4gKHQpID0+IHQgKiB0ICogKChzICsgMSkgKiB0IC0gcyk7XG4gIH1cbiAgc3RhdGljIGJvdW5jZSh0KSB7XG4gICAgaWYgKHQgPCAxIC8gMi43NSkge1xuICAgICAgcmV0dXJuIDcuNTYyNSAqIHQgKiB0O1xuICAgIH1cbiAgICBpZiAodCA8IDIgLyAyLjc1KSB7XG4gICAgICBjb25zdCB0Ml8gPSB0IC0gMS41IC8gMi43NTtcbiAgICAgIHJldHVybiA3LjU2MjUgKiB0Ml8gKiB0Ml8gKyAwLjc1O1xuICAgIH1cbiAgICBpZiAodCA8IDIuNSAvIDIuNzUpIHtcbiAgICAgIGNvbnN0IHQyXyA9IHQgLSAyLjI1IC8gMi43NTtcbiAgICAgIHJldHVybiA3LjU2MjUgKiB0Ml8gKiB0Ml8gKyAwLjkzNzU7XG4gICAgfVxuICAgIGNvbnN0IHQyID0gdCAtIDIuNjI1IC8gMi43NTtcbiAgICByZXR1cm4gNy41NjI1ICogdDIgKiB0MiArIDAuOTg0Mzc1O1xuICB9XG4gIHN0YXRpYyBiZXppZXIoeDEsIHkxLCB4MiwgeTIpIHtcbiAgICByZXR1cm4gYmV6aWVyKHgxLCB5MSwgeDIsIHkyKTtcbiAgfVxuICBzdGF0aWMgaW4oZWFzaW5nKSB7XG4gICAgcmV0dXJuIGVhc2luZztcbiAgfVxuICBzdGF0aWMgb3V0KGVhc2luZykge1xuICAgIHJldHVybiAodCkgPT4gMSAtIGVhc2luZygxIC0gdCk7XG4gIH1cbiAgc3RhdGljIGluT3V0KGVhc2luZykge1xuICAgIHJldHVybiAodCkgPT4ge1xuICAgICAgaWYgKHQgPCAwLjUpIHtcbiAgICAgICAgcmV0dXJuIGVhc2luZyh0ICogMikgLyAyO1xuICAgICAgfVxuICAgICAgcmV0dXJuIDEgLSBlYXNpbmcoKDEgLSB0KSAqIDIpIC8gMjtcbiAgICB9O1xuICB9XG59XG4vLyBzcmMvdjUtZmxhZy50c1xudmFyIEVOQUJMRV9WNV9CUkVBS0lOR19DSEFOR0VTID0gZmFsc2U7XG5cbi8vIHNyYy9nZXQtc3RhdGljLWZpbGVzLnRzXG52YXIgd2FybmVkU2VydmVyID0gZmFsc2U7XG52YXIgd2FybmVkUGxheWVyID0gZmFsc2U7XG52YXIgd2FyblNlcnZlck9uY2UgPSAoKSA9PiB7XG4gIGlmICh3YXJuZWRTZXJ2ZXIpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgd2FybmVkU2VydmVyID0gdHJ1ZTtcbiAgY29uc29sZS53YXJuKFwiQ2FsbGVkIGdldFN0YXRpY0ZpbGVzKCkgb24gdGhlIHNlcnZlci4gVGhlIEFQSSBpcyBvbmx5IGF2YWlsYWJsZSBpbiB0aGUgYnJvd3Nlci4gQW4gZW1wdHkgYXJyYXkgd2FzIHJldHVybmVkLlwiKTtcbn07XG52YXIgd2FyblBsYXllck9uY2UgPSAoKSA9PiB7XG4gIGlmICh3YXJuZWRQbGF5ZXIpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgd2FybmVkUGxheWVyID0gdHJ1ZTtcbiAgY29uc29sZS53YXJuKFwiQ2FsbGVkIGdldFN0YXRpY0ZpbGVzKCkgd2hpbGUgdXNpbmcgdGhlIFJlbW90aW9uIFBsYXllci4gVGhlIEFQSSBpcyBvbmx5IGF2YWlsYWJsZSB3aGlsZSB1c2luZyB0aGUgUmVtb3Rpb24gU3R1ZGlvLiBBbiBlbXB0eSBhcnJheSB3YXMgcmV0dXJuZWQuXCIpO1xufTtcbnZhciBnZXRTdGF0aWNGaWxlcyA9ICgpID0+IHtcbiAgaWYgKEVOQUJMRV9WNV9CUkVBS0lOR19DSEFOR0VTKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiZ2V0U3RhdGljRmlsZXMoKSBoYXMgbW92ZWQgaW50byB0aGUgYEByZW1vdGlvbi9zdHVkaW9gIHBhY2thZ2UuIFVwZGF0ZSB5b3VyIGltcG9ydHMuXCIpO1xuICB9XG4gIGlmICh0eXBlb2YgZG9jdW1lbnQgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICB3YXJuU2VydmVyT25jZSgpO1xuICAgIHJldHVybiBbXTtcbiAgfVxuICBpZiAod2luZG93LnJlbW90aW9uX2lzUGxheWVyKSB7XG4gICAgd2FyblBsYXllck9uY2UoKTtcbiAgICByZXR1cm4gW107XG4gIH1cbiAgcmV0dXJuIHdpbmRvdy5yZW1vdGlvbl9zdGF0aWNGaWxlcztcbn07XG4vLyBzcmMvSUZyYW1lLnRzeFxuaW1wb3J0IHsgZm9yd2FyZFJlZiBhcyBmb3J3YXJkUmVmNiwgdXNlQ2FsbGJhY2sgYXMgdXNlQ2FsbGJhY2sxMSwgdXNlU3RhdGUgYXMgdXNlU3RhdGUxNiB9IGZyb20gXCJyZWFjdFwiO1xuaW1wb3J0IHsganN4IGFzIGpzeDIzIH0gZnJvbSBcInJlYWN0L2pzeC1ydW50aW1lXCI7XG52YXIgSUZyYW1lUmVmRm9yd2FyZGluZyA9ICh7XG4gIG9uTG9hZCxcbiAgb25FcnJvcixcbiAgZGVsYXlSZW5kZXJSZXRyaWVzLFxuICBkZWxheVJlbmRlclRpbWVvdXRJbk1pbGxpc2Vjb25kcyxcbiAgLi4ucHJvcHMyXG59LCByZWYpID0+IHtcbiAgY29uc3QgW2hhbmRsZV0gPSB1c2VTdGF0ZTE2KCgpID0+IGRlbGF5UmVuZGVyKGBMb2FkaW5nIDxJRnJhbWU+IHdpdGggc291cmNlICR7cHJvcHMyLnNyY31gLCB7XG4gICAgcmV0cmllczogZGVsYXlSZW5kZXJSZXRyaWVzID8/IHVuZGVmaW5lZCxcbiAgICB0aW1lb3V0SW5NaWxsaXNlY29uZHM6IGRlbGF5UmVuZGVyVGltZW91dEluTWlsbGlzZWNvbmRzID8/IHVuZGVmaW5lZFxuICB9KSk7XG4gIGNvbnN0IGRpZExvYWQgPSB1c2VDYWxsYmFjazExKChlKSA9PiB7XG4gICAgY29udGludWVSZW5kZXIoaGFuZGxlKTtcbiAgICBvbkxvYWQ/LihlKTtcbiAgfSwgW2hhbmRsZSwgb25Mb2FkXSk7XG4gIGNvbnN0IGRpZEdldEVycm9yID0gdXNlQ2FsbGJhY2sxMSgoZSkgPT4ge1xuICAgIGNvbnRpbnVlUmVuZGVyKGhhbmRsZSk7XG4gICAgaWYgKG9uRXJyb3IpIHtcbiAgICAgIG9uRXJyb3IoZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoXCJFcnJvciBsb2FkaW5nIGlmcmFtZTpcIiwgZSwgXCJIYW5kbGUgdGhlIGV2ZW50IHVzaW5nIHRoZSBvbkVycm9yKCkgcHJvcCB0byBtYWtlIHRoaXMgbWVzc2FnZSBkaXNhcHBlYXIuXCIpO1xuICAgIH1cbiAgfSwgW2hhbmRsZSwgb25FcnJvcl0pO1xuICByZXR1cm4gLyogQF9fUFVSRV9fICovIGpzeDIzKFwiaWZyYW1lXCIsIHtcbiAgICAuLi5wcm9wczIsXG4gICAgcmVmLFxuICAgIG9uRXJyb3I6IGRpZEdldEVycm9yLFxuICAgIG9uTG9hZDogZGlkTG9hZFxuICB9KTtcbn07XG52YXIgSUZyYW1lID0gZm9yd2FyZFJlZjYoSUZyYW1lUmVmRm9yd2FyZGluZyk7XG4vLyBzcmMvSW1nLnRzeFxuaW1wb3J0IHtcbiAgZm9yd2FyZFJlZiBhcyBmb3J3YXJkUmVmNyxcbiAgdXNlQ2FsbGJhY2sgYXMgdXNlQ2FsbGJhY2sxMixcbiAgdXNlQ29udGV4dCBhcyB1c2VDb250ZXh0MjYsXG4gIHVzZUltcGVyYXRpdmVIYW5kbGUgYXMgdXNlSW1wZXJhdGl2ZUhhbmRsZTYsXG4gIHVzZUxheW91dEVmZmVjdCBhcyB1c2VMYXlvdXRFZmZlY3Q0LFxuICB1c2VSZWYgYXMgdXNlUmVmMTFcbn0gZnJvbSBcInJlYWN0XCI7XG5mdW5jdGlvbiBleHBvbmVudGlhbEJhY2tvZmYoZXJyb3JDb3VudCkge1xuICByZXR1cm4gMTAwMCAqIDIgKiogKGVycm9yQ291bnQgLSAxKTtcbn1cbmltcG9ydCB7IGpzeCBhcyBqc3gyNCB9IGZyb20gXCJyZWFjdC9qc3gtcnVudGltZVwiO1xudmFyIEltZ1JlZkZvcndhcmRpbmcgPSAoe1xuICBvbkVycm9yLFxuICBtYXhSZXRyaWVzID0gMixcbiAgc3JjLFxuICBwYXVzZVdoZW5Mb2FkaW5nLFxuICBkZWxheVJlbmRlclJldHJpZXMsXG4gIGRlbGF5UmVuZGVyVGltZW91dEluTWlsbGlzZWNvbmRzLFxuICBvbkltYWdlRnJhbWUsXG4gIC4uLnByb3BzMlxufSwgcmVmKSA9PiB7XG4gIGNvbnN0IGltYWdlUmVmID0gdXNlUmVmMTEobnVsbCk7XG4gIGNvbnN0IGVycm9ycyA9IHVzZVJlZjExKHt9KTtcbiAgY29uc3QgeyBkZWxheVBsYXliYWNrIH0gPSB1c2VCdWZmZXJTdGF0ZSgpO1xuICBjb25zdCBzZXF1ZW5jZUNvbnRleHQgPSB1c2VDb250ZXh0MjYoU2VxdWVuY2VDb250ZXh0KTtcbiAgaWYgKCFzcmMpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ05vIFwic3JjXCIgcHJvcCB3YXMgcGFzc2VkIHRvIDxJbWc+LicpO1xuICB9XG4gIHVzZUltcGVyYXRpdmVIYW5kbGU2KHJlZiwgKCkgPT4ge1xuICAgIHJldHVybiBpbWFnZVJlZi5jdXJyZW50O1xuICB9LCBbXSk7XG4gIGNvbnN0IGFjdHVhbFNyYyA9IHVzZVByZWxvYWQoc3JjKTtcbiAgY29uc3QgcmV0cnlJbiA9IHVzZUNhbGxiYWNrMTIoKHRpbWVvdXQpID0+IHtcbiAgICBpZiAoIWltYWdlUmVmLmN1cnJlbnQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgY3VycmVudFNyYyA9IGltYWdlUmVmLmN1cnJlbnQuc3JjO1xuICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgaWYgKCFpbWFnZVJlZi5jdXJyZW50KSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGNvbnN0IG5ld1NyYyA9IGltYWdlUmVmLmN1cnJlbnQ/LnNyYztcbiAgICAgIGlmIChuZXdTcmMgIT09IGN1cnJlbnRTcmMpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaW1hZ2VSZWYuY3VycmVudC5yZW1vdmVBdHRyaWJ1dGUoXCJzcmNcIik7XG4gICAgICBpbWFnZVJlZi5jdXJyZW50LnNldEF0dHJpYnV0ZShcInNyY1wiLCBuZXdTcmMpO1xuICAgIH0sIHRpbWVvdXQpO1xuICB9LCBbXSk7XG4gIGNvbnN0IGRpZEdldEVycm9yID0gdXNlQ2FsbGJhY2sxMigoZSkgPT4ge1xuICAgIGlmICghZXJyb3JzLmN1cnJlbnQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZXJyb3JzLmN1cnJlbnRbaW1hZ2VSZWYuY3VycmVudD8uc3JjXSA9IChlcnJvcnMuY3VycmVudFtpbWFnZVJlZi5jdXJyZW50Py5zcmNdID8/IDApICsgMTtcbiAgICBpZiAob25FcnJvciAmJiAoZXJyb3JzLmN1cnJlbnRbaW1hZ2VSZWYuY3VycmVudD8uc3JjXSA/PyAwKSA+IG1heFJldHJpZXMpIHtcbiAgICAgIG9uRXJyb3IoZSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICgoZXJyb3JzLmN1cnJlbnRbaW1hZ2VSZWYuY3VycmVudD8uc3JjXSA/PyAwKSA8PSBtYXhSZXRyaWVzKSB7XG4gICAgICBjb25zdCBiYWNrb2ZmID0gZXhwb25lbnRpYWxCYWNrb2ZmKGVycm9ycy5jdXJyZW50W2ltYWdlUmVmLmN1cnJlbnQ/LnNyY10gPz8gMCk7XG4gICAgICBjb25zb2xlLndhcm4oYENvdWxkIG5vdCBsb2FkIGltYWdlIHdpdGggc291cmNlICR7aW1hZ2VSZWYuY3VycmVudD8uc3JjfSwgcmV0cnlpbmcgYWdhaW4gaW4gJHtiYWNrb2ZmfW1zYCk7XG4gICAgICByZXRyeUluKGJhY2tvZmYpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjYW5jZWxSZW5kZXIoXCJFcnJvciBsb2FkaW5nIGltYWdlIHdpdGggc3JjOiBcIiArIGltYWdlUmVmLmN1cnJlbnQ/LnNyYyk7XG4gIH0sIFttYXhSZXRyaWVzLCBvbkVycm9yLCByZXRyeUluXSk7XG4gIGlmICh0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgY29uc3QgaXNQcmVtb3VudGluZyA9IEJvb2xlYW4oc2VxdWVuY2VDb250ZXh0Py5wcmVtb3VudGluZyk7XG4gICAgdXNlTGF5b3V0RWZmZWN0NCgoKSA9PiB7XG4gICAgICBpZiAod2luZG93LnByb2Nlc3M/LmVudj8uTk9ERV9FTlYgPT09IFwidGVzdFwiKSB7XG4gICAgICAgIGlmIChpbWFnZVJlZi5jdXJyZW50KSB7XG4gICAgICAgICAgaW1hZ2VSZWYuY3VycmVudC5zcmMgPSBhY3R1YWxTcmM7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgY29uc3QgbmV3SGFuZGxlID0gZGVsYXlSZW5kZXIoXCJMb2FkaW5nIDxJbWc+IHdpdGggc3JjPVwiICsgYWN0dWFsU3JjLCB7XG4gICAgICAgIHJldHJpZXM6IGRlbGF5UmVuZGVyUmV0cmllcyA/PyB1bmRlZmluZWQsXG4gICAgICAgIHRpbWVvdXRJbk1pbGxpc2Vjb25kczogZGVsYXlSZW5kZXJUaW1lb3V0SW5NaWxsaXNlY29uZHMgPz8gdW5kZWZpbmVkXG4gICAgICB9KTtcbiAgICAgIGNvbnN0IHVuYmxvY2sgPSBwYXVzZVdoZW5Mb2FkaW5nICYmICFpc1ByZW1vdW50aW5nID8gZGVsYXlQbGF5YmFjaygpLnVuYmxvY2sgOiAoKSA9PiB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH07XG4gICAgICBjb25zdCB7IGN1cnJlbnQgfSA9IGltYWdlUmVmO1xuICAgICAgbGV0IHVubW91bnRlZCA9IGZhbHNlO1xuICAgICAgY29uc3Qgb25Db21wbGV0ZSA9ICgpID0+IHtcbiAgICAgICAgaWYgKHVubW91bnRlZCkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoKGVycm9ycy5jdXJyZW50W2ltYWdlUmVmLmN1cnJlbnQ/LnNyY10gPz8gMCkgPiAwKSB7XG4gICAgICAgICAgZGVsZXRlIGVycm9ycy5jdXJyZW50W2ltYWdlUmVmLmN1cnJlbnQ/LnNyY107XG4gICAgICAgICAgY29uc29sZS5pbmZvKGBSZXRyeSBzdWNjZXNzZnVsIC0gJHtpbWFnZVJlZi5jdXJyZW50Py5zcmN9IGlzIG5vdyBsb2FkZWRgKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY3VycmVudCkge1xuICAgICAgICAgIGN1cnJlbnQuc3JjID0gYWN0dWFsU3JjO1xuICAgICAgICAgIG9uSW1hZ2VGcmFtZT8uKGN1cnJlbnQpO1xuICAgICAgICB9XG4gICAgICAgIHVuYmxvY2soKTtcbiAgICAgICAgY29udGludWVSZW5kZXIobmV3SGFuZGxlKTtcbiAgICAgIH07XG4gICAgICBjb25zdCBuZXdJbWcgPSBuZXcgSW1hZ2U7XG4gICAgICBuZXdJbWcuc3JjID0gYWN0dWFsU3JjO1xuICAgICAgbmV3SW1nLmRlY29kZSgpLnRoZW4ob25Db21wbGV0ZSkuY2F0Y2goKGVycikgPT4ge1xuICAgICAgICBjb25zb2xlLndhcm4oZXJyKTtcbiAgICAgICAgaWYgKG5ld0ltZy5jb21wbGV0ZSkge1xuICAgICAgICAgIG9uQ29tcGxldGUoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBuZXdJbWcuYWRkRXZlbnRMaXN0ZW5lcihcImxvYWRcIiwgb25Db21wbGV0ZSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgcmV0dXJuICgpID0+IHtcbiAgICAgICAgdW5tb3VudGVkID0gdHJ1ZTtcbiAgICAgICAgbmV3SW1nLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJsb2FkXCIsIG9uQ29tcGxldGUpO1xuICAgICAgICB1bmJsb2NrKCk7XG4gICAgICAgIGNvbnRpbnVlUmVuZGVyKG5ld0hhbmRsZSk7XG4gICAgICB9O1xuICAgIH0sIFtcbiAgICAgIGFjdHVhbFNyYyxcbiAgICAgIGRlbGF5UGxheWJhY2ssXG4gICAgICBkZWxheVJlbmRlclJldHJpZXMsXG4gICAgICBkZWxheVJlbmRlclRpbWVvdXRJbk1pbGxpc2Vjb25kcyxcbiAgICAgIHBhdXNlV2hlbkxvYWRpbmcsXG4gICAgICBpc1ByZW1vdW50aW5nLFxuICAgICAgb25JbWFnZUZyYW1lXG4gICAgXSk7XG4gIH1cbiAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqLyBqc3gyNChcImltZ1wiLCB7XG4gICAgLi4ucHJvcHMyLFxuICAgIHJlZjogaW1hZ2VSZWYsXG4gICAgb25FcnJvcjogZGlkR2V0RXJyb3JcbiAgfSk7XG59O1xudmFyIEltZyA9IGZvcndhcmRSZWY3KEltZ1JlZkZvcndhcmRpbmcpO1xuLy8gc3JjL2RlZmF1bHQtY3NzLnRzXG52YXIgZXhwb3J0c19kZWZhdWx0X2NzcyA9IHt9O1xuX19leHBvcnQoZXhwb3J0c19kZWZhdWx0X2Nzcywge1xuICBtYWtlRGVmYXVsdFByZXZpZXdDU1M6ICgpID0+IG1ha2VEZWZhdWx0UHJldmlld0NTUyxcbiAgaW5qZWN0Q1NTOiAoKSA9PiBpbmplY3RDU1MsXG4gIE9GRlRIUkVBRF9WSURFT19DTEFTU19OQU1FOiAoKSA9PiBPRkZUSFJFQURfVklERU9fQ0xBU1NfTkFNRVxufSk7XG52YXIgaW5qZWN0ZWQgPSB7fTtcbnZhciBpbmplY3RDU1MgPSAoY3NzKSA9PiB7XG4gIGlmICh0eXBlb2YgZG9jdW1lbnQgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgaWYgKGluamVjdGVkW2Nzc10pIHtcbiAgICByZXR1cm47XG4gIH1cbiAgY29uc3QgaGVhZCA9IGRvY3VtZW50LmhlYWQgfHwgZG9jdW1lbnQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoXCJoZWFkXCIpWzBdO1xuICBjb25zdCBzdHlsZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJzdHlsZVwiKTtcbiAgc3R5bGUuYXBwZW5kQ2hpbGQoZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoY3NzKSk7XG4gIGhlYWQucHJlcGVuZChzdHlsZSk7XG4gIGluamVjdGVkW2Nzc10gPSB0cnVlO1xufTtcbnZhciBPRkZUSFJFQURfVklERU9fQ0xBU1NfTkFNRSA9IFwiX19yZW1vdGlvbl9vZmZ0aHJlYWR2aWRlb1wiO1xudmFyIG1ha2VEZWZhdWx0UHJldmlld0NTUyA9IChzY29wZSwgYmFja2dyb3VuZENvbG9yKSA9PiB7XG4gIGlmICghc2NvcGUpIHtcbiAgICByZXR1cm4gYFxuICAgICoge1xuICAgICAgYm94LXNpemluZzogYm9yZGVyLWJveDtcbiAgICB9XG4gICAgYm9keSB7XG4gICAgICBtYXJnaW46IDA7XG5cdCAgICBiYWNrZ3JvdW5kLWNvbG9yOiAke2JhY2tncm91bmRDb2xvcn07XG4gICAgfVxuICAgIC4ke09GRlRIUkVBRF9WSURFT19DTEFTU19OQU1FfSB7XG4gICAgICBvYmplY3QtZml0OiBjb250YWluO1xuICAgIH1cbiAgICBgO1xuICB9XG4gIHJldHVybiBgXG4gICAgJHtzY29wZX0gKiB7XG4gICAgICBib3gtc2l6aW5nOiBib3JkZXItYm94O1xuICAgIH1cbiAgICAke3Njb3BlfSAqOi13ZWJraXQtZnVsbC1zY3JlZW4ge1xuICAgICAgd2lkdGg6IDEwMCU7XG4gICAgICBoZWlnaHQ6IDEwMCU7XG4gICAgfVxuICAgICR7c2NvcGV9IC4ke09GRlRIUkVBRF9WSURFT19DTEFTU19OQU1FfSB7XG4gICAgICBvYmplY3QtZml0OiBjb250YWluO1xuICAgIH1cbiAgYDtcbn07XG5cbi8vIHNyYy9nZXQtcHJldmlldy1kb20tZWxlbWVudC50c1xudmFyIFJFTU9USU9OX1NUVURJT19DT05UQUlORVJfRUxFTUVOVCA9IFwiX19yZW1vdGlvbi1zdHVkaW8tY29udGFpbmVyXCI7XG52YXIgZ2V0UHJldmlld0RvbUVsZW1lbnQgPSAoKSA9PiB7XG4gIHJldHVybiBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChSRU1PVElPTl9TVFVESU9fQ09OVEFJTkVSX0VMRU1FTlQpO1xufTtcblxuLy8gc3JjL3JlZ2lzdGVyLXJvb3QudHNcbnZhciBSb290ID0gbnVsbDtcbnZhciBsaXN0ZW5lcnMgPSBbXTtcbnZhciByZWdpc3RlclJvb3QgPSAoY29tcCkgPT4ge1xuICBpZiAoIWNvbXApIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYFlvdSBtdXN0IHBhc3MgYSBSZWFjdCBjb21wb25lbnQgdG8gcmVnaXN0ZXJSb290KCksIGJ1dCAke0pTT04uc3RyaW5naWZ5KGNvbXApfSB3YXMgcGFzc2VkLmApO1xuICB9XG4gIGlmIChSb290KSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwicmVnaXN0ZXJSb290KCkgd2FzIGNhbGxlZCBtb3JlIHRoYW4gb25jZS5cIik7XG4gIH1cbiAgUm9vdCA9IGNvbXA7XG4gIGxpc3RlbmVycy5mb3JFYWNoKChsKSA9PiB7XG4gICAgbChjb21wKTtcbiAgfSk7XG59O1xudmFyIGdldFJvb3QgPSAoKSA9PiB7XG4gIHJldHVybiBSb290O1xufTtcbnZhciB3YWl0Rm9yUm9vdCA9IChmbikgPT4ge1xuICBpZiAoUm9vdCkge1xuICAgIGZuKFJvb3QpO1xuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICByZXR1cm47XG4gICAgfTtcbiAgfVxuICBsaXN0ZW5lcnMucHVzaChmbik7XG4gIHJldHVybiAoKSA9PiB7XG4gICAgbGlzdGVuZXJzID0gbGlzdGVuZXJzLmZpbHRlcigobCkgPT4gbCAhPT0gZm4pO1xuICB9O1xufTtcblxuLy8gc3JjL1JlbW90aW9uUm9vdC50c3hcbmltcG9ydCB7XG4gIHVzZUVmZmVjdCBhcyB1c2VFZmZlY3QyMCxcbiAgdXNlTGF5b3V0RWZmZWN0IGFzIHVzZUxheW91dEVmZmVjdDUsXG4gIHVzZU1lbW8gYXMgdXNlTWVtbzI2LFxuICB1c2VSZWYgYXMgdXNlUmVmMTIsXG4gIHVzZVN0YXRlIGFzIHVzZVN0YXRlMTdcbn0gZnJvbSBcInJlYWN0XCI7XG5pbXBvcnQgeyBqc3ggYXMganN4MjUgfSBmcm9tIFwicmVhY3QvanN4LXJ1bnRpbWVcIjtcbnZhciBSZW1vdGlvblJvb3QgPSAoeyBjaGlsZHJlbiwgbnVtYmVyT2ZBdWRpb1RhZ3MgfSkgPT4ge1xuICBjb25zdCBbcmVtb3Rpb25Sb290SWRdID0gdXNlU3RhdGUxNygoKSA9PiBTdHJpbmcocmFuZG9tKG51bGwpKSk7XG4gIGNvbnN0IFtmcmFtZSwgc2V0RnJhbWVdID0gdXNlU3RhdGUxNygoKSA9PiBnZXRJbml0aWFsRnJhbWVTdGF0ZSgpKTtcbiAgY29uc3QgW3BsYXlpbmcsIHNldFBsYXlpbmddID0gdXNlU3RhdGUxNyhmYWxzZSk7XG4gIGNvbnN0IGltcGVyYXRpdmVQbGF5aW5nID0gdXNlUmVmMTIoZmFsc2UpO1xuICBjb25zdCBbZmFzdFJlZnJlc2hlcywgc2V0RmFzdFJlZnJlc2hlc10gPSB1c2VTdGF0ZTE3KDApO1xuICBjb25zdCBbcGxheWJhY2tSYXRlLCBzZXRQbGF5YmFja1JhdGVdID0gdXNlU3RhdGUxNygxKTtcbiAgY29uc3QgYXVkaW9BbmRWaWRlb1RhZ3MgPSB1c2VSZWYxMihbXSk7XG4gIGlmICh0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgdXNlTGF5b3V0RWZmZWN0NSgoKSA9PiB7XG4gICAgICB3aW5kb3cucmVtb3Rpb25fc2V0RnJhbWUgPSAoZiwgY29tcG9zaXRpb24sIGF0dGVtcHQpID0+IHtcbiAgICAgICAgd2luZG93LnJlbW90aW9uX2F0dGVtcHQgPSBhdHRlbXB0O1xuICAgICAgICBjb25zdCBpZCA9IGRlbGF5UmVuZGVyKGBTZXR0aW5nIHRoZSBjdXJyZW50IGZyYW1lIHRvICR7Zn1gKTtcbiAgICAgICAgbGV0IGFzeW5jVXBkYXRlID0gdHJ1ZTtcbiAgICAgICAgc2V0RnJhbWUoKHMpID0+IHtcbiAgICAgICAgICBjb25zdCBjdXJyZW50RnJhbWUgPSBzW2NvbXBvc2l0aW9uXSA/PyB3aW5kb3cucmVtb3Rpb25faW5pdGlhbEZyYW1lO1xuICAgICAgICAgIGlmIChjdXJyZW50RnJhbWUgPT09IGYpIHtcbiAgICAgICAgICAgIGFzeW5jVXBkYXRlID0gZmFsc2U7XG4gICAgICAgICAgICByZXR1cm4gcztcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIC4uLnMsXG4gICAgICAgICAgICBbY29tcG9zaXRpb25dOiBmXG4gICAgICAgICAgfTtcbiAgICAgICAgfSk7XG4gICAgICAgIGlmIChhc3luY1VwZGF0ZSkge1xuICAgICAgICAgIHJlcXVlc3RBbmltYXRpb25GcmFtZSgoKSA9PiBjb250aW51ZVJlbmRlcihpZCkpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNvbnRpbnVlUmVuZGVyKGlkKTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIHdpbmRvdy5yZW1vdGlvbl9pc1BsYXllciA9IGZhbHNlO1xuICAgIH0sIFtdKTtcbiAgfVxuICBjb25zdCB0aW1lbGluZUNvbnRleHRWYWx1ZSA9IHVzZU1lbW8yNigoKSA9PiB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGZyYW1lLFxuICAgICAgcGxheWluZyxcbiAgICAgIGltcGVyYXRpdmVQbGF5aW5nLFxuICAgICAgcm9vdElkOiByZW1vdGlvblJvb3RJZCxcbiAgICAgIHBsYXliYWNrUmF0ZSxcbiAgICAgIHNldFBsYXliYWNrUmF0ZSxcbiAgICAgIGF1ZGlvQW5kVmlkZW9UYWdzXG4gICAgfTtcbiAgfSwgW2ZyYW1lLCBwbGF5YmFja1JhdGUsIHBsYXlpbmcsIHJlbW90aW9uUm9vdElkXSk7XG4gIGNvbnN0IHNldFRpbWVsaW5lQ29udGV4dFZhbHVlID0gdXNlTWVtbzI2KCgpID0+IHtcbiAgICByZXR1cm4ge1xuICAgICAgc2V0RnJhbWUsXG4gICAgICBzZXRQbGF5aW5nXG4gICAgfTtcbiAgfSwgW10pO1xuICBjb25zdCBub25jZUNvbnRleHQgPSB1c2VNZW1vMjYoKCkgPT4ge1xuICAgIGxldCBjb3VudGVyID0gMDtcbiAgICByZXR1cm4ge1xuICAgICAgZ2V0Tm9uY2U6ICgpID0+IGNvdW50ZXIrKyxcbiAgICAgIGZhc3RSZWZyZXNoZXNcbiAgICB9O1xuICB9LCBbZmFzdFJlZnJlc2hlc10pO1xuICB1c2VFZmZlY3QyMCgoKSA9PiB7XG4gICAgaWYgKHR5cGVvZiBfX3dlYnBhY2tfbW9kdWxlX18gIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgIGlmIChfX3dlYnBhY2tfbW9kdWxlX18uaG90KSB7XG4gICAgICAgIF9fd2VicGFja19tb2R1bGVfXy5ob3QuYWRkU3RhdHVzSGFuZGxlcigoc3RhdHVzKSA9PiB7XG4gICAgICAgICAgaWYgKHN0YXR1cyA9PT0gXCJpZGxlXCIpIHtcbiAgICAgICAgICAgIHNldEZhc3RSZWZyZXNoZXMoKGkpID0+IGkgKyAxKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cbiAgfSwgW10pO1xuICByZXR1cm4gLyogQF9fUFVSRV9fICovIGpzeDI1KE5vbmNlQ29udGV4dC5Qcm92aWRlciwge1xuICAgIHZhbHVlOiBub25jZUNvbnRleHQsXG4gICAgY2hpbGRyZW46IC8qIEBfX1BVUkVfXyAqLyBqc3gyNShUaW1lbGluZUNvbnRleHQuUHJvdmlkZXIsIHtcbiAgICAgIHZhbHVlOiB0aW1lbGluZUNvbnRleHRWYWx1ZSxcbiAgICAgIGNoaWxkcmVuOiAvKiBAX19QVVJFX18gKi8ganN4MjUoU2V0VGltZWxpbmVDb250ZXh0LlByb3ZpZGVyLCB7XG4gICAgICAgIHZhbHVlOiBzZXRUaW1lbGluZUNvbnRleHRWYWx1ZSxcbiAgICAgICAgY2hpbGRyZW46IC8qIEBfX1BVUkVfXyAqLyBqc3gyNShFZGl0b3JQcm9wc1Byb3ZpZGVyLCB7XG4gICAgICAgICAgY2hpbGRyZW46IC8qIEBfX1BVUkVfXyAqLyBqc3gyNShQcmVmZXRjaFByb3ZpZGVyLCB7XG4gICAgICAgICAgICBjaGlsZHJlbjogLyogQF9fUFVSRV9fICovIGpzeDI1KE5hdGl2ZUxheWVyc1Byb3ZpZGVyLCB7XG4gICAgICAgICAgICAgIGNoaWxkcmVuOiAvKiBAX19QVVJFX18gKi8ganN4MjUoQ29tcG9zaXRpb25NYW5hZ2VyUHJvdmlkZXIsIHtcbiAgICAgICAgICAgICAgICBudW1iZXJPZkF1ZGlvVGFncyxcbiAgICAgICAgICAgICAgICBjaGlsZHJlbjogLyogQF9fUFVSRV9fICovIGpzeDI1KER1cmF0aW9uc0NvbnRleHRQcm92aWRlciwge1xuICAgICAgICAgICAgICAgICAgY2hpbGRyZW46IC8qIEBfX1BVUkVfXyAqLyBqc3gyNShCdWZmZXJpbmdQcm92aWRlciwge1xuICAgICAgICAgICAgICAgICAgICBjaGlsZHJlblxuICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgfSlcbiAgICAgICAgICB9KVxuICAgICAgICB9KVxuICAgICAgfSlcbiAgICB9KVxuICB9KTtcbn07XG5cbi8vIHNyYy9zZXR1cC1lbnYtdmFyaWFibGVzLnRzXG52YXIgZ2V0RW52VmFyaWFibGVzID0gKCkgPT4ge1xuICBpZiAoZ2V0UmVtb3Rpb25FbnZpcm9ubWVudCgpLmlzUmVuZGVyaW5nKSB7XG4gICAgY29uc3QgcGFyYW0gPSB3aW5kb3cucmVtb3Rpb25fZW52VmFyaWFibGVzO1xuICAgIGlmICghcGFyYW0pIHtcbiAgICAgIHJldHVybiB7fTtcbiAgICB9XG4gICAgcmV0dXJuIHsgLi4uSlNPTi5wYXJzZShwYXJhbSksIE5PREVfRU5WOiBcInByb2R1Y3Rpb25cIiB9O1xuICB9XG4gIGlmIChmYWxzZSkge1xuICB9XG4gIHJldHVybiB7XG4gICAgTk9ERV9FTlY6IFwicHJvZHVjdGlvblwiXG4gIH07XG59O1xudmFyIHNldHVwRW52VmFyaWFibGVzID0gKCkgPT4ge1xuICBjb25zdCBlbnYgPSBnZXRFbnZWYXJpYWJsZXMoKTtcbiAgaWYgKCF3aW5kb3cucHJvY2Vzcykge1xuICAgIHdpbmRvdy5wcm9jZXNzID0ge307XG4gIH1cbiAgaWYgKCF3aW5kb3cucHJvY2Vzcy5lbnYpIHtcbiAgICB3aW5kb3cucHJvY2Vzcy5lbnYgPSB7fTtcbiAgfVxuICBPYmplY3Qua2V5cyhlbnYpLmZvckVhY2goKGtleSkgPT4ge1xuICAgIHdpbmRvdy5wcm9jZXNzLmVudltrZXldID0gZW52W2tleV07XG4gIH0pO1xufTtcblxuLy8gc3JjL3VzZS1jdXJyZW50LXNjYWxlLnRzXG5pbXBvcnQgUmVhY3QyMiwgeyBjcmVhdGVDb250ZXh0IGFzIGNyZWF0ZUNvbnRleHQxOCB9IGZyb20gXCJyZWFjdFwiO1xudmFyIEN1cnJlbnRTY2FsZUNvbnRleHQgPSBSZWFjdDIyLmNyZWF0ZUNvbnRleHQobnVsbCk7XG52YXIgUHJldmlld1NpemVDb250ZXh0ID0gY3JlYXRlQ29udGV4dDE4KHtcbiAgc2V0U2l6ZTogKCkgPT4ge1xuICAgIHJldHVybjtcbiAgfSxcbiAgc2l6ZTogeyBzaXplOiBcImF1dG9cIiwgdHJhbnNsYXRpb246IHsgeDogMCwgeTogMCB9IH1cbn0pO1xudmFyIGNhbGN1bGF0ZVNjYWxlID0gKHtcbiAgY2FudmFzU2l6ZSxcbiAgY29tcG9zaXRpb25IZWlnaHQsXG4gIGNvbXBvc2l0aW9uV2lkdGgsXG4gIHByZXZpZXdTaXplXG59KSA9PiB7XG4gIGNvbnN0IGhlaWdodFJhdGlvID0gY2FudmFzU2l6ZS5oZWlnaHQgLyBjb21wb3NpdGlvbkhlaWdodDtcbiAgY29uc3Qgd2lkdGhSYXRpbyA9IGNhbnZhc1NpemUud2lkdGggLyBjb21wb3NpdGlvbldpZHRoO1xuICBjb25zdCByYXRpbyA9IE1hdGgubWluKGhlaWdodFJhdGlvLCB3aWR0aFJhdGlvKTtcbiAgcmV0dXJuIHByZXZpZXdTaXplID09PSBcImF1dG9cIiA/IHJhdGlvIDogTnVtYmVyKHByZXZpZXdTaXplKTtcbn07XG52YXIgdXNlQ3VycmVudFNjYWxlID0gKG9wdGlvbnMpID0+IHtcbiAgY29uc3QgaGFzQ29udGV4dCA9IFJlYWN0MjIudXNlQ29udGV4dChDdXJyZW50U2NhbGVDb250ZXh0KTtcbiAgY29uc3Qgem9vbUNvbnRleHQgPSBSZWFjdDIyLnVzZUNvbnRleHQoUHJldmlld1NpemVDb250ZXh0KTtcbiAgY29uc3QgY29uZmlnID0gdXNlVW5zYWZlVmlkZW9Db25maWcoKTtcbiAgaWYgKGhhc0NvbnRleHQgPT09IG51bGwgfHwgY29uZmlnID09PSBudWxsIHx8IHpvb21Db250ZXh0ID09PSBudWxsKSB7XG4gICAgaWYgKG9wdGlvbnM/LmRvbnRUaHJvd0lmT3V0c2lkZU9mUmVtb3Rpb24pIHtcbiAgICAgIHJldHVybiAxO1xuICAgIH1cbiAgICBpZiAoZ2V0UmVtb3Rpb25FbnZpcm9ubWVudCgpLmlzUmVuZGVyaW5nKSB7XG4gICAgICByZXR1cm4gMTtcbiAgICB9XG4gICAgdGhyb3cgbmV3IEVycm9yKFtcbiAgICAgIFwidXNlQ3VycmVudFNjYWxlKCkgd2FzIGNhbGxlZCBvdXRzaWRlIG9mIGEgUmVtb3Rpb24gY29udGV4dC5cIixcbiAgICAgIFwiVGhpcyBob29rIGNhbiBvbmx5IGJlIGNhbGxlZCBpbiBhIGNvbXBvbmVudCB0aGF0IGlzIGJlaW5nIHJlbmRlcmVkIGJ5IFJlbW90aW9uLlwiLFxuICAgICAgXCJJZiB5b3Ugd2FudCB0byB0aGlzIGhvb2sgdG8gcmV0dXJuIDEgb3V0c2lkZSBvZiBSZW1vdGlvbiwgcGFzcyB7ZG9udFRocm93SWZPdXRzaWRlT2ZSZW1vdGlvbjogdHJ1ZX0gYXMgYW4gb3B0aW9uLlwiLFxuICAgICAgXCJJZiB5b3UgdGhpbmsgeW91IGNhbGxlZCB0aGlzIGhvb2sgaW4gYSBSZW1vdGlvbiBjb21wb25lbnQsIG1ha2Ugc3VyZSBhbGwgdmVyc2lvbnMgb2YgUmVtb3Rpb24gYXJlIGFsaWduZWQuXCJcbiAgICBdLmpvaW4oXCJcXG5cIikpO1xuICB9XG4gIGlmIChoYXNDb250ZXh0LnR5cGUgPT09IFwic2NhbGVcIikge1xuICAgIHJldHVybiBoYXNDb250ZXh0LnNjYWxlO1xuICB9XG4gIHJldHVybiBjYWxjdWxhdGVTY2FsZSh7XG4gICAgY2FudmFzU2l6ZTogaGFzQ29udGV4dC5jYW52YXNTaXplLFxuICAgIGNvbXBvc2l0aW9uSGVpZ2h0OiBjb25maWcuaGVpZ2h0LFxuICAgIGNvbXBvc2l0aW9uV2lkdGg6IGNvbmZpZy53aWR0aCxcbiAgICBwcmV2aWV3U2l6ZTogem9vbUNvbnRleHQuc2l6ZS5zaXplXG4gIH0pO1xufTtcblxuLy8gc3JjL3dhdGNoLXN0YXRpYy1maWxlLnRzXG52YXIgV0FUQ0hfUkVNT1RJT05fU1RBVElDX0ZJTEVTID0gXCJyZW1vdGlvbl9zdGF0aWNGaWxlc0NoYW5nZWRcIjtcbnZhciB3YXRjaFN0YXRpY0ZpbGUgPSAoZmlsZU5hbWUsIGNhbGxiYWNrKSA9PiB7XG4gIGlmIChFTkFCTEVfVjVfQlJFQUtJTkdfQ0hBTkdFUykge1xuICAgIHRocm93IG5ldyBFcnJvcihcIndhdGNoU3RhdGljRmlsZSgpIGhhcyBtb3ZlZCBpbnRvIHRoZSBgQHJlbW90aW9uL3N0dWRpb2AgcGFja2FnZS4gVXBkYXRlIHlvdXIgaW1wb3J0cy5cIik7XG4gIH1cbiAgaWYgKCFnZXRSZW1vdGlvbkVudmlyb25tZW50KCkuaXNTdHVkaW8pIHtcbiAgICBjb25zb2xlLndhcm4oXCJUaGUgQVBJIGlzIG9ubHkgYXZhaWxhYmxlIHdoaWxlIHVzaW5nIHRoZSBSZW1vdGlvbiBTdHVkaW8uXCIpO1xuICAgIHJldHVybiB7IGNhbmNlbDogKCkgPT4ge1xuICAgICAgcmV0dXJuO1xuICAgIH0gfTtcbiAgfVxuICBjb25zdCB3aXRob3V0U3RhdGljQmFzZSA9IGZpbGVOYW1lLnN0YXJ0c1dpdGgod2luZG93LnJlbW90aW9uX3N0YXRpY0Jhc2UpID8gZmlsZU5hbWUucmVwbGFjZSh3aW5kb3cucmVtb3Rpb25fc3RhdGljQmFzZSwgXCJcIikgOiBmaWxlTmFtZTtcbiAgY29uc3Qgd2l0aG91dExlYWRpbmdTbGFzaCA9IHdpdGhvdXRTdGF0aWNCYXNlLnN0YXJ0c1dpdGgoXCIvXCIpID8gd2l0aG91dFN0YXRpY0Jhc2Uuc2xpY2UoMSkgOiB3aXRob3V0U3RhdGljQmFzZTtcbiAgbGV0IHByZXZGaWxlRGF0YSA9IHdpbmRvdy5yZW1vdGlvbl9zdGF0aWNGaWxlcy5maW5kKChmaWxlKSA9PiBmaWxlLm5hbWUgPT09IHdpdGhvdXRMZWFkaW5nU2xhc2gpO1xuICBjb25zdCBjaGVja0ZpbGUgPSAoZXZlbnQpID0+IHtcbiAgICBjb25zdCBzdGF0aWNGaWxlcyA9IGV2ZW50LmRldGFpbC5maWxlcztcbiAgICBjb25zdCBuZXdGaWxlRGF0YSA9IHN0YXRpY0ZpbGVzLmZpbmQoKGZpbGUpID0+IGZpbGUubmFtZSA9PT0gd2l0aG91dExlYWRpbmdTbGFzaCk7XG4gICAgaWYgKCFuZXdGaWxlRGF0YSkge1xuICAgICAgaWYgKHByZXZGaWxlRGF0YSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGNhbGxiYWNrKG51bGwpO1xuICAgICAgfVxuICAgICAgcHJldkZpbGVEYXRhID0gdW5kZWZpbmVkO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAocHJldkZpbGVEYXRhID09PSB1bmRlZmluZWQgfHwgcHJldkZpbGVEYXRhLmxhc3RNb2RpZmllZCAhPT0gbmV3RmlsZURhdGEubGFzdE1vZGlmaWVkKSB7XG4gICAgICBjYWxsYmFjayhuZXdGaWxlRGF0YSk7XG4gICAgICBwcmV2RmlsZURhdGEgPSBuZXdGaWxlRGF0YTtcbiAgICB9XG4gIH07XG4gIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFdBVENIX1JFTU9USU9OX1NUQVRJQ19GSUxFUywgY2hlY2tGaWxlKTtcbiAgY29uc3QgY2FuY2VsID0gKCkgPT4ge1xuICAgIHJldHVybiB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcihXQVRDSF9SRU1PVElPTl9TVEFUSUNfRklMRVMsIGNoZWNrRmlsZSk7XG4gIH07XG4gIHJldHVybiB7IGNhbmNlbCB9O1xufTtcblxuLy8gc3JjL3dyYXAtcmVtb3Rpb24tY29udGV4dC50c3hcbmltcG9ydCBSZWFjdDIzLCB7IHVzZU1lbW8gYXMgdXNlTWVtbzI3IH0gZnJvbSBcInJlYWN0XCI7XG5mdW5jdGlvbiB1c2VSZW1vdGlvbkNvbnRleHRzKCkge1xuICBjb25zdCBjb21wb3NpdGlvbk1hbmFnZXJDdHggPSBSZWFjdDIzLnVzZUNvbnRleHQoQ29tcG9zaXRpb25NYW5hZ2VyKTtcbiAgY29uc3QgdGltZWxpbmVDb250ZXh0ID0gUmVhY3QyMy51c2VDb250ZXh0KFRpbWVsaW5lQ29udGV4dCk7XG4gIGNvbnN0IHNldFRpbWVsaW5lQ29udGV4dCA9IFJlYWN0MjMudXNlQ29udGV4dChTZXRUaW1lbGluZUNvbnRleHQpO1xuICBjb25zdCBzZXF1ZW5jZUNvbnRleHQgPSBSZWFjdDIzLnVzZUNvbnRleHQoU2VxdWVuY2VDb250ZXh0KTtcbiAgY29uc3Qgbm9uY2VDb250ZXh0ID0gUmVhY3QyMy51c2VDb250ZXh0KE5vbmNlQ29udGV4dCk7XG4gIGNvbnN0IGNhblVzZVJlbW90aW9uSG9va3NDb250ZXh0ID0gUmVhY3QyMy51c2VDb250ZXh0KENhblVzZVJlbW90aW9uSG9va3MpO1xuICBjb25zdCBuYXRpdmVMYXllcnNDb250ZXh0ID0gUmVhY3QyMy51c2VDb250ZXh0KE5hdGl2ZUxheWVyc0NvbnRleHQpO1xuICBjb25zdCBwcmVsb2FkQ29udGV4dCA9IFJlYWN0MjMudXNlQ29udGV4dChQcmVsb2FkQ29udGV4dCk7XG4gIGNvbnN0IHJlc29sdmVDb21wb3NpdGlvbkNvbnRleHQgPSBSZWFjdDIzLnVzZUNvbnRleHQoUmVzb2x2ZUNvbXBvc2l0aW9uQ29udGV4dCk7XG4gIGNvbnN0IHJlbmRlckFzc2V0TWFuYWdlckNvbnRleHQgPSBSZWFjdDIzLnVzZUNvbnRleHQoUmVuZGVyQXNzZXRNYW5hZ2VyKTtcbiAgY29uc3Qgc2VxdWVuY2VNYW5hZ2VyQ29udGV4dCA9IFJlYWN0MjMudXNlQ29udGV4dChTZXF1ZW5jZU1hbmFnZXIpO1xuICBjb25zdCBidWZmZXJNYW5hZ2VyQ29udGV4dCA9IFJlYWN0MjMudXNlQ29udGV4dChCdWZmZXJpbmdDb250ZXh0UmVhY3QpO1xuICByZXR1cm4gdXNlTWVtbzI3KCgpID0+ICh7XG4gICAgY29tcG9zaXRpb25NYW5hZ2VyQ3R4LFxuICAgIHRpbWVsaW5lQ29udGV4dCxcbiAgICBzZXRUaW1lbGluZUNvbnRleHQsXG4gICAgc2VxdWVuY2VDb250ZXh0LFxuICAgIG5vbmNlQ29udGV4dCxcbiAgICBjYW5Vc2VSZW1vdGlvbkhvb2tzQ29udGV4dCxcbiAgICBuYXRpdmVMYXllcnNDb250ZXh0LFxuICAgIHByZWxvYWRDb250ZXh0LFxuICAgIHJlc29sdmVDb21wb3NpdGlvbkNvbnRleHQsXG4gICAgcmVuZGVyQXNzZXRNYW5hZ2VyQ29udGV4dCxcbiAgICBzZXF1ZW5jZU1hbmFnZXJDb250ZXh0LFxuICAgIGJ1ZmZlck1hbmFnZXJDb250ZXh0XG4gIH0pLCBbXG4gICAgY29tcG9zaXRpb25NYW5hZ2VyQ3R4LFxuICAgIG5vbmNlQ29udGV4dCxcbiAgICBzZXF1ZW5jZUNvbnRleHQsXG4gICAgc2V0VGltZWxpbmVDb250ZXh0LFxuICAgIHRpbWVsaW5lQ29udGV4dCxcbiAgICBjYW5Vc2VSZW1vdGlvbkhvb2tzQ29udGV4dCxcbiAgICBuYXRpdmVMYXllcnNDb250ZXh0LFxuICAgIHByZWxvYWRDb250ZXh0LFxuICAgIHJlc29sdmVDb21wb3NpdGlvbkNvbnRleHQsXG4gICAgcmVuZGVyQXNzZXRNYW5hZ2VyQ29udGV4dCxcbiAgICBzZXF1ZW5jZU1hbmFnZXJDb250ZXh0LFxuICAgIGJ1ZmZlck1hbmFnZXJDb250ZXh0XG4gIF0pO1xufVxuaW1wb3J0IHsganN4IGFzIGpzeDI2IH0gZnJvbSBcInJlYWN0L2pzeC1ydW50aW1lXCI7XG52YXIgUmVtb3Rpb25Db250ZXh0UHJvdmlkZXIgPSAocHJvcHMyKSA9PiB7XG4gIGNvbnN0IHsgY2hpbGRyZW4sIGNvbnRleHRzIH0gPSBwcm9wczI7XG4gIHJldHVybiAvKiBAX19QVVJFX18gKi8ganN4MjYoQ2FuVXNlUmVtb3Rpb25Ib29rcy5Qcm92aWRlciwge1xuICAgIHZhbHVlOiBjb250ZXh0cy5jYW5Vc2VSZW1vdGlvbkhvb2tzQ29udGV4dCxcbiAgICBjaGlsZHJlbjogLyogQF9fUFVSRV9fICovIGpzeDI2KE5vbmNlQ29udGV4dC5Qcm92aWRlciwge1xuICAgICAgdmFsdWU6IGNvbnRleHRzLm5vbmNlQ29udGV4dCxcbiAgICAgIGNoaWxkcmVuOiAvKiBAX19QVVJFX18gKi8ganN4MjYoTmF0aXZlTGF5ZXJzQ29udGV4dC5Qcm92aWRlciwge1xuICAgICAgICB2YWx1ZTogY29udGV4dHMubmF0aXZlTGF5ZXJzQ29udGV4dCxcbiAgICAgICAgY2hpbGRyZW46IC8qIEBfX1BVUkVfXyAqLyBqc3gyNihQcmVsb2FkQ29udGV4dC5Qcm92aWRlciwge1xuICAgICAgICAgIHZhbHVlOiBjb250ZXh0cy5wcmVsb2FkQ29udGV4dCxcbiAgICAgICAgICBjaGlsZHJlbjogLyogQF9fUFVSRV9fICovIGpzeDI2KENvbXBvc2l0aW9uTWFuYWdlci5Qcm92aWRlciwge1xuICAgICAgICAgICAgdmFsdWU6IGNvbnRleHRzLmNvbXBvc2l0aW9uTWFuYWdlckN0eCxcbiAgICAgICAgICAgIGNoaWxkcmVuOiAvKiBAX19QVVJFX18gKi8ganN4MjYoU2VxdWVuY2VNYW5hZ2VyLlByb3ZpZGVyLCB7XG4gICAgICAgICAgICAgIHZhbHVlOiBjb250ZXh0cy5zZXF1ZW5jZU1hbmFnZXJDb250ZXh0LFxuICAgICAgICAgICAgICBjaGlsZHJlbjogLyogQF9fUFVSRV9fICovIGpzeDI2KFJlbmRlckFzc2V0TWFuYWdlci5Qcm92aWRlciwge1xuICAgICAgICAgICAgICAgIHZhbHVlOiBjb250ZXh0cy5yZW5kZXJBc3NldE1hbmFnZXJDb250ZXh0LFxuICAgICAgICAgICAgICAgIGNoaWxkcmVuOiAvKiBAX19QVVJFX18gKi8ganN4MjYoUmVzb2x2ZUNvbXBvc2l0aW9uQ29udGV4dC5Qcm92aWRlciwge1xuICAgICAgICAgICAgICAgICAgdmFsdWU6IGNvbnRleHRzLnJlc29sdmVDb21wb3NpdGlvbkNvbnRleHQsXG4gICAgICAgICAgICAgICAgICBjaGlsZHJlbjogLyogQF9fUFVSRV9fICovIGpzeDI2KFRpbWVsaW5lQ29udGV4dC5Qcm92aWRlciwge1xuICAgICAgICAgICAgICAgICAgICB2YWx1ZTogY29udGV4dHMudGltZWxpbmVDb250ZXh0LFxuICAgICAgICAgICAgICAgICAgICBjaGlsZHJlbjogLyogQF9fUFVSRV9fICovIGpzeDI2KFNldFRpbWVsaW5lQ29udGV4dC5Qcm92aWRlciwge1xuICAgICAgICAgICAgICAgICAgICAgIHZhbHVlOiBjb250ZXh0cy5zZXRUaW1lbGluZUNvbnRleHQsXG4gICAgICAgICAgICAgICAgICAgICAgY2hpbGRyZW46IC8qIEBfX1BVUkVfXyAqLyBqc3gyNihTZXF1ZW5jZUNvbnRleHQuUHJvdmlkZXIsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlOiBjb250ZXh0cy5zZXF1ZW5jZUNvbnRleHQsXG4gICAgICAgICAgICAgICAgICAgICAgICBjaGlsZHJlbjogLyogQF9fUFVSRV9fICovIGpzeDI2KEJ1ZmZlcmluZ0NvbnRleHRSZWFjdC5Qcm92aWRlciwge1xuICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZTogY29udGV4dHMuYnVmZmVyTWFuYWdlckNvbnRleHQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgIGNoaWxkcmVuXG4gICAgICAgICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICB9KVxuICAgICAgICAgIH0pXG4gICAgICAgIH0pXG4gICAgICB9KVxuICAgIH0pXG4gIH0pO1xufTtcblxuLy8gc3JjL2ludGVybmFscy50c1xudmFyIEludGVybmFscyA9IHtcbiAgdXNlVW5zYWZlVmlkZW9Db25maWcsXG4gIFRpbWVsaW5lOiBleHBvcnRzX3RpbWVsaW5lX3Bvc2l0aW9uX3N0YXRlLFxuICBDb21wb3NpdGlvbk1hbmFnZXIsXG4gIFNlcXVlbmNlTWFuYWdlcixcbiAgU2VxdWVuY2VWaXNpYmlsaXR5VG9nZ2xlQ29udGV4dCxcbiAgUmVtb3Rpb25Sb290LFxuICB1c2VWaWRlbyxcbiAgZ2V0Um9vdCxcbiAgdXNlTWVkaWFWb2x1bWVTdGF0ZSxcbiAgdXNlTWVkaWFNdXRlZFN0YXRlLFxuICB1c2VMYXp5Q29tcG9uZW50LFxuICB0cnV0aHksXG4gIFNlcXVlbmNlQ29udGV4dCxcbiAgdXNlUmVtb3Rpb25Db250ZXh0cyxcbiAgUmVtb3Rpb25Db250ZXh0UHJvdmlkZXIsXG4gIENTU1V0aWxzOiBleHBvcnRzX2RlZmF1bHRfY3NzLFxuICBzZXR1cEVudlZhcmlhYmxlcyxcbiAgTWVkaWFWb2x1bWVDb250ZXh0LFxuICBTZXRNZWRpYVZvbHVtZUNvbnRleHQsXG4gIGdldFJlbW90aW9uRW52aXJvbm1lbnQsXG4gIFNoYXJlZEF1ZGlvQ29udGV4dCxcbiAgU2hhcmVkQXVkaW9Db250ZXh0UHJvdmlkZXIsXG4gIGludmFsaWRDb21wb3NpdGlvbkVycm9yTWVzc2FnZSxcbiAgaXNDb21wb3NpdGlvbklkVmFsaWQsXG4gIGdldFByZXZpZXdEb21FbGVtZW50LFxuICBjb21wb3NpdGlvbnNSZWYsXG4gIHBvcnRhbE5vZGUsXG4gIHdhaXRGb3JSb290LFxuICBDYW5Vc2VSZW1vdGlvbkhvb2tzUHJvdmlkZXIsXG4gIENhblVzZVJlbW90aW9uSG9va3MsXG4gIFByZWZldGNoUHJvdmlkZXIsXG4gIER1cmF0aW9uc0NvbnRleHRQcm92aWRlcixcbiAgSXNQbGF5ZXJDb250ZXh0UHJvdmlkZXIsXG4gIHVzZUlzUGxheWVyLFxuICBFZGl0b3JQcm9wc1Byb3ZpZGVyLFxuICBFZGl0b3JQcm9wc0NvbnRleHQsXG4gIHVzZVByZWxvYWQsXG4gIE5vbmNlQ29udGV4dCxcbiAgcmVzb2x2ZVZpZGVvQ29uZmlnLFxuICB1c2VSZXNvbHZlZFZpZGVvQ29uZmlnLFxuICByZXNvbHZlQ29tcG9zaXRpb25zUmVmLFxuICBSZXNvbHZlQ29tcG9zaXRpb25Db25maWcsXG4gIFJFTU9USU9OX1NUVURJT19DT05UQUlORVJfRUxFTUVOVCxcbiAgUmVuZGVyQXNzZXRNYW5hZ2VyLFxuICBwZXJzaXN0Q3VycmVudEZyYW1lLFxuICB1c2VUaW1lbGluZVNldEZyYW1lLFxuICBOYXRpdmVMYXllcnNQcm92aWRlcixcbiAgQ2xpcENvbXBvc2l0aW9uLFxuICBpc0lvc1NhZmFyaSxcbiAgV0FUQ0hfUkVNT1RJT05fU1RBVElDX0ZJTEVTLFxuICBhZGRTZXF1ZW5jZVN0YWNrVHJhY2VzLFxuICB1c2VNZWRpYVN0YXJ0c0F0LFxuICBCdWZmZXJpbmdQcm92aWRlcixcbiAgQnVmZmVyaW5nQ29udGV4dFJlYWN0LFxuICBlbmFibGVTZXF1ZW5jZVN0YWNrVHJhY2VzLFxuICBDdXJyZW50U2NhbGVDb250ZXh0LFxuICBQcmV2aWV3U2l6ZUNvbnRleHQsXG4gIGNhbGN1bGF0ZVNjYWxlLFxuICBlZGl0b3JQcm9wc1Byb3ZpZGVyUmVmLFxuICBQUk9QU19VUERBVEVEX0VYVEVSTkFMTFksXG4gIHZhbGlkYXRlUmVuZGVyQXNzZXRcbn07XG4vLyBzcmMvaW50ZXJwb2xhdGUtY29sb3JzLnRzXG5mdW5jdGlvbiBjYWxsKC4uLmFyZ3MpIHtcbiAgcmV0dXJuIFwiXFxcXChcXFxccyooXCIgKyBhcmdzLmpvaW4oXCIpXFxcXHMqLFxcXFxzKihcIikgKyBcIilcXFxccypcXFxcKVwiO1xufVxuZnVuY3Rpb24gZ2V0TWF0Y2hlcnMoKSB7XG4gIGNvbnN0IGNhY2hlZE1hdGNoZXJzID0ge1xuICAgIHJnYjogdW5kZWZpbmVkLFxuICAgIHJnYmE6IHVuZGVmaW5lZCxcbiAgICBoc2w6IHVuZGVmaW5lZCxcbiAgICBoc2xhOiB1bmRlZmluZWQsXG4gICAgaGV4MzogdW5kZWZpbmVkLFxuICAgIGhleDQ6IHVuZGVmaW5lZCxcbiAgICBoZXg1OiB1bmRlZmluZWQsXG4gICAgaGV4NjogdW5kZWZpbmVkLFxuICAgIGhleDg6IHVuZGVmaW5lZFxuICB9O1xuICBpZiAoY2FjaGVkTWF0Y2hlcnMucmdiID09PSB1bmRlZmluZWQpIHtcbiAgICBjYWNoZWRNYXRjaGVycy5yZ2IgPSBuZXcgUmVnRXhwKFwicmdiXCIgKyBjYWxsKE5VTUJFUiwgTlVNQkVSLCBOVU1CRVIpKTtcbiAgICBjYWNoZWRNYXRjaGVycy5yZ2JhID0gbmV3IFJlZ0V4cChcInJnYmFcIiArIGNhbGwoTlVNQkVSLCBOVU1CRVIsIE5VTUJFUiwgTlVNQkVSKSk7XG4gICAgY2FjaGVkTWF0Y2hlcnMuaHNsID0gbmV3IFJlZ0V4cChcImhzbFwiICsgY2FsbChOVU1CRVIsIFBFUkNFTlRBR0UsIFBFUkNFTlRBR0UpKTtcbiAgICBjYWNoZWRNYXRjaGVycy5oc2xhID0gbmV3IFJlZ0V4cChcImhzbGFcIiArIGNhbGwoTlVNQkVSLCBQRVJDRU5UQUdFLCBQRVJDRU5UQUdFLCBOVU1CRVIpKTtcbiAgICBjYWNoZWRNYXRjaGVycy5oZXgzID0gL14jKFswLTlhLWZBLUZdezF9KShbMC05YS1mQS1GXXsxfSkoWzAtOWEtZkEtRl17MX0pJC87XG4gICAgY2FjaGVkTWF0Y2hlcnMuaGV4NCA9IC9eIyhbMC05YS1mQS1GXXsxfSkoWzAtOWEtZkEtRl17MX0pKFswLTlhLWZBLUZdezF9KShbMC05YS1mQS1GXXsxfSkkLztcbiAgICBjYWNoZWRNYXRjaGVycy5oZXg2ID0gL14jKFswLTlhLWZBLUZdezZ9KSQvO1xuICAgIGNhY2hlZE1hdGNoZXJzLmhleDggPSAvXiMoWzAtOWEtZkEtRl17OH0pJC87XG4gIH1cbiAgcmV0dXJuIGNhY2hlZE1hdGNoZXJzO1xufVxuZnVuY3Rpb24gaHVlMnJnYihwLCBxLCB0KSB7XG4gIGlmICh0IDwgMCkge1xuICAgIHQgKz0gMTtcbiAgfVxuICBpZiAodCA+IDEpIHtcbiAgICB0IC09IDE7XG4gIH1cbiAgaWYgKHQgPCAxIC8gNikge1xuICAgIHJldHVybiBwICsgKHEgLSBwKSAqIDYgKiB0O1xuICB9XG4gIGlmICh0IDwgMSAvIDIpIHtcbiAgICByZXR1cm4gcTtcbiAgfVxuICBpZiAodCA8IDIgLyAzKSB7XG4gICAgcmV0dXJuIHAgKyAocSAtIHApICogKDIgLyAzIC0gdCkgKiA2O1xuICB9XG4gIHJldHVybiBwO1xufVxuZnVuY3Rpb24gaHNsVG9SZ2IoaCwgcywgbCkge1xuICBjb25zdCBxID0gbCA8IDAuNSA/IGwgKiAoMSArIHMpIDogbCArIHMgLSBsICogcztcbiAgY29uc3QgcCA9IDIgKiBsIC0gcTtcbiAgY29uc3QgciA9IGh1ZTJyZ2IocCwgcSwgaCArIDEgLyAzKTtcbiAgY29uc3QgZyA9IGh1ZTJyZ2IocCwgcSwgaCk7XG4gIGNvbnN0IGIyID0gaHVlMnJnYihwLCBxLCBoIC0gMSAvIDMpO1xuICByZXR1cm4gTWF0aC5yb3VuZChyICogMjU1KSA8PCAyNCB8IE1hdGgucm91bmQoZyAqIDI1NSkgPDwgMTYgfCBNYXRoLnJvdW5kKGIyICogMjU1KSA8PCA4O1xufVxuZnVuY3Rpb24gcGFyc2UyNTUoc3RyKSB7XG4gIGNvbnN0IGludCA9IE51bWJlci5wYXJzZUludChzdHIsIDEwKTtcbiAgaWYgKGludCA8IDApIHtcbiAgICByZXR1cm4gMDtcbiAgfVxuICBpZiAoaW50ID4gMjU1KSB7XG4gICAgcmV0dXJuIDI1NTtcbiAgfVxuICByZXR1cm4gaW50O1xufVxuZnVuY3Rpb24gcGFyc2UzNjAoc3RyKSB7XG4gIGNvbnN0IGludCA9IE51bWJlci5wYXJzZUZsb2F0KHN0cik7XG4gIHJldHVybiAoaW50ICUgMzYwICsgMzYwKSAlIDM2MCAvIDM2MDtcbn1cbmZ1bmN0aW9uIHBhcnNlMShzdHIpIHtcbiAgY29uc3QgbnVtID0gTnVtYmVyLnBhcnNlRmxvYXQoc3RyKTtcbiAgaWYgKG51bSA8IDApIHtcbiAgICByZXR1cm4gMDtcbiAgfVxuICBpZiAobnVtID4gMSkge1xuICAgIHJldHVybiAyNTU7XG4gIH1cbiAgcmV0dXJuIE1hdGgucm91bmQobnVtICogMjU1KTtcbn1cbmZ1bmN0aW9uIHBhcnNlUGVyY2VudGFnZShzdHIpIHtcbiAgY29uc3QgaW50ID0gTnVtYmVyLnBhcnNlRmxvYXQoc3RyKTtcbiAgaWYgKGludCA8IDApIHtcbiAgICByZXR1cm4gMDtcbiAgfVxuICBpZiAoaW50ID4gMTAwKSB7XG4gICAgcmV0dXJuIDE7XG4gIH1cbiAgcmV0dXJuIGludCAvIDEwMDtcbn1cbmZ1bmN0aW9uIG5vcm1hbGl6ZUNvbG9yKGNvbG9yKSB7XG4gIGNvbnN0IG1hdGNoZXJzID0gZ2V0TWF0Y2hlcnMoKTtcbiAgbGV0IG1hdGNoO1xuICBpZiAobWF0Y2hlcnMuaGV4Nikge1xuICAgIGlmIChtYXRjaCA9IG1hdGNoZXJzLmhleDYuZXhlYyhjb2xvcikpIHtcbiAgICAgIHJldHVybiBOdW1iZXIucGFyc2VJbnQobWF0Y2hbMV0gKyBcImZmXCIsIDE2KSA+Pj4gMDtcbiAgICB9XG4gIH1cbiAgaWYgKGNvbG9yTmFtZXNbY29sb3JdICE9PSB1bmRlZmluZWQpIHtcbiAgICByZXR1cm4gY29sb3JOYW1lc1tjb2xvcl07XG4gIH1cbiAgaWYgKG1hdGNoZXJzLnJnYikge1xuICAgIGlmIChtYXRjaCA9IG1hdGNoZXJzLnJnYi5leGVjKGNvbG9yKSkge1xuICAgICAgcmV0dXJuIChwYXJzZTI1NShtYXRjaFsxXSkgPDwgMjQgfCBwYXJzZTI1NShtYXRjaFsyXSkgPDwgMTYgfCBwYXJzZTI1NShtYXRjaFszXSkgPDwgOCB8IDI1NSkgPj4+IDA7XG4gICAgfVxuICB9XG4gIGlmIChtYXRjaGVycy5yZ2JhKSB7XG4gICAgaWYgKG1hdGNoID0gbWF0Y2hlcnMucmdiYS5leGVjKGNvbG9yKSkge1xuICAgICAgcmV0dXJuIChwYXJzZTI1NShtYXRjaFsxXSkgPDwgMjQgfCBwYXJzZTI1NShtYXRjaFsyXSkgPDwgMTYgfCBwYXJzZTI1NShtYXRjaFszXSkgPDwgOCB8IHBhcnNlMShtYXRjaFs0XSkpID4+PiAwO1xuICAgIH1cbiAgfVxuICBpZiAobWF0Y2hlcnMuaGV4Mykge1xuICAgIGlmIChtYXRjaCA9IG1hdGNoZXJzLmhleDMuZXhlYyhjb2xvcikpIHtcbiAgICAgIHJldHVybiBOdW1iZXIucGFyc2VJbnQobWF0Y2hbMV0gKyBtYXRjaFsxXSArIG1hdGNoWzJdICsgbWF0Y2hbMl0gKyBtYXRjaFszXSArIG1hdGNoWzNdICsgXCJmZlwiLCAxNikgPj4+IDA7XG4gICAgfVxuICB9XG4gIGlmIChtYXRjaGVycy5oZXg4KSB7XG4gICAgaWYgKG1hdGNoID0gbWF0Y2hlcnMuaGV4OC5leGVjKGNvbG9yKSkge1xuICAgICAgcmV0dXJuIE51bWJlci5wYXJzZUludChtYXRjaFsxXSwgMTYpID4+PiAwO1xuICAgIH1cbiAgfVxuICBpZiAobWF0Y2hlcnMuaGV4NCkge1xuICAgIGlmIChtYXRjaCA9IG1hdGNoZXJzLmhleDQuZXhlYyhjb2xvcikpIHtcbiAgICAgIHJldHVybiBOdW1iZXIucGFyc2VJbnQobWF0Y2hbMV0gKyBtYXRjaFsxXSArIG1hdGNoWzJdICsgbWF0Y2hbMl0gKyBtYXRjaFszXSArIG1hdGNoWzNdICsgbWF0Y2hbNF0gKyBtYXRjaFs0XSwgMTYpID4+PiAwO1xuICAgIH1cbiAgfVxuICBpZiAobWF0Y2hlcnMuaHNsKSB7XG4gICAgaWYgKG1hdGNoID0gbWF0Y2hlcnMuaHNsLmV4ZWMoY29sb3IpKSB7XG4gICAgICByZXR1cm4gKGhzbFRvUmdiKHBhcnNlMzYwKG1hdGNoWzFdKSwgcGFyc2VQZXJjZW50YWdlKG1hdGNoWzJdKSwgcGFyc2VQZXJjZW50YWdlKG1hdGNoWzNdKSkgfCAyNTUpID4+PiAwO1xuICAgIH1cbiAgfVxuICBpZiAobWF0Y2hlcnMuaHNsYSkge1xuICAgIGlmIChtYXRjaCA9IG1hdGNoZXJzLmhzbGEuZXhlYyhjb2xvcikpIHtcbiAgICAgIHJldHVybiAoaHNsVG9SZ2IocGFyc2UzNjAobWF0Y2hbMV0pLCBwYXJzZVBlcmNlbnRhZ2UobWF0Y2hbMl0pLCBwYXJzZVBlcmNlbnRhZ2UobWF0Y2hbM10pKSB8IHBhcnNlMShtYXRjaFs0XSkpID4+PiAwO1xuICAgIH1cbiAgfVxuICB0aHJvdyBuZXcgRXJyb3IoYGludmFsaWQgY29sb3Igc3RyaW5nICR7Y29sb3J9IHByb3ZpZGVkYCk7XG59XG5mdW5jdGlvbiBwcm9jZXNzQ29sb3IoY29sb3IpIHtcbiAgY29uc3Qgbm9ybWFsaXplZENvbG9yID0gbm9ybWFsaXplQ29sb3IoY29sb3IpO1xuICByZXR1cm4gKG5vcm1hbGl6ZWRDb2xvciA8PCAyNCB8IG5vcm1hbGl6ZWRDb2xvciA+Pj4gOCkgPj4+IDA7XG59XG52YXIgTlVNQkVSID0gXCJbLStdP1xcXFxkKlxcXFwuP1xcXFxkK1wiO1xudmFyIFBFUkNFTlRBR0UgPSBOVU1CRVIgKyBcIiVcIjtcbnZhciBjb2xvck5hbWVzID0ge1xuICB0cmFuc3BhcmVudDogMCxcbiAgYWxpY2VibHVlOiA0MDQyODUwMzAzLFxuICBhbnRpcXVld2hpdGU6IDQyMDk3NjAyNTUsXG4gIGFxdWE6IDE2Nzc3MjE1LFxuICBhcXVhbWFyaW5lOiAyMTQ3NDcyNjM5LFxuICBhenVyZTogNDA0MzMwOTA1NSxcbiAgYmVpZ2U6IDQxMjY1MzA4MTUsXG4gIGJpc3F1ZTogNDI5MzE4MjcxOSxcbiAgYmxhY2s6IDI1NSxcbiAgYmxhbmNoZWRhbG1vbmQ6IDQyOTM2NDM3NzUsXG4gIGJsdWU6IDY1NTM1LFxuICBibHVldmlvbGV0OiAyMzE4MTMxOTY3LFxuICBicm93bjogMjc3MTAwNDE1OSxcbiAgYnVybHl3b29kOiAzNzM2NjM1MzkxLFxuICBidXJudHNpZW5uYTogMzkzNDE1MDE0MyxcbiAgY2FkZXRibHVlOiAxNjA0MjMxNDIzLFxuICBjaGFydHJldXNlOiAyMTQ3NDE4MzY3LFxuICBjaG9jb2xhdGU6IDM1MzAxMDQ1NzUsXG4gIGNvcmFsOiA0Mjg2NTMzODg3LFxuICBjb3JuZmxvd2VyYmx1ZTogMTY4NzU0NzM5MSxcbiAgY29ybnNpbGs6IDQyOTQ0OTk1ODMsXG4gIGNyaW1zb246IDM2OTIzMTM4NTUsXG4gIGN5YW46IDE2Nzc3MjE1LFxuICBkYXJrYmx1ZTogMzU4MzksXG4gIGRhcmtjeWFuOiA5MTQ1MzQzLFxuICBkYXJrZ29sZGVucm9kOiAzMDk1NzkyNjM5LFxuICBkYXJrZ3JheTogMjg0NjQ2ODYwNyxcbiAgZGFya2dyZWVuOiA2NTUzODU1LFxuICBkYXJrZ3JleTogMjg0NjQ2ODYwNyxcbiAgZGFya2toYWtpOiAzMTgyOTE0NTU5LFxuICBkYXJrbWFnZW50YTogMjMzMjA2ODg2MyxcbiAgZGFya29saXZlZ3JlZW46IDE0MzMwODc5OTksXG4gIGRhcmtvcmFuZ2U6IDQyODczNjUzNzUsXG4gIGRhcmtvcmNoaWQ6IDI1NzAyNDMzMjcsXG4gIGRhcmtyZWQ6IDIzMzIwMzMyNzksXG4gIGRhcmtzYWxtb246IDM5MTg5NTMyMTUsXG4gIGRhcmtzZWFncmVlbjogMjQxMTQ5OTUxOSxcbiAgZGFya3NsYXRlYmx1ZTogMTIxMTk5MzA4NyxcbiAgZGFya3NsYXRlZ3JheTogNzkzNzI2OTc1LFxuICBkYXJrc2xhdGVncmV5OiA3OTM3MjY5NzUsXG4gIGRhcmt0dXJxdW9pc2U6IDEzNTU0MTc1LFxuICBkYXJrdmlvbGV0OiAyNDgzMDgyMjM5LFxuICBkZWVwcGluazogNDI3OTUzODY4NyxcbiAgZGVlcHNreWJsdWU6IDEyNTgyOTExLFxuICBkaW1ncmF5OiAxNzY4NTE2MDk1LFxuICBkaW1ncmV5OiAxNzY4NTE2MDk1LFxuICBkb2RnZXJibHVlOiA1MTI4MTkxOTksXG4gIGZpcmVicmljazogMjk4ODU4MTYzMSxcbiAgZmxvcmFsd2hpdGU6IDQyOTQ2MzU3NzUsXG4gIGZvcmVzdGdyZWVuOiA1Nzk1NDM4MDcsXG4gIGZ1Y2hzaWE6IDQyNzgyNTU2MTUsXG4gIGdhaW5zYm9ybzogMzcwNTQ2MjAxNSxcbiAgZ2hvc3R3aGl0ZTogNDE3NzA2ODAzMSxcbiAgZ29sZDogNDI5MjI4MDU3NSxcbiAgZ29sZGVucm9kOiAzNjY4MjU0OTc1LFxuICBncmF5OiAyMTU1OTA1Mjc5LFxuICBncmVlbjogODM4ODg2MyxcbiAgZ3JlZW55ZWxsb3c6IDI5MTkxODIzMzUsXG4gIGdyZXk6IDIxNTU5MDUyNzksXG4gIGhvbmV5ZGV3OiA0MDQzMzA1MjE1LFxuICBob3RwaW5rOiA0Mjg1MTE3Njk1LFxuICBpbmRpYW5yZWQ6IDM0NDUzODIzOTksXG4gIGluZGlnbzogMTI1ODMyNDczNSxcbiAgaXZvcnk6IDQyOTQ5NjM0NTUsXG4gIGtoYWtpOiA0MDQxNjQxMjE1LFxuICBsYXZlbmRlcjogMzg3Mzg5NzIxNSxcbiAgbGF2ZW5kZXJibHVzaDogNDI5Mzk4MTY5NSxcbiAgbGF3bmdyZWVuOiAyMDk2ODkwMTExLFxuICBsZW1vbmNoaWZmb246IDQyOTQ2MjY4MTUsXG4gIGxpZ2h0Ymx1ZTogMjkxNjY3MzI3OSxcbiAgbGlnaHRjb3JhbDogNDAzNDk1MzQ3MSxcbiAgbGlnaHRjeWFuOiAzNzc0ODczNTk5LFxuICBsaWdodGdvbGRlbnJvZHllbGxvdzogNDIxMDc0MjAxNSxcbiAgbGlnaHRncmF5OiAzNTUzODc0OTQzLFxuICBsaWdodGdyZWVuOiAyNDMxNTUzNzkxLFxuICBsaWdodGdyZXk6IDM1NTM4NzQ5NDMsXG4gIGxpZ2h0cGluazogNDI5MDE2NzI5NSxcbiAgbGlnaHRzYWxtb246IDQyODg3MDczMjcsXG4gIGxpZ2h0c2VhZ3JlZW46IDU0ODU4MDA5NSxcbiAgbGlnaHRza3libHVlOiAyMjc4NDg4ODMxLFxuICBsaWdodHNsYXRlZ3JheTogMjAwNTQ0MTAyMyxcbiAgbGlnaHRzbGF0ZWdyZXk6IDIwMDU0NDEwMjMsXG4gIGxpZ2h0c3RlZWxibHVlOiAyOTY1NjkyMTU5LFxuICBsaWdodHllbGxvdzogNDI5NDk1OTM1OSxcbiAgbGltZTogMTY3MTE5MzUsXG4gIGxpbWVncmVlbjogODUyMzA4NzM1LFxuICBsaW5lbjogNDIxMDA5MTc3NSxcbiAgbWFnZW50YTogNDI3ODI1NTYxNSxcbiAgbWFyb29uOiAyMTQ3NDgzOTAzLFxuICBtZWRpdW1hcXVhbWFyaW5lOiAxNzI0NzU0Njg3LFxuICBtZWRpdW1ibHVlOiA1MjczNSxcbiAgbWVkaXVtb3JjaGlkOiAzMTI2MTg3MDA3LFxuICBtZWRpdW1wdXJwbGU6IDI0NzM2NDcxMDMsXG4gIG1lZGl1bXNlYWdyZWVuOiAxMDE4MzkzMDg3LFxuICBtZWRpdW1zbGF0ZWJsdWU6IDIwNzA0NzQ0OTUsXG4gIG1lZGl1bXNwcmluZ2dyZWVuOiAxNjQyMzY3OSxcbiAgbWVkaXVtdHVycXVvaXNlOiAxMjIxNzA5MDU1LFxuICBtZWRpdW12aW9sZXRyZWQ6IDMzNDAwNzY1NDMsXG4gIG1pZG5pZ2h0Ymx1ZTogNDIxMDk3NzI3LFxuICBtaW50Y3JlYW06IDQxMjcxOTM4NTUsXG4gIG1pc3R5cm9zZTogNDI5MzE5MDE0MyxcbiAgbW9jY2FzaW46IDQyOTMxNzg4NzksXG4gIG5hdmFqb3doaXRlOiA0MjkyNzgzNjE1LFxuICBuYXZ5OiAzMzAyMyxcbiAgb2xkbGFjZTogNDI2MDc1MTEwMyxcbiAgb2xpdmU6IDIxNTU4NzI1MTEsXG4gIG9saXZlZHJhYjogMTgwNDQ3NzQzOSxcbiAgb3JhbmdlOiA0Mjg5MDAzNzc1LFxuICBvcmFuZ2VyZWQ6IDQyODI3MTIzMTksXG4gIG9yY2hpZDogMzY2NDgyODE1OSxcbiAgcGFsZWdvbGRlbnJvZDogNDAwODIyNTUzNSxcbiAgcGFsZWdyZWVuOiAyNTY2NjI1NTM1LFxuICBwYWxldHVycXVvaXNlOiAyOTUxNjcxNTUxLFxuICBwYWxldmlvbGV0cmVkOiAzNjgxNTg4MjIzLFxuICBwYXBheWF3aGlwOiA0MjkzOTA3OTY3LFxuICBwZWFjaHB1ZmY6IDQyOTI1MjQ1NDMsXG4gIHBlcnU6IDM0NDgwNjE5NTEsXG4gIHBpbms6IDQyOTA4MjUyMTUsXG4gIHBsdW06IDM3MTgzMDczMjcsXG4gIHBvd2RlcmJsdWU6IDI5Njc1MjkyMTUsXG4gIHB1cnBsZTogMjE0NzUxNjY3MSxcbiAgcmViZWNjYXB1cnBsZTogMTcxNDY1Nzc5MSxcbiAgcmVkOiA0Mjc4MTkwMzM1LFxuICByb3N5YnJvd246IDMxNjM1MjUxMTksXG4gIHJveWFsYmx1ZTogMTA5NzQ1ODE3NSxcbiAgc2FkZGxlYnJvd246IDIzMzY1NjAxMjcsXG4gIHNhbG1vbjogNDIwMjcyMjA0NyxcbiAgc2FuZHlicm93bjogNDEwNDQxMzQzOSxcbiAgc2VhZ3JlZW46IDc4MDg4Mzk2NyxcbiAgc2Vhc2hlbGw6IDQyOTQzMDc1ODMsXG4gIHNpZW5uYTogMjY4OTc0MDI4NyxcbiAgc2lsdmVyOiAzMjMzODU3NzkxLFxuICBza3libHVlOiAyMjc4NDg0OTkxLFxuICBzbGF0ZWJsdWU6IDE3ODQzMzU4NzEsXG4gIHNsYXRlZ3JheTogMTg4NzQ3MzkxOSxcbiAgc2xhdGVncmV5OiAxODg3NDczOTE5LFxuICBzbm93OiA0Mjk0NjM4MzM1LFxuICBzcHJpbmdncmVlbjogMTY3NDQ0NDcsXG4gIHN0ZWVsYmx1ZTogMTE4Mjk3MTEzNSxcbiAgdGFuOiAzNTM1MDQ3OTM1LFxuICB0ZWFsOiA4NDIxNjMxLFxuICB0aGlzdGxlOiAzNjM2NDUxNTgzLFxuICB0b21hdG86IDQyODQ2OTY1NzUsXG4gIHR1cnF1b2lzZTogMTA4ODQ3NTM5MSxcbiAgdmlvbGV0OiA0MDAxNTU4MjcxLFxuICB3aGVhdDogNDEyNTAxMjk5MSxcbiAgd2hpdGU6IDQyOTQ5NjcyOTUsXG4gIHdoaXRlc21va2U6IDQxMjY1MzcyMTUsXG4gIHllbGxvdzogNDI5NDkwMjAxNSxcbiAgeWVsbG93Z3JlZW46IDI1OTcxMzkxOTlcbn07XG52YXIgb3BhY2l0eSA9IChjMikgPT4ge1xuICByZXR1cm4gKGMyID4+IDI0ICYgMjU1KSAvIDI1NTtcbn07XG52YXIgcmVkID0gKGMyKSA9PiB7XG4gIHJldHVybiBjMiA+PiAxNiAmIDI1NTtcbn07XG52YXIgZ3JlZW4gPSAoYzIpID0+IHtcbiAgcmV0dXJuIGMyID4+IDggJiAyNTU7XG59O1xudmFyIGJsdWUgPSAoYzIpID0+IHtcbiAgcmV0dXJuIGMyICYgMjU1O1xufTtcbnZhciByZ2JhQ29sb3IgPSAociwgZywgYjIsIGFscGhhKSA9PiB7XG4gIHJldHVybiBgcmdiYSgke3J9LCAke2d9LCAke2IyfSwgJHthbHBoYX0pYDtcbn07XG52YXIgaW50ZXJwb2xhdGVDb2xvcnNSR0IgPSAodmFsdWUsIGlucHV0UmFuZ2UsIGNvbG9ycykgPT4ge1xuICBjb25zdCBbciwgZywgYjIsIGEyXSA9IFtyZWQsIGdyZWVuLCBibHVlLCBvcGFjaXR5XS5tYXAoKGYpID0+IHtcbiAgICBjb25zdCB1bnJvdW5kZWQgPSBpbnRlcnBvbGF0ZSh2YWx1ZSwgaW5wdXRSYW5nZSwgY29sb3JzLm1hcCgoYzIpID0+IGYoYzIpKSwge1xuICAgICAgZXh0cmFwb2xhdGVMZWZ0OiBcImNsYW1wXCIsXG4gICAgICBleHRyYXBvbGF0ZVJpZ2h0OiBcImNsYW1wXCJcbiAgICB9KTtcbiAgICBpZiAoZiA9PT0gb3BhY2l0eSkge1xuICAgICAgcmV0dXJuIE51bWJlcih1bnJvdW5kZWQudG9GaXhlZCgzKSk7XG4gICAgfVxuICAgIHJldHVybiBNYXRoLnJvdW5kKHVucm91bmRlZCk7XG4gIH0pO1xuICByZXR1cm4gcmdiYUNvbG9yKHIsIGcsIGIyLCBhMik7XG59O1xudmFyIGludGVycG9sYXRlQ29sb3JzID0gKGlucHV0LCBpbnB1dFJhbmdlLCBvdXRwdXRSYW5nZSkgPT4ge1xuICBpZiAodHlwZW9mIGlucHV0ID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcImlucHV0IGNhbiBub3QgYmUgdW5kZWZpbmVkXCIpO1xuICB9XG4gIGlmICh0eXBlb2YgaW5wdXRSYW5nZSA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJpbnB1dFJhbmdlIGNhbiBub3QgYmUgdW5kZWZpbmVkXCIpO1xuICB9XG4gIGlmICh0eXBlb2Ygb3V0cHV0UmFuZ2UgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwib3V0cHV0UmFuZ2UgY2FuIG5vdCBiZSB1bmRlZmluZWRcIik7XG4gIH1cbiAgaWYgKGlucHV0UmFuZ2UubGVuZ3RoICE9PSBvdXRwdXRSYW5nZS5sZW5ndGgpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiaW5wdXRSYW5nZSAoXCIgKyBpbnB1dFJhbmdlLmxlbmd0aCArIFwiIHZhbHVlcyBwcm92aWRlZCkgYW5kIG91dHB1dFJhbmdlIChcIiArIG91dHB1dFJhbmdlLmxlbmd0aCArIFwiIHZhbHVlcyBwcm92aWRlZCkgbXVzdCBoYXZlIHRoZSBzYW1lIGxlbmd0aFwiKTtcbiAgfVxuICBjb25zdCBwcm9jZXNzZWRPdXRwdXRSYW5nZSA9IG91dHB1dFJhbmdlLm1hcCgoYzIpID0+IHByb2Nlc3NDb2xvcihjMikpO1xuICByZXR1cm4gaW50ZXJwb2xhdGVDb2xvcnNSR0IoaW5wdXQsIGlucHV0UmFuZ2UsIHByb2Nlc3NlZE91dHB1dFJhbmdlKTtcbn07XG4vLyBzcmMvdmFsaWRhdGUtZnJhbWUudHNcbnZhciB2YWxpZGF0ZUZyYW1lID0gKHtcbiAgYWxsb3dGbG9hdHMsXG4gIGR1cmF0aW9uSW5GcmFtZXMsXG4gIGZyYW1lXG59KSA9PiB7XG4gIGlmICh0eXBlb2YgZnJhbWUgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBBcmd1bWVudCBtaXNzaW5nIGZvciBwYXJhbWV0ZXIgXCJmcmFtZVwiYCk7XG4gIH1cbiAgaWYgKHR5cGVvZiBmcmFtZSAhPT0gXCJudW1iZXJcIikge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYEFyZ3VtZW50IHBhc3NlZCBmb3IgXCJmcmFtZVwiIGlzIG5vdCBhIG51bWJlcjogJHtmcmFtZX1gKTtcbiAgfVxuICBpZiAoIU51bWJlci5pc0Zpbml0ZShmcmFtZSkpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihgRnJhbWUgJHtmcmFtZX0gaXMgbm90IGZpbml0ZWApO1xuICB9XG4gIGlmIChmcmFtZSAlIDEgIT09IDAgJiYgIWFsbG93RmxvYXRzKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoYEFyZ3VtZW50IGZvciBmcmFtZSBtdXN0IGJlIGFuIGludGVnZXIsIGJ1dCBnb3QgJHtmcmFtZX1gKTtcbiAgfVxuICBpZiAoZnJhbWUgPCAwICYmIGZyYW1lIDwgLWR1cmF0aW9uSW5GcmFtZXMpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihgQ2Fubm90IHVzZSBmcmFtZSAke2ZyYW1lfTogRHVyYXRpb24gb2YgY29tcG9zaXRpb24gaXMgJHtkdXJhdGlvbkluRnJhbWVzfSwgdGhlcmVmb3JlIHRoZSBsb3dlc3QgZnJhbWUgdGhhdCBjYW4gYmUgcmVuZGVyZWQgaXMgJHstZHVyYXRpb25JbkZyYW1lc31gKTtcbiAgfVxuICBpZiAoZnJhbWUgPiBkdXJhdGlvbkluRnJhbWVzIC0gMSkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKGBDYW5ub3QgdXNlIGZyYW1lICR7ZnJhbWV9OiBEdXJhdGlvbiBvZiBjb21wb3NpdGlvbiBpcyAke2R1cmF0aW9uSW5GcmFtZXN9LCB0aGVyZWZvcmUgdGhlIGhpZ2hlc3QgZnJhbWUgdGhhdCBjYW4gYmUgcmVuZGVyZWQgaXMgJHtkdXJhdGlvbkluRnJhbWVzIC0gMX1gKTtcbiAgfVxufTtcblxuLy8gc3JjL3ZpZGVvL29mZnRocmVhZC12aWRlby1zb3VyY2UudHNcbnZhciBnZXRPZmZ0aHJlYWRWaWRlb1NvdXJjZSA9ICh7XG4gIHNyYyxcbiAgdHJhbnNwYXJlbnQsXG4gIGN1cnJlbnRUaW1lLFxuICB0b25lTWFwcGVkXG59KSA9PiB7XG4gIHJldHVybiBgaHR0cDovL2xvY2FsaG9zdDoke3dpbmRvdy5yZW1vdGlvbl9wcm94eVBvcnR9L3Byb3h5P3NyYz0ke2VuY29kZVVSSUNvbXBvbmVudChnZXRBYnNvbHV0ZVNyYyhzcmMpKX0mdGltZT0ke2VuY29kZVVSSUNvbXBvbmVudChjdXJyZW50VGltZSl9JnRyYW5zcGFyZW50PSR7U3RyaW5nKHRyYW5zcGFyZW50KX0mdG9uZU1hcHBlZD0ke1N0cmluZyh0b25lTWFwcGVkKX1gO1xufTtcbi8vIHNyYy9zZXJpZXMvaW5kZXgudHN4XG5pbXBvcnQgeyBDaGlsZHJlbiwgZm9yd2FyZFJlZiBhcyBmb3J3YXJkUmVmOCwgdXNlTWVtbyBhcyB1c2VNZW1vMjggfSBmcm9tIFwicmVhY3RcIjtcblxuLy8gc3JjL3Nlcmllcy9mbGF0dGVuLWNoaWxkcmVuLnRzeFxuaW1wb3J0IFJlYWN0MjQgZnJvbSBcInJlYWN0XCI7XG52YXIgZmxhdHRlbkNoaWxkcmVuID0gKGNoaWxkcmVuKSA9PiB7XG4gIGNvbnN0IGNoaWxkcmVuQXJyYXkgPSBSZWFjdDI0LkNoaWxkcmVuLnRvQXJyYXkoY2hpbGRyZW4pO1xuICByZXR1cm4gY2hpbGRyZW5BcnJheS5yZWR1Y2UoKGZsYXRDaGlsZHJlbiwgY2hpbGQpID0+IHtcbiAgICBpZiAoY2hpbGQudHlwZSA9PT0gUmVhY3QyNC5GcmFnbWVudCkge1xuICAgICAgcmV0dXJuIGZsYXRDaGlsZHJlbi5jb25jYXQoZmxhdHRlbkNoaWxkcmVuKGNoaWxkLnByb3BzLmNoaWxkcmVuKSk7XG4gICAgfVxuICAgIGZsYXRDaGlsZHJlbi5wdXNoKGNoaWxkKTtcbiAgICByZXR1cm4gZmxhdENoaWxkcmVuO1xuICB9LCBbXSk7XG59O1xuXG4vLyBzcmMvc2VyaWVzL2lzLWluc2lkZS1zZXJpZXMudHN4XG5pbXBvcnQgUmVhY3QyNSwgeyBjcmVhdGVDb250ZXh0IGFzIGNyZWF0ZUNvbnRleHQxOSB9IGZyb20gXCJyZWFjdFwiO1xuaW1wb3J0IHsganN4IGFzIGpzeDI3IH0gZnJvbSBcInJlYWN0L2pzeC1ydW50aW1lXCI7XG52YXIgSXNJbnNpZGVTZXJpZXNDb250ZXh0ID0gY3JlYXRlQ29udGV4dDE5KGZhbHNlKTtcbnZhciBJc0luc2lkZVNlcmllc0NvbnRhaW5lciA9ICh7IGNoaWxkcmVuIH0pID0+IHtcbiAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqLyBqc3gyNyhJc0luc2lkZVNlcmllc0NvbnRleHQuUHJvdmlkZXIsIHtcbiAgICB2YWx1ZTogdHJ1ZSxcbiAgICBjaGlsZHJlblxuICB9KTtcbn07XG52YXIgSXNOb3RJbnNpZGVTZXJpZXNQcm92aWRlciA9ICh7IGNoaWxkcmVuIH0pID0+IHtcbiAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqLyBqc3gyNyhJc0luc2lkZVNlcmllc0NvbnRleHQuUHJvdmlkZXIsIHtcbiAgICB2YWx1ZTogZmFsc2UsXG4gICAgY2hpbGRyZW5cbiAgfSk7XG59O1xudmFyIHVzZVJlcXVpcmVUb0JlSW5zaWRlU2VyaWVzID0gKCkgPT4ge1xuICBjb25zdCBpc0luc2lkZVNlcmllcyA9IFJlYWN0MjUudXNlQ29udGV4dChJc0luc2lkZVNlcmllc0NvbnRleHQpO1xuICBpZiAoIWlzSW5zaWRlU2VyaWVzKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiVGhpcyBjb21wb25lbnQgbXVzdCBiZSBpbnNpZGUgYSA8U2VyaWVzIC8+IGNvbXBvbmVudC5cIik7XG4gIH1cbn07XG5cbi8vIHNyYy9zZXJpZXMvaW5kZXgudHN4XG5pbXBvcnQgeyBqc3ggYXMganN4MjggfSBmcm9tIFwicmVhY3QvanN4LXJ1bnRpbWVcIjtcbnZhciBTZXJpZXNTZXF1ZW5jZVJlZkZvcndhcmRpbmdGdW5jdGlvbiA9ICh7IGNoaWxkcmVuIH0sIF9yZWYpID0+IHtcbiAgdXNlUmVxdWlyZVRvQmVJbnNpZGVTZXJpZXMoKTtcbiAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqLyBqc3gyOChJc05vdEluc2lkZVNlcmllc1Byb3ZpZGVyLCB7XG4gICAgY2hpbGRyZW5cbiAgfSk7XG59O1xudmFyIFNlcmllc1NlcXVlbmNlID0gZm9yd2FyZFJlZjgoU2VyaWVzU2VxdWVuY2VSZWZGb3J3YXJkaW5nRnVuY3Rpb24pO1xudmFyIFNlcmllcyA9IChwcm9wczIpID0+IHtcbiAgY29uc3QgY2hpbGRyZW5WYWx1ZSA9IHVzZU1lbW8yOCgoKSA9PiB7XG4gICAgbGV0IHN0YXJ0RnJhbWUgPSAwO1xuICAgIGNvbnN0IGZsYXR0ZW5lZENoaWxkcmVuID0gZmxhdHRlbkNoaWxkcmVuKHByb3BzMi5jaGlsZHJlbik7XG4gICAgcmV0dXJuIENoaWxkcmVuLm1hcChmbGF0dGVuZWRDaGlsZHJlbiwgKGNoaWxkLCBpKSA9PiB7XG4gICAgICBjb25zdCBjYXN0ZWRDaGlsZCA9IGNoaWxkO1xuICAgICAgaWYgKHR5cGVvZiBjYXN0ZWRDaGlsZCA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICBpZiAoY2FzdGVkQ2hpbGQudHJpbSgpID09PSBcIlwiKSB7XG4gICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgVGhlIDxTZXJpZXMgLz4gY29tcG9uZW50IG9ubHkgYWNjZXB0cyBhIGxpc3Qgb2YgPFNlcmllcy5TZXF1ZW5jZSAvPiBjb21wb25lbnRzIGFzIGl0cyBjaGlsZHJlbiwgYnV0IHlvdSBwYXNzZWQgYSBzdHJpbmcgXCIke2Nhc3RlZENoaWxkfVwiYCk7XG4gICAgICB9XG4gICAgICBpZiAoY2FzdGVkQ2hpbGQudHlwZSAhPT0gU2VyaWVzU2VxdWVuY2UpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgVGhlIDxTZXJpZXMgLz4gY29tcG9uZW50IG9ubHkgYWNjZXB0cyBhIGxpc3Qgb2YgPFNlcmllcy5TZXF1ZW5jZSAvPiBjb21wb25lbnRzIGFzIGl0cyBjaGlsZHJlbiwgYnV0IGdvdCAke2Nhc3RlZENoaWxkfSBpbnN0ZWFkYCk7XG4gICAgICB9XG4gICAgICBjb25zdCBkZWJ1Z0luZm8gPSBgaW5kZXggPSAke2l9LCBkdXJhdGlvbiA9ICR7Y2FzdGVkQ2hpbGQucHJvcHMuZHVyYXRpb25JbkZyYW1lc31gO1xuICAgICAgaWYgKCFjYXN0ZWRDaGlsZD8ucHJvcHMuY2hpbGRyZW4pIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgQSA8U2VyaWVzLlNlcXVlbmNlIC8+IGNvbXBvbmVudCAoJHtkZWJ1Z0luZm99KSB3YXMgZGV0ZWN0ZWQgdG8gbm90IGhhdmUgYW55IGNoaWxkcmVuLiBEZWxldGUgaXQgdG8gZml4IHRoaXMgZXJyb3IuYCk7XG4gICAgICB9XG4gICAgICBjb25zdCBkdXJhdGlvbkluRnJhbWVzUHJvcCA9IGNhc3RlZENoaWxkLnByb3BzLmR1cmF0aW9uSW5GcmFtZXM7XG4gICAgICBjb25zdCB7XG4gICAgICAgIGR1cmF0aW9uSW5GcmFtZXMsXG4gICAgICAgIGNoaWxkcmVuOiBfY2hpbGRyZW4sXG4gICAgICAgIGZyb20sXG4gICAgICAgIG5hbWUsXG4gICAgICAgIC4uLnBhc3NlZFByb3BzXG4gICAgICB9ID0gY2FzdGVkQ2hpbGQucHJvcHM7XG4gICAgICBpZiAoaSAhPT0gZmxhdHRlbmVkQ2hpbGRyZW4ubGVuZ3RoIC0gMSB8fCBkdXJhdGlvbkluRnJhbWVzUHJvcCAhPT0gSW5maW5pdHkpIHtcbiAgICAgICAgdmFsaWRhdGVEdXJhdGlvbkluRnJhbWVzKGR1cmF0aW9uSW5GcmFtZXNQcm9wLCB7XG4gICAgICAgICAgY29tcG9uZW50OiBgb2YgYSA8U2VyaWVzLlNlcXVlbmNlIC8+IGNvbXBvbmVudGAsXG4gICAgICAgICAgYWxsb3dGbG9hdHM6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICBjb25zdCBvZmZzZXQgPSBjYXN0ZWRDaGlsZC5wcm9wcy5vZmZzZXQgPz8gMDtcbiAgICAgIGlmIChOdW1iZXIuaXNOYU4ob2Zmc2V0KSkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBUaGUgXCJvZmZzZXRcIiBwcm9wZXJ0eSBvZiBhIDxTZXJpZXMuU2VxdWVuY2UgLz4gbXVzdCBub3QgYmUgTmFOLCBidXQgZ290IE5hTiAoJHtkZWJ1Z0luZm99KS5gKTtcbiAgICAgIH1cbiAgICAgIGlmICghTnVtYmVyLmlzRmluaXRlKG9mZnNldCkpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgVGhlIFwib2Zmc2V0XCIgcHJvcGVydHkgb2YgYSA8U2VyaWVzLlNlcXVlbmNlIC8+IG11c3QgYmUgZmluaXRlLCBidXQgZ290ICR7b2Zmc2V0fSAoJHtkZWJ1Z0luZm99KS5gKTtcbiAgICAgIH1cbiAgICAgIGlmIChvZmZzZXQgJSAxICE9PSAwKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYFRoZSBcIm9mZnNldFwiIHByb3BlcnR5IG9mIGEgPFNlcmllcy5TZXF1ZW5jZSAvPiBtdXN0IGJlIGZpbml0ZSwgYnV0IGdvdCAke29mZnNldH0gKCR7ZGVidWdJbmZvfSkuYCk7XG4gICAgICB9XG4gICAgICBjb25zdCBjdXJyZW50U3RhcnRGcmFtZSA9IHN0YXJ0RnJhbWUgKyBvZmZzZXQ7XG4gICAgICBzdGFydEZyYW1lICs9IGR1cmF0aW9uSW5GcmFtZXNQcm9wICsgb2Zmc2V0O1xuICAgICAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqLyBqc3gyOChTZXF1ZW5jZSwge1xuICAgICAgICBuYW1lOiBuYW1lIHx8IFwiPFNlcmllcy5TZXF1ZW5jZT5cIixcbiAgICAgICAgZnJvbTogY3VycmVudFN0YXJ0RnJhbWUsXG4gICAgICAgIGR1cmF0aW9uSW5GcmFtZXM6IGR1cmF0aW9uSW5GcmFtZXNQcm9wLFxuICAgICAgICAuLi5wYXNzZWRQcm9wcyxcbiAgICAgICAgcmVmOiBjYXN0ZWRDaGlsZC5yZWYsXG4gICAgICAgIGNoaWxkcmVuOiBjaGlsZFxuICAgICAgfSk7XG4gICAgfSk7XG4gIH0sIFtwcm9wczIuY2hpbGRyZW5dKTtcbiAgaWYgKEVOQUJMRV9WNV9CUkVBS0lOR19DSEFOR0VTKSB7XG4gICAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqLyBqc3gyOChJc0luc2lkZVNlcmllc0NvbnRhaW5lciwge1xuICAgICAgY2hpbGRyZW46IC8qIEBfX1BVUkVfXyAqLyBqc3gyOChTZXF1ZW5jZSwge1xuICAgICAgICAuLi5wcm9wczIsXG4gICAgICAgIGNoaWxkcmVuOiBjaGlsZHJlblZhbHVlXG4gICAgICB9KVxuICAgIH0pO1xuICB9XG4gIHJldHVybiAvKiBAX19QVVJFX18gKi8ganN4MjgoSXNJbnNpZGVTZXJpZXNDb250YWluZXIsIHtcbiAgICBjaGlsZHJlbjogY2hpbGRyZW5WYWx1ZVxuICB9KTtcbn07XG5TZXJpZXMuU2VxdWVuY2UgPSBTZXJpZXNTZXF1ZW5jZTtcbmFkZFNlcXVlbmNlU3RhY2tUcmFjZXMoU2VyaWVzU2VxdWVuY2UpO1xuLy8gc3JjL3ZhbGlkYXRpb24vdmFsaWRhdGlvbi1zcHJpbmctZHVyYXRpb24udHNcbnZhciB2YWxpZGF0ZVNwcmluZ0R1cmF0aW9uID0gKGR1cikgPT4ge1xuICBpZiAodHlwZW9mIGR1ciA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgIHJldHVybjtcbiAgfVxuICBpZiAodHlwZW9mIGR1ciAhPT0gXCJudW1iZXJcIikge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYEEgXCJkdXJhdGlvblwiIG9mIGEgc3ByaW5nIG11c3QgYmUgYSBcIm51bWJlclwiIGJ1dCBpcyBcIiR7dHlwZW9mIGR1cn1cImApO1xuICB9XG4gIGlmIChOdW1iZXIuaXNOYU4oZHVyKSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0EgXCJkdXJhdGlvblwiIG9mIGEgc3ByaW5nIGlzIE5hTiwgd2hpY2ggaXQgbXVzdCBub3QgYmUnKTtcbiAgfVxuICBpZiAoIU51bWJlci5pc0Zpbml0ZShkdXIpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQSBcImR1cmF0aW9uXCIgb2YgYSBzcHJpbmcgbXVzdCBiZSBmaW5pdGUsIGJ1dCBpcyAnICsgZHVyKTtcbiAgfVxuICBpZiAoZHVyIDw9IDApIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdBIFwiZHVyYXRpb25cIiBvZiBhIHNwcmluZyBtdXN0IGJlIHBvc2l0aXZlLCBidXQgaXMgJyArIGR1cik7XG4gIH1cbn07XG5cbi8vIHNyYy9zcHJpbmcvc3ByaW5nLXV0aWxzLnRzXG5mdW5jdGlvbiBhZHZhbmNlKHtcbiAgYW5pbWF0aW9uLFxuICBub3csXG4gIGNvbmZpZ1xufSkge1xuICBjb25zdCB7IHRvVmFsdWUsIGxhc3RUaW1lc3RhbXAsIGN1cnJlbnQsIHZlbG9jaXR5IH0gPSBhbmltYXRpb247XG4gIGNvbnN0IGRlbHRhVGltZSA9IE1hdGgubWluKG5vdyAtIGxhc3RUaW1lc3RhbXAsIDY0KTtcbiAgaWYgKGNvbmZpZy5kYW1waW5nIDw9IDApIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJTcHJpbmcgZGFtcGluZyBtdXN0IGJlIGdyZWF0ZXIgdGhhbiAwLCBvdGhlcndpc2UgdGhlIHNwcmluZygpIGFuaW1hdGlvbiB3aWxsIG5ldmVyIGVuZCwgY2F1c2luZyBhbiBpbmZpbml0ZSBsb29wLlwiKTtcbiAgfVxuICBjb25zdCBjMiA9IGNvbmZpZy5kYW1waW5nO1xuICBjb25zdCBtID0gY29uZmlnLm1hc3M7XG4gIGNvbnN0IGsgPSBjb25maWcuc3RpZmZuZXNzO1xuICBjb25zdCBjYWNoZUtleSA9IFtcbiAgICB0b1ZhbHVlLFxuICAgIGxhc3RUaW1lc3RhbXAsXG4gICAgY3VycmVudCxcbiAgICB2ZWxvY2l0eSxcbiAgICBjMixcbiAgICBtLFxuICAgIGssXG4gICAgbm93XG4gIF0uam9pbihcIi1cIik7XG4gIGlmIChhZHZhbmNlQ2FjaGVbY2FjaGVLZXldKSB7XG4gICAgcmV0dXJuIGFkdmFuY2VDYWNoZVtjYWNoZUtleV07XG4gIH1cbiAgY29uc3QgdjAgPSAtdmVsb2NpdHk7XG4gIGNvbnN0IHgwID0gdG9WYWx1ZSAtIGN1cnJlbnQ7XG4gIGNvbnN0IHpldGEgPSBjMiAvICgyICogTWF0aC5zcXJ0KGsgKiBtKSk7XG4gIGNvbnN0IG9tZWdhMCA9IE1hdGguc3FydChrIC8gbSk7XG4gIGNvbnN0IG9tZWdhMSA9IG9tZWdhMCAqIE1hdGguc3FydCgxIC0gemV0YSAqKiAyKTtcbiAgY29uc3QgdCA9IGRlbHRhVGltZSAvIDEwMDA7XG4gIGNvbnN0IHNpbjEgPSBNYXRoLnNpbihvbWVnYTEgKiB0KTtcbiAgY29uc3QgY29zMSA9IE1hdGguY29zKG9tZWdhMSAqIHQpO1xuICBjb25zdCB1bmRlckRhbXBlZEVudmVsb3BlID0gTWF0aC5leHAoLXpldGEgKiBvbWVnYTAgKiB0KTtcbiAgY29uc3QgdW5kZXJEYW1wZWRGcmFnMSA9IHVuZGVyRGFtcGVkRW52ZWxvcGUgKiAoc2luMSAqICgodjAgKyB6ZXRhICogb21lZ2EwICogeDApIC8gb21lZ2ExKSArIHgwICogY29zMSk7XG4gIGNvbnN0IHVuZGVyRGFtcGVkUG9zaXRpb24gPSB0b1ZhbHVlIC0gdW5kZXJEYW1wZWRGcmFnMTtcbiAgY29uc3QgdW5kZXJEYW1wZWRWZWxvY2l0eSA9IHpldGEgKiBvbWVnYTAgKiB1bmRlckRhbXBlZEZyYWcxIC0gdW5kZXJEYW1wZWRFbnZlbG9wZSAqIChjb3MxICogKHYwICsgemV0YSAqIG9tZWdhMCAqIHgwKSAtIG9tZWdhMSAqIHgwICogc2luMSk7XG4gIGNvbnN0IGNyaXRpY2FsbHlEYW1wZWRFbnZlbG9wZSA9IE1hdGguZXhwKC1vbWVnYTAgKiB0KTtcbiAgY29uc3QgY3JpdGljYWxseURhbXBlZFBvc2l0aW9uID0gdG9WYWx1ZSAtIGNyaXRpY2FsbHlEYW1wZWRFbnZlbG9wZSAqICh4MCArICh2MCArIG9tZWdhMCAqIHgwKSAqIHQpO1xuICBjb25zdCBjcml0aWNhbGx5RGFtcGVkVmVsb2NpdHkgPSBjcml0aWNhbGx5RGFtcGVkRW52ZWxvcGUgKiAodjAgKiAodCAqIG9tZWdhMCAtIDEpICsgdCAqIHgwICogb21lZ2EwICogb21lZ2EwKTtcbiAgY29uc3QgYW5pbWF0aW9uTm9kZSA9IHtcbiAgICB0b1ZhbHVlLFxuICAgIHByZXZQb3NpdGlvbjogY3VycmVudCxcbiAgICBsYXN0VGltZXN0YW1wOiBub3csXG4gICAgY3VycmVudDogemV0YSA8IDEgPyB1bmRlckRhbXBlZFBvc2l0aW9uIDogY3JpdGljYWxseURhbXBlZFBvc2l0aW9uLFxuICAgIHZlbG9jaXR5OiB6ZXRhIDwgMSA/IHVuZGVyRGFtcGVkVmVsb2NpdHkgOiBjcml0aWNhbGx5RGFtcGVkVmVsb2NpdHlcbiAgfTtcbiAgYWR2YW5jZUNhY2hlW2NhY2hlS2V5XSA9IGFuaW1hdGlvbk5vZGU7XG4gIHJldHVybiBhbmltYXRpb25Ob2RlO1xufVxuZnVuY3Rpb24gc3ByaW5nQ2FsY3VsYXRpb24oe1xuICBmcmFtZSxcbiAgZnBzLFxuICBjb25maWcgPSB7fVxufSkge1xuICBjb25zdCBmcm9tID0gMDtcbiAgY29uc3QgdG8gPSAxO1xuICBjb25zdCBjYWNoZUtleSA9IFtcbiAgICBmcmFtZSxcbiAgICBmcHMsXG4gICAgY29uZmlnLmRhbXBpbmcsXG4gICAgY29uZmlnLm1hc3MsXG4gICAgY29uZmlnLm92ZXJzaG9vdENsYW1waW5nLFxuICAgIGNvbmZpZy5zdGlmZm5lc3NcbiAgXS5qb2luKFwiLVwiKTtcbiAgaWYgKGNhbGN1bGF0aW9uQ2FjaGVbY2FjaGVLZXldKSB7XG4gICAgcmV0dXJuIGNhbGN1bGF0aW9uQ2FjaGVbY2FjaGVLZXldO1xuICB9XG4gIGxldCBhbmltYXRpb24gPSB7XG4gICAgbGFzdFRpbWVzdGFtcDogMCxcbiAgICBjdXJyZW50OiBmcm9tLFxuICAgIHRvVmFsdWU6IHRvLFxuICAgIHZlbG9jaXR5OiAwLFxuICAgIHByZXZQb3NpdGlvbjogMFxuICB9O1xuICBjb25zdCBmcmFtZUNsYW1wZWQgPSBNYXRoLm1heCgwLCBmcmFtZSk7XG4gIGNvbnN0IHVuZXZlblJlc3QgPSBmcmFtZUNsYW1wZWQgJSAxO1xuICBmb3IgKGxldCBmID0gMDtmIDw9IE1hdGguZmxvb3IoZnJhbWVDbGFtcGVkKTsgZisrKSB7XG4gICAgaWYgKGYgPT09IE1hdGguZmxvb3IoZnJhbWVDbGFtcGVkKSkge1xuICAgICAgZiArPSB1bmV2ZW5SZXN0O1xuICAgIH1cbiAgICBjb25zdCB0aW1lID0gZiAvIGZwcyAqIDEwMDA7XG4gICAgYW5pbWF0aW9uID0gYWR2YW5jZSh7XG4gICAgICBhbmltYXRpb24sXG4gICAgICBub3c6IHRpbWUsXG4gICAgICBjb25maWc6IHtcbiAgICAgICAgLi4uZGVmYXVsdFNwcmluZ0NvbmZpZyxcbiAgICAgICAgLi4uY29uZmlnXG4gICAgICB9XG4gICAgfSk7XG4gIH1cbiAgY2FsY3VsYXRpb25DYWNoZVtjYWNoZUtleV0gPSBhbmltYXRpb247XG4gIHJldHVybiBhbmltYXRpb247XG59XG52YXIgZGVmYXVsdFNwcmluZ0NvbmZpZyA9IHtcbiAgZGFtcGluZzogMTAsXG4gIG1hc3M6IDEsXG4gIHN0aWZmbmVzczogMTAwLFxuICBvdmVyc2hvb3RDbGFtcGluZzogZmFsc2Vcbn07XG52YXIgYWR2YW5jZUNhY2hlID0ge307XG52YXIgY2FsY3VsYXRpb25DYWNoZSA9IHt9O1xuXG4vLyBzcmMvc3ByaW5nL21lYXN1cmUtc3ByaW5nLnRzXG5mdW5jdGlvbiBtZWFzdXJlU3ByaW5nKHtcbiAgZnBzLFxuICBjb25maWcgPSB7fSxcbiAgdGhyZXNob2xkID0gMC4wMDVcbn0pIHtcbiAgaWYgKHR5cGVvZiB0aHJlc2hvbGQgIT09IFwibnVtYmVyXCIpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGB0aHJlc2hvbGQgbXVzdCBiZSBhIG51bWJlciwgZ290ICR7dGhyZXNob2xkfSBvZiB0eXBlICR7dHlwZW9mIHRocmVzaG9sZH1gKTtcbiAgfVxuICBpZiAodGhyZXNob2xkID09PSAwKSB7XG4gICAgcmV0dXJuIEluZmluaXR5O1xuICB9XG4gIGlmICh0aHJlc2hvbGQgPT09IDEpIHtcbiAgICByZXR1cm4gMDtcbiAgfVxuICBpZiAoaXNOYU4odGhyZXNob2xkKSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJUaHJlc2hvbGQgaXMgTmFOXCIpO1xuICB9XG4gIGlmICghTnVtYmVyLmlzRmluaXRlKHRocmVzaG9sZCkpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiVGhyZXNob2xkIGlzIG5vdCBmaW5pdGVcIik7XG4gIH1cbiAgaWYgKHRocmVzaG9sZCA8IDApIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiVGhyZXNob2xkIGlzIGJlbG93IDBcIik7XG4gIH1cbiAgY29uc3QgY2FjaGVLZXkgPSBbXG4gICAgZnBzLFxuICAgIGNvbmZpZy5kYW1waW5nLFxuICAgIGNvbmZpZy5tYXNzLFxuICAgIGNvbmZpZy5vdmVyc2hvb3RDbGFtcGluZyxcbiAgICBjb25maWcuc3RpZmZuZXNzLFxuICAgIHRocmVzaG9sZFxuICBdLmpvaW4oXCItXCIpO1xuICBpZiAoY2FjaGUuaGFzKGNhY2hlS2V5KSkge1xuICAgIHJldHVybiBjYWNoZS5nZXQoY2FjaGVLZXkpO1xuICB9XG4gIHZhbGlkYXRlRnBzKGZwcywgXCJ0byB0aGUgbWVhc3VyZVNwcmluZygpIGZ1bmN0aW9uXCIsIGZhbHNlKTtcbiAgbGV0IGZyYW1lID0gMDtcbiAgbGV0IGZpbmlzaGVkRnJhbWUgPSAwO1xuICBjb25zdCBjYWxjID0gKCkgPT4ge1xuICAgIHJldHVybiBzcHJpbmdDYWxjdWxhdGlvbih7XG4gICAgICBmcHMsXG4gICAgICBmcmFtZSxcbiAgICAgIGNvbmZpZ1xuICAgIH0pO1xuICB9O1xuICBsZXQgYW5pbWF0aW9uID0gY2FsYygpO1xuICBjb25zdCBjYWxjRGlmZmVyZW5jZSA9ICgpID0+IHtcbiAgICByZXR1cm4gTWF0aC5hYnMoYW5pbWF0aW9uLmN1cnJlbnQgLSBhbmltYXRpb24udG9WYWx1ZSk7XG4gIH07XG4gIGxldCBkaWZmZXJlbmNlID0gY2FsY0RpZmZlcmVuY2UoKTtcbiAgd2hpbGUgKGRpZmZlcmVuY2UgPj0gdGhyZXNob2xkKSB7XG4gICAgZnJhbWUrKztcbiAgICBhbmltYXRpb24gPSBjYWxjKCk7XG4gICAgZGlmZmVyZW5jZSA9IGNhbGNEaWZmZXJlbmNlKCk7XG4gIH1cbiAgZmluaXNoZWRGcmFtZSA9IGZyYW1lO1xuICBmb3IgKGxldCBpID0gMDtpIDwgMjA7IGkrKykge1xuICAgIGZyYW1lKys7XG4gICAgYW5pbWF0aW9uID0gY2FsYygpO1xuICAgIGRpZmZlcmVuY2UgPSBjYWxjRGlmZmVyZW5jZSgpO1xuICAgIGlmIChkaWZmZXJlbmNlID49IHRocmVzaG9sZCkge1xuICAgICAgaSA9IDA7XG4gICAgICBmaW5pc2hlZEZyYW1lID0gZnJhbWUgKyAxO1xuICAgIH1cbiAgfVxuICBjYWNoZS5zZXQoY2FjaGVLZXksIGZpbmlzaGVkRnJhbWUpO1xuICByZXR1cm4gZmluaXNoZWRGcmFtZTtcbn1cbnZhciBjYWNoZSA9IG5ldyBNYXA7XG5cbi8vIHNyYy9zcHJpbmcvaW5kZXgudHNcbmZ1bmN0aW9uIHNwcmluZyh7XG4gIGZyYW1lOiBwYXNzZWRGcmFtZSxcbiAgZnBzLFxuICBjb25maWcgPSB7fSxcbiAgZnJvbSA9IDAsXG4gIHRvID0gMSxcbiAgZHVyYXRpb25JbkZyYW1lczogcGFzc2VkRHVyYXRpb25JbkZyYW1lcyxcbiAgZHVyYXRpb25SZXN0VGhyZXNob2xkLFxuICBkZWxheSA9IDAsXG4gIHJldmVyc2UgPSBmYWxzZVxufSkge1xuICB2YWxpZGF0ZVNwcmluZ0R1cmF0aW9uKHBhc3NlZER1cmF0aW9uSW5GcmFtZXMpO1xuICB2YWxpZGF0ZUZyYW1lKHtcbiAgICBmcmFtZTogcGFzc2VkRnJhbWUsXG4gICAgZHVyYXRpb25JbkZyYW1lczogSW5maW5pdHksXG4gICAgYWxsb3dGbG9hdHM6IHRydWVcbiAgfSk7XG4gIHZhbGlkYXRlRnBzKGZwcywgXCJ0byBzcHJpbmcoKVwiLCBmYWxzZSk7XG4gIGNvbnN0IG5lZWRzVG9DYWxjdWxhdGVOYXR1cmFsRHVyYXRpb24gPSByZXZlcnNlIHx8IHR5cGVvZiBwYXNzZWREdXJhdGlvbkluRnJhbWVzICE9PSBcInVuZGVmaW5lZFwiO1xuICBjb25zdCBuYXR1cmFsRHVyYXRpb24gPSBuZWVkc1RvQ2FsY3VsYXRlTmF0dXJhbER1cmF0aW9uID8gbWVhc3VyZVNwcmluZyh7XG4gICAgZnBzLFxuICAgIGNvbmZpZyxcbiAgICB0aHJlc2hvbGQ6IGR1cmF0aW9uUmVzdFRocmVzaG9sZFxuICB9KSA6IHVuZGVmaW5lZDtcbiAgY29uc3QgbmF0dXJhbER1cmF0aW9uR2V0dGVyID0gbmVlZHNUb0NhbGN1bGF0ZU5hdHVyYWxEdXJhdGlvbiA/IHtcbiAgICBnZXQ6ICgpID0+IG5hdHVyYWxEdXJhdGlvblxuICB9IDoge1xuICAgIGdldDogKCkgPT4ge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiZGlkIG5vdCBjYWxjdWxhdGUgbmF0dXJhbCBkdXJhdGlvbiwgdGhpcyBpcyBhbiBlcnJvciB3aXRoIFJlbW90aW9uLiBQbGVhc2UgcmVwb3J0XCIpO1xuICAgIH1cbiAgfTtcbiAgY29uc3QgcmV2ZXJzZVByb2Nlc3NlZCA9IHJldmVyc2UgPyAocGFzc2VkRHVyYXRpb25JbkZyYW1lcyA/PyBuYXR1cmFsRHVyYXRpb25HZXR0ZXIuZ2V0KCkpIC0gcGFzc2VkRnJhbWUgOiBwYXNzZWRGcmFtZTtcbiAgY29uc3QgZGVsYXlQcm9jZXNzZWQgPSByZXZlcnNlUHJvY2Vzc2VkICsgKHJldmVyc2UgPyBkZWxheSA6IC1kZWxheSk7XG4gIGNvbnN0IGR1cmF0aW9uUHJvY2Vzc2VkID0gcGFzc2VkRHVyYXRpb25JbkZyYW1lcyA9PT0gdW5kZWZpbmVkID8gZGVsYXlQcm9jZXNzZWQgOiBkZWxheVByb2Nlc3NlZCAvIChwYXNzZWREdXJhdGlvbkluRnJhbWVzIC8gbmF0dXJhbER1cmF0aW9uR2V0dGVyLmdldCgpKTtcbiAgaWYgKHBhc3NlZER1cmF0aW9uSW5GcmFtZXMgJiYgZGVsYXlQcm9jZXNzZWQgPiBwYXNzZWREdXJhdGlvbkluRnJhbWVzKSB7XG4gICAgcmV0dXJuIHRvO1xuICB9XG4gIGNvbnN0IHNwciA9IHNwcmluZ0NhbGN1bGF0aW9uKHtcbiAgICBmcHMsXG4gICAgZnJhbWU6IGR1cmF0aW9uUHJvY2Vzc2VkLFxuICAgIGNvbmZpZ1xuICB9KTtcbiAgY29uc3QgaW5uZXIyID0gY29uZmlnLm92ZXJzaG9vdENsYW1waW5nID8gdG8gPj0gZnJvbSA/IE1hdGgubWluKHNwci5jdXJyZW50LCB0bykgOiBNYXRoLm1heChzcHIuY3VycmVudCwgdG8pIDogc3ByLmN1cnJlbnQ7XG4gIGNvbnN0IGludGVycG9sYXRlZCA9IGZyb20gPT09IDAgJiYgdG8gPT09IDEgPyBpbm5lcjIgOiBpbnRlcnBvbGF0ZShpbm5lcjIsIFswLCAxXSwgW2Zyb20sIHRvXSk7XG4gIHJldHVybiBpbnRlcnBvbGF0ZWQ7XG59XG4vLyBzcmMvU3RpbGwudHN4XG5pbXBvcnQgUmVhY3QyNyBmcm9tIFwicmVhY3RcIjtcbnZhciBTdGlsbCA9IChwcm9wczIpID0+IHtcbiAgY29uc3QgbmV3UHJvcHMgPSB7XG4gICAgLi4ucHJvcHMyLFxuICAgIGR1cmF0aW9uSW5GcmFtZXM6IDEsXG4gICAgZnBzOiAxXG4gIH07XG4gIHJldHVybiBSZWFjdDI3LmNyZWF0ZUVsZW1lbnQoQ29tcG9zaXRpb24sIG5ld1Byb3BzKTtcbn07XG4vLyBzcmMvdmlkZW8vT2ZmdGhyZWFkVmlkZW8udHN4XG5pbXBvcnQgeyB1c2VDYWxsYmFjayBhcyB1c2VDYWxsYmFjazE0IH0gZnJvbSBcInJlYWN0XCI7XG5cbi8vIHNyYy92aWRlby9PZmZ0aHJlYWRWaWRlb0ZvclJlbmRlcmluZy50c3hcbmltcG9ydCB7XG4gIHVzZUNhbGxiYWNrIGFzIHVzZUNhbGxiYWNrMTMsXG4gIHVzZUNvbnRleHQgYXMgdXNlQ29udGV4dDI3LFxuICB1c2VFZmZlY3QgYXMgdXNlRWZmZWN0MjEsXG4gIHVzZUxheW91dEVmZmVjdCBhcyB1c2VMYXlvdXRFZmZlY3Q2LFxuICB1c2VNZW1vIGFzIHVzZU1lbW8yOSxcbiAgdXNlU3RhdGUgYXMgdXNlU3RhdGUxOFxufSBmcm9tIFwicmVhY3RcIjtcbmltcG9ydCB7IGpzeCBhcyBqc3gyOSB9IGZyb20gXCJyZWFjdC9qc3gtcnVudGltZVwiO1xudmFyIE9mZnRocmVhZFZpZGVvRm9yUmVuZGVyaW5nID0gKHtcbiAgb25FcnJvcixcbiAgdm9sdW1lOiB2b2x1bWVQcm9wLFxuICBwbGF5YmFja1JhdGUsXG4gIHNyYyxcbiAgbXV0ZWQsXG4gIGFsbG93QW1wbGlmaWNhdGlvbkR1cmluZ1JlbmRlcixcbiAgdHJhbnNwYXJlbnQgPSBmYWxzZSxcbiAgdG9uZU1hcHBlZCA9IHRydWUsXG4gIHRvbmVGcmVxdWVuY3ksXG4gIG5hbWUsXG4gIGxvb3BWb2x1bWVDdXJ2ZUJlaGF2aW9yLFxuICBkZWxheVJlbmRlclJldHJpZXMsXG4gIGRlbGF5UmVuZGVyVGltZW91dEluTWlsbGlzZWNvbmRzLFxuICBvblZpZGVvRnJhbWUsXG4gIC4uLnByb3BzMlxufSkgPT4ge1xuICBjb25zdCBhYnNvbHV0ZUZyYW1lID0gdXNlVGltZWxpbmVQb3NpdGlvbigpO1xuICBjb25zdCBmcmFtZSA9IHVzZUN1cnJlbnRGcmFtZSgpO1xuICBjb25zdCB2b2x1bWVQcm9wc0ZyYW1lID0gdXNlRnJhbWVGb3JWb2x1bWVQcm9wKGxvb3BWb2x1bWVDdXJ2ZUJlaGF2aW9yID8/IFwicmVwZWF0XCIpO1xuICBjb25zdCB2aWRlb0NvbmZpZyA9IHVzZVVuc2FmZVZpZGVvQ29uZmlnKCk7XG4gIGNvbnN0IHNlcXVlbmNlQ29udGV4dCA9IHVzZUNvbnRleHQyNyhTZXF1ZW5jZUNvbnRleHQpO1xuICBjb25zdCBtZWRpYVN0YXJ0c0F0ID0gdXNlTWVkaWFTdGFydHNBdCgpO1xuICBjb25zdCB7IHJlZ2lzdGVyUmVuZGVyQXNzZXQsIHVucmVnaXN0ZXJSZW5kZXJBc3NldCB9ID0gdXNlQ29udGV4dDI3KFJlbmRlckFzc2V0TWFuYWdlcik7XG4gIGlmICghc3JjKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIk5vIGBzcmNgIHdhcyBwYXNzZWQgdG8gPE9mZnRocmVhZFZpZGVvPi5cIik7XG4gIH1cbiAgY29uc3QgaWQgPSB1c2VNZW1vMjkoKCkgPT4gYG9mZnRocmVhZHZpZGVvLSR7cmFuZG9tKHNyYyA/PyBcIlwiKX0tJHtzZXF1ZW5jZUNvbnRleHQ/LmN1bXVsYXRlZEZyb219LSR7c2VxdWVuY2VDb250ZXh0Py5yZWxhdGl2ZUZyb219LSR7c2VxdWVuY2VDb250ZXh0Py5kdXJhdGlvbkluRnJhbWVzfWAsIFtcbiAgICBzcmMsXG4gICAgc2VxdWVuY2VDb250ZXh0Py5jdW11bGF0ZWRGcm9tLFxuICAgIHNlcXVlbmNlQ29udGV4dD8ucmVsYXRpdmVGcm9tLFxuICAgIHNlcXVlbmNlQ29udGV4dD8uZHVyYXRpb25JbkZyYW1lc1xuICBdKTtcbiAgaWYgKCF2aWRlb0NvbmZpZykge1xuICAgIHRocm93IG5ldyBFcnJvcihcIk5vIHZpZGVvIGNvbmZpZyBmb3VuZFwiKTtcbiAgfVxuICBjb25zdCB2b2x1bWUgPSBldmFsdWF0ZVZvbHVtZSh7XG4gICAgdm9sdW1lOiB2b2x1bWVQcm9wLFxuICAgIGZyYW1lOiB2b2x1bWVQcm9wc0ZyYW1lLFxuICAgIG1lZGlhVm9sdW1lOiAxLFxuICAgIGFsbG93QW1wbGlmaWNhdGlvbkR1cmluZ1JlbmRlcjogYWxsb3dBbXBsaWZpY2F0aW9uRHVyaW5nUmVuZGVyID8/IGZhbHNlXG4gIH0pO1xuICB1c2VFZmZlY3QyMSgoKSA9PiB7XG4gICAgaWYgKCFzcmMpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIk5vIHNyYyBwYXNzZWRcIik7XG4gICAgfVxuICAgIGlmICghd2luZG93LnJlbW90aW9uX2F1ZGlvRW5hYmxlZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAobXV0ZWQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKHZvbHVtZSA8PSAwKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHJlZ2lzdGVyUmVuZGVyQXNzZXQoe1xuICAgICAgdHlwZTogXCJ2aWRlb1wiLFxuICAgICAgc3JjOiBnZXRBYnNvbHV0ZVNyYyhzcmMpLFxuICAgICAgaWQsXG4gICAgICBmcmFtZTogYWJzb2x1dGVGcmFtZSxcbiAgICAgIHZvbHVtZSxcbiAgICAgIG1lZGlhRnJhbWU6IGZyYW1lLFxuICAgICAgcGxheWJhY2tSYXRlOiBwbGF5YmFja1JhdGUgPz8gMSxcbiAgICAgIGFsbG93QW1wbGlmaWNhdGlvbkR1cmluZ1JlbmRlcjogYWxsb3dBbXBsaWZpY2F0aW9uRHVyaW5nUmVuZGVyID8/IGZhbHNlLFxuICAgICAgdG9uZUZyZXF1ZW5jeTogdG9uZUZyZXF1ZW5jeSA/PyBudWxsLFxuICAgICAgYXVkaW9TdGFydEZyYW1lOiBNYXRoLm1heCgwLCAtKHNlcXVlbmNlQ29udGV4dD8ucmVsYXRpdmVGcm9tID8/IDApKVxuICAgIH0pO1xuICAgIHJldHVybiAoKSA9PiB1bnJlZ2lzdGVyUmVuZGVyQXNzZXQoaWQpO1xuICB9LCBbXG4gICAgbXV0ZWQsXG4gICAgc3JjLFxuICAgIHJlZ2lzdGVyUmVuZGVyQXNzZXQsXG4gICAgaWQsXG4gICAgdW5yZWdpc3RlclJlbmRlckFzc2V0LFxuICAgIHZvbHVtZSxcbiAgICBmcmFtZSxcbiAgICBhYnNvbHV0ZUZyYW1lLFxuICAgIHBsYXliYWNrUmF0ZSxcbiAgICBhbGxvd0FtcGxpZmljYXRpb25EdXJpbmdSZW5kZXIsXG4gICAgdG9uZUZyZXF1ZW5jeSxcbiAgICBzZXF1ZW5jZUNvbnRleHQ/LnJlbGF0aXZlRnJvbVxuICBdKTtcbiAgY29uc3QgY3VycmVudFRpbWUgPSB1c2VNZW1vMjkoKCkgPT4ge1xuICAgIHJldHVybiBnZXRFeHBlY3RlZE1lZGlhRnJhbWVVbmNvcnJlY3RlZCh7XG4gICAgICBmcmFtZSxcbiAgICAgIHBsYXliYWNrUmF0ZTogcGxheWJhY2tSYXRlIHx8IDEsXG4gICAgICBzdGFydEZyb206IC1tZWRpYVN0YXJ0c0F0XG4gICAgfSkgLyB2aWRlb0NvbmZpZy5mcHM7XG4gIH0sIFtmcmFtZSwgbWVkaWFTdGFydHNBdCwgcGxheWJhY2tSYXRlLCB2aWRlb0NvbmZpZy5mcHNdKTtcbiAgY29uc3QgYWN0dWFsU3JjID0gdXNlTWVtbzI5KCgpID0+IHtcbiAgICByZXR1cm4gZ2V0T2ZmdGhyZWFkVmlkZW9Tb3VyY2Uoe1xuICAgICAgc3JjLFxuICAgICAgY3VycmVudFRpbWUsXG4gICAgICB0cmFuc3BhcmVudCxcbiAgICAgIHRvbmVNYXBwZWRcbiAgICB9KTtcbiAgfSwgW3RvbmVNYXBwZWQsIGN1cnJlbnRUaW1lLCBzcmMsIHRyYW5zcGFyZW50XSk7XG4gIGNvbnN0IFtpbWFnZVNyYywgc2V0SW1hZ2VTcmNdID0gdXNlU3RhdGUxOChudWxsKTtcbiAgdXNlTGF5b3V0RWZmZWN0NigoKSA9PiB7XG4gICAgaWYgKCF3aW5kb3cucmVtb3Rpb25fdmlkZW9FbmFibGVkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IGNsZWFudXAgPSBbXTtcbiAgICBzZXRJbWFnZVNyYyhudWxsKTtcbiAgICBjb25zdCBjb250cm9sbGVyID0gbmV3IEFib3J0Q29udHJvbGxlcjtcbiAgICBjb25zdCBuZXdIYW5kbGUgPSBkZWxheVJlbmRlcihgRmV0Y2hpbmcgJHthY3R1YWxTcmN9IGZyb20gc2VydmVyYCwge1xuICAgICAgcmV0cmllczogZGVsYXlSZW5kZXJSZXRyaWVzID8/IHVuZGVmaW5lZCxcbiAgICAgIHRpbWVvdXRJbk1pbGxpc2Vjb25kczogZGVsYXlSZW5kZXJUaW1lb3V0SW5NaWxsaXNlY29uZHMgPz8gdW5kZWZpbmVkXG4gICAgfSk7XG4gICAgY29uc3QgZXhlY3V0ZSA9IGFzeW5jICgpID0+IHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IHJlcyA9IGF3YWl0IGZldGNoKGFjdHVhbFNyYywge1xuICAgICAgICAgIHNpZ25hbDogY29udHJvbGxlci5zaWduYWxcbiAgICAgICAgfSk7XG4gICAgICAgIGlmIChyZXMuc3RhdHVzICE9PSAyMDApIHtcbiAgICAgICAgICBpZiAocmVzLnN0YXR1cyA9PT0gNTAwKSB7XG4gICAgICAgICAgICBjb25zdCBqc29uID0gYXdhaXQgcmVzLmpzb24oKTtcbiAgICAgICAgICAgIGlmIChqc29uLmVycm9yKSB7XG4gICAgICAgICAgICAgIGNvbnN0IGNsZWFuZWRVcEVycm9yTWVzc2FnZSA9IGpzb24uZXJyb3IucmVwbGFjZSgvXkVycm9yOiAvLCBcIlwiKTtcbiAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGNsZWFuZWRVcEVycm9yTWVzc2FnZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgU2VydmVyIHJldHVybmVkIHN0YXR1cyAke3Jlcy5zdGF0dXN9IHdoaWxlIGZldGNoaW5nICR7YWN0dWFsU3JjfWApO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGJsb2IgPSBhd2FpdCByZXMuYmxvYigpO1xuICAgICAgICBjb25zdCB1cmwgPSBVUkwuY3JlYXRlT2JqZWN0VVJMKGJsb2IpO1xuICAgICAgICBjbGVhbnVwLnB1c2goKCkgPT4gVVJMLnJldm9rZU9iamVjdFVSTCh1cmwpKTtcbiAgICAgICAgc2V0SW1hZ2VTcmMoe1xuICAgICAgICAgIHNyYzogdXJsLFxuICAgICAgICAgIGhhbmRsZTogbmV3SGFuZGxlXG4gICAgICAgIH0pO1xuICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIGlmIChlcnIubWVzc2FnZS5pbmNsdWRlcyhcImFib3J0ZWRcIikpIHtcbiAgICAgICAgICBjb250aW51ZVJlbmRlcihuZXdIYW5kbGUpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY29udHJvbGxlci5zaWduYWwuYWJvcnRlZCkge1xuICAgICAgICAgIGNvbnRpbnVlUmVuZGVyKG5ld0hhbmRsZSk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmIChlcnIubWVzc2FnZS5pbmNsdWRlcyhcIkZhaWxlZCB0byBmZXRjaFwiKSkge1xuICAgICAgICAgIGVyciA9IG5ldyBFcnJvcihgRmFpbGVkIHRvIGZldGNoICR7YWN0dWFsU3JjfS4gVGhpcyBjb3VsZCBiZSBjYXVzZWQgYnkgQ2hyb21lIHJlamVjdGluZyB0aGUgcmVxdWVzdCBiZWNhdXNlIHRoZSBkaXNrIHNwYWNlIGlzIGxvdy4gQ29uc2lkZXIgaW5jcmVhc2luZyB0aGUgZGlzayBzaXplIG9mIHlvdXIgZW52aXJvbm1lbnQuYCwgeyBjYXVzZTogZXJyIH0pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChvbkVycm9yKSB7XG4gICAgICAgICAgb25FcnJvcihlcnIpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNhbmNlbFJlbmRlcihlcnIpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcbiAgICBleGVjdXRlKCk7XG4gICAgY2xlYW51cC5wdXNoKCgpID0+IHtcbiAgICAgIGlmIChjb250cm9sbGVyLnNpZ25hbC5hYm9ydGVkKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGNvbnRyb2xsZXIuYWJvcnQoKTtcbiAgICB9KTtcbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgY2xlYW51cC5mb3JFYWNoKChjMikgPT4gYzIoKSk7XG4gICAgfTtcbiAgfSwgW1xuICAgIGFjdHVhbFNyYyxcbiAgICBkZWxheVJlbmRlclJldHJpZXMsXG4gICAgZGVsYXlSZW5kZXJUaW1lb3V0SW5NaWxsaXNlY29uZHMsXG4gICAgb25FcnJvclxuICBdKTtcbiAgY29uc3Qgb25FcnIgPSB1c2VDYWxsYmFjazEzKCgpID0+IHtcbiAgICBpZiAob25FcnJvcikge1xuICAgICAgb25FcnJvcj8uKG5ldyBFcnJvcihcIkZhaWxlZCB0byBsb2FkIGltYWdlIHdpdGggc3JjIFwiICsgaW1hZ2VTcmMpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY2FuY2VsUmVuZGVyKFwiRmFpbGVkIHRvIGxvYWQgaW1hZ2Ugd2l0aCBzcmMgXCIgKyBpbWFnZVNyYyk7XG4gICAgfVxuICB9LCBbaW1hZ2VTcmMsIG9uRXJyb3JdKTtcbiAgY29uc3QgY2xhc3NOYW1lID0gdXNlTWVtbzI5KCgpID0+IHtcbiAgICByZXR1cm4gW09GRlRIUkVBRF9WSURFT19DTEFTU19OQU1FLCBwcm9wczIuY2xhc3NOYW1lXS5maWx0ZXIodHJ1dGh5KS5qb2luKFwiIFwiKTtcbiAgfSwgW3Byb3BzMi5jbGFzc05hbWVdKTtcbiAgY29uc3Qgb25JbWFnZUZyYW1lID0gdXNlQ2FsbGJhY2sxMygoaW1nKSA9PiB7XG4gICAgaWYgKG9uVmlkZW9GcmFtZSkge1xuICAgICAgb25WaWRlb0ZyYW1lKGltZyk7XG4gICAgfVxuICB9LCBbb25WaWRlb0ZyYW1lXSk7XG4gIGlmICghaW1hZ2VTcmMgfHwgIXdpbmRvdy5yZW1vdGlvbl92aWRlb0VuYWJsZWQpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICBjb250aW51ZVJlbmRlcihpbWFnZVNyYy5oYW5kbGUpO1xuICByZXR1cm4gLyogQF9fUFVSRV9fICovIGpzeDI5KEltZywge1xuICAgIHNyYzogaW1hZ2VTcmMuc3JjLFxuICAgIGNsYXNzTmFtZSxcbiAgICBkZWxheVJlbmRlclJldHJpZXMsXG4gICAgZGVsYXlSZW5kZXJUaW1lb3V0SW5NaWxsaXNlY29uZHMsXG4gICAgb25JbWFnZUZyYW1lLFxuICAgIC4uLnByb3BzMixcbiAgICBvbkVycm9yOiBvbkVyclxuICB9KTtcbn07XG5cbi8vIHNyYy92aWRlby9WaWRlb0ZvclByZXZpZXcudHN4XG5pbXBvcnQge1xuICBmb3J3YXJkUmVmIGFzIGZvcndhcmRSZWY5LFxuICB1c2VDb250ZXh0IGFzIHVzZUNvbnRleHQyOCxcbiAgdXNlRWZmZWN0IGFzIHVzZUVmZmVjdDIzLFxuICB1c2VJbXBlcmF0aXZlSGFuZGxlIGFzIHVzZUltcGVyYXRpdmVIYW5kbGU3LFxuICB1c2VNZW1vIGFzIHVzZU1lbW8zMCxcbiAgdXNlUmVmIGFzIHVzZVJlZjEzLFxuICB1c2VTdGF0ZSBhcyB1c2VTdGF0ZTE5XG59IGZyb20gXCJyZWFjdFwiO1xuXG4vLyBzcmMvdmlkZW8vZW1pdC12aWRlby1mcmFtZS50c1xuaW1wb3J0IHsgdXNlRWZmZWN0IGFzIHVzZUVmZmVjdDIyIH0gZnJvbSBcInJlYWN0XCI7XG52YXIgdXNlRW1pdFZpZGVvRnJhbWUgPSAoe1xuICByZWYsXG4gIG9uVmlkZW9GcmFtZVxufSkgPT4ge1xuICB1c2VFZmZlY3QyMigoKSA9PiB7XG4gICAgY29uc3QgeyBjdXJyZW50IH0gPSByZWY7XG4gICAgaWYgKCFjdXJyZW50KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICghb25WaWRlb0ZyYW1lKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGxldCBoYW5kbGUgPSAwO1xuICAgIGNvbnN0IGNhbGxiYWNrID0gKCkgPT4ge1xuICAgICAgaWYgKCFyZWYuY3VycmVudCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBvblZpZGVvRnJhbWUocmVmLmN1cnJlbnQpO1xuICAgICAgaGFuZGxlID0gcmVmLmN1cnJlbnQucmVxdWVzdFZpZGVvRnJhbWVDYWxsYmFjayhjYWxsYmFjayk7XG4gICAgfTtcbiAgICBjYWxsYmFjaygpO1xuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICBjdXJyZW50LmNhbmNlbFZpZGVvRnJhbWVDYWxsYmFjayhoYW5kbGUpO1xuICAgIH07XG4gIH0sIFtvblZpZGVvRnJhbWUsIHJlZl0pO1xufTtcblxuLy8gc3JjL3ZpZGVvL1ZpZGVvRm9yUHJldmlldy50c3hcbmltcG9ydCB7IGpzeCBhcyBqc3gzMCB9IGZyb20gXCJyZWFjdC9qc3gtcnVudGltZVwiO1xudmFyIFZpZGVvRm9yRGV2ZWxvcG1lbnRSZWZGb3J3YXJkaW5nRnVuY3Rpb24gPSAocHJvcHMyLCByZWYpID0+IHtcbiAgY29uc3QgdmlkZW9SZWYgPSB1c2VSZWYxMyhudWxsKTtcbiAgY29uc3Qge1xuICAgIHZvbHVtZSxcbiAgICBtdXRlZCxcbiAgICBwbGF5YmFja1JhdGUsXG4gICAgb25seVdhcm5Gb3JNZWRpYVNlZWtpbmdFcnJvcixcbiAgICBzcmMsXG4gICAgb25EdXJhdGlvbixcbiAgICBhY2NlcHRhYmxlVGltZVNoaWZ0LFxuICAgIGFjY2VwdGFibGVUaW1lU2hpZnRJblNlY29uZHMsXG4gICAgdG9uZUZyZXF1ZW5jeSxcbiAgICBuYW1lLFxuICAgIF9yZW1vdGlvbkludGVybmFsTmF0aXZlTG9vcFBhc3NlZCxcbiAgICBfcmVtb3Rpb25JbnRlcm5hbFN0YWNrLFxuICAgIF9yZW1vdGlvbkRlYnVnU2Vla2luZyxcbiAgICBzdHlsZSxcbiAgICBwYXVzZVdoZW5CdWZmZXJpbmcsXG4gICAgc2hvd0luVGltZWxpbmUsXG4gICAgbG9vcFZvbHVtZUN1cnZlQmVoYXZpb3IsXG4gICAgb25FcnJvcixcbiAgICBvbkF1dG9QbGF5RXJyb3IsXG4gICAgb25WaWRlb0ZyYW1lLFxuICAgIGNyb3NzT3JpZ2luLFxuICAgIC4uLm5hdGl2ZVByb3BzXG4gIH0gPSBwcm9wczI7XG4gIGNvbnN0IHZvbHVtZVByb3BGcmFtZSA9IHVzZUZyYW1lRm9yVm9sdW1lUHJvcChsb29wVm9sdW1lQ3VydmVCZWhhdmlvciA/PyBcInJlcGVhdFwiKTtcbiAgY29uc3QgeyBmcHMsIGR1cmF0aW9uSW5GcmFtZXMgfSA9IHVzZVZpZGVvQ29uZmlnKCk7XG4gIGNvbnN0IHBhcmVudFNlcXVlbmNlID0gdXNlQ29udGV4dDI4KFNlcXVlbmNlQ29udGV4dCk7XG4gIGNvbnN0IHsgaGlkZGVuIH0gPSB1c2VDb250ZXh0MjgoU2VxdWVuY2VWaXNpYmlsaXR5VG9nZ2xlQ29udGV4dCk7XG4gIGNvbnN0IFt0aW1lbGluZUlkXSA9IHVzZVN0YXRlMTkoKCkgPT4gU3RyaW5nKE1hdGgucmFuZG9tKCkpKTtcbiAgY29uc3QgaXNTZXF1ZW5jZUhpZGRlbiA9IGhpZGRlblt0aW1lbGluZUlkXSA/PyBmYWxzZTtcbiAgaWYgKHR5cGVvZiBhY2NlcHRhYmxlVGltZVNoaWZ0ICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiYWNjZXB0YWJsZVRpbWVTaGlmdCBoYXMgYmVlbiByZW1vdmVkLiBVc2UgYWNjZXB0YWJsZVRpbWVTaGlmdEluU2Vjb25kcyBpbnN0ZWFkLlwiKTtcbiAgfVxuICBjb25zdCBhY3R1YWxWb2x1bWUgPSB1c2VNZWRpYVRhZ1ZvbHVtZSh2aWRlb1JlZik7XG4gIGNvbnN0IFttZWRpYVZvbHVtZV0gPSB1c2VNZWRpYVZvbHVtZVN0YXRlKCk7XG4gIGNvbnN0IFttZWRpYU11dGVkXSA9IHVzZU1lZGlhTXV0ZWRTdGF0ZSgpO1xuICB1c2VNZWRpYUluVGltZWxpbmUoe1xuICAgIG1lZGlhUmVmOiB2aWRlb1JlZixcbiAgICB2b2x1bWUsXG4gICAgbWVkaWFWb2x1bWUsXG4gICAgbWVkaWFUeXBlOiBcInZpZGVvXCIsXG4gICAgc3JjLFxuICAgIHBsYXliYWNrUmF0ZTogcHJvcHMyLnBsYXliYWNrUmF0ZSA/PyAxLFxuICAgIGRpc3BsYXlOYW1lOiBuYW1lID8/IG51bGwsXG4gICAgaWQ6IHRpbWVsaW5lSWQsXG4gICAgc3RhY2s6IF9yZW1vdGlvbkludGVybmFsU3RhY2ssXG4gICAgc2hvd0luVGltZWxpbmUsXG4gICAgcHJlbW91bnREaXNwbGF5OiBudWxsLFxuICAgIG9uQXV0b1BsYXlFcnJvcjogb25BdXRvUGxheUVycm9yID8/IG51bGxcbiAgfSk7XG4gIHVzZVN5bmNWb2x1bWVXaXRoTWVkaWFUYWcoe1xuICAgIHZvbHVtZVByb3BGcmFtZSxcbiAgICBhY3R1YWxWb2x1bWUsXG4gICAgdm9sdW1lLFxuICAgIG1lZGlhVm9sdW1lLFxuICAgIG1lZGlhUmVmOiB2aWRlb1JlZlxuICB9KTtcbiAgdXNlTWVkaWFQbGF5YmFjayh7XG4gICAgbWVkaWFSZWY6IHZpZGVvUmVmLFxuICAgIHNyYyxcbiAgICBtZWRpYVR5cGU6IFwidmlkZW9cIixcbiAgICBwbGF5YmFja1JhdGU6IHByb3BzMi5wbGF5YmFja1JhdGUgPz8gMSxcbiAgICBvbmx5V2FybkZvck1lZGlhU2Vla2luZ0Vycm9yLFxuICAgIGFjY2VwdGFibGVUaW1lc2hpZnQ6IGFjY2VwdGFibGVUaW1lU2hpZnRJblNlY29uZHMgPz8gREVGQVVMVF9BQ0NFUFRBQkxFX1RJTUVTSElGVCxcbiAgICBpc1ByZW1vdW50aW5nOiBCb29sZWFuKHBhcmVudFNlcXVlbmNlPy5wcmVtb3VudGluZyksXG4gICAgcGF1c2VXaGVuQnVmZmVyaW5nLFxuICAgIGRlYnVnU2Vla2luZzogX3JlbW90aW9uRGVidWdTZWVraW5nLFxuICAgIG9uQXV0b1BsYXlFcnJvcjogb25BdXRvUGxheUVycm9yID8/IG51bGxcbiAgfSk7XG4gIGNvbnN0IGFjdHVhbEZyb20gPSBwYXJlbnRTZXF1ZW5jZSA/IHBhcmVudFNlcXVlbmNlLnJlbGF0aXZlRnJvbSA6IDA7XG4gIGNvbnN0IGR1cmF0aW9uID0gcGFyZW50U2VxdWVuY2UgPyBNYXRoLm1pbihwYXJlbnRTZXF1ZW5jZS5kdXJhdGlvbkluRnJhbWVzLCBkdXJhdGlvbkluRnJhbWVzKSA6IGR1cmF0aW9uSW5GcmFtZXM7XG4gIGNvbnN0IGFjdHVhbFNyYyA9IHVzZUFwcGVuZFZpZGVvRnJhZ21lbnQoe1xuICAgIGFjdHVhbFNyYzogdXNlUHJlbG9hZChzcmMpLFxuICAgIGFjdHVhbEZyb20sXG4gICAgZHVyYXRpb24sXG4gICAgZnBzXG4gIH0pO1xuICB1c2VJbXBlcmF0aXZlSGFuZGxlNyhyZWYsICgpID0+IHtcbiAgICByZXR1cm4gdmlkZW9SZWYuY3VycmVudDtcbiAgfSwgW10pO1xuICB1c2VFZmZlY3QyMygoKSA9PiB7XG4gICAgY29uc3QgeyBjdXJyZW50IH0gPSB2aWRlb1JlZjtcbiAgICBpZiAoIWN1cnJlbnQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgZXJyb3JIYW5kbGVyID0gKCkgPT4ge1xuICAgICAgaWYgKGN1cnJlbnQuZXJyb3IpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcihcIkVycm9yIG9jY3VycmVkIGluIHZpZGVvXCIsIGN1cnJlbnQ/LmVycm9yKTtcbiAgICAgICAgaWYgKG9uRXJyb3IpIHtcbiAgICAgICAgICBjb25zdCBlcnIgPSBuZXcgRXJyb3IoYENvZGUgJHtjdXJyZW50LmVycm9yLmNvZGV9OiAke2N1cnJlbnQuZXJyb3IubWVzc2FnZX1gKTtcbiAgICAgICAgICBvbkVycm9yKGVycik7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgVGhlIGJyb3dzZXIgdGhyZXcgYW4gZXJyb3Igd2hpbGUgcGxheWluZyB0aGUgdmlkZW8gJHtzcmN9OiBDb2RlICR7Y3VycmVudC5lcnJvci5jb2RlfSAtICR7Y3VycmVudD8uZXJyb3I/Lm1lc3NhZ2V9LiBTZWUgaHR0cHM6Ly9yZW1vdGlvbi5kZXYvZG9jcy9tZWRpYS1wbGF5YmFjay1lcnJvciBmb3IgaGVscC4gUGFzcyBhbiBvbkVycm9yKCkgcHJvcCB0byBoYW5kbGUgdGhlIGVycm9yLmApO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKG9uRXJyb3IpIHtcbiAgICAgICAgICBjb25zdCBlcnIgPSBuZXcgRXJyb3IoYFRoZSBicm93c2VyIHRocmV3IGFuIGVycm9yIHdoaWxlIHBsYXlpbmcgdGhlIHZpZGVvICR7c3JjfWApO1xuICAgICAgICAgIG9uRXJyb3IoZXJyKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVGhlIGJyb3dzZXIgdGhyZXcgYW4gZXJyb3Igd2hpbGUgcGxheWluZyB0aGUgdmlkZW9cIik7XG4gICAgICB9XG4gICAgfTtcbiAgICBjdXJyZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJlcnJvclwiLCBlcnJvckhhbmRsZXIsIHsgb25jZTogdHJ1ZSB9KTtcbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgY3VycmVudC5yZW1vdmVFdmVudExpc3RlbmVyKFwiZXJyb3JcIiwgZXJyb3JIYW5kbGVyKTtcbiAgICB9O1xuICB9LCBbb25FcnJvciwgc3JjXSk7XG4gIGNvbnN0IGN1cnJlbnRPbkR1cmF0aW9uQ2FsbGJhY2sgPSB1c2VSZWYxMygpO1xuICBjdXJyZW50T25EdXJhdGlvbkNhbGxiYWNrLmN1cnJlbnQgPSBvbkR1cmF0aW9uO1xuICB1c2VFbWl0VmlkZW9GcmFtZSh7IHJlZjogdmlkZW9SZWYsIG9uVmlkZW9GcmFtZSB9KTtcbiAgdXNlRWZmZWN0MjMoKCkgPT4ge1xuICAgIGNvbnN0IHsgY3VycmVudCB9ID0gdmlkZW9SZWY7XG4gICAgaWYgKCFjdXJyZW50KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmIChjdXJyZW50LmR1cmF0aW9uKSB7XG4gICAgICBjdXJyZW50T25EdXJhdGlvbkNhbGxiYWNrLmN1cnJlbnQ/LihzcmMsIGN1cnJlbnQuZHVyYXRpb24pO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBvbkxvYWRlZE1ldGFkYXRhID0gKCkgPT4ge1xuICAgICAgY3VycmVudE9uRHVyYXRpb25DYWxsYmFjay5jdXJyZW50Py4oc3JjLCBjdXJyZW50LmR1cmF0aW9uKTtcbiAgICB9O1xuICAgIGN1cnJlbnQuYWRkRXZlbnRMaXN0ZW5lcihcImxvYWRlZG1ldGFkYXRhXCIsIG9uTG9hZGVkTWV0YWRhdGEpO1xuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICBjdXJyZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJsb2FkZWRtZXRhZGF0YVwiLCBvbkxvYWRlZE1ldGFkYXRhKTtcbiAgICB9O1xuICB9LCBbc3JjXSk7XG4gIHVzZUVmZmVjdDIzKCgpID0+IHtcbiAgICBjb25zdCB7IGN1cnJlbnQgfSA9IHZpZGVvUmVmO1xuICAgIGlmICghY3VycmVudCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoaXNJb3NTYWZhcmkoKSkge1xuICAgICAgY3VycmVudC5wcmVsb2FkID0gXCJtZXRhZGF0YVwiO1xuICAgIH0gZWxzZSB7XG4gICAgICBjdXJyZW50LnByZWxvYWQgPSBcImF1dG9cIjtcbiAgICB9XG4gIH0sIFtdKTtcbiAgY29uc3QgYWN0dWFsU3R5bGUgPSB1c2VNZW1vMzAoKCkgPT4ge1xuICAgIHJldHVybiB7XG4gICAgICAuLi5zdHlsZSxcbiAgICAgIG9wYWNpdHk6IGlzU2VxdWVuY2VIaWRkZW4gPyAwIDogc3R5bGU/Lm9wYWNpdHkgPz8gMVxuICAgIH07XG4gIH0sIFtpc1NlcXVlbmNlSGlkZGVuLCBzdHlsZV0pO1xuICBjb25zdCBjcm9zc09yaWdpblZhbHVlID0gY3Jvc3NPcmlnaW4gPz8gKG9uVmlkZW9GcmFtZSA/IFwiYW5vbnltb3VzXCIgOiB1bmRlZmluZWQpO1xuICByZXR1cm4gLyogQF9fUFVSRV9fICovIGpzeDMwKFwidmlkZW9cIiwge1xuICAgIHJlZjogdmlkZW9SZWYsXG4gICAgbXV0ZWQ6IG11dGVkIHx8IG1lZGlhTXV0ZWQsXG4gICAgcGxheXNJbmxpbmU6IHRydWUsXG4gICAgc3JjOiBhY3R1YWxTcmMsXG4gICAgbG9vcDogX3JlbW90aW9uSW50ZXJuYWxOYXRpdmVMb29wUGFzc2VkLFxuICAgIHN0eWxlOiBhY3R1YWxTdHlsZSxcbiAgICBkaXNhYmxlUmVtb3RlUGxheWJhY2s6IHRydWUsXG4gICAgY3Jvc3NPcmlnaW46IGNyb3NzT3JpZ2luVmFsdWUsXG4gICAgLi4ubmF0aXZlUHJvcHNcbiAgfSk7XG59O1xudmFyIFZpZGVvRm9yUHJldmlldyA9IGZvcndhcmRSZWY5KFZpZGVvRm9yRGV2ZWxvcG1lbnRSZWZGb3J3YXJkaW5nRnVuY3Rpb24pO1xuXG4vLyBzcmMvdmlkZW8vT2ZmdGhyZWFkVmlkZW8udHN4XG5pbXBvcnQgeyBqc3ggYXMganN4MzEgfSBmcm9tIFwicmVhY3QvanN4LXJ1bnRpbWVcIjtcbnZhciBPZmZ0aHJlYWRWaWRlbyA9IChwcm9wczIpID0+IHtcbiAgY29uc3Qge1xuICAgIHN0YXJ0RnJvbSxcbiAgICBlbmRBdCxcbiAgICBuYW1lLFxuICAgIHBhdXNlV2hlbkJ1ZmZlcmluZyxcbiAgICBzdGFjayxcbiAgICBzaG93SW5UaW1lbGluZSxcbiAgICAuLi5vdGhlclByb3BzXG4gIH0gPSBwcm9wczI7XG4gIGNvbnN0IGVudmlyb25tZW50ID0gZ2V0UmVtb3Rpb25FbnZpcm9ubWVudCgpO1xuICBjb25zdCBvbkR1cmF0aW9uID0gdXNlQ2FsbGJhY2sxNCgoKSA9PiB7XG4gICAgcmV0dXJuO1xuICB9LCBbXSk7XG4gIGlmICh0eXBlb2YgcHJvcHMyLnNyYyAhPT0gXCJzdHJpbmdcIikge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYFRoZSBcXGA8T2ZmdGhyZWFkVmlkZW8+XFxgIHRhZyByZXF1aXJlcyBhIHN0cmluZyBmb3IgXFxgc3JjXFxgLCBidXQgZ290ICR7SlNPTi5zdHJpbmdpZnkocHJvcHMyLnNyYyl9IGluc3RlYWQuYCk7XG4gIH1cbiAgaWYgKHByb3BzMi5pbWFnZUZvcm1hdCkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYFRoZSBcXGA8T2ZmdGhyZWFkVmlkZW8+XFxgIHRhZyBkb2VzIG5vIGxvbmdlciBhY2NlcHQgXFxgaW1hZ2VGb3JtYXRcXGAuIFVzZSB0aGUgXFxgdHJhbnNwYXJlbnRcXGAgcHJvcCBpZiB5b3Ugd2FudCB0byByZW5kZXIgYSB0cmFuc3BhcmVudCB2aWRlby5gKTtcbiAgfVxuICBpZiAodHlwZW9mIHN0YXJ0RnJvbSAhPT0gXCJ1bmRlZmluZWRcIiB8fCB0eXBlb2YgZW5kQXQgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICB2YWxpZGF0ZVN0YXJ0RnJvbVByb3BzKHN0YXJ0RnJvbSwgZW5kQXQpO1xuICAgIGNvbnN0IHN0YXJ0RnJvbUZyYW1lTm8gPSBzdGFydEZyb20gPz8gMDtcbiAgICBjb25zdCBlbmRBdEZyYW1lTm8gPSBlbmRBdCA/PyBJbmZpbml0eTtcbiAgICByZXR1cm4gLyogQF9fUFVSRV9fICovIGpzeDMxKFNlcXVlbmNlLCB7XG4gICAgICBsYXlvdXQ6IFwibm9uZVwiLFxuICAgICAgZnJvbTogMCAtIHN0YXJ0RnJvbUZyYW1lTm8sXG4gICAgICBzaG93SW5UaW1lbGluZTogZmFsc2UsXG4gICAgICBkdXJhdGlvbkluRnJhbWVzOiBlbmRBdEZyYW1lTm8sXG4gICAgICBuYW1lLFxuICAgICAgY2hpbGRyZW46IC8qIEBfX1BVUkVfXyAqLyBqc3gzMShPZmZ0aHJlYWRWaWRlbywge1xuICAgICAgICBwYXVzZVdoZW5CdWZmZXJpbmc6IHBhdXNlV2hlbkJ1ZmZlcmluZyA/PyBmYWxzZSxcbiAgICAgICAgLi4ub3RoZXJQcm9wc1xuICAgICAgfSlcbiAgICB9KTtcbiAgfVxuICB2YWxpZGF0ZU1lZGlhUHJvcHMocHJvcHMyLCBcIlZpZGVvXCIpO1xuICBpZiAoZW52aXJvbm1lbnQuaXNSZW5kZXJpbmcpIHtcbiAgICByZXR1cm4gLyogQF9fUFVSRV9fICovIGpzeDMxKE9mZnRocmVhZFZpZGVvRm9yUmVuZGVyaW5nLCB7XG4gICAgICAuLi5vdGhlclByb3BzXG4gICAgfSk7XG4gIH1cbiAgY29uc3Qge1xuICAgIHRyYW5zcGFyZW50LFxuICAgIHRvbmVNYXBwZWQsXG4gICAgX3JlbW90aW9uRGVidWdTZWVraW5nLFxuICAgIG9uQXV0b1BsYXlFcnJvcixcbiAgICBvblZpZGVvRnJhbWUsXG4gICAgY3Jvc3NPcmlnaW4sXG4gICAgLi4ud2l0aG91dFRyYW5zcGFyZW50XG4gIH0gPSBvdGhlclByb3BzO1xuICByZXR1cm4gLyogQF9fUFVSRV9fICovIGpzeDMxKFZpZGVvRm9yUHJldmlldywge1xuICAgIF9yZW1vdGlvbkludGVybmFsU3RhY2s6IHN0YWNrID8/IG51bGwsXG4gICAgX3JlbW90aW9uSW50ZXJuYWxOYXRpdmVMb29wUGFzc2VkOiBmYWxzZSxcbiAgICBfcmVtb3Rpb25EZWJ1Z1NlZWtpbmc6IF9yZW1vdGlvbkRlYnVnU2Vla2luZyA/PyBmYWxzZSxcbiAgICBvbkR1cmF0aW9uLFxuICAgIG9ubHlXYXJuRm9yTWVkaWFTZWVraW5nRXJyb3I6IHRydWUsXG4gICAgcGF1c2VXaGVuQnVmZmVyaW5nOiBwYXVzZVdoZW5CdWZmZXJpbmcgPz8gZmFsc2UsXG4gICAgc2hvd0luVGltZWxpbmU6IHNob3dJblRpbWVsaW5lID8/IHRydWUsXG4gICAgb25BdXRvUGxheUVycm9yOiBvbkF1dG9QbGF5RXJyb3IgPz8gdW5kZWZpbmVkLFxuICAgIG9uVmlkZW9GcmFtZTogb25WaWRlb0ZyYW1lID8/IG51bGwsXG4gICAgY3Jvc3NPcmlnaW4sXG4gICAgLi4ud2l0aG91dFRyYW5zcGFyZW50XG4gIH0pO1xufTtcbi8vIHNyYy92aWRlby9WaWRlby50c3hcbmltcG9ydCB7IGZvcndhcmRSZWYgYXMgZm9yd2FyZFJlZjExLCB1c2VDYWxsYmFjayBhcyB1c2VDYWxsYmFjazE1LCB1c2VDb250ZXh0IGFzIHVzZUNvbnRleHQzMCB9IGZyb20gXCJyZWFjdFwiO1xuXG4vLyBzcmMvdmlkZW8vVmlkZW9Gb3JSZW5kZXJpbmcudHN4XG5pbXBvcnQge1xuICBmb3J3YXJkUmVmIGFzIGZvcndhcmRSZWYxMCxcbiAgdXNlQ29udGV4dCBhcyB1c2VDb250ZXh0MjksXG4gIHVzZUVmZmVjdCBhcyB1c2VFZmZlY3QyNCxcbiAgdXNlSW1wZXJhdGl2ZUhhbmRsZSBhcyB1c2VJbXBlcmF0aXZlSGFuZGxlOCxcbiAgdXNlTGF5b3V0RWZmZWN0IGFzIHVzZUxheW91dEVmZmVjdDcsXG4gIHVzZU1lbW8gYXMgdXNlTWVtbzMxLFxuICB1c2VSZWYgYXMgdXNlUmVmMTRcbn0gZnJvbSBcInJlYWN0XCI7XG5cbi8vIHNyYy92aWRlby9zZWVrLXVudGlsLXJpZ2h0LnRzXG52YXIgcm91bmRUbzZDb21tYXMgPSAobnVtKSA9PiB7XG4gIHJldHVybiBNYXRoLnJvdW5kKG51bSAqIDFlNSkgLyAxZTU7XG59O1xudmFyIHNlZWtUb1RpbWUgPSAoZWxlbWVudCwgZGVzaXJlZFRpbWUpID0+IHtcbiAgZWxlbWVudC5jdXJyZW50VGltZSA9IGRlc2lyZWRUaW1lO1xuICBsZXQgY2FuY2VsO1xuICBsZXQgY2FuY2VsU2Vla2VkID0gbnVsbDtcbiAgY29uc3QgcHJvbSA9IG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiB7XG4gICAgY2FuY2VsID0gZWxlbWVudC5yZXF1ZXN0VmlkZW9GcmFtZUNhbGxiYWNrKChub3csIG1ldGFkYXRhKSA9PiB7XG4gICAgICBjb25zdCBkaXNwbGF5SW4gPSBtZXRhZGF0YS5leHBlY3RlZERpc3BsYXlUaW1lIC0gbm93O1xuICAgICAgaWYgKGRpc3BsYXlJbiA8PSAwKSB7XG4gICAgICAgIHJlc29sdmUobWV0YWRhdGEubWVkaWFUaW1lKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgIHJlc29sdmUobWV0YWRhdGEubWVkaWFUaW1lKTtcbiAgICAgIH0sIGRpc3BsYXlJbiArIDE1MCk7XG4gICAgfSk7XG4gIH0pO1xuICBjb25zdCB3YWl0Rm9yU2Vla2VkRXZlbnQgPSBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4ge1xuICAgIGNvbnN0IG9uRG9uZSA9ICgpID0+IHtcbiAgICAgIHJlc29sdmUoKTtcbiAgICB9O1xuICAgIGVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcInNlZWtlZFwiLCBvbkRvbmUsIHtcbiAgICAgIG9uY2U6IHRydWVcbiAgICB9KTtcbiAgICBjYW5jZWxTZWVrZWQgPSAoKSA9PiB7XG4gICAgICBlbGVtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJzZWVrZWRcIiwgb25Eb25lKTtcbiAgICB9O1xuICB9KTtcbiAgcmV0dXJuIHtcbiAgICB3YWl0OiBQcm9taXNlLmFsbChbcHJvbSwgd2FpdEZvclNlZWtlZEV2ZW50XSkudGhlbigoW3RpbWVdKSA9PiB0aW1lKSxcbiAgICBjYW5jZWw6ICgpID0+IHtcbiAgICAgIGNhbmNlbFNlZWtlZD8uKCk7XG4gICAgICBlbGVtZW50LmNhbmNlbFZpZGVvRnJhbWVDYWxsYmFjayhjYW5jZWwpO1xuICAgIH1cbiAgfTtcbn07XG52YXIgc2Vla1RvVGltZU11bHRpcGxlVW50aWxSaWdodCA9IChlbGVtZW50LCBkZXNpcmVkVGltZSwgZnBzKSA9PiB7XG4gIGNvbnN0IHRocmVzaG9sZCA9IDEgLyBmcHMgLyAyO1xuICBsZXQgY3VycmVudENhbmNlbCA9ICgpID0+IHtcbiAgICByZXR1cm47XG4gIH07XG4gIGlmIChOdW1iZXIuaXNGaW5pdGUoZWxlbWVudC5kdXJhdGlvbikgJiYgZWxlbWVudC5jdXJyZW50VGltZSA+PSBlbGVtZW50LmR1cmF0aW9uICYmIGRlc2lyZWRUaW1lID49IGVsZW1lbnQuZHVyYXRpb24pIHtcbiAgICByZXR1cm4ge1xuICAgICAgcHJvbTogUHJvbWlzZS5yZXNvbHZlKCksXG4gICAgICBjYW5jZWw6ICgpID0+IHtcbiAgICAgIH1cbiAgICB9O1xuICB9XG4gIGNvbnN0IHByb20gPSBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgY29uc3QgZmlyc3RTZWVrID0gc2Vla1RvVGltZShlbGVtZW50LCBkZXNpcmVkVGltZSArIHRocmVzaG9sZCk7XG4gICAgZmlyc3RTZWVrLndhaXQudGhlbigoc2Vla2VkVG8pID0+IHtcbiAgICAgIGNvbnN0IGRpZmZlcmVuY2UgPSBNYXRoLmFicyhkZXNpcmVkVGltZSAtIHNlZWtlZFRvKTtcbiAgICAgIGlmIChkaWZmZXJlbmNlIDw9IHRocmVzaG9sZCkge1xuICAgICAgICByZXR1cm4gcmVzb2x2ZSgpO1xuICAgICAgfVxuICAgICAgY29uc3Qgc2lnbiA9IGRlc2lyZWRUaW1lID4gc2Vla2VkVG8gPyAxIDogLTE7XG4gICAgICBjb25zdCBuZXdTZWVrID0gc2Vla1RvVGltZShlbGVtZW50LCBzZWVrZWRUbyArIHRocmVzaG9sZCAqIHNpZ24pO1xuICAgICAgY3VycmVudENhbmNlbCA9IG5ld1NlZWsuY2FuY2VsO1xuICAgICAgbmV3U2Vlay53YWl0LnRoZW4oKG5ld1RpbWUpID0+IHtcbiAgICAgICAgY29uc3QgbmV3RGlmZmVyZW5jZSA9IE1hdGguYWJzKGRlc2lyZWRUaW1lIC0gbmV3VGltZSk7XG4gICAgICAgIGlmIChyb3VuZFRvNkNvbW1hcyhuZXdEaWZmZXJlbmNlKSA8PSByb3VuZFRvNkNvbW1hcyh0aHJlc2hvbGQpKSB7XG4gICAgICAgICAgcmV0dXJuIHJlc29sdmUoKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB0aGlyZFNlZWsgPSBzZWVrVG9UaW1lKGVsZW1lbnQsIGRlc2lyZWRUaW1lICsgdGhyZXNob2xkKTtcbiAgICAgICAgY3VycmVudENhbmNlbCA9IHRoaXJkU2Vlay5jYW5jZWw7XG4gICAgICAgIHJldHVybiB0aGlyZFNlZWsud2FpdC50aGVuKCgpID0+IHtcbiAgICAgICAgICByZXNvbHZlKCk7XG4gICAgICAgIH0pLmNhdGNoKChlcnIpID0+IHtcbiAgICAgICAgICByZWplY3QoZXJyKTtcbiAgICAgICAgfSk7XG4gICAgICB9KS5jYXRjaCgoZXJyKSA9PiB7XG4gICAgICAgIHJlamVjdChlcnIpO1xuICAgICAgfSk7XG4gICAgfSk7XG4gICAgY3VycmVudENhbmNlbCA9IGZpcnN0U2Vlay5jYW5jZWw7XG4gIH0pO1xuICByZXR1cm4ge1xuICAgIHByb20sXG4gICAgY2FuY2VsOiAoKSA9PiB7XG4gICAgICBjdXJyZW50Q2FuY2VsKCk7XG4gICAgfVxuICB9O1xufTtcblxuLy8gc3JjL3ZpZGVvL1ZpZGVvRm9yUmVuZGVyaW5nLnRzeFxuaW1wb3J0IHsganN4IGFzIGpzeDMyIH0gZnJvbSBcInJlYWN0L2pzeC1ydW50aW1lXCI7XG52YXIgVmlkZW9Gb3JSZW5kZXJpbmdGb3J3YXJkRnVuY3Rpb24gPSAoe1xuICBvbkVycm9yLFxuICB2b2x1bWU6IHZvbHVtZVByb3AsXG4gIGFsbG93QW1wbGlmaWNhdGlvbkR1cmluZ1JlbmRlcixcbiAgcGxheWJhY2tSYXRlLFxuICBvbkR1cmF0aW9uLFxuICB0b25lRnJlcXVlbmN5LFxuICBuYW1lLFxuICBhY2NlcHRhYmxlVGltZVNoaWZ0SW5TZWNvbmRzLFxuICBkZWxheVJlbmRlclJldHJpZXMsXG4gIGRlbGF5UmVuZGVyVGltZW91dEluTWlsbGlzZWNvbmRzLFxuICBsb29wVm9sdW1lQ3VydmVCZWhhdmlvcixcbiAgLi4ucHJvcHMyXG59LCByZWYpID0+IHtcbiAgY29uc3QgYWJzb2x1dGVGcmFtZSA9IHVzZVRpbWVsaW5lUG9zaXRpb24oKTtcbiAgY29uc3QgZnJhbWUgPSB1c2VDdXJyZW50RnJhbWUoKTtcbiAgY29uc3Qgdm9sdW1lUHJvcHNGcmFtZSA9IHVzZUZyYW1lRm9yVm9sdW1lUHJvcChsb29wVm9sdW1lQ3VydmVCZWhhdmlvciA/PyBcInJlcGVhdFwiKTtcbiAgY29uc3QgdmlkZW9Db25maWcgPSB1c2VVbnNhZmVWaWRlb0NvbmZpZygpO1xuICBjb25zdCB2aWRlb1JlZiA9IHVzZVJlZjE0KG51bGwpO1xuICBjb25zdCBzZXF1ZW5jZUNvbnRleHQgPSB1c2VDb250ZXh0MjkoU2VxdWVuY2VDb250ZXh0KTtcbiAgY29uc3QgbWVkaWFTdGFydHNBdCA9IHVzZU1lZGlhU3RhcnRzQXQoKTtcbiAgY29uc3QgZW52aXJvbm1lbnQgPSBnZXRSZW1vdGlvbkVudmlyb25tZW50KCk7XG4gIGNvbnN0IHsgcmVnaXN0ZXJSZW5kZXJBc3NldCwgdW5yZWdpc3RlclJlbmRlckFzc2V0IH0gPSB1c2VDb250ZXh0MjkoUmVuZGVyQXNzZXRNYW5hZ2VyKTtcbiAgY29uc3QgaWQgPSB1c2VNZW1vMzEoKCkgPT4gYHZpZGVvLSR7cmFuZG9tKHByb3BzMi5zcmMgPz8gXCJcIil9LSR7c2VxdWVuY2VDb250ZXh0Py5jdW11bGF0ZWRGcm9tfS0ke3NlcXVlbmNlQ29udGV4dD8ucmVsYXRpdmVGcm9tfS0ke3NlcXVlbmNlQ29udGV4dD8uZHVyYXRpb25JbkZyYW1lc31gLCBbXG4gICAgcHJvcHMyLnNyYyxcbiAgICBzZXF1ZW5jZUNvbnRleHQ/LmN1bXVsYXRlZEZyb20sXG4gICAgc2VxdWVuY2VDb250ZXh0Py5yZWxhdGl2ZUZyb20sXG4gICAgc2VxdWVuY2VDb250ZXh0Py5kdXJhdGlvbkluRnJhbWVzXG4gIF0pO1xuICBpZiAoIXZpZGVvQ29uZmlnKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiTm8gdmlkZW8gY29uZmlnIGZvdW5kXCIpO1xuICB9XG4gIGNvbnN0IHZvbHVtZSA9IGV2YWx1YXRlVm9sdW1lKHtcbiAgICB2b2x1bWU6IHZvbHVtZVByb3AsXG4gICAgZnJhbWU6IHZvbHVtZVByb3BzRnJhbWUsXG4gICAgbWVkaWFWb2x1bWU6IDEsXG4gICAgYWxsb3dBbXBsaWZpY2F0aW9uRHVyaW5nUmVuZGVyOiBhbGxvd0FtcGxpZmljYXRpb25EdXJpbmdSZW5kZXIgPz8gZmFsc2VcbiAgfSk7XG4gIHVzZUVmZmVjdDI0KCgpID0+IHtcbiAgICBpZiAoIXByb3BzMi5zcmMpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIk5vIHNyYyBwYXNzZWRcIik7XG4gICAgfVxuICAgIGlmIChwcm9wczIubXV0ZWQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKHZvbHVtZSA8PSAwKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICghd2luZG93LnJlbW90aW9uX2F1ZGlvRW5hYmxlZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICByZWdpc3RlclJlbmRlckFzc2V0KHtcbiAgICAgIHR5cGU6IFwidmlkZW9cIixcbiAgICAgIHNyYzogZ2V0QWJzb2x1dGVTcmMocHJvcHMyLnNyYyksXG4gICAgICBpZCxcbiAgICAgIGZyYW1lOiBhYnNvbHV0ZUZyYW1lLFxuICAgICAgdm9sdW1lLFxuICAgICAgbWVkaWFGcmFtZTogZnJhbWUsXG4gICAgICBwbGF5YmFja1JhdGU6IHBsYXliYWNrUmF0ZSA/PyAxLFxuICAgICAgYWxsb3dBbXBsaWZpY2F0aW9uRHVyaW5nUmVuZGVyOiBhbGxvd0FtcGxpZmljYXRpb25EdXJpbmdSZW5kZXIgPz8gZmFsc2UsXG4gICAgICB0b25lRnJlcXVlbmN5OiB0b25lRnJlcXVlbmN5ID8/IG51bGwsXG4gICAgICBhdWRpb1N0YXJ0RnJhbWU6IE1hdGgubWF4KDAsIC0oc2VxdWVuY2VDb250ZXh0Py5yZWxhdGl2ZUZyb20gPz8gMCkpXG4gICAgfSk7XG4gICAgcmV0dXJuICgpID0+IHVucmVnaXN0ZXJSZW5kZXJBc3NldChpZCk7XG4gIH0sIFtcbiAgICBwcm9wczIubXV0ZWQsXG4gICAgcHJvcHMyLnNyYyxcbiAgICByZWdpc3RlclJlbmRlckFzc2V0LFxuICAgIGlkLFxuICAgIHVucmVnaXN0ZXJSZW5kZXJBc3NldCxcbiAgICB2b2x1bWUsXG4gICAgZnJhbWUsXG4gICAgYWJzb2x1dGVGcmFtZSxcbiAgICBwbGF5YmFja1JhdGUsXG4gICAgYWxsb3dBbXBsaWZpY2F0aW9uRHVyaW5nUmVuZGVyLFxuICAgIHRvbmVGcmVxdWVuY3ksXG4gICAgc2VxdWVuY2VDb250ZXh0Py5yZWxhdGl2ZUZyb21cbiAgXSk7XG4gIHVzZUltcGVyYXRpdmVIYW5kbGU4KHJlZiwgKCkgPT4ge1xuICAgIHJldHVybiB2aWRlb1JlZi5jdXJyZW50O1xuICB9LCBbXSk7XG4gIHVzZUVmZmVjdDI0KCgpID0+IHtcbiAgICBpZiAoIXdpbmRvdy5yZW1vdGlvbl92aWRlb0VuYWJsZWQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgeyBjdXJyZW50IH0gPSB2aWRlb1JlZjtcbiAgICBpZiAoIWN1cnJlbnQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgY3VycmVudFRpbWUgPSBnZXRNZWRpYVRpbWUoe1xuICAgICAgZnJhbWUsXG4gICAgICBwbGF5YmFja1JhdGU6IHBsYXliYWNrUmF0ZSB8fCAxLFxuICAgICAgc3RhcnRGcm9tOiAtbWVkaWFTdGFydHNBdCxcbiAgICAgIGZwczogdmlkZW9Db25maWcuZnBzXG4gICAgfSk7XG4gICAgY29uc3QgaGFuZGxlID0gZGVsYXlSZW5kZXIoYFJlbmRlcmluZyA8VmlkZW8gLz4gd2l0aCBzcmM9XCIke3Byb3BzMi5zcmN9XCJgLCB7XG4gICAgICByZXRyaWVzOiBkZWxheVJlbmRlclJldHJpZXMgPz8gdW5kZWZpbmVkLFxuICAgICAgdGltZW91dEluTWlsbGlzZWNvbmRzOiBkZWxheVJlbmRlclRpbWVvdXRJbk1pbGxpc2Vjb25kcyA/PyB1bmRlZmluZWRcbiAgICB9KTtcbiAgICBpZiAod2luZG93LnByb2Nlc3M/LmVudj8uTk9ERV9FTlYgPT09IFwidGVzdFwiKSB7XG4gICAgICBjb250aW51ZVJlbmRlcihoYW5kbGUpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoaXNBcHByb3hpbWF0ZWx5VGhlU2FtZShjdXJyZW50LmN1cnJlbnRUaW1lLCBjdXJyZW50VGltZSkpIHtcbiAgICAgIGlmIChjdXJyZW50LnJlYWR5U3RhdGUgPj0gMikge1xuICAgICAgICBjb250aW51ZVJlbmRlcihoYW5kbGUpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBjb25zdCBsb2FkZWREYXRhSGFuZGxlciA9ICgpID0+IHtcbiAgICAgICAgY29udGludWVSZW5kZXIoaGFuZGxlKTtcbiAgICAgIH07XG4gICAgICBjdXJyZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJsb2FkZWRkYXRhXCIsIGxvYWRlZERhdGFIYW5kbGVyLCB7IG9uY2U6IHRydWUgfSk7XG4gICAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgICBjdXJyZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJsb2FkZWRkYXRhXCIsIGxvYWRlZERhdGFIYW5kbGVyKTtcbiAgICAgIH07XG4gICAgfVxuICAgIGNvbnN0IGVuZGVkSGFuZGxlciA9ICgpID0+IHtcbiAgICAgIGNvbnRpbnVlUmVuZGVyKGhhbmRsZSk7XG4gICAgfTtcbiAgICBjb25zdCBzZWVrMiA9IHNlZWtUb1RpbWVNdWx0aXBsZVVudGlsUmlnaHQoY3VycmVudCwgY3VycmVudFRpbWUsIHZpZGVvQ29uZmlnLmZwcyk7XG4gICAgc2VlazIucHJvbS50aGVuKCgpID0+IHtcbiAgICAgIGNvbnRpbnVlUmVuZGVyKGhhbmRsZSk7XG4gICAgfSk7XG4gICAgY3VycmVudC5hZGRFdmVudExpc3RlbmVyKFwiZW5kZWRcIiwgZW5kZWRIYW5kbGVyLCB7IG9uY2U6IHRydWUgfSk7XG4gICAgY29uc3QgZXJyb3JIYW5kbGVyID0gKCkgPT4ge1xuICAgICAgaWYgKGN1cnJlbnQ/LmVycm9yKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoXCJFcnJvciBvY2N1cnJlZCBpbiB2aWRlb1wiLCBjdXJyZW50Py5lcnJvcik7XG4gICAgICAgIGlmIChvbkVycm9yKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgVGhlIGJyb3dzZXIgdGhyZXcgYW4gZXJyb3Igd2hpbGUgcGxheWluZyB0aGUgdmlkZW8gJHtwcm9wczIuc3JjfTogQ29kZSAke2N1cnJlbnQuZXJyb3IuY29kZX0gLSAke2N1cnJlbnQ/LmVycm9yPy5tZXNzYWdlfS4gU2VlIGh0dHBzOi8vcmVtb3Rpb24uZGV2L2RvY3MvbWVkaWEtcGxheWJhY2stZXJyb3IgZm9yIGhlbHAuIFBhc3MgYW4gb25FcnJvcigpIHByb3AgdG8gaGFuZGxlIHRoZSBlcnJvci5gKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIlRoZSBicm93c2VyIHRocmV3IGFuIGVycm9yXCIpO1xuICAgICAgfVxuICAgIH07XG4gICAgY3VycmVudC5hZGRFdmVudExpc3RlbmVyKFwiZXJyb3JcIiwgZXJyb3JIYW5kbGVyLCB7IG9uY2U6IHRydWUgfSk7XG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgIHNlZWsyLmNhbmNlbCgpO1xuICAgICAgY3VycmVudC5yZW1vdmVFdmVudExpc3RlbmVyKFwiZW5kZWRcIiwgZW5kZWRIYW5kbGVyKTtcbiAgICAgIGN1cnJlbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImVycm9yXCIsIGVycm9ySGFuZGxlcik7XG4gICAgICBjb250aW51ZVJlbmRlcihoYW5kbGUpO1xuICAgIH07XG4gIH0sIFtcbiAgICB2b2x1bWVQcm9wc0ZyYW1lLFxuICAgIHByb3BzMi5zcmMsXG4gICAgcGxheWJhY2tSYXRlLFxuICAgIHZpZGVvQ29uZmlnLmZwcyxcbiAgICBmcmFtZSxcbiAgICBtZWRpYVN0YXJ0c0F0LFxuICAgIG9uRXJyb3IsXG4gICAgZGVsYXlSZW5kZXJSZXRyaWVzLFxuICAgIGRlbGF5UmVuZGVyVGltZW91dEluTWlsbGlzZWNvbmRzXG4gIF0pO1xuICBjb25zdCB7IHNyYyB9ID0gcHJvcHMyO1xuICBpZiAoZW52aXJvbm1lbnQuaXNSZW5kZXJpbmcpIHtcbiAgICB1c2VMYXlvdXRFZmZlY3Q3KCgpID0+IHtcbiAgICAgIGlmICh3aW5kb3cucHJvY2Vzcz8uZW52Py5OT0RFX0VOViA9PT0gXCJ0ZXN0XCIpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgY29uc3QgbmV3SGFuZGxlID0gZGVsYXlSZW5kZXIoXCJMb2FkaW5nIDxWaWRlbz4gZHVyYXRpb24gd2l0aCBzcmM9XCIgKyBzcmMsIHtcbiAgICAgICAgcmV0cmllczogZGVsYXlSZW5kZXJSZXRyaWVzID8/IHVuZGVmaW5lZCxcbiAgICAgICAgdGltZW91dEluTWlsbGlzZWNvbmRzOiBkZWxheVJlbmRlclRpbWVvdXRJbk1pbGxpc2Vjb25kcyA/PyB1bmRlZmluZWRcbiAgICAgIH0pO1xuICAgICAgY29uc3QgeyBjdXJyZW50IH0gPSB2aWRlb1JlZjtcbiAgICAgIGNvbnN0IGRpZExvYWQgPSAoKSA9PiB7XG4gICAgICAgIGlmIChjdXJyZW50Py5kdXJhdGlvbikge1xuICAgICAgICAgIG9uRHVyYXRpb24oc3JjLCBjdXJyZW50LmR1cmF0aW9uKTtcbiAgICAgICAgfVxuICAgICAgICBjb250aW51ZVJlbmRlcihuZXdIYW5kbGUpO1xuICAgICAgfTtcbiAgICAgIGlmIChjdXJyZW50Py5kdXJhdGlvbikge1xuICAgICAgICBvbkR1cmF0aW9uKHNyYywgY3VycmVudC5kdXJhdGlvbik7XG4gICAgICAgIGNvbnRpbnVlUmVuZGVyKG5ld0hhbmRsZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjdXJyZW50Py5hZGRFdmVudExpc3RlbmVyKFwibG9hZGVkbWV0YWRhdGFcIiwgZGlkTG9hZCwgeyBvbmNlOiB0cnVlIH0pO1xuICAgICAgfVxuICAgICAgcmV0dXJuICgpID0+IHtcbiAgICAgICAgY3VycmVudD8ucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImxvYWRlZG1ldGFkYXRhXCIsIGRpZExvYWQpO1xuICAgICAgICBjb250aW51ZVJlbmRlcihuZXdIYW5kbGUpO1xuICAgICAgfTtcbiAgICB9LCBbc3JjLCBvbkR1cmF0aW9uLCBkZWxheVJlbmRlclJldHJpZXMsIGRlbGF5UmVuZGVyVGltZW91dEluTWlsbGlzZWNvbmRzXSk7XG4gIH1cbiAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqLyBqc3gzMihcInZpZGVvXCIsIHtcbiAgICByZWY6IHZpZGVvUmVmLFxuICAgIGRpc2FibGVSZW1vdGVQbGF5YmFjazogdHJ1ZSxcbiAgICAuLi5wcm9wczJcbiAgfSk7XG59O1xudmFyIFZpZGVvRm9yUmVuZGVyaW5nID0gZm9yd2FyZFJlZjEwKFZpZGVvRm9yUmVuZGVyaW5nRm9yd2FyZEZ1bmN0aW9uKTtcblxuLy8gc3JjL3ZpZGVvL1ZpZGVvLnRzeFxuaW1wb3J0IHsganN4IGFzIGpzeDMzIH0gZnJvbSBcInJlYWN0L2pzeC1ydW50aW1lXCI7XG52YXIgVmlkZW9Gb3J3YXJkaW5nRnVuY3Rpb24gPSAocHJvcHMyLCByZWYpID0+IHtcbiAgY29uc3Qge1xuICAgIHN0YXJ0RnJvbSxcbiAgICBlbmRBdCxcbiAgICBuYW1lLFxuICAgIHBhdXNlV2hlbkJ1ZmZlcmluZyxcbiAgICBzdGFjayxcbiAgICBfcmVtb3Rpb25JbnRlcm5hbE5hdGl2ZUxvb3BQYXNzZWQsXG4gICAgc2hvd0luVGltZWxpbmUsXG4gICAgb25BdXRvUGxheUVycm9yLFxuICAgIC4uLm90aGVyUHJvcHNcbiAgfSA9IHByb3BzMjtcbiAgY29uc3QgeyBsb29wLCBfcmVtb3Rpb25EZWJ1Z1NlZWtpbmcsIC4uLnByb3BzT3RoZXJUaGFuTG9vcCB9ID0gcHJvcHMyO1xuICBjb25zdCB7IGZwcyB9ID0gdXNlVmlkZW9Db25maWcoKTtcbiAgY29uc3QgZW52aXJvbm1lbnQgPSBnZXRSZW1vdGlvbkVudmlyb25tZW50KCk7XG4gIGNvbnN0IHsgZHVyYXRpb25zLCBzZXREdXJhdGlvbnMgfSA9IHVzZUNvbnRleHQzMChEdXJhdGlvbnNDb250ZXh0KTtcbiAgaWYgKHR5cGVvZiByZWYgPT09IFwic3RyaW5nXCIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJzdHJpbmcgcmVmcyBhcmUgbm90IHN1cHBvcnRlZFwiKTtcbiAgfVxuICBpZiAodHlwZW9mIHByb3BzMi5zcmMgIT09IFwic3RyaW5nXCIpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBUaGUgXFxgPFZpZGVvPlxcYCB0YWcgcmVxdWlyZXMgYSBzdHJpbmcgZm9yIFxcYHNyY1xcYCwgYnV0IGdvdCAke0pTT04uc3RyaW5naWZ5KHByb3BzMi5zcmMpfSBpbnN0ZWFkLmApO1xuICB9XG4gIGNvbnN0IHByZWxvYWRlZFNyYyA9IHVzZVByZWxvYWQocHJvcHMyLnNyYyk7XG4gIGNvbnN0IG9uRHVyYXRpb24gPSB1c2VDYWxsYmFjazE1KChzcmMsIGR1cmF0aW9uSW5TZWNvbmRzKSA9PiB7XG4gICAgc2V0RHVyYXRpb25zKHsgdHlwZTogXCJnb3QtZHVyYXRpb25cIiwgZHVyYXRpb25JblNlY29uZHMsIHNyYyB9KTtcbiAgfSwgW3NldER1cmF0aW9uc10pO1xuICBjb25zdCBvblZpZGVvRnJhbWUgPSB1c2VDYWxsYmFjazE1KCgpID0+IHtcbiAgfSwgW10pO1xuICBjb25zdCBkdXJhdGlvbkZldGNoZWQgPSBkdXJhdGlvbnNbZ2V0QWJzb2x1dGVTcmMocHJlbG9hZGVkU3JjKV0gPz8gZHVyYXRpb25zW2dldEFic29sdXRlU3JjKHByb3BzMi5zcmMpXTtcbiAgaWYgKGxvb3AgJiYgZHVyYXRpb25GZXRjaGVkICE9PSB1bmRlZmluZWQpIHtcbiAgICBjb25zdCBtZWRpYUR1cmF0aW9uID0gZHVyYXRpb25GZXRjaGVkICogZnBzO1xuICAgIHJldHVybiAvKiBAX19QVVJFX18gKi8ganN4MzMoTG9vcCwge1xuICAgICAgZHVyYXRpb25JbkZyYW1lczogY2FsY3VsYXRlTG9vcER1cmF0aW9uKHtcbiAgICAgICAgZW5kQXQsXG4gICAgICAgIG1lZGlhRHVyYXRpb24sXG4gICAgICAgIHBsYXliYWNrUmF0ZTogcHJvcHMyLnBsYXliYWNrUmF0ZSA/PyAxLFxuICAgICAgICBzdGFydEZyb21cbiAgICAgIH0pLFxuICAgICAgbGF5b3V0OiBcIm5vbmVcIixcbiAgICAgIG5hbWUsXG4gICAgICBjaGlsZHJlbjogLyogQF9fUFVSRV9fICovIGpzeDMzKFZpZGVvLCB7XG4gICAgICAgIC4uLnByb3BzT3RoZXJUaGFuTG9vcCxcbiAgICAgICAgcmVmLFxuICAgICAgICBfcmVtb3Rpb25JbnRlcm5hbE5hdGl2ZUxvb3BQYXNzZWQ6IHRydWVcbiAgICAgIH0pXG4gICAgfSk7XG4gIH1cbiAgaWYgKHR5cGVvZiBzdGFydEZyb20gIT09IFwidW5kZWZpbmVkXCIgfHwgdHlwZW9mIGVuZEF0ICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgdmFsaWRhdGVTdGFydEZyb21Qcm9wcyhzdGFydEZyb20sIGVuZEF0KTtcbiAgICBjb25zdCBzdGFydEZyb21GcmFtZU5vID0gc3RhcnRGcm9tID8/IDA7XG4gICAgY29uc3QgZW5kQXRGcmFtZU5vID0gZW5kQXQgPz8gSW5maW5pdHk7XG4gICAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqLyBqc3gzMyhTZXF1ZW5jZSwge1xuICAgICAgbGF5b3V0OiBcIm5vbmVcIixcbiAgICAgIGZyb206IDAgLSBzdGFydEZyb21GcmFtZU5vLFxuICAgICAgc2hvd0luVGltZWxpbmU6IGZhbHNlLFxuICAgICAgZHVyYXRpb25JbkZyYW1lczogZW5kQXRGcmFtZU5vLFxuICAgICAgbmFtZSxcbiAgICAgIGNoaWxkcmVuOiAvKiBAX19QVVJFX18gKi8ganN4MzMoVmlkZW8sIHtcbiAgICAgICAgcGF1c2VXaGVuQnVmZmVyaW5nOiBwYXVzZVdoZW5CdWZmZXJpbmcgPz8gZmFsc2UsXG4gICAgICAgIC4uLm90aGVyUHJvcHMsXG4gICAgICAgIHJlZlxuICAgICAgfSlcbiAgICB9KTtcbiAgfVxuICB2YWxpZGF0ZU1lZGlhUHJvcHMocHJvcHMyLCBcIlZpZGVvXCIpO1xuICBpZiAoZW52aXJvbm1lbnQuaXNSZW5kZXJpbmcpIHtcbiAgICByZXR1cm4gLyogQF9fUFVSRV9fICovIGpzeDMzKFZpZGVvRm9yUmVuZGVyaW5nLCB7XG4gICAgICBvbkR1cmF0aW9uLFxuICAgICAgb25WaWRlb0ZyYW1lOiBvblZpZGVvRnJhbWUgPz8gbnVsbCxcbiAgICAgIC4uLm90aGVyUHJvcHMsXG4gICAgICByZWZcbiAgICB9KTtcbiAgfVxuICByZXR1cm4gLyogQF9fUFVSRV9fICovIGpzeDMzKFZpZGVvRm9yUHJldmlldywge1xuICAgIG9ubHlXYXJuRm9yTWVkaWFTZWVraW5nRXJyb3I6IGZhbHNlLFxuICAgIC4uLm90aGVyUHJvcHMsXG4gICAgcmVmLFxuICAgIG9uVmlkZW9GcmFtZTogbnVsbCxcbiAgICBwYXVzZVdoZW5CdWZmZXJpbmc6IHBhdXNlV2hlbkJ1ZmZlcmluZyA/PyBmYWxzZSxcbiAgICBvbkR1cmF0aW9uLFxuICAgIF9yZW1vdGlvbkludGVybmFsU3RhY2s6IHN0YWNrID8/IG51bGwsXG4gICAgX3JlbW90aW9uSW50ZXJuYWxOYXRpdmVMb29wUGFzc2VkOiBfcmVtb3Rpb25JbnRlcm5hbE5hdGl2ZUxvb3BQYXNzZWQgPz8gZmFsc2UsXG4gICAgX3JlbW90aW9uRGVidWdTZWVraW5nOiBfcmVtb3Rpb25EZWJ1Z1NlZWtpbmcgPz8gZmFsc2UsXG4gICAgc2hvd0luVGltZWxpbmU6IHNob3dJblRpbWVsaW5lID8/IHRydWUsXG4gICAgb25BdXRvUGxheUVycm9yOiBvbkF1dG9QbGF5RXJyb3IgPz8gdW5kZWZpbmVkXG4gIH0pO1xufTtcbnZhciBWaWRlbyA9IGZvcndhcmRSZWYxMShWaWRlb0ZvcndhcmRpbmdGdW5jdGlvbik7XG5hZGRTZXF1ZW5jZVN0YWNrVHJhY2VzKFZpZGVvKTtcbi8vIHNyYy9pbmRleC50c1xuY2hlY2tNdWx0aXBsZVJlbW90aW9uVmVyc2lvbnMoKTtcbnZhciBFeHBlcmltZW50YWwgPSB7XG4gIENsaXBwZXIsXG4gIE51bGwsXG4gIHVzZUlzUGxheWVyXG59O1xudmFyIHByb3h5T2JqID0ge307XG52YXIgQ29uZmlnID0gbmV3IFByb3h5KHByb3h5T2JqLCB7XG4gIGdldChfLCBwcm9wKSB7XG4gICAgaWYgKHByb3AgPT09IFwiQnVuZGxpbmdcIiB8fCBwcm9wID09PSBcIlJlbmRlcmluZ1wiIHx8IHByb3AgPT09IFwiTG9nXCIgfHwgcHJvcCA9PT0gXCJQdXBwZXRlZXJcIiB8fCBwcm9wID09PSBcIk91dHB1dFwiKSB7XG4gICAgICByZXR1cm4gQ29uZmlnO1xuICAgIH1cbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgY29uc29sZS53YXJuKFwiXFx1MjZBMFxcdUZFMEYgIFRoZSBDTEkgY29uZmlndXJhdGlvbiBoYXMgYmVlbiBleHRyYWN0ZWQgZnJvbSBSZW1vdGlvbiBDb3JlLlwiKTtcbiAgICAgIGNvbnNvbGUud2FybihcIlVwZGF0ZSB0aGUgaW1wb3J0IGZyb20gdGhlIGNvbmZpZyBmaWxlOlwiKTtcbiAgICAgIGNvbnNvbGUud2FybigpO1xuICAgICAgY29uc29sZS53YXJuKFwiLSBEZWxldGU6XCIpO1xuICAgICAgY29uc29sZS53YXJuKCdpbXBvcnQge0NvbmZpZ30gZnJvbSBcInJlbW90aW9uXCI7Jyk7XG4gICAgICBjb25zb2xlLndhcm4oXCIrIFJlcGxhY2U6XCIpO1xuICAgICAgY29uc29sZS53YXJuKCdpbXBvcnQge0NvbmZpZ30gZnJvbSBcIkByZW1vdGlvbi9jbGkvY29uZmlnXCI7Jyk7XG4gICAgICBjb25zb2xlLndhcm4oKTtcbiAgICAgIGNvbnNvbGUud2FybihcIkZvciBtb3JlIGluZm9ybWF0aW9uLCBzZWUgaHR0cHM6Ly93d3cucmVtb3Rpb24uZGV2L2RvY3MvNC0wLW1pZ3JhdGlvbi5cIik7XG4gICAgICBwcm9jZXNzLmV4aXQoMSk7XG4gICAgfTtcbiAgfVxufSk7XG5hZGRTZXF1ZW5jZVN0YWNrVHJhY2VzKFNlcXVlbmNlKTtcbmV4cG9ydCB7XG4gIHdhdGNoU3RhdGljRmlsZSxcbiAgdXNlVmlkZW9Db25maWcsXG4gIHVzZUN1cnJlbnRTY2FsZSxcbiAgdXNlQ3VycmVudEZyYW1lLFxuICB1c2VCdWZmZXJTdGF0ZSxcbiAgc3RhdGljRmlsZSxcbiAgc3ByaW5nLFxuICByZWdpc3RlclJvb3QsXG4gIHJhbmRvbSxcbiAgcHJlZmV0Y2gsXG4gIG1lYXN1cmVTcHJpbmcsXG4gIGludGVycG9sYXRlQ29sb3JzLFxuICBpbnRlcnBvbGF0ZSxcbiAgZ2V0U3RhdGljRmlsZXMsXG4gIGdldFJlbW90aW9uRW52aXJvbm1lbnQsXG4gIGdldElucHV0UHJvcHMsXG4gIGRlbGF5UmVuZGVyLFxuICBjb250aW51ZVJlbmRlcixcbiAgY2FuY2VsUmVuZGVyLFxuICBWaWRlbyxcbiAgVkVSU0lPTixcbiAgU3RpbGwsXG4gIFNlcmllcyxcbiAgU2VxdWVuY2UsXG4gIE9mZnRocmVhZFZpZGVvLFxuICBMb29wLFxuICBJbnRlcm5hbHMsXG4gIEltZyxcbiAgSUZyYW1lLFxuICBGcmVlemUsXG4gIEZvbGRlckNvbnRleHQsXG4gIEZvbGRlcixcbiAgRXhwZXJpbWVudGFsLFxuICBFYXNpbmcsXG4gIENvbmZpZyxcbiAgQ29tcG9zaXRpb24sXG4gIEF1ZGlvLFxuICBBcnRpZmFjdCxcbiAgQWJzb2x1dGVGaWxsXG59O1xuIl0sIm5hbWVzIjpbIl9fZGVmUHJvcCIsIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiX19leHBvcnQiLCJ0YXJnZXQiLCJhbGwiLCJuYW1lIiwiZ2V0IiwiZW51bWVyYWJsZSIsImNvbmZpZ3VyYWJsZSIsInNldCIsIm5ld1ZhbHVlIiwiY3JlYXRlQ29udGV4dCIsImVyciIsIkVycm9yIiwiam9pbiIsInVzZUNvbnRleHQiLCJ1c2VFZmZlY3QiLCJjcmVhdGVDb250ZXh0MiIsInVzZUxheW91dEVmZmVjdCIsInVzZU1lbW8iLCJ1c2VTdGF0ZSIsImpzeCIsIk5hdGl2ZUxheWVyc0NvbnRleHQiLCJzZXRDbGlwUmVnaW9uIiwiY2xpcFJlZ2lvbiIsIk5hdGl2ZUxheWVyc1Byb3ZpZGVyIiwiY2hpbGRyZW4iLCJjb250ZXh0Iiwid2luZG93IiwicmVtb3Rpb25fZ2V0Q2xpcFJlZ2lvbiIsIlByb3ZpZGVyIiwidmFsdWUiLCJDbGlwcGVyIiwiaGVpZ2h0Iiwid2lkdGgiLCJ4IiwieSIsImMiLCJSZWFjdCIsImdldE5vZGVFbnZTdHJpbmciLCJnZXRFbnZTdHJpbmciLCJnZXRSZW1vdGlvbkVudmlyb25tZW50IiwiaXNQbGF5ZXIiLCJyZW1vdGlvbl9pc1BsYXllciIsImlzUmVuZGVyaW5nIiwicHJvY2VzcyIsImVudiIsInJlbW90aW9uX3B1cHBldGVlclRpbWVvdXQiLCJpc1N0dWRpbyIsInJlbW90aW9uX2lzU3R1ZGlvIiwib3JpZ2luYWxDcmVhdGVFbGVtZW50IiwiY3JlYXRlRWxlbWVudCIsImNvbXBvbmVudHNUb0FkZFN0YWNrc1RvIiwiZW5hYmxlU2VxdWVuY2VTdGFja1RyYWNlcyIsInByb3h5IiwiUHJveHkiLCJhcHBseSIsInRoaXNBcmciLCJhcmdBcnJheSIsImluY2x1ZGVzIiwiZmlyc3QiLCJwcm9wcyIsInJlc3QiLCJuZXdQcm9wcyIsInN0YWNrIiwiUmVmbGVjdCIsImFkZFNlcXVlbmNlU3RhY2tUcmFjZXMiLCJjb21wb25lbnQiLCJwdXNoIiwiY3JlYXRlQ29udGV4dDMiLCJ1c2VDb250ZXh0MiIsImpzeDIiLCJJc1BsYXllckNvbnRleHQiLCJJc1BsYXllckNvbnRleHRQcm92aWRlciIsInVzZUlzUGxheWVyIiwidHJ1dGh5IiwiQm9vbGVhbiIsIlZFUlNJT04iLCJjaGVja011bHRpcGxlUmVtb3Rpb25WZXJzaW9ucyIsImdsb2JhbFRoaXMiLCJhbHJlYWR5SW1wb3J0ZWQiLCJyZW1vdGlvbl9pbXBvcnRlZCIsIlR5cGVFcnJvciIsImZpbHRlciIsInVzZUNvbnRleHQzIiwidXNlRWZmZWN0MiIsIk51bGwiLCJmb3J3YXJkUmVmIiwiZm9yd2FyZFJlZjIiLCJ1c2VDb250ZXh0MTIiLCJ1c2VFZmZlY3Q1IiwidXNlTWVtbzEwIiwidXNlU3RhdGU1IiwidXNlTWVtbzIiLCJqc3gzIiwiQWJzb2x1dGVGaWxsUmVmRm9yd2FyZGluZyIsInJlZiIsInN0eWxlIiwib3RoZXIiLCJhY3R1YWxTdHlsZSIsInBvc2l0aW9uIiwidG9wIiwibGVmdCIsInJpZ2h0IiwiYm90dG9tIiwiZGlzcGxheSIsImZsZXhEaXJlY3Rpb24iLCJBYnNvbHV0ZUZpbGwiLCJjcmVhdGVDb250ZXh0NCIsIlNlcXVlbmNlQ29udGV4dCIsIlJlYWN0MyIsInVzZUNhbGxiYWNrIiwidXNlTWVtbzMiLCJ1c2VTdGF0ZTIiLCJqc3g0IiwiU2VxdWVuY2VNYW5hZ2VyIiwicmVnaXN0ZXJTZXF1ZW5jZSIsInVucmVnaXN0ZXJTZXF1ZW5jZSIsInNlcXVlbmNlcyIsIlNlcXVlbmNlVmlzaWJpbGl0eVRvZ2dsZUNvbnRleHQiLCJoaWRkZW4iLCJzZXRIaWRkZW4iLCJTZXF1ZW5jZU1hbmFnZXJQcm92aWRlciIsInNldFNlcXVlbmNlcyIsInNlcSIsInNlcXMiLCJzIiwiaWQiLCJzZXF1ZW5jZUNvbnRleHQiLCJoaWRkZW5Db250ZXh0IiwiY3JlYXRlQ29udGV4dDUiLCJ1c2VDb250ZXh0NCIsInVzZUVmZmVjdDMiLCJ1c2VSZWYiLCJ1c2VTdGF0ZTMiLCJOb25jZUNvbnRleHQiLCJnZXROb25jZSIsImZhc3RSZWZyZXNoZXMiLCJ1c2VOb25jZSIsIm5vbmNlIiwic2V0Tm9uY2UiLCJsYXN0Q29udGV4dCIsImN1cnJlbnQiLCJleHBvcnRzX3RpbWVsaW5lX3Bvc2l0aW9uX3N0YXRlIiwidXNlVGltZWxpbmVTZXRGcmFtZSIsInVzZVRpbWVsaW5lUG9zaXRpb24iLCJ1c2VQbGF5aW5nU3RhdGUiLCJwZXJzaXN0Q3VycmVudEZyYW1lIiwiZ2V0SW5pdGlhbEZyYW1lU3RhdGUiLCJnZXRGcmFtZUZvckNvbXBvc2l0aW9uIiwiVGltZWxpbmVDb250ZXh0IiwiU2V0VGltZWxpbmVDb250ZXh0IiwiY3JlYXRlQ29udGV4dDkiLCJ1c2VDb250ZXh0NyIsInVzZU1lbW83IiwidXNlQ29udGV4dDYiLCJ1c2VNZW1vNiIsImNyZWF0ZUNvbnRleHQ2IiwiQ29tcG9zaXRpb25NYW5hZ2VyIiwiY29tcG9zaXRpb25zIiwicmVnaXN0ZXJDb21wb3NpdGlvbiIsInVucmVnaXN0ZXJDb21wb3NpdGlvbiIsInJlZ2lzdGVyRm9sZGVyIiwidW5yZWdpc3RlckZvbGRlciIsInNldEN1cnJlbnRDb21wb3NpdGlvbk1ldGFkYXRhIiwidXBkYXRlQ29tcG9zaXRpb25EZWZhdWx0UHJvcHMiLCJmb2xkZXJzIiwiY3VycmVudENvbXBvc2l0aW9uTWV0YWRhdGEiLCJjYW52YXNDb250ZW50Iiwic2V0Q2FudmFzQ29udGVudCIsImNyZWF0ZUNvbnRleHQ4IiwiY3JlYXRlUmVmIiwidXNlQ2FsbGJhY2szIiwidXNlQ29udGV4dDUiLCJ1c2VFZmZlY3Q0IiwidXNlSW1wZXJhdGl2ZUhhbmRsZSIsInVzZUltcGVyYXRpdmVIYW5kbGUyIiwidXNlTWVtbzUiLCJ1c2VTdGF0ZTQiLCJSZWFjdDQiLCJjcmVhdGVDb250ZXh0NyIsInVzZUNhbGxiYWNrMiIsInVzZU1lbW80IiwianN4NSIsIkVkaXRvclByb3BzQ29udGV4dCIsInVwZGF0ZVByb3BzIiwicmVzZXRVbnNhdmVkIiwiZWRpdG9yUHJvcHNQcm92aWRlclJlZiIsIkVkaXRvclByb3BzUHJvdmlkZXIiLCJzZXRQcm9wcyIsImRlZmF1bHRQcm9wcyIsInByZXYiLCJnZXRQcm9wcyIsImN0eCIsInByb2JsZW1hdGljQ2hhcmFjdGVycyIsImRpZFdhcm4iLCJ3YXJuT25jZSIsIm1lc3NhZ2UiLCJjb25zb2xlIiwid2FybiIsImluY2x1ZGVzSGV4T2ZVbnNhZmVDaGFyIiwicGF0aCIsImtleSIsImtleXMiLCJjb250YWluc0hleCIsImhleENvZGUiLCJ0cmltTGVhZGluZ1NsYXNoIiwic3RhcnRzV2l0aCIsInN1YnN0cmluZyIsImlubmVyIiwicmVtb3Rpb25fc3RhdGljQmFzZSIsImVuY29kZUJ5U3BsaXR0aW5nIiwic3BsaXRCeVNsYXNoIiwic3BsaXQiLCJlbmNvZGVkQXJyYXkiLCJtYXAiLCJlbGVtZW50IiwiZW5jb2RlVVJJQ29tcG9uZW50IiwibWVyZ2VkIiwic3RhdGljRmlsZSIsImluY2x1ZGVzSGV4IiwicHJlcHJvY2Vzc2VkIiwicHJlcGFyc2VkIiwiREFURV9UT0tFTiIsIkZJTEVfVE9LRU4iLCJzZXJpYWxpemVKU09OV2l0aERhdGUiLCJkYXRhIiwiaW5kZW50Iiwic3RhdGljQmFzZSIsImN1c3RvbURhdGVVc2VkIiwiY3VzdG9tRmlsZVVzZWQiLCJtYXBVc2VkIiwic2V0VXNlZCIsInNlcmlhbGl6ZWRTdHJpbmciLCJKU09OIiwic3RyaW5naWZ5IiwiaXRlbSIsIkRhdGUiLCJ0b0lTT1N0cmluZyIsIk1hcCIsIlNldCIsInJlcGxhY2UiLCJkZXNlcmlhbGl6ZUpTT05XaXRoQ3VzdG9tRmllbGRzIiwicGFyc2UiLCJfIiwic2VyaWFsaXplVGhlbkRlc2VyaWFsaXplSW5TdHVkaW8iLCJkaWRXYXJuU1NSSW1wb3J0Iiwid2Fybk9uY2VTU1JJbXBvcnQiLCJnZXRJbnB1dFByb3BzIiwicGFyYW0iLCJyZW1vdGlvbl9pbnB1dFByb3BzIiwicGFyc2VkIiwidmFsaWRDb2RlY3MiLCJ2YWxpZGF0ZURlZmF1bHRDb2RlYyIsImRlZmF1bHRDb2RlYyIsImxvY2F0aW9uIiwidmFsaWRhdGVEaW1lbnNpb24iLCJhbW91bnQiLCJuYW1lT2ZQcm9wIiwiaXNOYU4iLCJOdW1iZXIiLCJpc0Zpbml0ZSIsInZhbGlkYXRlRHVyYXRpb25JbkZyYW1lcyIsImR1cmF0aW9uSW5GcmFtZXMiLCJvcHRpb25zIiwiYWxsb3dGbG9hdHMiLCJ2YWxpZGF0ZUZwcyIsImZwcyIsImlzR2lmIiwidmFsaWRhdGVDYWxjdWxhdGVkIiwiY2FsY3VsYXRlZCIsImNvbXBvc2l0aW9uSWQiLCJjb21wb3NpdGlvbkZwcyIsImNvbXBvc2l0aW9uSGVpZ2h0IiwiY29tcG9zaXRpb25XaWR0aCIsImNvbXBvc2l0aW9uRHVyYXRpb25JbkZyYW1lcyIsImNhbGN1bGF0ZU1ldGFkYXRhRXJyb3JMb2NhdGlvbiIsImRlZmF1bHRFcnJvckxvY2F0aW9uIiwidW5kZWZpbmVkIiwicmVzb2x2ZVZpZGVvQ29uZmlnIiwiY2FsY3VsYXRlTWV0YWRhdGEiLCJzaWduYWwiLCJvcmlnaW5hbFByb3BzIiwiY2FsY3VsYXRlZFByb20iLCJhYm9ydFNpZ25hbCIsInRoZW4iLCJyZXNvbHZlVmlkZW9Db25maWdPckNhdGNoIiwicGFyYW1zIiwicHJvbWlzZU9yUmV0dXJuVmFsdWUiLCJ0eXBlIiwicmVzdWx0IiwiZXJyb3IiLCJqc3g2IiwiUmVzb2x2ZUNvbXBvc2l0aW9uQ29udGV4dCIsInJlc29sdmVDb21wb3NpdGlvbnNSZWYiLCJuZWVkc1Jlc29sdXRpb24iLCJjb21wb3NpdGlvbiIsIlBST1BTX1VQREFURURfRVhURVJOQUxMWSIsIlJlc29sdmVDb21wb3NpdGlvbkNvbmZpZyIsImN1cnJlbnRSZW5kZXJNb2RhbENvbXBvc2l0aW9uIiwic2V0Q3VycmVudFJlbmRlck1vZGFsQ29tcG9zaXRpb24iLCJzZWxlY3RlZENvbXBvc2l0aW9uIiwiZmluZCIsInJlbmRlck1vZGFsQ29tcG9zaXRpb24iLCJhbGxFZGl0b3JQcm9wcyIsImlucHV0UHJvcHMiLCJyZXNvbHZlZENvbmZpZ3MiLCJzZXRSZXNvbHZlZENvbmZpZ3MiLCJzZWxlY3RlZEVkaXRvclByb3BzIiwicmVuZGVyTW9kYWxQcm9wcyIsImhhc1Jlc29sdXRpb24iLCJkb1Jlc29sdXRpb24iLCJjb21iaW5lZFByb3BzIiwiY29udHJvbGxlciIsIkFib3J0Q29udHJvbGxlciIsInIiLCJwcm9tT3JOb3QiLCJhYm9ydGVkIiwiY2F0Y2giLCJjdXJyZW50Q29tcG9zaXRpb24iLCJyZWxvYWRDdXJyZW50bHlTZWxlY3RlZENvbXBvc2l0aW9uIiwiZWRpdG9yUHJvcHMiLCJpc1RoZVNhbWUiLCJjdXJyZW50RGVmYXVsdFByb3BzIiwiY2FuUmVzb2x2ZSIsInNob3VsZElnbm9yZVVwZGF0ZSIsInJlbW90aW9uX2lnbm9yZUZhc3RSZWZyZXNoVXBkYXRlIiwiYWJvcnQiLCJkaXNwYXRjaEV2ZW50IiwiQ3VzdG9tRXZlbnQiLCJyZXNvbHZlZENvbmZpZ3NJbmNsdWRpbmdTdGF0aWNPbmVzIiwic3RhdGljQ29tcHMiLCJyZWR1Y2UiLCJhY2MiLCJjdXJyIiwidXNlUmVzb2x2ZWRWaWRlb0NvbmZpZyIsInByZWZlcnJlZENvbXBvc2l0aW9uSWQiLCJ1c2VWaWRlbyIsInNlbGVjdGVkIiwicmVzb2x2ZWQiLCJmcmFtZSIsInBsYXlpbmciLCJwbGF5YmFja1JhdGUiLCJyb290SWQiLCJpbXBlcmF0aXZlUGxheWluZyIsInNldFBsYXliYWNrUmF0ZSIsImF1ZGlvQW5kVmlkZW9UYWdzIiwic2V0RnJhbWUiLCJzZXRQbGF5aW5nIiwibWFrZUtleSIsInRpbWUiLCJsb2NhbFN0b3JhZ2UiLCJzZXRJdGVtIiwiZ2V0SXRlbSIsIm9iaiIsInJlbW90aW9uX2luaXRpYWxGcmFtZSIsInZpZGVvQ29uZmlnIiwic3RhdGUiLCJ1bmNsYW1wZWQiLCJNYXRoIiwibWluIiwidXNlQ29udGV4dDkiLCJjcmVhdGVDb250ZXh0MTAiLCJqc3g3IiwiQ2FuVXNlUmVtb3Rpb25Ib29rcyIsIkNhblVzZVJlbW90aW9uSG9va3NQcm92aWRlciIsInVzZUNvbnRleHQ4IiwidXNlTWVtbzgiLCJ1c2VVbnNhZmVWaWRlb0NvbmZpZyIsImN0eFdpZHRoIiwiY3R4SGVpZ2h0IiwiY3R4RHVyYXRpb24iLCJ2aWRlbyIsInVzZVZpZGVvQ29uZmlnIiwidXNlQ29udGV4dDExIiwidXNlTWVtbzkiLCJ1c2VDb250ZXh0MTAiLCJ1c2VDdXJyZW50RnJhbWUiLCJjYW5Vc2VSZW1vdGlvbkhvb2tzIiwiY29udGV4dE9mZnNldCIsImN1bXVsYXRlZEZyb20iLCJyZWxhdGl2ZUZyb20iLCJqc3g4IiwiRnJlZXplIiwiZnJhbWVUb0ZyZWV6ZSIsImFjdGl2ZSIsImlzQWN0aXZlIiwidGltZWxpbmVDb250ZXh0IiwidGltZWxpbmVWYWx1ZSIsImpzeDkiLCJSZWd1bGFyU2VxdWVuY2VSZWZGb3J3YXJkaW5nRnVuY3Rpb24iLCJmcm9tIiwiSW5maW5pdHkiLCJzaG93SW5UaW1lbGluZSIsIl9yZW1vdGlvbkludGVybmFsTG9vcERpc3BsYXkiLCJsb29wRGlzcGxheSIsIl9yZW1vdGlvbkludGVybmFsU3RhY2siLCJfcmVtb3Rpb25JbnRlcm5hbFByZW1vdW50RGlzcGxheSIsInByZW1vdW50RGlzcGxheSIsImxheW91dCIsIlN0cmluZyIsInJhbmRvbSIsInBhcmVudFNlcXVlbmNlIiwiYWJzb2x1dGVGcmFtZSIsInBhcmVudFNlcXVlbmNlRHVyYXRpb24iLCJhY3R1YWxEdXJhdGlvbkluRnJhbWVzIiwibWF4IiwicHJlbW91bnRpbmciLCJfcmVtb3Rpb25JbnRlcm5hbElzUHJlbW91bnRpbmciLCJjb250ZXh0VmFsdWUiLCJwYXJlbnRGcm9tIiwidGltZWxpbmVDbGlwTmFtZSIsImR1cmF0aW9uIiwiZGlzcGxheU5hbWUiLCJwYXJlbnQiLCJlbmRUaHJlc2hvbGQiLCJjZWlsIiwiY29udGVudCIsInN0eWxlSWZUaGVyZSIsImRlZmF1bHRTdHlsZSIsImlzU2VxdWVuY2VIaWRkZW4iLCJjbGFzc05hbWUiLCJSZWd1bGFyU2VxdWVuY2UiLCJQcmVtb3VudGVkU2VxdWVuY2VSZWZGb3J3YXJkaW5nRnVuY3Rpb24iLCJwYXNzZWRTdHlsZSIsInByZW1vdW50Rm9yIiwib3RoZXJQcm9wcyIsInByZW1vdW50aW5nQWN0aXZlIiwib3BhY2l0eSIsInBvaW50ZXJFdmVudHMiLCJTZXF1ZW5jZSIsIlByZW1vdW50ZWRTZXF1ZW5jZSIsIlNlcXVlbmNlUmVmRm9yd2FyZGluZ0Z1bmN0aW9uIiwidXNlQ29udGV4dDEzIiwidXNlRWZmZWN0NiIsInVzZVN0YXRlNyIsImNyZWF0ZUNvbnRleHQxMSIsInVzZUNhbGxiYWNrNCIsInVzZUxheW91dEVmZmVjdDIiLCJ1c2VNZW1vMTEiLCJ1c2VTdGF0ZTYiLCJ2YWxpZGF0ZUFydGlmYWN0RmlsZW5hbWUiLCJmaWxlbmFtZSIsInRyaW0iLCJtYXRjaCIsInZhbGlkYXRlQ29udGVudCIsIlVpbnQ4QXJyYXkiLCJ2YWxpZGF0ZVJlbmRlckFzc2V0IiwiYXJ0aWZhY3QiLCJqc3gxMCIsIlJlbmRlckFzc2V0TWFuYWdlciIsInJlZ2lzdGVyUmVuZGVyQXNzZXQiLCJ1bnJlZ2lzdGVyUmVuZGVyQXNzZXQiLCJyZW5kZXJBc3NldHMiLCJSZW5kZXJBc3NldE1hbmFnZXJQcm92aWRlciIsInNldFJlbmRlckFzc2V0cyIsInJlbmRlckFzc2V0IiwiYXNzZXRzIiwiYXNzdHMiLCJhIiwicmVtb3Rpb25fY29sbGVjdEFzc2V0cyIsIkFydGlmYWN0IiwiYnRvYSIsIlRleHREZWNvZGVyIiwiZGVjb2RlIiwiYmluYXJ5IiwiZm9yd2FyZFJlZjUiLCJ1c2VDYWxsYmFjazkiLCJ1c2VDb250ZXh0MjMiLCJnZXRBYnNvbHV0ZVNyYyIsInJlbGF0aXZlU3JjIiwiVVJMIiwib3JpZ2luIiwiaHJlZiIsImNhbGN1bGF0ZUxvb3BEdXJhdGlvbiIsImVuZEF0IiwibWVkaWFEdXJhdGlvbiIsInN0YXJ0RnJvbSIsImFjdHVhbER1cmF0aW9uIiwiZmxvb3IiLCJjYW5jZWxSZW5kZXIiLCJpc0Vycm9yTGlrZSIsInJlbW90aW9uX2NhbmNlbGxlZEVycm9yIiwiUmVhY3Q4IiwiY3JlYXRlQ29udGV4dDEyIiwidXNlTWVtbzEyIiwianN4MTEiLCJMb29wQ29udGV4dCIsInVzZUxvb3AiLCJMb29wIiwidGltZXMiLCJjdXJyZW50RnJhbWUiLCJjb21wRHVyYXRpb24iLCJtYXhUaW1lcyIsImFjdHVhbFRpbWVzIiwibWF4RnJhbWUiLCJpdGVyYXRpb24iLCJzdGFydCIsIm51bWJlck9mVGltZXMiLCJzdGFydE9mZnNldCIsImxvb3BDb250ZXh0IiwidXNlQ29udGV4dDE0IiwiY3JlYXRlQ29udGV4dDEzIiwidXNlRWZmZWN0NyIsInVzZVN0YXRlOCIsImpzeDEyIiwiUHJlbG9hZENvbnRleHQiLCJwcmVsb2FkcyIsInVwZGF0ZXJzIiwic2V0UHJlbG9hZHMiLCJ1cGRhdGVyIiwiZm9yRWFjaCIsInUiLCJQcmVmZXRjaFByb3ZpZGVyIiwiX3ByZWxvYWRzIiwiX3NldFByZWxvYWRzIiwidXBkYXRlckZ1bmN0aW9uIiwidXNlUHJlbG9hZCIsInNyYyIsInByZWxvYWRzMiIsImJsb2JUb0Jhc2U2NCIsImJsb2IiLCJyZWFkZXIiLCJGaWxlUmVhZGVyIiwiUHJvbWlzZSIsInJlc29sdmUiLCJyZWplY3QiLCJvbmxvYWQiLCJkYXRhVXJsIiwib25lcnJvciIsInJlYWRBc0RhdGFVUkwiLCJnZXRCbG9iRnJvbVJlYWRlciIsImNvbnRlbnRUeXBlIiwiY29udGVudExlbmd0aCIsIm9uUHJvZ3Jlc3MiLCJyZWNlaXZlZExlbmd0aCIsImNodW5rcyIsImRvbmUiLCJyZWFkIiwibGVuZ3RoIiwibG9hZGVkQnl0ZXMiLCJ0b3RhbEJ5dGVzIiwiY2h1bmtzQWxsIiwiY2h1bmsiLCJCbG9iIiwicHJlZmV0Y2giLCJtZXRob2QiLCJmcmVlIiwid2FpdFVudGlsRG9uZSIsImNhbmNlbGVkIiwib2JqZWN0VXJsIiwicmVzIiwicmVqIiwiY2FuQmVBYm9ydGVkIiwiZmV0Y2giLCJvayIsInN0YXR1cyIsImhlYWRlckNvbnRlbnRUeXBlIiwiaGVhZGVycyIsImhhc1Byb3BlckNvbnRlbnRUeXBlIiwiYm9keSIsImdldFJlYWRlciIsInBhcnNlSW50IiwiYnVmIiwiYWN0dWFsQmxvYiIsImNyZWF0ZU9iamVjdFVSTCIsInVybCIsInAiLCJyZXZva2VPYmplY3RVUkwiLCJjb3B5IiwiZSIsInZhbGlkYXRlTWVkaWFQcm9wcyIsInZvbHVtZSIsInZhbGlkYXRlU3RhcnRGcm9tUHJvcHMiLCJjcmVhdGVDb250ZXh0MTQiLCJ1c2VNZW1vMTMiLCJ1c2VSZWR1Y2VyIiwianN4MTMiLCJkdXJhdGlvblJlZHVjZXIiLCJhY3Rpb24iLCJhYnNvbHV0ZVNyYyIsImR1cmF0aW9uSW5TZWNvbmRzIiwiRHVyYXRpb25zQ29udGV4dCIsImR1cmF0aW9ucyIsInNldER1cmF0aW9ucyIsIkR1cmF0aW9uc0NvbnRleHRQcm92aWRlciIsImZvcndhcmRSZWYzIiwidXNlQ29udGV4dDIxIiwidXNlRWZmZWN0MTYiLCJ1c2VJbXBlcmF0aXZlSGFuZGxlMyIsInVzZU1lbW8yMCIsInVzZVJlZjgiLCJ1c2VTdGF0ZTE0IiwibXVsYmVycnkzMiIsInQiLCJpbXVsIiwiaGFzaENvZGUiLCJzdHIiLCJpIiwiY2hyIiwiaGFzaCIsImNoYXJDb2RlQXQiLCJzZWVkIiwiZHVtbXkiLCJ1c2VDb250ZXh0MTYiLCJ1c2VFZmZlY3Q4IiwidXNlTWVtbzE0IiwidXNlU3RhdGU5IiwidXNlQ29udGV4dDE1IiwidXNlTWVkaWFTdGFydHNBdCIsInN0YXJ0c0F0IiwidXNlRnJhbWVGb3JWb2x1bWVQcm9wIiwiYmVoYXZpb3IiLCJsb29wIiwiZ2V0QXNzZXREaXNwbGF5TmFtZSIsInRlc3QiLCJzcGxpdHRlZCIsImZsYXQiLCJwbGF5QW5kSGFuZGxlTm90QWxsb3dlZEVycm9yIiwibWVkaWFSZWYiLCJtZWRpYVR5cGUiLCJvbkF1dG9QbGF5RXJyb3IiLCJwcm9tIiwicGxheSIsImxvZyIsIm11dGVkIiwiZXZhbHVhdGVWb2x1bWUiLCJtZWRpYVZvbHVtZSIsImFsbG93QW1wbGlmaWNhdGlvbkR1cmluZ1JlbmRlciIsIm1heFZvbHVtZSIsImV2YWx1YXRlZCIsImRpZFdhcm4yIiwid2Fybk9uY2UyIiwidXNlTWVkaWFJblRpbWVsaW5lIiwiYWN0dWFsRnJvbSIsImluaXRpYWxWb2x1bWUiLCJkb2VzVm9sdW1lQ2hhbmdlIiwidm9sdW1lcyIsIkFycmF5IiwiZmlsbCIsIk5PREVfRU5WIiwic3RhcnRNZWRpYUZyb20iLCJ0YWciLCJ1c2VDYWxsYmFjazciLCJ1c2VDb250ZXh0MTgiLCJ1c2VFZmZlY3QxMiIsInVzZVJlZjYiLCJ1c2VDYWxsYmFjazYiLCJ1c2VNZW1vMTciLCJ1c2VSZWYzIiwidXNlQ29udGV4dDE3IiwidXNlTWVtbzE2IiwiUmVhY3QxMSIsInVzZUNhbGxiYWNrNSIsInVzZUVmZmVjdDkiLCJ1c2VNZW1vMTUiLCJ1c2VSZWYyIiwidXNlU3RhdGUxMCIsImpzeDE0IiwidXNlQnVmZmVyTWFuYWdlciIsImJsb2NrcyIsInNldEJsb2NrcyIsIm9uQnVmZmVyaW5nQ2FsbGJhY2tzIiwic2V0T25CdWZmZXJpbmdDYWxsYmFja3MiLCJvblJlc3VtZUNhbGxiYWNrcyIsInNldE9uUmVzdW1lQ2FsbGJhY2tzIiwiYnVmZmVyaW5nIiwiYWRkQmxvY2siLCJibG9jayIsImIiLCJ1bmJsb2NrIiwibmV3QXJyIiwiYngiLCJsaXN0ZW5Gb3JCdWZmZXJpbmciLCJjYWxsYmFjayIsInJlbW92ZSIsImNiIiwibGlzdGVuRm9yUmVzdW1lIiwiQnVmZmVyaW5nQ29udGV4dFJlYWN0IiwiQnVmZmVyaW5nUHJvdmlkZXIiLCJidWZmZXJNYW5hZ2VyIiwidXNlSXNQbGF5ZXJCdWZmZXJpbmciLCJpc0J1ZmZlcmluZyIsInNldElzQnVmZmVyaW5nIiwib25CdWZmZXIiLCJvblJlc3VtZSIsInVzZUJ1ZmZlclN0YXRlIiwiYnVmZmVyIiwiZGVsYXlQbGF5YmFjayIsInVzZUJ1ZmZlclVudGlsRmlyc3RGcmFtZSIsIm9uVmFyaWFibGVGcHNWaWRlb0RldGVjdGVkIiwicGF1c2VXaGVuQnVmZmVyaW5nIiwiYnVmZmVyaW5nUmVmIiwiYnVmZmVyVW50aWxGaXJzdEZyYW1lIiwicmVxdWVzdGVkVGltZSIsInJlcXVlc3RWaWRlb0ZyYW1lQ2FsbGJhY2siLCJwbGF5YmFjayIsInJlbW92ZUV2ZW50TGlzdGVuZXIiLCJvbmNlIiwib25FbmRlZE9yUGF1c2VPckNhblBsYXkiLCJpbmZvIiwiZGlmZmVyZW5jZUZyb21SZXF1ZXN0ZWQiLCJhYnMiLCJtZWRpYVRpbWUiLCJhZGRFdmVudExpc3RlbmVyIiwidXNlRWZmZWN0MTAiLCJ1c2VTdGF0ZTExIiwidXNlTWVkaWFCdWZmZXJpbmciLCJzaG91bGRCdWZmZXIiLCJpc1ByZW1vdW50aW5nIiwiY2xlYW51cEZucyIsImNsZWFudXAiLCJmbiIsIm9uV2FpdGluZyIsIm9uQ2FuUGxheSIsImluaXQiLCJvbkVycm9yIiwicmVhZHlTdGF0ZSIsIkhBVkVfRlVUVVJFX0RBVEEiLCJuYXZpZ2F0b3IiLCJ1c2VyQWdlbnQiLCJsb2FkIiwidXNlRWZmZWN0MTEiLCJ1c2VSZWY0IiwidXNlUmVxdWVzdFZpZGVvQ2FsbGJhY2tUaW1lIiwibGFzdFNlZWsiLCJjdXJyZW50VGltZSIsInZpZGVvVGFnIiwiY2FuY2VsIiwicmVxdWVzdCIsImRpZmZlcmVuY2UiLCJkaWZmZXJlbmNlVG9MYXN0U2VlayIsImNhbmNlbFZpZGVvRnJhbWVDYWxsYmFjayIsImludGVycG9sYXRlRnVuY3Rpb24iLCJpbnB1dCIsImlucHV0UmFuZ2UiLCJvdXRwdXRSYW5nZSIsImV4dHJhcG9sYXRlTGVmdCIsImV4dHJhcG9sYXRlUmlnaHQiLCJlYXNpbmciLCJpbnB1dE1pbiIsImlucHV0TWF4Iiwib3V0cHV0TWluIiwib3V0cHV0TWF4IiwicmFuZ2UiLCJmaW5kUmFuZ2UiLCJjaGVja1ZhbGlkSW5wdXRSYW5nZSIsImFyciIsImNoZWNrSW5maW5pdGVSYW5nZSIsImludGVycG9sYXRlIiwibnVtIiwiZ2V0RXhwZWN0ZWRNZWRpYUZyYW1lVW5jb3JyZWN0ZWQiLCJnZXRNZWRpYVRpbWUiLCJleHBlY3RlZEZyYW1lIiwibXNQZXJGcmFtZSIsInVzZVJlZjUiLCJ0b1NlY29uZHMiLCJyb3VuZCIsImlzSW9zU2FmYXJpIiwiaXNJcGFkSVBvZElQaG9uZSIsImlzQXBwbGVXZWJLaXQiLCJpc0lPU1NhZmFyaUFuZEJsb2IiLCJhY3R1YWxTcmMiLCJnZXRWaWRlb0ZyYWdtZW50U3RhcnQiLCJnZXRWaWRlb0ZyYWdtZW50RW5kIiwiYXBwZW5kVmlkZW9GcmFnbWVudCIsImV4aXN0aW5nSGFzaCIsIndpdGhTdGFydEhhc2giLCJpc1N1YnNldE9mRHVyYXRpb24iLCJwcmV2U3RhcnRGcm9tIiwibmV3U3RhcnRGcm9tIiwicHJldkR1cmF0aW9uIiwibmV3RHVyYXRpb24iLCJwcmV2aW91c0Zyb20iLCJuZXdGcm9tIiwicHJldmlvdXNFbmQiLCJuZXdFbmQiLCJ1c2VBcHBlbmRWaWRlb0ZyYWdtZW50IiwiaW5pdGlhbEFjdHVhbFNyYyIsImluaXRpYWxBY3R1YWxGcm9tIiwiaW5pdGlhbER1cmF0aW9uIiwiYWN0dWFsRnJvbVJlZiIsImFwcGVuZGVkIiwiYWxyZWFkeVdhcm5lZCIsIndhcm5BYm91dE5vblNlZWthYmxlTWVkaWEiLCJzZWVrYWJsZSIsImVuZCIsIm1zZyIsIkRFRkFVTFRfQUNDRVBUQUJMRV9USU1FU0hJRlQiLCJzZWVrIiwidGltZVRvU2V0IiwidG9GaXhlZCIsInVzZU1lZGlhUGxheWJhY2siLCJsb2NhbFBsYXliYWNrUmF0ZSIsIm9ubHlXYXJuRm9yTWVkaWFTZWVraW5nRXJyb3IiLCJhY2NlcHRhYmxlVGltZXNoaWZ0IiwiZGVidWdTZWVraW5nIiwiZ2xvYmFsUGxheWJhY2tSYXRlIiwibWVkaWFTdGFydHNBdCIsImxhc3RTZWVrRHVlVG9TaGlmdCIsImlzVmFyaWFibGVGcHNWaWRlb01hcCIsImRlc2lyZWRVbmNsYW1wZWRUaW1lIiwiaXNNZWRpYVRhZ0J1ZmZlcmluZyIsImFjY2VwdGFibGVUaW1lU2hpZnRCdXRMZXNzVGhhbkR1cmF0aW9uIiwiaXNQbGF5ZXJCdWZmZXJpbmciLCJwYXVzZSIsImlzTWVkaWFUYWdCdWZmZXJpbmdPclN0YWxsZWQiLCJ0YWdOYW1lIiwicGxheWJhY2tSYXRlVG9TZXQiLCJzaG91bGRCZVRpbWUiLCJtZWRpYVRhZ1RpbWUiLCJydmNUaW1lIiwiaXNWYXJpYWJsZUZwc1ZpZGVvIiwidGltZVNoaWZ0TWVkaWFUYWciLCJ0aW1lU2hpZnRSdmNUYWciLCJ0aW1lU2hpZnQiLCJwYXVzZWQiLCJpc1RpbWUiLCJzZWVrVGhyZXNob2xkIiwibWFrZXNTZW5zZVRvU2VlayIsImlzU29tZXRoaW5nRWxzZUJ1ZmZlcmluZyIsImVuZGVkIiwidXNlRWZmZWN0MTMiLCJ1c2VTdGF0ZTEyIiwidXNlTWVkaWFUYWdWb2x1bWUiLCJhY3R1YWxWb2x1bWUiLCJzZXRBY3R1YWxWb2x1bWUiLCJvbkNoYW5nZSIsInVzZUVmZmVjdDE0IiwiRkxPQVRJTkdfUE9JTlRfRVJST1JfVEhSRVNIT0xEIiwiaXNBcHByb3hpbWF0ZWx5VGhlU2FtZSIsIm51bTEiLCJudW0yIiwidXNlU3luY1ZvbHVtZVdpdGhNZWRpYVRhZyIsInZvbHVtZVByb3BGcmFtZSIsInVzZXJQcmVmZXJyZWRWb2x1bWUiLCJjcmVhdGVDb250ZXh0MTUiLCJ1c2VDb250ZXh0MTkiLCJ1c2VNZW1vMTgiLCJNZWRpYVZvbHVtZUNvbnRleHQiLCJtZWRpYU11dGVkIiwiU2V0TWVkaWFWb2x1bWVDb250ZXh0Iiwic2V0TWVkaWFNdXRlZCIsInNldE1lZGlhVm9sdW1lIiwidXNlTWVkaWFWb2x1bWVTdGF0ZSIsInVzZU1lZGlhTXV0ZWRTdGF0ZSIsIlJlYWN0MTIiLCJjcmVhdGVDb250ZXh0MTYiLCJjcmVhdGVSZWYyIiwidXNlQ2FsbGJhY2s4IiwidXNlQ29udGV4dDIwIiwidXNlRWZmZWN0MTUiLCJ1c2VNZW1vMTkiLCJ1c2VSZWY3IiwidXNlU3RhdGUxMyIsImpzeDE1IiwianN4cyIsIkVNUFRZX0FVRElPIiwiY29tcGFyZVByb3BzIiwib2JqMSIsIm9iajIiLCJrZXlzQSIsInNvcnQiLCJrZXlzQiIsImRpZFByb3BDaGFuZ2UiLCJuZXdQcm9wIiwicHJldlByb3AiLCJ0b1N0cmluZyIsIlNoYXJlZEF1ZGlvQ29udGV4dCIsIlNoYXJlZEF1ZGlvQ29udGV4dFByb3ZpZGVyIiwibnVtYmVyT2ZBdWRpb1RhZ3MiLCJhdWRpb3MiLCJpbml0aWFsTnVtYmVyT2ZBdWRpb1RhZ3MiLCJyZWZzIiwidGFrZW5BdWRpb3MiLCJyZXJlbmRlckF1ZGlvcyIsInJlZ2lzdGVyQXVkaW8iLCJhdWQiLCJhdWRpb0lkIiwiZm91bmQiLCJmaXJzdEZyZWVBdWRpbyIsImZpbmRJbmRleCIsImNsb25lZCIsIm5ld0VsZW0iLCJlbCIsInVucmVnaXN0ZXJBdWRpbyIsImluZGV4IiwidXBkYXRlQXVkaW8iLCJjaGFuZ2VkIiwicHJldkEiLCJwbGF5QWxsQXVkaW9zIiwicmVzZXRBdWRpbyIsInByZWxvYWQiLCJ1c2VTaGFyZWRBdWRpbyIsImVsZW0iLCJlZmZlY3RUb1VzZSIsInVzZUluc2VydGlvbkVmZmVjdCIsImRvY3VtZW50IiwianN4MTYiLCJBdWRpb0ZvckRldmVsb3BtZW50Rm9yd2FyZFJlZkZ1bmN0aW9uIiwiaW5pdGlhbFNob3VsZFByZU1vdW50QXVkaW9FbGVtZW50cyIsInNob3VsZFByZU1vdW50QXVkaW9UYWdzIiwib25EdXJhdGlvbiIsImFjY2VwdGFibGVUaW1lU2hpZnRJblNlY29uZHMiLCJfcmVtb3Rpb25JbnRlcm5hbE5lZWRzRHVyYXRpb25DYWxjdWxhdGlvbiIsIl9yZW1vdGlvbkludGVybmFsTmF0aXZlTG9vcFBhc3NlZCIsIl9yZW1vdGlvbkRlYnVnU2Vla2luZyIsImxvb3BWb2x1bWVDdXJ2ZUJlaGF2aW9yIiwibmF0aXZlUHJvcHMiLCJwcmVsb2FkZWRTcmMiLCJ0aW1lbGluZUlkIiwicHJvcHNUb1Bhc3MiLCJhdWRpb1JlZiIsImN1cnJlbnRPbkR1cmF0aW9uQ2FsbGJhY2siLCJvbkxvYWRlZE1ldGFkYXRhIiwiQXVkaW9Gb3JQcmV2aWV3IiwiZm9yd2FyZFJlZjQiLCJ1c2VDb250ZXh0MjIiLCJ1c2VFZmZlY3QxNyIsInVzZUltcGVyYXRpdmVIYW5kbGU0IiwidXNlTGF5b3V0RWZmZWN0MyIsInVzZU1lbW8yMSIsInVzZVJlZjkiLCJyZW1vdGlvbl9yZW5kZXJSZWFkeSIsImhhbmRsZXMiLCJyZW1vdGlvbl9kZWxheVJlbmRlclRpbWVvdXRzIiwiREVMQVlfUkVOREVSX0NBTExTVEFDS19UT0tFTiIsIkRFTEFZX1JFTkRFUl9SRVRSSUVTX0xFRlQiLCJERUxBWV9SRU5ERVJfUkVUUllfVE9LRU4iLCJkZWZhdWx0VGltZW91dCIsImRlbGF5UmVuZGVyIiwibGFiZWwiLCJoYW5kbGUiLCJjYWxsZWQiLCJ0aW1lb3V0VG9Vc2UiLCJ0aW1lb3V0SW5NaWxsaXNlY29uZHMiLCJyZXRyaWVzTGVmdCIsInJldHJpZXMiLCJyZW1vdGlvbl9hdHRlbXB0IiwidGltZW91dCIsInNldFRpbWVvdXQiLCJjb250aW51ZVJlbmRlciIsImgiLCJjbGVhclRpbWVvdXQiLCJqc3gxNyIsIkF1ZGlvRm9yUmVuZGVyaW5nUmVmRm9yd2FyZGluZ0Z1bmN0aW9uIiwidm9sdW1lUHJvcCIsInRvbmVGcmVxdWVuY3kiLCJkZWxheVJlbmRlclJldHJpZXMiLCJkZWxheVJlbmRlclRpbWVvdXRJbk1pbGxpc2Vjb25kcyIsInJlbW90aW9uX2F1ZGlvRW5hYmxlZCIsIm1lZGlhRnJhbWUiLCJhdWRpb1N0YXJ0RnJhbWUiLCJuZWVkc1RvUmVuZGVyQXVkaW9UYWciLCJuZXdIYW5kbGUiLCJkaWRMb2FkIiwiQXVkaW9Gb3JSZW5kZXJpbmciLCJqc3gxOCIsIkF1ZGlvUmVmRm9yd2FyZGluZ0Z1bmN0aW9uIiwiYXVkaW9Db250ZXh0IiwicHJvcHNPdGhlclRoYW5Mb29wIiwiZW52aXJvbm1lbnQiLCJjdXJyZW50VGFyZ2V0IiwiZXJyTWVzc2FnZSIsImR1cmF0aW9uRmV0Y2hlZCIsIkF1ZGlvIiwic3RhcnRGcm9tRnJhbWVObyIsImVuZEF0RnJhbWVObyIsIlN1c3BlbnNlIiwidXNlQ29udGV4dDI1IiwidXNlRWZmZWN0MTkiLCJ1c2VNZW1vMjQiLCJjcmVhdGVQb3J0YWwiLCJjcmVhdGVDb250ZXh0MTciLCJ1c2VDb250ZXh0MjQiLCJ1c2VFZmZlY3QxOCIsInVzZU1lbW8yMiIsImdldFJlZ2V4IiwiaXNGb2xkZXJOYW1lVmFsaWQiLCJ2YWxpZGF0ZUZvbGRlck5hbWUiLCJpbnZhbGlkRm9sZGVyTmFtZUVycm9yTWVzc2FnZSIsImpzeDE5IiwiRm9sZGVyQ29udGV4dCIsImZvbGRlck5hbWUiLCJwYXJlbnROYW1lIiwiRm9sZGVyIiwicGFyZW50TmFtZUFyciIsImpzeDIwIiwianN4czIiLCJyb3RhdGUiLCJ0cmFuc2Zvcm0iLCJJQ09OX1NJWkUiLCJjb2xvciIsImZvbnRTaXplIiwiZm9udEZhbWlseSIsImNvbnRhaW5lciIsImp1c3RpZnlDb250ZW50IiwiYWxpZ25JdGVtcyIsIkxvYWRpbmciLCJ2aWV3Qm94Iiwic3Ryb2tlIiwic3Ryb2tlV2lkdGgiLCJzdHJva2VMaW5lam9pbiIsImQiLCJfcG9ydGFsTm9kZSIsInBvcnRhbE5vZGUiLCJjb250YWluZXJOb2RlIiwiYXBwZW5kQ2hpbGQiLCJSZWFjdDE2IiwidXNlTWVtbzIzIiwidXNlTGF6eUNvbXBvbmVudCIsImNvbXBQcm9wcyIsImxhenkiLCJsYXp5Q29tcG9uZW50IiwiZGVmYXVsdCIsImdldFJlZ2V4MiIsImlzQ29tcG9zaXRpb25JZFZhbGlkIiwidmFsaWRhdGVDb21wb3NpdGlvbklkIiwiaW52YWxpZENvbXBvc2l0aW9uRXJyb3JNZXNzYWdlIiwidmFsaWRhdGVEZWZhdWx0QW5kSW5wdXRQcm9wcyIsImlzQXJyYXkiLCJqc3gyMSIsIkNsaXBDb21wb3NpdGlvbiIsImNsaXBQYXRoIiwiRmFsbGJhY2siLCJmYWxsYmFjayIsIkNvbXBvc2l0aW9uIiwic2NoZW1hIiwiY2FuVXNlQ29tcG9zaXRpb24iLCJwYXJlbnRGb2xkZXJOYW1lIiwiQ29tcCIsIlJlYWN0MTgiLCJ1c2VDYWxsYmFjazEwIiwidXNlSW1wZXJhdGl2ZUhhbmRsZTUiLCJ1c2VNZW1vMjUiLCJ1c2VSZWYxMCIsInVzZVN0YXRlMTUiLCJqc3gyMiIsImNvbXBvc2l0aW9uc1JlZiIsIkNvbXBvc2l0aW9uTWFuYWdlclByb3ZpZGVyIiwic2V0Q29tcG9zaXRpb25zIiwiY3VycmVudGNvbXBvc2l0aW9uc1JlZiIsInNldEZvbGRlcnMiLCJ1cGRhdGVDb21wb3NpdGlvbnMiLCJ1cGRhdGVDb21wcyIsImNvbXBzIiwidXBkYXRlZCIsImNvbXAiLCJzbGljZSIsInByZXZGb2xkZXJzIiwiZ2V0Q29tcG9zaXRpb25zIiwibmV3RGVmYXVsdFByb3BzIiwiYUExIiwiYUEyIiwiY2FsY0JlemllciIsImFUIiwiZ2V0U2xvcGUiLCJiaW5hcnlTdWJkaXZpZGUiLCJhWCIsIl9hQSIsIl9hQiIsIm1YMSIsIm1YMiIsImN1cnJlbnRYIiwiY3VycmVudFQiLCJhQSIsImFCIiwiU1VCRElWSVNJT05fUFJFQ0lTSU9OIiwiU1VCRElWSVNJT05fTUFYX0lURVJBVElPTlMiLCJuZXd0b25SYXBoc29uSXRlcmF0ZSIsIl9hR3Vlc3NUIiwiYUd1ZXNzVCIsIk5FV1RPTl9JVEVSQVRJT05TIiwiY3VycmVudFNsb3BlIiwiYmV6aWVyIiwibVkxIiwibVkyIiwic2FtcGxlVmFsdWVzIiwiZmxvYXQzMkFycmF5U3VwcG9ydGVkIiwiRmxvYXQzMkFycmF5Iiwia1NwbGluZVRhYmxlU2l6ZSIsImtTYW1wbGVTdGVwU2l6ZSIsImdldFRGb3JYIiwiaW50ZXJ2YWxTdGFydCIsImN1cnJlbnRTYW1wbGUiLCJsYXN0U2FtcGxlIiwiZGlzdCIsImd1ZXNzRm9yVCIsImluaXRpYWxTbG9wZSIsIk5FV1RPTl9NSU5fU0xPUEUiLCJFYXNpbmciLCJzdGVwMCIsIm4iLCJzdGVwMSIsImxpbmVhciIsImVhc2UiLCJxdWFkIiwiY3ViaWMiLCJwb2x5Iiwic2luIiwiY29zIiwiUEkiLCJjaXJjbGUiLCJzcXJ0IiwiZXhwIiwiZWxhc3RpYyIsImJvdW5jaW5lc3MiLCJiYWNrIiwiYm91bmNlIiwidDJfIiwidDIiLCJ4MSIsInkxIiwieDIiLCJ5MiIsImluIiwib3V0IiwiaW5PdXQiLCJFTkFCTEVfVjVfQlJFQUtJTkdfQ0hBTkdFUyIsIndhcm5lZFNlcnZlciIsIndhcm5lZFBsYXllciIsIndhcm5TZXJ2ZXJPbmNlIiwid2FyblBsYXllck9uY2UiLCJnZXRTdGF0aWNGaWxlcyIsInJlbW90aW9uX3N0YXRpY0ZpbGVzIiwiZm9yd2FyZFJlZjYiLCJ1c2VDYWxsYmFjazExIiwidXNlU3RhdGUxNiIsImpzeDIzIiwiSUZyYW1lUmVmRm9yd2FyZGluZyIsIm9uTG9hZCIsInByb3BzMiIsImRpZEdldEVycm9yIiwiSUZyYW1lIiwiZm9yd2FyZFJlZjciLCJ1c2VDYWxsYmFjazEyIiwidXNlQ29udGV4dDI2IiwidXNlSW1wZXJhdGl2ZUhhbmRsZTYiLCJ1c2VMYXlvdXRFZmZlY3Q0IiwidXNlUmVmMTEiLCJleHBvbmVudGlhbEJhY2tvZmYiLCJlcnJvckNvdW50IiwianN4MjQiLCJJbWdSZWZGb3J3YXJkaW5nIiwibWF4UmV0cmllcyIsInBhdXNlV2hlbkxvYWRpbmciLCJvbkltYWdlRnJhbWUiLCJpbWFnZVJlZiIsImVycm9ycyIsInJldHJ5SW4iLCJjdXJyZW50U3JjIiwibmV3U3JjIiwicmVtb3ZlQXR0cmlidXRlIiwic2V0QXR0cmlidXRlIiwiYmFja29mZiIsInVubW91bnRlZCIsIm9uQ29tcGxldGUiLCJuZXdJbWciLCJJbWFnZSIsImNvbXBsZXRlIiwiSW1nIiwiZXhwb3J0c19kZWZhdWx0X2NzcyIsIm1ha2VEZWZhdWx0UHJldmlld0NTUyIsImluamVjdENTUyIsIk9GRlRIUkVBRF9WSURFT19DTEFTU19OQU1FIiwiaW5qZWN0ZWQiLCJjc3MiLCJoZWFkIiwiZ2V0RWxlbWVudHNCeVRhZ05hbWUiLCJjcmVhdGVUZXh0Tm9kZSIsInByZXBlbmQiLCJzY29wZSIsImJhY2tncm91bmRDb2xvciIsIlJFTU9USU9OX1NUVURJT19DT05UQUlORVJfRUxFTUVOVCIsImdldFByZXZpZXdEb21FbGVtZW50IiwiZ2V0RWxlbWVudEJ5SWQiLCJSb290IiwibGlzdGVuZXJzIiwicmVnaXN0ZXJSb290IiwibCIsImdldFJvb3QiLCJ3YWl0Rm9yUm9vdCIsInVzZUVmZmVjdDIwIiwidXNlTGF5b3V0RWZmZWN0NSIsInVzZU1lbW8yNiIsInVzZVJlZjEyIiwidXNlU3RhdGUxNyIsImpzeDI1IiwiUmVtb3Rpb25Sb290IiwicmVtb3Rpb25Sb290SWQiLCJzZXRGYXN0UmVmcmVzaGVzIiwicmVtb3Rpb25fc2V0RnJhbWUiLCJmIiwiYXR0ZW1wdCIsImFzeW5jVXBkYXRlIiwicmVxdWVzdEFuaW1hdGlvbkZyYW1lIiwidGltZWxpbmVDb250ZXh0VmFsdWUiLCJzZXRUaW1lbGluZUNvbnRleHRWYWx1ZSIsIm5vbmNlQ29udGV4dCIsImNvdW50ZXIiLCJfX3dlYnBhY2tfbW9kdWxlX18iLCJob3QiLCJhZGRTdGF0dXNIYW5kbGVyIiwiZ2V0RW52VmFyaWFibGVzIiwicmVtb3Rpb25fZW52VmFyaWFibGVzIiwic2V0dXBFbnZWYXJpYWJsZXMiLCJSZWFjdDIyIiwiY3JlYXRlQ29udGV4dDE4IiwiQ3VycmVudFNjYWxlQ29udGV4dCIsIlByZXZpZXdTaXplQ29udGV4dCIsInNldFNpemUiLCJzaXplIiwidHJhbnNsYXRpb24iLCJjYWxjdWxhdGVTY2FsZSIsImNhbnZhc1NpemUiLCJwcmV2aWV3U2l6ZSIsImhlaWdodFJhdGlvIiwid2lkdGhSYXRpbyIsInJhdGlvIiwidXNlQ3VycmVudFNjYWxlIiwiaGFzQ29udGV4dCIsInpvb21Db250ZXh0IiwiY29uZmlnIiwiZG9udFRocm93SWZPdXRzaWRlT2ZSZW1vdGlvbiIsInNjYWxlIiwiV0FUQ0hfUkVNT1RJT05fU1RBVElDX0ZJTEVTIiwid2F0Y2hTdGF0aWNGaWxlIiwiZmlsZU5hbWUiLCJ3aXRob3V0U3RhdGljQmFzZSIsIndpdGhvdXRMZWFkaW5nU2xhc2giLCJwcmV2RmlsZURhdGEiLCJmaWxlIiwiY2hlY2tGaWxlIiwiZXZlbnQiLCJzdGF0aWNGaWxlcyIsImRldGFpbCIsImZpbGVzIiwibmV3RmlsZURhdGEiLCJsYXN0TW9kaWZpZWQiLCJSZWFjdDIzIiwidXNlTWVtbzI3IiwidXNlUmVtb3Rpb25Db250ZXh0cyIsImNvbXBvc2l0aW9uTWFuYWdlckN0eCIsInNldFRpbWVsaW5lQ29udGV4dCIsImNhblVzZVJlbW90aW9uSG9va3NDb250ZXh0IiwibmF0aXZlTGF5ZXJzQ29udGV4dCIsInByZWxvYWRDb250ZXh0IiwicmVzb2x2ZUNvbXBvc2l0aW9uQ29udGV4dCIsInJlbmRlckFzc2V0TWFuYWdlckNvbnRleHQiLCJzZXF1ZW5jZU1hbmFnZXJDb250ZXh0IiwiYnVmZmVyTWFuYWdlckNvbnRleHQiLCJqc3gyNiIsIlJlbW90aW9uQ29udGV4dFByb3ZpZGVyIiwiY29udGV4dHMiLCJJbnRlcm5hbHMiLCJUaW1lbGluZSIsIkNTU1V0aWxzIiwiY2FsbCIsImFyZ3MiLCJnZXRNYXRjaGVycyIsImNhY2hlZE1hdGNoZXJzIiwicmdiIiwicmdiYSIsImhzbCIsImhzbGEiLCJoZXgzIiwiaGV4NCIsImhleDUiLCJoZXg2IiwiaGV4OCIsIlJlZ0V4cCIsIk5VTUJFUiIsIlBFUkNFTlRBR0UiLCJodWUycmdiIiwicSIsImhzbFRvUmdiIiwiZyIsImIyIiwicGFyc2UyNTUiLCJpbnQiLCJwYXJzZTM2MCIsInBhcnNlRmxvYXQiLCJwYXJzZTEiLCJwYXJzZVBlcmNlbnRhZ2UiLCJub3JtYWxpemVDb2xvciIsIm1hdGNoZXJzIiwiZXhlYyIsImNvbG9yTmFtZXMiLCJwcm9jZXNzQ29sb3IiLCJub3JtYWxpemVkQ29sb3IiLCJ0cmFuc3BhcmVudCIsImFsaWNlYmx1ZSIsImFudGlxdWV3aGl0ZSIsImFxdWEiLCJhcXVhbWFyaW5lIiwiYXp1cmUiLCJiZWlnZSIsImJpc3F1ZSIsImJsYWNrIiwiYmxhbmNoZWRhbG1vbmQiLCJibHVlIiwiYmx1ZXZpb2xldCIsImJyb3duIiwiYnVybHl3b29kIiwiYnVybnRzaWVubmEiLCJjYWRldGJsdWUiLCJjaGFydHJldXNlIiwiY2hvY29sYXRlIiwiY29yYWwiLCJjb3JuZmxvd2VyYmx1ZSIsImNvcm5zaWxrIiwiY3JpbXNvbiIsImN5YW4iLCJkYXJrYmx1ZSIsImRhcmtjeWFuIiwiZGFya2dvbGRlbnJvZCIsImRhcmtncmF5IiwiZGFya2dyZWVuIiwiZGFya2dyZXkiLCJkYXJra2hha2kiLCJkYXJrbWFnZW50YSIsImRhcmtvbGl2ZWdyZWVuIiwiZGFya29yYW5nZSIsImRhcmtvcmNoaWQiLCJkYXJrcmVkIiwiZGFya3NhbG1vbiIsImRhcmtzZWFncmVlbiIsImRhcmtzbGF0ZWJsdWUiLCJkYXJrc2xhdGVncmF5IiwiZGFya3NsYXRlZ3JleSIsImRhcmt0dXJxdW9pc2UiLCJkYXJrdmlvbGV0IiwiZGVlcHBpbmsiLCJkZWVwc2t5Ymx1ZSIsImRpbWdyYXkiLCJkaW1ncmV5IiwiZG9kZ2VyYmx1ZSIsImZpcmVicmljayIsImZsb3JhbHdoaXRlIiwiZm9yZXN0Z3JlZW4iLCJmdWNoc2lhIiwiZ2FpbnNib3JvIiwiZ2hvc3R3aGl0ZSIsImdvbGQiLCJnb2xkZW5yb2QiLCJncmF5IiwiZ3JlZW4iLCJncmVlbnllbGxvdyIsImdyZXkiLCJob25leWRldyIsImhvdHBpbmsiLCJpbmRpYW5yZWQiLCJpbmRpZ28iLCJpdm9yeSIsImtoYWtpIiwibGF2ZW5kZXIiLCJsYXZlbmRlcmJsdXNoIiwibGF3bmdyZWVuIiwibGVtb25jaGlmZm9uIiwibGlnaHRibHVlIiwibGlnaHRjb3JhbCIsImxpZ2h0Y3lhbiIsImxpZ2h0Z29sZGVucm9keWVsbG93IiwibGlnaHRncmF5IiwibGlnaHRncmVlbiIsImxpZ2h0Z3JleSIsImxpZ2h0cGluayIsImxpZ2h0c2FsbW9uIiwibGlnaHRzZWFncmVlbiIsImxpZ2h0c2t5Ymx1ZSIsImxpZ2h0c2xhdGVncmF5IiwibGlnaHRzbGF0ZWdyZXkiLCJsaWdodHN0ZWVsYmx1ZSIsImxpZ2h0eWVsbG93IiwibGltZSIsImxpbWVncmVlbiIsImxpbmVuIiwibWFnZW50YSIsIm1hcm9vbiIsIm1lZGl1bWFxdWFtYXJpbmUiLCJtZWRpdW1ibHVlIiwibWVkaXVtb3JjaGlkIiwibWVkaXVtcHVycGxlIiwibWVkaXVtc2VhZ3JlZW4iLCJtZWRpdW1zbGF0ZWJsdWUiLCJtZWRpdW1zcHJpbmdncmVlbiIsIm1lZGl1bXR1cnF1b2lzZSIsIm1lZGl1bXZpb2xldHJlZCIsIm1pZG5pZ2h0Ymx1ZSIsIm1pbnRjcmVhbSIsIm1pc3R5cm9zZSIsIm1vY2Nhc2luIiwibmF2YWpvd2hpdGUiLCJuYXZ5Iiwib2xkbGFjZSIsIm9saXZlIiwib2xpdmVkcmFiIiwib3JhbmdlIiwib3JhbmdlcmVkIiwib3JjaGlkIiwicGFsZWdvbGRlbnJvZCIsInBhbGVncmVlbiIsInBhbGV0dXJxdW9pc2UiLCJwYWxldmlvbGV0cmVkIiwicGFwYXlhd2hpcCIsInBlYWNocHVmZiIsInBlcnUiLCJwaW5rIiwicGx1bSIsInBvd2RlcmJsdWUiLCJwdXJwbGUiLCJyZWJlY2NhcHVycGxlIiwicmVkIiwicm9zeWJyb3duIiwicm95YWxibHVlIiwic2FkZGxlYnJvd24iLCJzYWxtb24iLCJzYW5keWJyb3duIiwic2VhZ3JlZW4iLCJzZWFzaGVsbCIsInNpZW5uYSIsInNpbHZlciIsInNreWJsdWUiLCJzbGF0ZWJsdWUiLCJzbGF0ZWdyYXkiLCJzbGF0ZWdyZXkiLCJzbm93Iiwic3ByaW5nZ3JlZW4iLCJzdGVlbGJsdWUiLCJ0YW4iLCJ0ZWFsIiwidGhpc3RsZSIsInRvbWF0byIsInR1cnF1b2lzZSIsInZpb2xldCIsIndoZWF0Iiwid2hpdGUiLCJ3aGl0ZXNtb2tlIiwieWVsbG93IiwieWVsbG93Z3JlZW4iLCJjMiIsInJnYmFDb2xvciIsImFscGhhIiwiaW50ZXJwb2xhdGVDb2xvcnNSR0IiLCJjb2xvcnMiLCJhMiIsInVucm91bmRlZCIsImludGVycG9sYXRlQ29sb3JzIiwicHJvY2Vzc2VkT3V0cHV0UmFuZ2UiLCJ2YWxpZGF0ZUZyYW1lIiwiUmFuZ2VFcnJvciIsImdldE9mZnRocmVhZFZpZGVvU291cmNlIiwidG9uZU1hcHBlZCIsInJlbW90aW9uX3Byb3h5UG9ydCIsIkNoaWxkcmVuIiwiZm9yd2FyZFJlZjgiLCJ1c2VNZW1vMjgiLCJSZWFjdDI0IiwiZmxhdHRlbkNoaWxkcmVuIiwiY2hpbGRyZW5BcnJheSIsInRvQXJyYXkiLCJmbGF0Q2hpbGRyZW4iLCJjaGlsZCIsIkZyYWdtZW50IiwiY29uY2F0IiwiUmVhY3QyNSIsImNyZWF0ZUNvbnRleHQxOSIsImpzeDI3IiwiSXNJbnNpZGVTZXJpZXNDb250ZXh0IiwiSXNJbnNpZGVTZXJpZXNDb250YWluZXIiLCJJc05vdEluc2lkZVNlcmllc1Byb3ZpZGVyIiwidXNlUmVxdWlyZVRvQmVJbnNpZGVTZXJpZXMiLCJpc0luc2lkZVNlcmllcyIsImpzeDI4IiwiU2VyaWVzU2VxdWVuY2VSZWZGb3J3YXJkaW5nRnVuY3Rpb24iLCJfcmVmIiwiU2VyaWVzU2VxdWVuY2UiLCJTZXJpZXMiLCJjaGlsZHJlblZhbHVlIiwic3RhcnRGcmFtZSIsImZsYXR0ZW5lZENoaWxkcmVuIiwiY2FzdGVkQ2hpbGQiLCJkZWJ1Z0luZm8iLCJkdXJhdGlvbkluRnJhbWVzUHJvcCIsIl9jaGlsZHJlbiIsInBhc3NlZFByb3BzIiwib2Zmc2V0IiwiY3VycmVudFN0YXJ0RnJhbWUiLCJ2YWxpZGF0ZVNwcmluZ0R1cmF0aW9uIiwiZHVyIiwiYWR2YW5jZSIsImFuaW1hdGlvbiIsIm5vdyIsInRvVmFsdWUiLCJsYXN0VGltZXN0YW1wIiwidmVsb2NpdHkiLCJkZWx0YVRpbWUiLCJkYW1waW5nIiwibSIsIm1hc3MiLCJrIiwic3RpZmZuZXNzIiwiY2FjaGVLZXkiLCJhZHZhbmNlQ2FjaGUiLCJ2MCIsIngwIiwiemV0YSIsIm9tZWdhMCIsIm9tZWdhMSIsInNpbjEiLCJjb3MxIiwidW5kZXJEYW1wZWRFbnZlbG9wZSIsInVuZGVyRGFtcGVkRnJhZzEiLCJ1bmRlckRhbXBlZFBvc2l0aW9uIiwidW5kZXJEYW1wZWRWZWxvY2l0eSIsImNyaXRpY2FsbHlEYW1wZWRFbnZlbG9wZSIsImNyaXRpY2FsbHlEYW1wZWRQb3NpdGlvbiIsImNyaXRpY2FsbHlEYW1wZWRWZWxvY2l0eSIsImFuaW1hdGlvbk5vZGUiLCJwcmV2UG9zaXRpb24iLCJzcHJpbmdDYWxjdWxhdGlvbiIsInRvIiwib3ZlcnNob290Q2xhbXBpbmciLCJjYWxjdWxhdGlvbkNhY2hlIiwiZnJhbWVDbGFtcGVkIiwidW5ldmVuUmVzdCIsImRlZmF1bHRTcHJpbmdDb25maWciLCJtZWFzdXJlU3ByaW5nIiwidGhyZXNob2xkIiwiY2FjaGUiLCJoYXMiLCJmaW5pc2hlZEZyYW1lIiwiY2FsYyIsImNhbGNEaWZmZXJlbmNlIiwic3ByaW5nIiwicGFzc2VkRnJhbWUiLCJwYXNzZWREdXJhdGlvbkluRnJhbWVzIiwiZHVyYXRpb25SZXN0VGhyZXNob2xkIiwiZGVsYXkiLCJyZXZlcnNlIiwibmVlZHNUb0NhbGN1bGF0ZU5hdHVyYWxEdXJhdGlvbiIsIm5hdHVyYWxEdXJhdGlvbiIsIm5hdHVyYWxEdXJhdGlvbkdldHRlciIsInJldmVyc2VQcm9jZXNzZWQiLCJkZWxheVByb2Nlc3NlZCIsImR1cmF0aW9uUHJvY2Vzc2VkIiwic3ByIiwiaW5uZXIyIiwiaW50ZXJwb2xhdGVkIiwiUmVhY3QyNyIsIlN0aWxsIiwidXNlQ2FsbGJhY2sxNCIsInVzZUNhbGxiYWNrMTMiLCJ1c2VDb250ZXh0MjciLCJ1c2VFZmZlY3QyMSIsInVzZUxheW91dEVmZmVjdDYiLCJ1c2VNZW1vMjkiLCJ1c2VTdGF0ZTE4IiwianN4MjkiLCJPZmZ0aHJlYWRWaWRlb0ZvclJlbmRlcmluZyIsIm9uVmlkZW9GcmFtZSIsInZvbHVtZVByb3BzRnJhbWUiLCJpbWFnZVNyYyIsInNldEltYWdlU3JjIiwicmVtb3Rpb25fdmlkZW9FbmFibGVkIiwiZXhlY3V0ZSIsImpzb24iLCJjbGVhbmVkVXBFcnJvck1lc3NhZ2UiLCJjYXVzZSIsIm9uRXJyIiwiaW1nIiwiZm9yd2FyZFJlZjkiLCJ1c2VDb250ZXh0MjgiLCJ1c2VFZmZlY3QyMyIsInVzZUltcGVyYXRpdmVIYW5kbGU3IiwidXNlTWVtbzMwIiwidXNlUmVmMTMiLCJ1c2VTdGF0ZTE5IiwidXNlRWZmZWN0MjIiLCJ1c2VFbWl0VmlkZW9GcmFtZSIsImpzeDMwIiwiVmlkZW9Gb3JEZXZlbG9wbWVudFJlZkZvcndhcmRpbmdGdW5jdGlvbiIsInZpZGVvUmVmIiwiYWNjZXB0YWJsZVRpbWVTaGlmdCIsImNyb3NzT3JpZ2luIiwiZXJyb3JIYW5kbGVyIiwiY29kZSIsImNyb3NzT3JpZ2luVmFsdWUiLCJwbGF5c0lubGluZSIsImRpc2FibGVSZW1vdGVQbGF5YmFjayIsIlZpZGVvRm9yUHJldmlldyIsImpzeDMxIiwiT2ZmdGhyZWFkVmlkZW8iLCJpbWFnZUZvcm1hdCIsIndpdGhvdXRUcmFuc3BhcmVudCIsImZvcndhcmRSZWYxMSIsInVzZUNhbGxiYWNrMTUiLCJ1c2VDb250ZXh0MzAiLCJmb3J3YXJkUmVmMTAiLCJ1c2VDb250ZXh0MjkiLCJ1c2VFZmZlY3QyNCIsInVzZUltcGVyYXRpdmVIYW5kbGU4IiwidXNlTGF5b3V0RWZmZWN0NyIsInVzZU1lbW8zMSIsInVzZVJlZjE0Iiwicm91bmRUbzZDb21tYXMiLCJzZWVrVG9UaW1lIiwiZGVzaXJlZFRpbWUiLCJjYW5jZWxTZWVrZWQiLCJtZXRhZGF0YSIsImRpc3BsYXlJbiIsImV4cGVjdGVkRGlzcGxheVRpbWUiLCJ3YWl0Rm9yU2Vla2VkRXZlbnQiLCJvbkRvbmUiLCJ3YWl0Iiwic2Vla1RvVGltZU11bHRpcGxlVW50aWxSaWdodCIsImN1cnJlbnRDYW5jZWwiLCJmaXJzdFNlZWsiLCJzZWVrZWRUbyIsInNpZ24iLCJuZXdTZWVrIiwibmV3VGltZSIsIm5ld0RpZmZlcmVuY2UiLCJ0aGlyZFNlZWsiLCJqc3gzMiIsIlZpZGVvRm9yUmVuZGVyaW5nRm9yd2FyZEZ1bmN0aW9uIiwibG9hZGVkRGF0YUhhbmRsZXIiLCJlbmRlZEhhbmRsZXIiLCJzZWVrMiIsIlZpZGVvRm9yUmVuZGVyaW5nIiwianN4MzMiLCJWaWRlb0ZvcndhcmRpbmdGdW5jdGlvbiIsIlZpZGVvIiwiRXhwZXJpbWVudGFsIiwicHJveHlPYmoiLCJDb25maWciLCJwcm9wIiwiZXhpdCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/remotion/dist/esm/index.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/remotion/dist/esm/no-react.mjs":
/*!*****************************************************!*\
  !*** ./node_modules/remotion/dist/esm/no-react.mjs ***!
  \*****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   NoReactInternals: () => (/* binding */ NoReactInternals),\n/* harmony export */   interpolate: () => (/* binding */ interpolate),\n/* harmony export */   random: () => (/* binding */ random)\n/* harmony export */ });\n// src/interpolate.ts\nfunction interpolateFunction(input, inputRange, outputRange, options) {\n  const { extrapolateLeft, extrapolateRight, easing } = options;\n  let result = input;\n  const [inputMin, inputMax] = inputRange;\n  const [outputMin, outputMax] = outputRange;\n  if (result < inputMin) {\n    if (extrapolateLeft === \"identity\") {\n      return result;\n    }\n    if (extrapolateLeft === \"clamp\") {\n      result = inputMin;\n    } else if (extrapolateLeft === \"wrap\") {\n      const range = inputMax - inputMin;\n      result = ((result - inputMin) % range + range) % range + inputMin;\n    } else if (extrapolateLeft === \"extend\") {\n    }\n  }\n  if (result > inputMax) {\n    if (extrapolateRight === \"identity\") {\n      return result;\n    }\n    if (extrapolateRight === \"clamp\") {\n      result = inputMax;\n    } else if (extrapolateRight === \"wrap\") {\n      const range = inputMax - inputMin;\n      result = ((result - inputMin) % range + range) % range + inputMin;\n    } else if (extrapolateRight === \"extend\") {\n    }\n  }\n  if (outputMin === outputMax) {\n    return outputMin;\n  }\n  result = (result - inputMin) / (inputMax - inputMin);\n  result = easing(result);\n  result = result * (outputMax - outputMin) + outputMin;\n  return result;\n}\nfunction findRange(input, inputRange) {\n  let i;\n  for (i = 1;i < inputRange.length - 1; ++i) {\n    if (inputRange[i] >= input) {\n      break;\n    }\n  }\n  return i - 1;\n}\nfunction checkValidInputRange(arr) {\n  for (let i = 1;i < arr.length; ++i) {\n    if (!(arr[i] > arr[i - 1])) {\n      throw new Error(`inputRange must be strictly monotonically increasing but got [${arr.join(\",\")}]`);\n    }\n  }\n}\nfunction checkInfiniteRange(name, arr) {\n  if (arr.length < 2) {\n    throw new Error(name + \" must have at least 2 elements\");\n  }\n  for (const element of arr) {\n    if (typeof element !== \"number\") {\n      throw new Error(`${name} must contain only numbers`);\n    }\n    if (!Number.isFinite(element)) {\n      throw new Error(`${name} must contain only finite numbers, but got [${arr.join(\",\")}]`);\n    }\n  }\n}\nfunction interpolate(input, inputRange, outputRange, options) {\n  if (typeof input === \"undefined\") {\n    throw new Error(\"input can not be undefined\");\n  }\n  if (typeof inputRange === \"undefined\") {\n    throw new Error(\"inputRange can not be undefined\");\n  }\n  if (typeof outputRange === \"undefined\") {\n    throw new Error(\"outputRange can not be undefined\");\n  }\n  if (inputRange.length !== outputRange.length) {\n    throw new Error(\"inputRange (\" + inputRange.length + \") and outputRange (\" + outputRange.length + \") must have the same length\");\n  }\n  checkInfiniteRange(\"inputRange\", inputRange);\n  checkInfiniteRange(\"outputRange\", outputRange);\n  checkValidInputRange(inputRange);\n  const easing = options?.easing ?? ((num) => num);\n  let extrapolateLeft = \"extend\";\n  if (options?.extrapolateLeft !== undefined) {\n    extrapolateLeft = options.extrapolateLeft;\n  }\n  let extrapolateRight = \"extend\";\n  if (options?.extrapolateRight !== undefined) {\n    extrapolateRight = options.extrapolateRight;\n  }\n  if (typeof input !== \"number\") {\n    throw new TypeError(\"Cannot interpolate an input which is not a number\");\n  }\n  const range = findRange(input, inputRange);\n  return interpolateFunction(input, [inputRange[range], inputRange[range + 1]], [outputRange[range], outputRange[range + 1]], {\n    easing,\n    extrapolateLeft,\n    extrapolateRight\n  });\n}\n// src/random.ts\nfunction mulberry32(a) {\n  let t = a + 1831565813;\n  t = Math.imul(t ^ t >>> 15, t | 1);\n  t ^= t + Math.imul(t ^ t >>> 7, t | 61);\n  return ((t ^ t >>> 14) >>> 0) / 4294967296;\n}\nfunction hashCode(str) {\n  let i = 0;\n  let chr = 0;\n  let hash = 0;\n  for (i = 0;i < str.length; i++) {\n    chr = str.charCodeAt(i);\n    hash = (hash << 5) - hash + chr;\n    hash |= 0;\n  }\n  return hash;\n}\nvar random = (seed, dummy) => {\n  if (dummy !== undefined) {\n    throw new TypeError(\"random() takes only one argument\");\n  }\n  if (seed === null) {\n    return Math.random();\n  }\n  if (typeof seed === \"string\") {\n    return mulberry32(hashCode(seed));\n  }\n  if (typeof seed === \"number\") {\n    return mulberry32(seed * 10000000000);\n  }\n  throw new Error(\"random() argument must be a number or a string\");\n};\n// src/truthy.ts\nfunction truthy(value) {\n  return Boolean(value);\n}\n\n// src/delay-render.ts\nif (typeof window !== \"undefined\") {\n  window.remotion_renderReady = false;\n}\nif (typeof window !== \"undefined\") {\n  window.remotion_delayRenderTimeouts = {};\n}\nvar DELAY_RENDER_CALLSTACK_TOKEN = \"The delayRender was called:\";\nvar DELAY_RENDER_RETRIES_LEFT = \"Retries left: \";\nvar DELAY_RENDER_RETRY_TOKEN = \"- Rendering the frame will be retried.\";\n\n// src/static-file.ts\nvar problematicCharacters = {\n  \"%3A\": \":\",\n  \"%2F\": \"/\",\n  \"%3F\": \"?\",\n  \"%23\": \"#\",\n  \"%5B\": \"[\",\n  \"%5D\": \"]\",\n  \"%40\": \"@\",\n  \"%21\": \"!\",\n  \"%24\": \"$\",\n  \"%26\": \"&\",\n  \"%27\": \"'\",\n  \"%28\": \"(\",\n  \"%29\": \")\",\n  \"%2A\": \"*\",\n  \"%2B\": \"+\",\n  \"%2C\": \",\",\n  \"%3B\": \";\"\n};\nvar didWarn = {};\nvar warnOnce = (message) => {\n  if (didWarn[message]) {\n    return;\n  }\n  console.warn(message);\n  didWarn[message] = true;\n};\nvar includesHexOfUnsafeChar = (path) => {\n  for (const key of Object.keys(problematicCharacters)) {\n    if (path.includes(key)) {\n      return { containsHex: true, hexCode: key };\n    }\n  }\n  return { containsHex: false };\n};\nvar trimLeadingSlash = (path) => {\n  if (path.startsWith(\"/\")) {\n    return trimLeadingSlash(path.substring(1));\n  }\n  return path;\n};\nvar inner = (path) => {\n  if (typeof window !== \"undefined\" && window.remotion_staticBase) {\n    if (path.startsWith(window.remotion_staticBase)) {\n      throw new Error(`The value \"${path}\" is already prefixed with the static base ${window.remotion_staticBase}. You don't need to call staticFile() on it.`);\n    }\n    return `${window.remotion_staticBase}/${trimLeadingSlash(path)}`;\n  }\n  return `/${trimLeadingSlash(path)}`;\n};\nvar encodeBySplitting = (path) => {\n  const splitBySlash = path.split(\"/\");\n  const encodedArray = splitBySlash.map((element) => {\n    return encodeURIComponent(element);\n  });\n  const merged = encodedArray.join(\"/\");\n  return merged;\n};\nvar staticFile = (path) => {\n  if (path === null) {\n    throw new TypeError(\"null was passed to staticFile()\");\n  }\n  if (typeof path === \"undefined\") {\n    throw new TypeError(\"undefined was passed to staticFile()\");\n  }\n  if (path.startsWith(\"http://\") || path.startsWith(\"https://\")) {\n    throw new TypeError(`staticFile() does not support remote URLs - got \"${path}\". Instead, pass the URL without wrapping it in staticFile(). See: https://remotion.dev/docs/staticfile-remote-urls`);\n  }\n  if (path.startsWith(\"..\") || path.startsWith(\"./\")) {\n    throw new TypeError(`staticFile() does not support relative paths - got \"${path}\". Instead, pass the name of a file that is inside the public/ folder. See: https://remotion.dev/docs/staticfile-relative-paths`);\n  }\n  if (path.startsWith(\"/Users\") || path.startsWith(\"/home\") || path.startsWith(\"/tmp\") || path.startsWith(\"/etc\") || path.startsWith(\"/opt\") || path.startsWith(\"/var\") || path.startsWith(\"C:\") || path.startsWith(\"D:\") || path.startsWith(\"E:\")) {\n    throw new TypeError(`staticFile() does not support absolute paths - got \"${path}\". Instead, pass the name of a file that is inside the public/ folder. See: https://remotion.dev/docs/staticfile-relative-paths`);\n  }\n  if (path.startsWith(\"public/\")) {\n    throw new TypeError(`Do not include the public/ prefix when using staticFile() - got \"${path}\". See: https://remotion.dev/docs/staticfile-relative-paths`);\n  }\n  const includesHex = includesHexOfUnsafeChar(path);\n  if (includesHex.containsHex) {\n    warnOnce(`WARNING: You seem to pass an already encoded path (path contains ${includesHex.hexCode}). Since Remotion 4.0, the encoding is done by staticFile() itself. You may want to remove a encodeURIComponent() wrapping.`);\n  }\n  const preprocessed = encodeBySplitting(path);\n  const preparsed = inner(preprocessed);\n  if (!preparsed.startsWith(\"/\")) {\n    return `/${preparsed}`;\n  }\n  return preparsed;\n};\n\n// src/input-props-serialization.ts\nvar DATE_TOKEN = \"remotion-date:\";\nvar FILE_TOKEN = \"remotion-file:\";\nvar serializeJSONWithDate = ({\n  data,\n  indent,\n  staticBase\n}) => {\n  let customDateUsed = false;\n  let customFileUsed = false;\n  let mapUsed = false;\n  let setUsed = false;\n  try {\n    const serializedString = JSON.stringify(data, function(key, value) {\n      const item = this[key];\n      if (item instanceof Date) {\n        customDateUsed = true;\n        return `${DATE_TOKEN}${item.toISOString()}`;\n      }\n      if (item instanceof Map) {\n        mapUsed = true;\n        return value;\n      }\n      if (item instanceof Set) {\n        setUsed = true;\n        return value;\n      }\n      if (typeof item === \"string\" && staticBase !== null && item.startsWith(staticBase)) {\n        customFileUsed = true;\n        return `${FILE_TOKEN}${item.replace(staticBase + \"/\", \"\")}`;\n      }\n      return value;\n    }, indent);\n    return { serializedString, customDateUsed, customFileUsed, mapUsed, setUsed };\n  } catch (err) {\n    throw new Error(\"Could not serialize the passed input props to JSON: \" + err.message);\n  }\n};\nvar deserializeJSONWithCustomFields = (data) => {\n  return JSON.parse(data, (_, value) => {\n    if (typeof value === \"string\" && value.startsWith(DATE_TOKEN)) {\n      return new Date(value.replace(DATE_TOKEN, \"\"));\n    }\n    if (typeof value === \"string\" && value.startsWith(FILE_TOKEN)) {\n      return staticFile(value.replace(FILE_TOKEN, \"\"));\n    }\n    return value;\n  });\n};\n\n// src/interpolate-colors.ts\nfunction call(...args) {\n  return \"\\\\(\\\\s*(\" + args.join(\")\\\\s*,\\\\s*(\") + \")\\\\s*\\\\)\";\n}\nfunction getMatchers() {\n  const cachedMatchers = {\n    rgb: undefined,\n    rgba: undefined,\n    hsl: undefined,\n    hsla: undefined,\n    hex3: undefined,\n    hex4: undefined,\n    hex5: undefined,\n    hex6: undefined,\n    hex8: undefined\n  };\n  if (cachedMatchers.rgb === undefined) {\n    cachedMatchers.rgb = new RegExp(\"rgb\" + call(NUMBER, NUMBER, NUMBER));\n    cachedMatchers.rgba = new RegExp(\"rgba\" + call(NUMBER, NUMBER, NUMBER, NUMBER));\n    cachedMatchers.hsl = new RegExp(\"hsl\" + call(NUMBER, PERCENTAGE, PERCENTAGE));\n    cachedMatchers.hsla = new RegExp(\"hsla\" + call(NUMBER, PERCENTAGE, PERCENTAGE, NUMBER));\n    cachedMatchers.hex3 = /^#([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})$/;\n    cachedMatchers.hex4 = /^#([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})$/;\n    cachedMatchers.hex6 = /^#([0-9a-fA-F]{6})$/;\n    cachedMatchers.hex8 = /^#([0-9a-fA-F]{8})$/;\n  }\n  return cachedMatchers;\n}\nfunction hue2rgb(p, q, t) {\n  if (t < 0) {\n    t += 1;\n  }\n  if (t > 1) {\n    t -= 1;\n  }\n  if (t < 1 / 6) {\n    return p + (q - p) * 6 * t;\n  }\n  if (t < 1 / 2) {\n    return q;\n  }\n  if (t < 2 / 3) {\n    return p + (q - p) * (2 / 3 - t) * 6;\n  }\n  return p;\n}\nfunction hslToRgb(h, s, l) {\n  const q = l < 0.5 ? l * (1 + s) : l + s - l * s;\n  const p = 2 * l - q;\n  const r = hue2rgb(p, q, h + 1 / 3);\n  const g = hue2rgb(p, q, h);\n  const b = hue2rgb(p, q, h - 1 / 3);\n  return Math.round(r * 255) << 24 | Math.round(g * 255) << 16 | Math.round(b * 255) << 8;\n}\nfunction parse255(str) {\n  const int = Number.parseInt(str, 10);\n  if (int < 0) {\n    return 0;\n  }\n  if (int > 255) {\n    return 255;\n  }\n  return int;\n}\nfunction parse360(str) {\n  const int = Number.parseFloat(str);\n  return (int % 360 + 360) % 360 / 360;\n}\nfunction parse1(str) {\n  const num = Number.parseFloat(str);\n  if (num < 0) {\n    return 0;\n  }\n  if (num > 1) {\n    return 255;\n  }\n  return Math.round(num * 255);\n}\nfunction parsePercentage(str) {\n  const int = Number.parseFloat(str);\n  if (int < 0) {\n    return 0;\n  }\n  if (int > 100) {\n    return 1;\n  }\n  return int / 100;\n}\nfunction normalizeColor(color) {\n  const matchers = getMatchers();\n  let match;\n  if (matchers.hex6) {\n    if (match = matchers.hex6.exec(color)) {\n      return Number.parseInt(match[1] + \"ff\", 16) >>> 0;\n    }\n  }\n  if (colorNames[color] !== undefined) {\n    return colorNames[color];\n  }\n  if (matchers.rgb) {\n    if (match = matchers.rgb.exec(color)) {\n      return (parse255(match[1]) << 24 | parse255(match[2]) << 16 | parse255(match[3]) << 8 | 255) >>> 0;\n    }\n  }\n  if (matchers.rgba) {\n    if (match = matchers.rgba.exec(color)) {\n      return (parse255(match[1]) << 24 | parse255(match[2]) << 16 | parse255(match[3]) << 8 | parse1(match[4])) >>> 0;\n    }\n  }\n  if (matchers.hex3) {\n    if (match = matchers.hex3.exec(color)) {\n      return Number.parseInt(match[1] + match[1] + match[2] + match[2] + match[3] + match[3] + \"ff\", 16) >>> 0;\n    }\n  }\n  if (matchers.hex8) {\n    if (match = matchers.hex8.exec(color)) {\n      return Number.parseInt(match[1], 16) >>> 0;\n    }\n  }\n  if (matchers.hex4) {\n    if (match = matchers.hex4.exec(color)) {\n      return Number.parseInt(match[1] + match[1] + match[2] + match[2] + match[3] + match[3] + match[4] + match[4], 16) >>> 0;\n    }\n  }\n  if (matchers.hsl) {\n    if (match = matchers.hsl.exec(color)) {\n      return (hslToRgb(parse360(match[1]), parsePercentage(match[2]), parsePercentage(match[3])) | 255) >>> 0;\n    }\n  }\n  if (matchers.hsla) {\n    if (match = matchers.hsla.exec(color)) {\n      return (hslToRgb(parse360(match[1]), parsePercentage(match[2]), parsePercentage(match[3])) | parse1(match[4])) >>> 0;\n    }\n  }\n  throw new Error(`invalid color string ${color} provided`);\n}\nfunction processColor(color) {\n  const normalizedColor = normalizeColor(color);\n  return (normalizedColor << 24 | normalizedColor >>> 8) >>> 0;\n}\nvar NUMBER = \"[-+]?\\\\d*\\\\.?\\\\d+\";\nvar PERCENTAGE = NUMBER + \"%\";\nvar colorNames = {\n  transparent: 0,\n  aliceblue: 4042850303,\n  antiquewhite: 4209760255,\n  aqua: 16777215,\n  aquamarine: 2147472639,\n  azure: 4043309055,\n  beige: 4126530815,\n  bisque: 4293182719,\n  black: 255,\n  blanchedalmond: 4293643775,\n  blue: 65535,\n  blueviolet: 2318131967,\n  brown: 2771004159,\n  burlywood: 3736635391,\n  burntsienna: 3934150143,\n  cadetblue: 1604231423,\n  chartreuse: 2147418367,\n  chocolate: 3530104575,\n  coral: 4286533887,\n  cornflowerblue: 1687547391,\n  cornsilk: 4294499583,\n  crimson: 3692313855,\n  cyan: 16777215,\n  darkblue: 35839,\n  darkcyan: 9145343,\n  darkgoldenrod: 3095792639,\n  darkgray: 2846468607,\n  darkgreen: 6553855,\n  darkgrey: 2846468607,\n  darkkhaki: 3182914559,\n  darkmagenta: 2332068863,\n  darkolivegreen: 1433087999,\n  darkorange: 4287365375,\n  darkorchid: 2570243327,\n  darkred: 2332033279,\n  darksalmon: 3918953215,\n  darkseagreen: 2411499519,\n  darkslateblue: 1211993087,\n  darkslategray: 793726975,\n  darkslategrey: 793726975,\n  darkturquoise: 13554175,\n  darkviolet: 2483082239,\n  deeppink: 4279538687,\n  deepskyblue: 12582911,\n  dimgray: 1768516095,\n  dimgrey: 1768516095,\n  dodgerblue: 512819199,\n  firebrick: 2988581631,\n  floralwhite: 4294635775,\n  forestgreen: 579543807,\n  fuchsia: 4278255615,\n  gainsboro: 3705462015,\n  ghostwhite: 4177068031,\n  gold: 4292280575,\n  goldenrod: 3668254975,\n  gray: 2155905279,\n  green: 8388863,\n  greenyellow: 2919182335,\n  grey: 2155905279,\n  honeydew: 4043305215,\n  hotpink: 4285117695,\n  indianred: 3445382399,\n  indigo: 1258324735,\n  ivory: 4294963455,\n  khaki: 4041641215,\n  lavender: 3873897215,\n  lavenderblush: 4293981695,\n  lawngreen: 2096890111,\n  lemonchiffon: 4294626815,\n  lightblue: 2916673279,\n  lightcoral: 4034953471,\n  lightcyan: 3774873599,\n  lightgoldenrodyellow: 4210742015,\n  lightgray: 3553874943,\n  lightgreen: 2431553791,\n  lightgrey: 3553874943,\n  lightpink: 4290167295,\n  lightsalmon: 4288707327,\n  lightseagreen: 548580095,\n  lightskyblue: 2278488831,\n  lightslategray: 2005441023,\n  lightslategrey: 2005441023,\n  lightsteelblue: 2965692159,\n  lightyellow: 4294959359,\n  lime: 16711935,\n  limegreen: 852308735,\n  linen: 4210091775,\n  magenta: 4278255615,\n  maroon: 2147483903,\n  mediumaquamarine: 1724754687,\n  mediumblue: 52735,\n  mediumorchid: 3126187007,\n  mediumpurple: 2473647103,\n  mediumseagreen: 1018393087,\n  mediumslateblue: 2070474495,\n  mediumspringgreen: 16423679,\n  mediumturquoise: 1221709055,\n  mediumvioletred: 3340076543,\n  midnightblue: 421097727,\n  mintcream: 4127193855,\n  mistyrose: 4293190143,\n  moccasin: 4293178879,\n  navajowhite: 4292783615,\n  navy: 33023,\n  oldlace: 4260751103,\n  olive: 2155872511,\n  olivedrab: 1804477439,\n  orange: 4289003775,\n  orangered: 4282712319,\n  orchid: 3664828159,\n  palegoldenrod: 4008225535,\n  palegreen: 2566625535,\n  paleturquoise: 2951671551,\n  palevioletred: 3681588223,\n  papayawhip: 4293907967,\n  peachpuff: 4292524543,\n  peru: 3448061951,\n  pink: 4290825215,\n  plum: 3718307327,\n  powderblue: 2967529215,\n  purple: 2147516671,\n  rebeccapurple: 1714657791,\n  red: 4278190335,\n  rosybrown: 3163525119,\n  royalblue: 1097458175,\n  saddlebrown: 2336560127,\n  salmon: 4202722047,\n  sandybrown: 4104413439,\n  seagreen: 780883967,\n  seashell: 4294307583,\n  sienna: 2689740287,\n  silver: 3233857791,\n  skyblue: 2278484991,\n  slateblue: 1784335871,\n  slategray: 1887473919,\n  slategrey: 1887473919,\n  snow: 4294638335,\n  springgreen: 16744447,\n  steelblue: 1182971135,\n  tan: 3535047935,\n  teal: 8421631,\n  thistle: 3636451583,\n  tomato: 4284696575,\n  turquoise: 1088475391,\n  violet: 4001558271,\n  wheat: 4125012991,\n  white: 4294967295,\n  whitesmoke: 4126537215,\n  yellow: 4294902015,\n  yellowgreen: 2597139199\n};\n\n// src/v5-flag.ts\nvar ENABLE_V5_BREAKING_CHANGES = false;\n\n// src/validate-frame.ts\nvar validateFrame = ({\n  allowFloats,\n  durationInFrames,\n  frame\n}) => {\n  if (typeof frame === \"undefined\") {\n    throw new TypeError(`Argument missing for parameter \"frame\"`);\n  }\n  if (typeof frame !== \"number\") {\n    throw new TypeError(`Argument passed for \"frame\" is not a number: ${frame}`);\n  }\n  if (!Number.isFinite(frame)) {\n    throw new RangeError(`Frame ${frame} is not finite`);\n  }\n  if (frame % 1 !== 0 && !allowFloats) {\n    throw new RangeError(`Argument for frame must be an integer, but got ${frame}`);\n  }\n  if (frame < 0 && frame < -durationInFrames) {\n    throw new RangeError(`Cannot use frame ${frame}: Duration of composition is ${durationInFrames}, therefore the lowest frame that can be rendered is ${-durationInFrames}`);\n  }\n  if (frame > durationInFrames - 1) {\n    throw new RangeError(`Cannot use frame ${frame}: Duration of composition is ${durationInFrames}, therefore the highest frame that can be rendered is ${durationInFrames - 1}`);\n  }\n};\n\n// src/validation/validate-default-props.ts\nvar validateDefaultAndInputProps = (defaultProps, name, compositionId) => {\n  if (!defaultProps) {\n    return;\n  }\n  if (typeof defaultProps !== \"object\") {\n    throw new Error(`\"${name}\" must be an object, but you passed a value of type ${typeof defaultProps}`);\n  }\n  if (Array.isArray(defaultProps)) {\n    throw new Error(`\"${name}\" must be an object, an array was passed ${compositionId ? `for composition \"${compositionId}\"` : \"\"}`);\n  }\n};\n\n// src/validation/validate-dimensions.ts\nfunction validateDimension(amount, nameOfProp, location) {\n  if (typeof amount !== \"number\") {\n    throw new Error(`The \"${nameOfProp}\" prop ${location} must be a number, but you passed a value of type ${typeof amount}`);\n  }\n  if (isNaN(amount)) {\n    throw new TypeError(`The \"${nameOfProp}\" prop ${location} must not be NaN, but is NaN.`);\n  }\n  if (!Number.isFinite(amount)) {\n    throw new TypeError(`The \"${nameOfProp}\" prop ${location} must be finite, but is ${amount}.`);\n  }\n  if (amount % 1 !== 0) {\n    throw new TypeError(`The \"${nameOfProp}\" prop ${location} must be an integer, but is ${amount}.`);\n  }\n  if (amount <= 0) {\n    throw new TypeError(`The \"${nameOfProp}\" prop ${location} must be positive, but got ${amount}.`);\n  }\n}\n\n// src/validation/validate-duration-in-frames.ts\nfunction validateDurationInFrames(durationInFrames, options) {\n  const { allowFloats, component } = options;\n  if (typeof durationInFrames === \"undefined\") {\n    throw new Error(`The \"durationInFrames\" prop ${component} is missing.`);\n  }\n  if (typeof durationInFrames !== \"number\") {\n    throw new Error(`The \"durationInFrames\" prop ${component} must be a number, but you passed a value of type ${typeof durationInFrames}`);\n  }\n  if (durationInFrames <= 0) {\n    throw new TypeError(`The \"durationInFrames\" prop ${component} must be positive, but got ${durationInFrames}.`);\n  }\n  if (!allowFloats && durationInFrames % 1 !== 0) {\n    throw new TypeError(`The \"durationInFrames\" prop ${component} must be an integer, but got ${durationInFrames}.`);\n  }\n  if (!Number.isFinite(durationInFrames)) {\n    throw new TypeError(`The \"durationInFrames\" prop ${component} must be finite, but got ${durationInFrames}.`);\n  }\n}\n\n// src/validation/validate-fps.ts\nfunction validateFps(fps, location, isGif) {\n  if (typeof fps !== \"number\") {\n    throw new Error(`\"fps\" must be a number, but you passed a value of type ${typeof fps} ${location}`);\n  }\n  if (!Number.isFinite(fps)) {\n    throw new Error(`\"fps\" must be a finite, but you passed ${fps} ${location}`);\n  }\n  if (isNaN(fps)) {\n    throw new Error(`\"fps\" must not be NaN, but got ${fps} ${location}`);\n  }\n  if (fps <= 0) {\n    throw new TypeError(`\"fps\" must be positive, but got ${fps} ${location}`);\n  }\n  if (isGif && fps > 50) {\n    throw new TypeError(`The FPS for a GIF cannot be higher than 50. Use the --every-nth-frame option to lower the FPS: https://remotion.dev/docs/render-as-gif`);\n  }\n}\n\n// src/video/get-current-time.ts\nvar getExpectedMediaFrameUncorrected = ({\n  frame,\n  playbackRate,\n  startFrom\n}) => {\n  return interpolate(frame, [-1, startFrom, startFrom + 1], [-1, startFrom, startFrom + playbackRate]);\n};\n\n// src/absolute-src.ts\nvar getAbsoluteSrc = (relativeSrc) => {\n  if (typeof window === \"undefined\") {\n    return relativeSrc;\n  }\n  return new URL(relativeSrc, window.origin).href;\n};\n\n// src/video/offthread-video-source.ts\nvar getOffthreadVideoSource = ({\n  src,\n  transparent,\n  currentTime,\n  toneMapped\n}) => {\n  return `http://localhost:${window.remotion_proxyPort}/proxy?src=${encodeURIComponent(getAbsoluteSrc(src))}&time=${encodeURIComponent(currentTime)}&transparent=${String(transparent)}&toneMapped=${String(toneMapped)}`;\n};\n\n// src/no-react.ts\nvar NoReactInternals = {\n  processColor,\n  truthy,\n  validateFps,\n  validateDimension,\n  validateDurationInFrames,\n  validateDefaultAndInputProps,\n  validateFrame,\n  serializeJSONWithDate,\n  bundleName: \"bundle.js\",\n  bundleMapName: \"bundle.js.map\",\n  deserializeJSONWithCustomFields,\n  DELAY_RENDER_CALLSTACK_TOKEN,\n  DELAY_RENDER_RETRY_TOKEN,\n  DELAY_RENDER_ATTEMPT_TOKEN: DELAY_RENDER_RETRIES_LEFT,\n  getOffthreadVideoSource,\n  getExpectedMediaFrameUncorrected,\n  ENABLE_V5_BREAKING_CHANGES,\n  MIN_NODE_VERSION: ENABLE_V5_BREAKING_CHANGES ? 18 : 16,\n  MIN_BUN_VERSION: ENABLE_V5_BREAKING_CHANGES ? \"1.1.3\" : \"1.0.3\",\n  colorNames,\n  DATE_TOKEN,\n  FILE_TOKEN\n};\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvcmVtb3Rpb24vZGlzdC9lc20vbm8tcmVhY3QubWpzIiwibWFwcGluZ3MiOiI7Ozs7OztBQUFBO0FBQ0E7QUFDQSxVQUFVLDRDQUE0QztBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSwyQkFBMkI7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsZ0JBQWdCO0FBQ2pDO0FBQ0EsdUZBQXVGLGNBQWM7QUFDckc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLE1BQU07QUFDL0I7QUFDQTtBQUNBLHlCQUF5QixNQUFNLDZDQUE2QyxjQUFjO0FBQzFGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLGdCQUFnQjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0MsS0FBSyw2Q0FBNkMsMkJBQTJCO0FBQ2pIO0FBQ0EsY0FBYywyQkFBMkIsR0FBRyx1QkFBdUI7QUFDbkU7QUFDQSxhQUFhLHVCQUF1QjtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0RUFBNEUsS0FBSztBQUNqRjtBQUNBO0FBQ0EsK0VBQStFLEtBQUs7QUFDcEY7QUFDQTtBQUNBLCtFQUErRSxLQUFLO0FBQ3BGO0FBQ0E7QUFDQSw0RkFBNEYsS0FBSztBQUNqRztBQUNBO0FBQ0E7QUFDQSxpRkFBaUYsb0JBQW9CO0FBQ3JHO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxVQUFVO0FBQ3pCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsV0FBVyxFQUFFLG1CQUFtQjtBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLFdBQVcsRUFBRSxtQ0FBbUM7QUFDbEU7QUFDQTtBQUNBLEtBQUs7QUFDTCxhQUFhO0FBQ2IsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEMsRUFBRSxjQUFjLEVBQUUsY0FBYyxFQUFFO0FBQzVFLDBDQUEwQyxFQUFFLGNBQWMsRUFBRSxjQUFjLEVBQUUsY0FBYyxFQUFFO0FBQzVGLDBDQUEwQyxFQUFFO0FBQzVDLDBDQUEwQyxFQUFFO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDLE9BQU87QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdFQUF3RSxNQUFNO0FBQzlFO0FBQ0E7QUFDQSxrQ0FBa0MsT0FBTztBQUN6QztBQUNBO0FBQ0EsMkVBQTJFLE1BQU07QUFDakY7QUFDQTtBQUNBLDZDQUE2QyxNQUFNLCtCQUErQixpQkFBaUIsdURBQXVELGtCQUFrQjtBQUM1SztBQUNBO0FBQ0EsNkNBQTZDLE1BQU0sK0JBQStCLGlCQUFpQix3REFBd0QscUJBQXFCO0FBQ2hMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLEtBQUssc0RBQXNELG9CQUFvQjtBQUN2RztBQUNBO0FBQ0Esd0JBQXdCLEtBQUssMkNBQTJDLG9DQUFvQyxjQUFjLFFBQVE7QUFDbEk7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsV0FBVyxTQUFTLFVBQVUsbURBQW1ELGNBQWM7QUFDM0g7QUFDQTtBQUNBLGdDQUFnQyxXQUFXLFNBQVMsVUFBVTtBQUM5RDtBQUNBO0FBQ0EsZ0NBQWdDLFdBQVcsU0FBUyxVQUFVLHlCQUF5QixPQUFPO0FBQzlGO0FBQ0E7QUFDQSxnQ0FBZ0MsV0FBVyxTQUFTLFVBQVUsNkJBQTZCLE9BQU87QUFDbEc7QUFDQTtBQUNBLGdDQUFnQyxXQUFXLFNBQVMsVUFBVSw0QkFBNEIsT0FBTztBQUNqRztBQUNBOztBQUVBO0FBQ0E7QUFDQSxVQUFVLHlCQUF5QjtBQUNuQztBQUNBLG1EQUFtRCxXQUFXO0FBQzlEO0FBQ0E7QUFDQSxtREFBbUQsV0FBVyxtREFBbUQsd0JBQXdCO0FBQ3pJO0FBQ0E7QUFDQSx1REFBdUQsV0FBVyw0QkFBNEIsaUJBQWlCO0FBQy9HO0FBQ0E7QUFDQSx1REFBdUQsV0FBVyw4QkFBOEIsaUJBQWlCO0FBQ2pIO0FBQ0E7QUFDQSx1REFBdUQsV0FBVywwQkFBMEIsaUJBQWlCO0FBQzdHO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsOEVBQThFLFlBQVksRUFBRSxTQUFTO0FBQ3JHO0FBQ0E7QUFDQSw4REFBOEQsS0FBSyxFQUFFLFNBQVM7QUFDOUU7QUFDQTtBQUNBLHNEQUFzRCxLQUFLLEVBQUUsU0FBUztBQUN0RTtBQUNBO0FBQ0EsMkRBQTJELEtBQUssRUFBRSxTQUFTO0FBQzNFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRCw2QkFBNkIsMEJBQTBCLGFBQWEsd0NBQXdDLFFBQVEsZ0NBQWdDLGVBQWUsb0JBQW9CLGNBQWMsbUJBQW1CO0FBQ3hOOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBS0UiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9teS1hcHAvLi9ub2RlX21vZHVsZXMvcmVtb3Rpb24vZGlzdC9lc20vbm8tcmVhY3QubWpzPzE5OTEiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gc3JjL2ludGVycG9sYXRlLnRzXG5mdW5jdGlvbiBpbnRlcnBvbGF0ZUZ1bmN0aW9uKGlucHV0LCBpbnB1dFJhbmdlLCBvdXRwdXRSYW5nZSwgb3B0aW9ucykge1xuICBjb25zdCB7IGV4dHJhcG9sYXRlTGVmdCwgZXh0cmFwb2xhdGVSaWdodCwgZWFzaW5nIH0gPSBvcHRpb25zO1xuICBsZXQgcmVzdWx0ID0gaW5wdXQ7XG4gIGNvbnN0IFtpbnB1dE1pbiwgaW5wdXRNYXhdID0gaW5wdXRSYW5nZTtcbiAgY29uc3QgW291dHB1dE1pbiwgb3V0cHV0TWF4XSA9IG91dHB1dFJhbmdlO1xuICBpZiAocmVzdWx0IDwgaW5wdXRNaW4pIHtcbiAgICBpZiAoZXh0cmFwb2xhdGVMZWZ0ID09PSBcImlkZW50aXR5XCIpIHtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIGlmIChleHRyYXBvbGF0ZUxlZnQgPT09IFwiY2xhbXBcIikge1xuICAgICAgcmVzdWx0ID0gaW5wdXRNaW47XG4gICAgfSBlbHNlIGlmIChleHRyYXBvbGF0ZUxlZnQgPT09IFwid3JhcFwiKSB7XG4gICAgICBjb25zdCByYW5nZSA9IGlucHV0TWF4IC0gaW5wdXRNaW47XG4gICAgICByZXN1bHQgPSAoKHJlc3VsdCAtIGlucHV0TWluKSAlIHJhbmdlICsgcmFuZ2UpICUgcmFuZ2UgKyBpbnB1dE1pbjtcbiAgICB9IGVsc2UgaWYgKGV4dHJhcG9sYXRlTGVmdCA9PT0gXCJleHRlbmRcIikge1xuICAgIH1cbiAgfVxuICBpZiAocmVzdWx0ID4gaW5wdXRNYXgpIHtcbiAgICBpZiAoZXh0cmFwb2xhdGVSaWdodCA9PT0gXCJpZGVudGl0eVwiKSB7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICBpZiAoZXh0cmFwb2xhdGVSaWdodCA9PT0gXCJjbGFtcFwiKSB7XG4gICAgICByZXN1bHQgPSBpbnB1dE1heDtcbiAgICB9IGVsc2UgaWYgKGV4dHJhcG9sYXRlUmlnaHQgPT09IFwid3JhcFwiKSB7XG4gICAgICBjb25zdCByYW5nZSA9IGlucHV0TWF4IC0gaW5wdXRNaW47XG4gICAgICByZXN1bHQgPSAoKHJlc3VsdCAtIGlucHV0TWluKSAlIHJhbmdlICsgcmFuZ2UpICUgcmFuZ2UgKyBpbnB1dE1pbjtcbiAgICB9IGVsc2UgaWYgKGV4dHJhcG9sYXRlUmlnaHQgPT09IFwiZXh0ZW5kXCIpIHtcbiAgICB9XG4gIH1cbiAgaWYgKG91dHB1dE1pbiA9PT0gb3V0cHV0TWF4KSB7XG4gICAgcmV0dXJuIG91dHB1dE1pbjtcbiAgfVxuICByZXN1bHQgPSAocmVzdWx0IC0gaW5wdXRNaW4pIC8gKGlucHV0TWF4IC0gaW5wdXRNaW4pO1xuICByZXN1bHQgPSBlYXNpbmcocmVzdWx0KTtcbiAgcmVzdWx0ID0gcmVzdWx0ICogKG91dHB1dE1heCAtIG91dHB1dE1pbikgKyBvdXRwdXRNaW47XG4gIHJldHVybiByZXN1bHQ7XG59XG5mdW5jdGlvbiBmaW5kUmFuZ2UoaW5wdXQsIGlucHV0UmFuZ2UpIHtcbiAgbGV0IGk7XG4gIGZvciAoaSA9IDE7aSA8IGlucHV0UmFuZ2UubGVuZ3RoIC0gMTsgKytpKSB7XG4gICAgaWYgKGlucHV0UmFuZ2VbaV0gPj0gaW5wdXQpIHtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuICByZXR1cm4gaSAtIDE7XG59XG5mdW5jdGlvbiBjaGVja1ZhbGlkSW5wdXRSYW5nZShhcnIpIHtcbiAgZm9yIChsZXQgaSA9IDE7aSA8IGFyci5sZW5ndGg7ICsraSkge1xuICAgIGlmICghKGFycltpXSA+IGFycltpIC0gMV0pKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYGlucHV0UmFuZ2UgbXVzdCBiZSBzdHJpY3RseSBtb25vdG9uaWNhbGx5IGluY3JlYXNpbmcgYnV0IGdvdCBbJHthcnIuam9pbihcIixcIil9XWApO1xuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gY2hlY2tJbmZpbml0ZVJhbmdlKG5hbWUsIGFycikge1xuICBpZiAoYXJyLmxlbmd0aCA8IDIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IobmFtZSArIFwiIG11c3QgaGF2ZSBhdCBsZWFzdCAyIGVsZW1lbnRzXCIpO1xuICB9XG4gIGZvciAoY29uc3QgZWxlbWVudCBvZiBhcnIpIHtcbiAgICBpZiAodHlwZW9mIGVsZW1lbnQgIT09IFwibnVtYmVyXCIpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgJHtuYW1lfSBtdXN0IGNvbnRhaW4gb25seSBudW1iZXJzYCk7XG4gICAgfVxuICAgIGlmICghTnVtYmVyLmlzRmluaXRlKGVsZW1lbnQpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYCR7bmFtZX0gbXVzdCBjb250YWluIG9ubHkgZmluaXRlIG51bWJlcnMsIGJ1dCBnb3QgWyR7YXJyLmpvaW4oXCIsXCIpfV1gKTtcbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIGludGVycG9sYXRlKGlucHV0LCBpbnB1dFJhbmdlLCBvdXRwdXRSYW5nZSwgb3B0aW9ucykge1xuICBpZiAodHlwZW9mIGlucHV0ID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiaW5wdXQgY2FuIG5vdCBiZSB1bmRlZmluZWRcIik7XG4gIH1cbiAgaWYgKHR5cGVvZiBpbnB1dFJhbmdlID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiaW5wdXRSYW5nZSBjYW4gbm90IGJlIHVuZGVmaW5lZFwiKTtcbiAgfVxuICBpZiAodHlwZW9mIG91dHB1dFJhbmdlID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwib3V0cHV0UmFuZ2UgY2FuIG5vdCBiZSB1bmRlZmluZWRcIik7XG4gIH1cbiAgaWYgKGlucHV0UmFuZ2UubGVuZ3RoICE9PSBvdXRwdXRSYW5nZS5sZW5ndGgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJpbnB1dFJhbmdlIChcIiArIGlucHV0UmFuZ2UubGVuZ3RoICsgXCIpIGFuZCBvdXRwdXRSYW5nZSAoXCIgKyBvdXRwdXRSYW5nZS5sZW5ndGggKyBcIikgbXVzdCBoYXZlIHRoZSBzYW1lIGxlbmd0aFwiKTtcbiAgfVxuICBjaGVja0luZmluaXRlUmFuZ2UoXCJpbnB1dFJhbmdlXCIsIGlucHV0UmFuZ2UpO1xuICBjaGVja0luZmluaXRlUmFuZ2UoXCJvdXRwdXRSYW5nZVwiLCBvdXRwdXRSYW5nZSk7XG4gIGNoZWNrVmFsaWRJbnB1dFJhbmdlKGlucHV0UmFuZ2UpO1xuICBjb25zdCBlYXNpbmcgPSBvcHRpb25zPy5lYXNpbmcgPz8gKChudW0pID0+IG51bSk7XG4gIGxldCBleHRyYXBvbGF0ZUxlZnQgPSBcImV4dGVuZFwiO1xuICBpZiAob3B0aW9ucz8uZXh0cmFwb2xhdGVMZWZ0ICE9PSB1bmRlZmluZWQpIHtcbiAgICBleHRyYXBvbGF0ZUxlZnQgPSBvcHRpb25zLmV4dHJhcG9sYXRlTGVmdDtcbiAgfVxuICBsZXQgZXh0cmFwb2xhdGVSaWdodCA9IFwiZXh0ZW5kXCI7XG4gIGlmIChvcHRpb25zPy5leHRyYXBvbGF0ZVJpZ2h0ICE9PSB1bmRlZmluZWQpIHtcbiAgICBleHRyYXBvbGF0ZVJpZ2h0ID0gb3B0aW9ucy5leHRyYXBvbGF0ZVJpZ2h0O1xuICB9XG4gIGlmICh0eXBlb2YgaW5wdXQgIT09IFwibnVtYmVyXCIpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGludGVycG9sYXRlIGFuIGlucHV0IHdoaWNoIGlzIG5vdCBhIG51bWJlclwiKTtcbiAgfVxuICBjb25zdCByYW5nZSA9IGZpbmRSYW5nZShpbnB1dCwgaW5wdXRSYW5nZSk7XG4gIHJldHVybiBpbnRlcnBvbGF0ZUZ1bmN0aW9uKGlucHV0LCBbaW5wdXRSYW5nZVtyYW5nZV0sIGlucHV0UmFuZ2VbcmFuZ2UgKyAxXV0sIFtvdXRwdXRSYW5nZVtyYW5nZV0sIG91dHB1dFJhbmdlW3JhbmdlICsgMV1dLCB7XG4gICAgZWFzaW5nLFxuICAgIGV4dHJhcG9sYXRlTGVmdCxcbiAgICBleHRyYXBvbGF0ZVJpZ2h0XG4gIH0pO1xufVxuLy8gc3JjL3JhbmRvbS50c1xuZnVuY3Rpb24gbXVsYmVycnkzMihhKSB7XG4gIGxldCB0ID0gYSArIDE4MzE1NjU4MTM7XG4gIHQgPSBNYXRoLmltdWwodCBeIHQgPj4+IDE1LCB0IHwgMSk7XG4gIHQgXj0gdCArIE1hdGguaW11bCh0IF4gdCA+Pj4gNywgdCB8IDYxKTtcbiAgcmV0dXJuICgodCBeIHQgPj4+IDE0KSA+Pj4gMCkgLyA0Mjk0OTY3Mjk2O1xufVxuZnVuY3Rpb24gaGFzaENvZGUoc3RyKSB7XG4gIGxldCBpID0gMDtcbiAgbGV0IGNociA9IDA7XG4gIGxldCBoYXNoID0gMDtcbiAgZm9yIChpID0gMDtpIDwgc3RyLmxlbmd0aDsgaSsrKSB7XG4gICAgY2hyID0gc3RyLmNoYXJDb2RlQXQoaSk7XG4gICAgaGFzaCA9IChoYXNoIDw8IDUpIC0gaGFzaCArIGNocjtcbiAgICBoYXNoIHw9IDA7XG4gIH1cbiAgcmV0dXJuIGhhc2g7XG59XG52YXIgcmFuZG9tID0gKHNlZWQsIGR1bW15KSA9PiB7XG4gIGlmIChkdW1teSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcInJhbmRvbSgpIHRha2VzIG9ubHkgb25lIGFyZ3VtZW50XCIpO1xuICB9XG4gIGlmIChzZWVkID09PSBudWxsKSB7XG4gICAgcmV0dXJuIE1hdGgucmFuZG9tKCk7XG4gIH1cbiAgaWYgKHR5cGVvZiBzZWVkID09PSBcInN0cmluZ1wiKSB7XG4gICAgcmV0dXJuIG11bGJlcnJ5MzIoaGFzaENvZGUoc2VlZCkpO1xuICB9XG4gIGlmICh0eXBlb2Ygc2VlZCA9PT0gXCJudW1iZXJcIikge1xuICAgIHJldHVybiBtdWxiZXJyeTMyKHNlZWQgKiAxMDAwMDAwMDAwMCk7XG4gIH1cbiAgdGhyb3cgbmV3IEVycm9yKFwicmFuZG9tKCkgYXJndW1lbnQgbXVzdCBiZSBhIG51bWJlciBvciBhIHN0cmluZ1wiKTtcbn07XG4vLyBzcmMvdHJ1dGh5LnRzXG5mdW5jdGlvbiB0cnV0aHkodmFsdWUpIHtcbiAgcmV0dXJuIEJvb2xlYW4odmFsdWUpO1xufVxuXG4vLyBzcmMvZGVsYXktcmVuZGVyLnRzXG5pZiAodHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIikge1xuICB3aW5kb3cucmVtb3Rpb25fcmVuZGVyUmVhZHkgPSBmYWxzZTtcbn1cbmlmICh0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gIHdpbmRvdy5yZW1vdGlvbl9kZWxheVJlbmRlclRpbWVvdXRzID0ge307XG59XG52YXIgREVMQVlfUkVOREVSX0NBTExTVEFDS19UT0tFTiA9IFwiVGhlIGRlbGF5UmVuZGVyIHdhcyBjYWxsZWQ6XCI7XG52YXIgREVMQVlfUkVOREVSX1JFVFJJRVNfTEVGVCA9IFwiUmV0cmllcyBsZWZ0OiBcIjtcbnZhciBERUxBWV9SRU5ERVJfUkVUUllfVE9LRU4gPSBcIi0gUmVuZGVyaW5nIHRoZSBmcmFtZSB3aWxsIGJlIHJldHJpZWQuXCI7XG5cbi8vIHNyYy9zdGF0aWMtZmlsZS50c1xudmFyIHByb2JsZW1hdGljQ2hhcmFjdGVycyA9IHtcbiAgXCIlM0FcIjogXCI6XCIsXG4gIFwiJTJGXCI6IFwiL1wiLFxuICBcIiUzRlwiOiBcIj9cIixcbiAgXCIlMjNcIjogXCIjXCIsXG4gIFwiJTVCXCI6IFwiW1wiLFxuICBcIiU1RFwiOiBcIl1cIixcbiAgXCIlNDBcIjogXCJAXCIsXG4gIFwiJTIxXCI6IFwiIVwiLFxuICBcIiUyNFwiOiBcIiRcIixcbiAgXCIlMjZcIjogXCImXCIsXG4gIFwiJTI3XCI6IFwiJ1wiLFxuICBcIiUyOFwiOiBcIihcIixcbiAgXCIlMjlcIjogXCIpXCIsXG4gIFwiJTJBXCI6IFwiKlwiLFxuICBcIiUyQlwiOiBcIitcIixcbiAgXCIlMkNcIjogXCIsXCIsXG4gIFwiJTNCXCI6IFwiO1wiXG59O1xudmFyIGRpZFdhcm4gPSB7fTtcbnZhciB3YXJuT25jZSA9IChtZXNzYWdlKSA9PiB7XG4gIGlmIChkaWRXYXJuW21lc3NhZ2VdKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGNvbnNvbGUud2FybihtZXNzYWdlKTtcbiAgZGlkV2FyblttZXNzYWdlXSA9IHRydWU7XG59O1xudmFyIGluY2x1ZGVzSGV4T2ZVbnNhZmVDaGFyID0gKHBhdGgpID0+IHtcbiAgZm9yIChjb25zdCBrZXkgb2YgT2JqZWN0LmtleXMocHJvYmxlbWF0aWNDaGFyYWN0ZXJzKSkge1xuICAgIGlmIChwYXRoLmluY2x1ZGVzKGtleSkpIHtcbiAgICAgIHJldHVybiB7IGNvbnRhaW5zSGV4OiB0cnVlLCBoZXhDb2RlOiBrZXkgfTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHsgY29udGFpbnNIZXg6IGZhbHNlIH07XG59O1xudmFyIHRyaW1MZWFkaW5nU2xhc2ggPSAocGF0aCkgPT4ge1xuICBpZiAocGF0aC5zdGFydHNXaXRoKFwiL1wiKSkge1xuICAgIHJldHVybiB0cmltTGVhZGluZ1NsYXNoKHBhdGguc3Vic3RyaW5nKDEpKTtcbiAgfVxuICByZXR1cm4gcGF0aDtcbn07XG52YXIgaW5uZXIgPSAocGF0aCkgPT4ge1xuICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiAmJiB3aW5kb3cucmVtb3Rpb25fc3RhdGljQmFzZSkge1xuICAgIGlmIChwYXRoLnN0YXJ0c1dpdGgod2luZG93LnJlbW90aW9uX3N0YXRpY0Jhc2UpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYFRoZSB2YWx1ZSBcIiR7cGF0aH1cIiBpcyBhbHJlYWR5IHByZWZpeGVkIHdpdGggdGhlIHN0YXRpYyBiYXNlICR7d2luZG93LnJlbW90aW9uX3N0YXRpY0Jhc2V9LiBZb3UgZG9uJ3QgbmVlZCB0byBjYWxsIHN0YXRpY0ZpbGUoKSBvbiBpdC5gKTtcbiAgICB9XG4gICAgcmV0dXJuIGAke3dpbmRvdy5yZW1vdGlvbl9zdGF0aWNCYXNlfS8ke3RyaW1MZWFkaW5nU2xhc2gocGF0aCl9YDtcbiAgfVxuICByZXR1cm4gYC8ke3RyaW1MZWFkaW5nU2xhc2gocGF0aCl9YDtcbn07XG52YXIgZW5jb2RlQnlTcGxpdHRpbmcgPSAocGF0aCkgPT4ge1xuICBjb25zdCBzcGxpdEJ5U2xhc2ggPSBwYXRoLnNwbGl0KFwiL1wiKTtcbiAgY29uc3QgZW5jb2RlZEFycmF5ID0gc3BsaXRCeVNsYXNoLm1hcCgoZWxlbWVudCkgPT4ge1xuICAgIHJldHVybiBlbmNvZGVVUklDb21wb25lbnQoZWxlbWVudCk7XG4gIH0pO1xuICBjb25zdCBtZXJnZWQgPSBlbmNvZGVkQXJyYXkuam9pbihcIi9cIik7XG4gIHJldHVybiBtZXJnZWQ7XG59O1xudmFyIHN0YXRpY0ZpbGUgPSAocGF0aCkgPT4ge1xuICBpZiAocGF0aCA9PT0gbnVsbCkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJudWxsIHdhcyBwYXNzZWQgdG8gc3RhdGljRmlsZSgpXCIpO1xuICB9XG4gIGlmICh0eXBlb2YgcGF0aCA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJ1bmRlZmluZWQgd2FzIHBhc3NlZCB0byBzdGF0aWNGaWxlKClcIik7XG4gIH1cbiAgaWYgKHBhdGguc3RhcnRzV2l0aChcImh0dHA6Ly9cIikgfHwgcGF0aC5zdGFydHNXaXRoKFwiaHR0cHM6Ly9cIikpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBzdGF0aWNGaWxlKCkgZG9lcyBub3Qgc3VwcG9ydCByZW1vdGUgVVJMcyAtIGdvdCBcIiR7cGF0aH1cIi4gSW5zdGVhZCwgcGFzcyB0aGUgVVJMIHdpdGhvdXQgd3JhcHBpbmcgaXQgaW4gc3RhdGljRmlsZSgpLiBTZWU6IGh0dHBzOi8vcmVtb3Rpb24uZGV2L2RvY3Mvc3RhdGljZmlsZS1yZW1vdGUtdXJsc2ApO1xuICB9XG4gIGlmIChwYXRoLnN0YXJ0c1dpdGgoXCIuLlwiKSB8fCBwYXRoLnN0YXJ0c1dpdGgoXCIuL1wiKSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYHN0YXRpY0ZpbGUoKSBkb2VzIG5vdCBzdXBwb3J0IHJlbGF0aXZlIHBhdGhzIC0gZ290IFwiJHtwYXRofVwiLiBJbnN0ZWFkLCBwYXNzIHRoZSBuYW1lIG9mIGEgZmlsZSB0aGF0IGlzIGluc2lkZSB0aGUgcHVibGljLyBmb2xkZXIuIFNlZTogaHR0cHM6Ly9yZW1vdGlvbi5kZXYvZG9jcy9zdGF0aWNmaWxlLXJlbGF0aXZlLXBhdGhzYCk7XG4gIH1cbiAgaWYgKHBhdGguc3RhcnRzV2l0aChcIi9Vc2Vyc1wiKSB8fCBwYXRoLnN0YXJ0c1dpdGgoXCIvaG9tZVwiKSB8fCBwYXRoLnN0YXJ0c1dpdGgoXCIvdG1wXCIpIHx8IHBhdGguc3RhcnRzV2l0aChcIi9ldGNcIikgfHwgcGF0aC5zdGFydHNXaXRoKFwiL29wdFwiKSB8fCBwYXRoLnN0YXJ0c1dpdGgoXCIvdmFyXCIpIHx8IHBhdGguc3RhcnRzV2l0aChcIkM6XCIpIHx8IHBhdGguc3RhcnRzV2l0aChcIkQ6XCIpIHx8IHBhdGguc3RhcnRzV2l0aChcIkU6XCIpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgc3RhdGljRmlsZSgpIGRvZXMgbm90IHN1cHBvcnQgYWJzb2x1dGUgcGF0aHMgLSBnb3QgXCIke3BhdGh9XCIuIEluc3RlYWQsIHBhc3MgdGhlIG5hbWUgb2YgYSBmaWxlIHRoYXQgaXMgaW5zaWRlIHRoZSBwdWJsaWMvIGZvbGRlci4gU2VlOiBodHRwczovL3JlbW90aW9uLmRldi9kb2NzL3N0YXRpY2ZpbGUtcmVsYXRpdmUtcGF0aHNgKTtcbiAgfVxuICBpZiAocGF0aC5zdGFydHNXaXRoKFwicHVibGljL1wiKSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYERvIG5vdCBpbmNsdWRlIHRoZSBwdWJsaWMvIHByZWZpeCB3aGVuIHVzaW5nIHN0YXRpY0ZpbGUoKSAtIGdvdCBcIiR7cGF0aH1cIi4gU2VlOiBodHRwczovL3JlbW90aW9uLmRldi9kb2NzL3N0YXRpY2ZpbGUtcmVsYXRpdmUtcGF0aHNgKTtcbiAgfVxuICBjb25zdCBpbmNsdWRlc0hleCA9IGluY2x1ZGVzSGV4T2ZVbnNhZmVDaGFyKHBhdGgpO1xuICBpZiAoaW5jbHVkZXNIZXguY29udGFpbnNIZXgpIHtcbiAgICB3YXJuT25jZShgV0FSTklORzogWW91IHNlZW0gdG8gcGFzcyBhbiBhbHJlYWR5IGVuY29kZWQgcGF0aCAocGF0aCBjb250YWlucyAke2luY2x1ZGVzSGV4LmhleENvZGV9KS4gU2luY2UgUmVtb3Rpb24gNC4wLCB0aGUgZW5jb2RpbmcgaXMgZG9uZSBieSBzdGF0aWNGaWxlKCkgaXRzZWxmLiBZb3UgbWF5IHdhbnQgdG8gcmVtb3ZlIGEgZW5jb2RlVVJJQ29tcG9uZW50KCkgd3JhcHBpbmcuYCk7XG4gIH1cbiAgY29uc3QgcHJlcHJvY2Vzc2VkID0gZW5jb2RlQnlTcGxpdHRpbmcocGF0aCk7XG4gIGNvbnN0IHByZXBhcnNlZCA9IGlubmVyKHByZXByb2Nlc3NlZCk7XG4gIGlmICghcHJlcGFyc2VkLnN0YXJ0c1dpdGgoXCIvXCIpKSB7XG4gICAgcmV0dXJuIGAvJHtwcmVwYXJzZWR9YDtcbiAgfVxuICByZXR1cm4gcHJlcGFyc2VkO1xufTtcblxuLy8gc3JjL2lucHV0LXByb3BzLXNlcmlhbGl6YXRpb24udHNcbnZhciBEQVRFX1RPS0VOID0gXCJyZW1vdGlvbi1kYXRlOlwiO1xudmFyIEZJTEVfVE9LRU4gPSBcInJlbW90aW9uLWZpbGU6XCI7XG52YXIgc2VyaWFsaXplSlNPTldpdGhEYXRlID0gKHtcbiAgZGF0YSxcbiAgaW5kZW50LFxuICBzdGF0aWNCYXNlXG59KSA9PiB7XG4gIGxldCBjdXN0b21EYXRlVXNlZCA9IGZhbHNlO1xuICBsZXQgY3VzdG9tRmlsZVVzZWQgPSBmYWxzZTtcbiAgbGV0IG1hcFVzZWQgPSBmYWxzZTtcbiAgbGV0IHNldFVzZWQgPSBmYWxzZTtcbiAgdHJ5IHtcbiAgICBjb25zdCBzZXJpYWxpemVkU3RyaW5nID0gSlNPTi5zdHJpbmdpZnkoZGF0YSwgZnVuY3Rpb24oa2V5LCB2YWx1ZSkge1xuICAgICAgY29uc3QgaXRlbSA9IHRoaXNba2V5XTtcbiAgICAgIGlmIChpdGVtIGluc3RhbmNlb2YgRGF0ZSkge1xuICAgICAgICBjdXN0b21EYXRlVXNlZCA9IHRydWU7XG4gICAgICAgIHJldHVybiBgJHtEQVRFX1RPS0VOfSR7aXRlbS50b0lTT1N0cmluZygpfWA7XG4gICAgICB9XG4gICAgICBpZiAoaXRlbSBpbnN0YW5jZW9mIE1hcCkge1xuICAgICAgICBtYXBVc2VkID0gdHJ1ZTtcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgfVxuICAgICAgaWYgKGl0ZW0gaW5zdGFuY2VvZiBTZXQpIHtcbiAgICAgICAgc2V0VXNlZCA9IHRydWU7XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgIH1cbiAgICAgIGlmICh0eXBlb2YgaXRlbSA9PT0gXCJzdHJpbmdcIiAmJiBzdGF0aWNCYXNlICE9PSBudWxsICYmIGl0ZW0uc3RhcnRzV2l0aChzdGF0aWNCYXNlKSkge1xuICAgICAgICBjdXN0b21GaWxlVXNlZCA9IHRydWU7XG4gICAgICAgIHJldHVybiBgJHtGSUxFX1RPS0VOfSR7aXRlbS5yZXBsYWNlKHN0YXRpY0Jhc2UgKyBcIi9cIiwgXCJcIil9YDtcbiAgICAgIH1cbiAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9LCBpbmRlbnQpO1xuICAgIHJldHVybiB7IHNlcmlhbGl6ZWRTdHJpbmcsIGN1c3RvbURhdGVVc2VkLCBjdXN0b21GaWxlVXNlZCwgbWFwVXNlZCwgc2V0VXNlZCB9O1xuICB9IGNhdGNoIChlcnIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJDb3VsZCBub3Qgc2VyaWFsaXplIHRoZSBwYXNzZWQgaW5wdXQgcHJvcHMgdG8gSlNPTjogXCIgKyBlcnIubWVzc2FnZSk7XG4gIH1cbn07XG52YXIgZGVzZXJpYWxpemVKU09OV2l0aEN1c3RvbUZpZWxkcyA9IChkYXRhKSA9PiB7XG4gIHJldHVybiBKU09OLnBhcnNlKGRhdGEsIChfLCB2YWx1ZSkgPT4ge1xuICAgIGlmICh0eXBlb2YgdmFsdWUgPT09IFwic3RyaW5nXCIgJiYgdmFsdWUuc3RhcnRzV2l0aChEQVRFX1RPS0VOKSkge1xuICAgICAgcmV0dXJuIG5ldyBEYXRlKHZhbHVlLnJlcGxhY2UoREFURV9UT0tFTiwgXCJcIikpO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIHZhbHVlID09PSBcInN0cmluZ1wiICYmIHZhbHVlLnN0YXJ0c1dpdGgoRklMRV9UT0tFTikpIHtcbiAgICAgIHJldHVybiBzdGF0aWNGaWxlKHZhbHVlLnJlcGxhY2UoRklMRV9UT0tFTiwgXCJcIikpO1xuICAgIH1cbiAgICByZXR1cm4gdmFsdWU7XG4gIH0pO1xufTtcblxuLy8gc3JjL2ludGVycG9sYXRlLWNvbG9ycy50c1xuZnVuY3Rpb24gY2FsbCguLi5hcmdzKSB7XG4gIHJldHVybiBcIlxcXFwoXFxcXHMqKFwiICsgYXJncy5qb2luKFwiKVxcXFxzKixcXFxccyooXCIpICsgXCIpXFxcXHMqXFxcXClcIjtcbn1cbmZ1bmN0aW9uIGdldE1hdGNoZXJzKCkge1xuICBjb25zdCBjYWNoZWRNYXRjaGVycyA9IHtcbiAgICByZ2I6IHVuZGVmaW5lZCxcbiAgICByZ2JhOiB1bmRlZmluZWQsXG4gICAgaHNsOiB1bmRlZmluZWQsXG4gICAgaHNsYTogdW5kZWZpbmVkLFxuICAgIGhleDM6IHVuZGVmaW5lZCxcbiAgICBoZXg0OiB1bmRlZmluZWQsXG4gICAgaGV4NTogdW5kZWZpbmVkLFxuICAgIGhleDY6IHVuZGVmaW5lZCxcbiAgICBoZXg4OiB1bmRlZmluZWRcbiAgfTtcbiAgaWYgKGNhY2hlZE1hdGNoZXJzLnJnYiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgY2FjaGVkTWF0Y2hlcnMucmdiID0gbmV3IFJlZ0V4cChcInJnYlwiICsgY2FsbChOVU1CRVIsIE5VTUJFUiwgTlVNQkVSKSk7XG4gICAgY2FjaGVkTWF0Y2hlcnMucmdiYSA9IG5ldyBSZWdFeHAoXCJyZ2JhXCIgKyBjYWxsKE5VTUJFUiwgTlVNQkVSLCBOVU1CRVIsIE5VTUJFUikpO1xuICAgIGNhY2hlZE1hdGNoZXJzLmhzbCA9IG5ldyBSZWdFeHAoXCJoc2xcIiArIGNhbGwoTlVNQkVSLCBQRVJDRU5UQUdFLCBQRVJDRU5UQUdFKSk7XG4gICAgY2FjaGVkTWF0Y2hlcnMuaHNsYSA9IG5ldyBSZWdFeHAoXCJoc2xhXCIgKyBjYWxsKE5VTUJFUiwgUEVSQ0VOVEFHRSwgUEVSQ0VOVEFHRSwgTlVNQkVSKSk7XG4gICAgY2FjaGVkTWF0Y2hlcnMuaGV4MyA9IC9eIyhbMC05YS1mQS1GXXsxfSkoWzAtOWEtZkEtRl17MX0pKFswLTlhLWZBLUZdezF9KSQvO1xuICAgIGNhY2hlZE1hdGNoZXJzLmhleDQgPSAvXiMoWzAtOWEtZkEtRl17MX0pKFswLTlhLWZBLUZdezF9KShbMC05YS1mQS1GXXsxfSkoWzAtOWEtZkEtRl17MX0pJC87XG4gICAgY2FjaGVkTWF0Y2hlcnMuaGV4NiA9IC9eIyhbMC05YS1mQS1GXXs2fSkkLztcbiAgICBjYWNoZWRNYXRjaGVycy5oZXg4ID0gL14jKFswLTlhLWZBLUZdezh9KSQvO1xuICB9XG4gIHJldHVybiBjYWNoZWRNYXRjaGVycztcbn1cbmZ1bmN0aW9uIGh1ZTJyZ2IocCwgcSwgdCkge1xuICBpZiAodCA8IDApIHtcbiAgICB0ICs9IDE7XG4gIH1cbiAgaWYgKHQgPiAxKSB7XG4gICAgdCAtPSAxO1xuICB9XG4gIGlmICh0IDwgMSAvIDYpIHtcbiAgICByZXR1cm4gcCArIChxIC0gcCkgKiA2ICogdDtcbiAgfVxuICBpZiAodCA8IDEgLyAyKSB7XG4gICAgcmV0dXJuIHE7XG4gIH1cbiAgaWYgKHQgPCAyIC8gMykge1xuICAgIHJldHVybiBwICsgKHEgLSBwKSAqICgyIC8gMyAtIHQpICogNjtcbiAgfVxuICByZXR1cm4gcDtcbn1cbmZ1bmN0aW9uIGhzbFRvUmdiKGgsIHMsIGwpIHtcbiAgY29uc3QgcSA9IGwgPCAwLjUgPyBsICogKDEgKyBzKSA6IGwgKyBzIC0gbCAqIHM7XG4gIGNvbnN0IHAgPSAyICogbCAtIHE7XG4gIGNvbnN0IHIgPSBodWUycmdiKHAsIHEsIGggKyAxIC8gMyk7XG4gIGNvbnN0IGcgPSBodWUycmdiKHAsIHEsIGgpO1xuICBjb25zdCBiID0gaHVlMnJnYihwLCBxLCBoIC0gMSAvIDMpO1xuICByZXR1cm4gTWF0aC5yb3VuZChyICogMjU1KSA8PCAyNCB8IE1hdGgucm91bmQoZyAqIDI1NSkgPDwgMTYgfCBNYXRoLnJvdW5kKGIgKiAyNTUpIDw8IDg7XG59XG5mdW5jdGlvbiBwYXJzZTI1NShzdHIpIHtcbiAgY29uc3QgaW50ID0gTnVtYmVyLnBhcnNlSW50KHN0ciwgMTApO1xuICBpZiAoaW50IDwgMCkge1xuICAgIHJldHVybiAwO1xuICB9XG4gIGlmIChpbnQgPiAyNTUpIHtcbiAgICByZXR1cm4gMjU1O1xuICB9XG4gIHJldHVybiBpbnQ7XG59XG5mdW5jdGlvbiBwYXJzZTM2MChzdHIpIHtcbiAgY29uc3QgaW50ID0gTnVtYmVyLnBhcnNlRmxvYXQoc3RyKTtcbiAgcmV0dXJuIChpbnQgJSAzNjAgKyAzNjApICUgMzYwIC8gMzYwO1xufVxuZnVuY3Rpb24gcGFyc2UxKHN0cikge1xuICBjb25zdCBudW0gPSBOdW1iZXIucGFyc2VGbG9hdChzdHIpO1xuICBpZiAobnVtIDwgMCkge1xuICAgIHJldHVybiAwO1xuICB9XG4gIGlmIChudW0gPiAxKSB7XG4gICAgcmV0dXJuIDI1NTtcbiAgfVxuICByZXR1cm4gTWF0aC5yb3VuZChudW0gKiAyNTUpO1xufVxuZnVuY3Rpb24gcGFyc2VQZXJjZW50YWdlKHN0cikge1xuICBjb25zdCBpbnQgPSBOdW1iZXIucGFyc2VGbG9hdChzdHIpO1xuICBpZiAoaW50IDwgMCkge1xuICAgIHJldHVybiAwO1xuICB9XG4gIGlmIChpbnQgPiAxMDApIHtcbiAgICByZXR1cm4gMTtcbiAgfVxuICByZXR1cm4gaW50IC8gMTAwO1xufVxuZnVuY3Rpb24gbm9ybWFsaXplQ29sb3IoY29sb3IpIHtcbiAgY29uc3QgbWF0Y2hlcnMgPSBnZXRNYXRjaGVycygpO1xuICBsZXQgbWF0Y2g7XG4gIGlmIChtYXRjaGVycy5oZXg2KSB7XG4gICAgaWYgKG1hdGNoID0gbWF0Y2hlcnMuaGV4Ni5leGVjKGNvbG9yKSkge1xuICAgICAgcmV0dXJuIE51bWJlci5wYXJzZUludChtYXRjaFsxXSArIFwiZmZcIiwgMTYpID4+PiAwO1xuICAgIH1cbiAgfVxuICBpZiAoY29sb3JOYW1lc1tjb2xvcl0gIT09IHVuZGVmaW5lZCkge1xuICAgIHJldHVybiBjb2xvck5hbWVzW2NvbG9yXTtcbiAgfVxuICBpZiAobWF0Y2hlcnMucmdiKSB7XG4gICAgaWYgKG1hdGNoID0gbWF0Y2hlcnMucmdiLmV4ZWMoY29sb3IpKSB7XG4gICAgICByZXR1cm4gKHBhcnNlMjU1KG1hdGNoWzFdKSA8PCAyNCB8IHBhcnNlMjU1KG1hdGNoWzJdKSA8PCAxNiB8IHBhcnNlMjU1KG1hdGNoWzNdKSA8PCA4IHwgMjU1KSA+Pj4gMDtcbiAgICB9XG4gIH1cbiAgaWYgKG1hdGNoZXJzLnJnYmEpIHtcbiAgICBpZiAobWF0Y2ggPSBtYXRjaGVycy5yZ2JhLmV4ZWMoY29sb3IpKSB7XG4gICAgICByZXR1cm4gKHBhcnNlMjU1KG1hdGNoWzFdKSA8PCAyNCB8IHBhcnNlMjU1KG1hdGNoWzJdKSA8PCAxNiB8IHBhcnNlMjU1KG1hdGNoWzNdKSA8PCA4IHwgcGFyc2UxKG1hdGNoWzRdKSkgPj4+IDA7XG4gICAgfVxuICB9XG4gIGlmIChtYXRjaGVycy5oZXgzKSB7XG4gICAgaWYgKG1hdGNoID0gbWF0Y2hlcnMuaGV4My5leGVjKGNvbG9yKSkge1xuICAgICAgcmV0dXJuIE51bWJlci5wYXJzZUludChtYXRjaFsxXSArIG1hdGNoWzFdICsgbWF0Y2hbMl0gKyBtYXRjaFsyXSArIG1hdGNoWzNdICsgbWF0Y2hbM10gKyBcImZmXCIsIDE2KSA+Pj4gMDtcbiAgICB9XG4gIH1cbiAgaWYgKG1hdGNoZXJzLmhleDgpIHtcbiAgICBpZiAobWF0Y2ggPSBtYXRjaGVycy5oZXg4LmV4ZWMoY29sb3IpKSB7XG4gICAgICByZXR1cm4gTnVtYmVyLnBhcnNlSW50KG1hdGNoWzFdLCAxNikgPj4+IDA7XG4gICAgfVxuICB9XG4gIGlmIChtYXRjaGVycy5oZXg0KSB7XG4gICAgaWYgKG1hdGNoID0gbWF0Y2hlcnMuaGV4NC5leGVjKGNvbG9yKSkge1xuICAgICAgcmV0dXJuIE51bWJlci5wYXJzZUludChtYXRjaFsxXSArIG1hdGNoWzFdICsgbWF0Y2hbMl0gKyBtYXRjaFsyXSArIG1hdGNoWzNdICsgbWF0Y2hbM10gKyBtYXRjaFs0XSArIG1hdGNoWzRdLCAxNikgPj4+IDA7XG4gICAgfVxuICB9XG4gIGlmIChtYXRjaGVycy5oc2wpIHtcbiAgICBpZiAobWF0Y2ggPSBtYXRjaGVycy5oc2wuZXhlYyhjb2xvcikpIHtcbiAgICAgIHJldHVybiAoaHNsVG9SZ2IocGFyc2UzNjAobWF0Y2hbMV0pLCBwYXJzZVBlcmNlbnRhZ2UobWF0Y2hbMl0pLCBwYXJzZVBlcmNlbnRhZ2UobWF0Y2hbM10pKSB8IDI1NSkgPj4+IDA7XG4gICAgfVxuICB9XG4gIGlmIChtYXRjaGVycy5oc2xhKSB7XG4gICAgaWYgKG1hdGNoID0gbWF0Y2hlcnMuaHNsYS5leGVjKGNvbG9yKSkge1xuICAgICAgcmV0dXJuIChoc2xUb1JnYihwYXJzZTM2MChtYXRjaFsxXSksIHBhcnNlUGVyY2VudGFnZShtYXRjaFsyXSksIHBhcnNlUGVyY2VudGFnZShtYXRjaFszXSkpIHwgcGFyc2UxKG1hdGNoWzRdKSkgPj4+IDA7XG4gICAgfVxuICB9XG4gIHRocm93IG5ldyBFcnJvcihgaW52YWxpZCBjb2xvciBzdHJpbmcgJHtjb2xvcn0gcHJvdmlkZWRgKTtcbn1cbmZ1bmN0aW9uIHByb2Nlc3NDb2xvcihjb2xvcikge1xuICBjb25zdCBub3JtYWxpemVkQ29sb3IgPSBub3JtYWxpemVDb2xvcihjb2xvcik7XG4gIHJldHVybiAobm9ybWFsaXplZENvbG9yIDw8IDI0IHwgbm9ybWFsaXplZENvbG9yID4+PiA4KSA+Pj4gMDtcbn1cbnZhciBOVU1CRVIgPSBcIlstK10/XFxcXGQqXFxcXC4/XFxcXGQrXCI7XG52YXIgUEVSQ0VOVEFHRSA9IE5VTUJFUiArIFwiJVwiO1xudmFyIGNvbG9yTmFtZXMgPSB7XG4gIHRyYW5zcGFyZW50OiAwLFxuICBhbGljZWJsdWU6IDQwNDI4NTAzMDMsXG4gIGFudGlxdWV3aGl0ZTogNDIwOTc2MDI1NSxcbiAgYXF1YTogMTY3NzcyMTUsXG4gIGFxdWFtYXJpbmU6IDIxNDc0NzI2MzksXG4gIGF6dXJlOiA0MDQzMzA5MDU1LFxuICBiZWlnZTogNDEyNjUzMDgxNSxcbiAgYmlzcXVlOiA0MjkzMTgyNzE5LFxuICBibGFjazogMjU1LFxuICBibGFuY2hlZGFsbW9uZDogNDI5MzY0Mzc3NSxcbiAgYmx1ZTogNjU1MzUsXG4gIGJsdWV2aW9sZXQ6IDIzMTgxMzE5NjcsXG4gIGJyb3duOiAyNzcxMDA0MTU5LFxuICBidXJseXdvb2Q6IDM3MzY2MzUzOTEsXG4gIGJ1cm50c2llbm5hOiAzOTM0MTUwMTQzLFxuICBjYWRldGJsdWU6IDE2MDQyMzE0MjMsXG4gIGNoYXJ0cmV1c2U6IDIxNDc0MTgzNjcsXG4gIGNob2NvbGF0ZTogMzUzMDEwNDU3NSxcbiAgY29yYWw6IDQyODY1MzM4ODcsXG4gIGNvcm5mbG93ZXJibHVlOiAxNjg3NTQ3MzkxLFxuICBjb3Juc2lsazogNDI5NDQ5OTU4MyxcbiAgY3JpbXNvbjogMzY5MjMxMzg1NSxcbiAgY3lhbjogMTY3NzcyMTUsXG4gIGRhcmtibHVlOiAzNTgzOSxcbiAgZGFya2N5YW46IDkxNDUzNDMsXG4gIGRhcmtnb2xkZW5yb2Q6IDMwOTU3OTI2MzksXG4gIGRhcmtncmF5OiAyODQ2NDY4NjA3LFxuICBkYXJrZ3JlZW46IDY1NTM4NTUsXG4gIGRhcmtncmV5OiAyODQ2NDY4NjA3LFxuICBkYXJra2hha2k6IDMxODI5MTQ1NTksXG4gIGRhcmttYWdlbnRhOiAyMzMyMDY4ODYzLFxuICBkYXJrb2xpdmVncmVlbjogMTQzMzA4Nzk5OSxcbiAgZGFya29yYW5nZTogNDI4NzM2NTM3NSxcbiAgZGFya29yY2hpZDogMjU3MDI0MzMyNyxcbiAgZGFya3JlZDogMjMzMjAzMzI3OSxcbiAgZGFya3NhbG1vbjogMzkxODk1MzIxNSxcbiAgZGFya3NlYWdyZWVuOiAyNDExNDk5NTE5LFxuICBkYXJrc2xhdGVibHVlOiAxMjExOTkzMDg3LFxuICBkYXJrc2xhdGVncmF5OiA3OTM3MjY5NzUsXG4gIGRhcmtzbGF0ZWdyZXk6IDc5MzcyNjk3NSxcbiAgZGFya3R1cnF1b2lzZTogMTM1NTQxNzUsXG4gIGRhcmt2aW9sZXQ6IDI0ODMwODIyMzksXG4gIGRlZXBwaW5rOiA0Mjc5NTM4Njg3LFxuICBkZWVwc2t5Ymx1ZTogMTI1ODI5MTEsXG4gIGRpbWdyYXk6IDE3Njg1MTYwOTUsXG4gIGRpbWdyZXk6IDE3Njg1MTYwOTUsXG4gIGRvZGdlcmJsdWU6IDUxMjgxOTE5OSxcbiAgZmlyZWJyaWNrOiAyOTg4NTgxNjMxLFxuICBmbG9yYWx3aGl0ZTogNDI5NDYzNTc3NSxcbiAgZm9yZXN0Z3JlZW46IDU3OTU0MzgwNyxcbiAgZnVjaHNpYTogNDI3ODI1NTYxNSxcbiAgZ2FpbnNib3JvOiAzNzA1NDYyMDE1LFxuICBnaG9zdHdoaXRlOiA0MTc3MDY4MDMxLFxuICBnb2xkOiA0MjkyMjgwNTc1LFxuICBnb2xkZW5yb2Q6IDM2NjgyNTQ5NzUsXG4gIGdyYXk6IDIxNTU5MDUyNzksXG4gIGdyZWVuOiA4Mzg4ODYzLFxuICBncmVlbnllbGxvdzogMjkxOTE4MjMzNSxcbiAgZ3JleTogMjE1NTkwNTI3OSxcbiAgaG9uZXlkZXc6IDQwNDMzMDUyMTUsXG4gIGhvdHBpbms6IDQyODUxMTc2OTUsXG4gIGluZGlhbnJlZDogMzQ0NTM4MjM5OSxcbiAgaW5kaWdvOiAxMjU4MzI0NzM1LFxuICBpdm9yeTogNDI5NDk2MzQ1NSxcbiAga2hha2k6IDQwNDE2NDEyMTUsXG4gIGxhdmVuZGVyOiAzODczODk3MjE1LFxuICBsYXZlbmRlcmJsdXNoOiA0MjkzOTgxNjk1LFxuICBsYXduZ3JlZW46IDIwOTY4OTAxMTEsXG4gIGxlbW9uY2hpZmZvbjogNDI5NDYyNjgxNSxcbiAgbGlnaHRibHVlOiAyOTE2NjczMjc5LFxuICBsaWdodGNvcmFsOiA0MDM0OTUzNDcxLFxuICBsaWdodGN5YW46IDM3NzQ4NzM1OTksXG4gIGxpZ2h0Z29sZGVucm9keWVsbG93OiA0MjEwNzQyMDE1LFxuICBsaWdodGdyYXk6IDM1NTM4NzQ5NDMsXG4gIGxpZ2h0Z3JlZW46IDI0MzE1NTM3OTEsXG4gIGxpZ2h0Z3JleTogMzU1Mzg3NDk0MyxcbiAgbGlnaHRwaW5rOiA0MjkwMTY3Mjk1LFxuICBsaWdodHNhbG1vbjogNDI4ODcwNzMyNyxcbiAgbGlnaHRzZWFncmVlbjogNTQ4NTgwMDk1LFxuICBsaWdodHNreWJsdWU6IDIyNzg0ODg4MzEsXG4gIGxpZ2h0c2xhdGVncmF5OiAyMDA1NDQxMDIzLFxuICBsaWdodHNsYXRlZ3JleTogMjAwNTQ0MTAyMyxcbiAgbGlnaHRzdGVlbGJsdWU6IDI5NjU2OTIxNTksXG4gIGxpZ2h0eWVsbG93OiA0Mjk0OTU5MzU5LFxuICBsaW1lOiAxNjcxMTkzNSxcbiAgbGltZWdyZWVuOiA4NTIzMDg3MzUsXG4gIGxpbmVuOiA0MjEwMDkxNzc1LFxuICBtYWdlbnRhOiA0Mjc4MjU1NjE1LFxuICBtYXJvb246IDIxNDc0ODM5MDMsXG4gIG1lZGl1bWFxdWFtYXJpbmU6IDE3MjQ3NTQ2ODcsXG4gIG1lZGl1bWJsdWU6IDUyNzM1LFxuICBtZWRpdW1vcmNoaWQ6IDMxMjYxODcwMDcsXG4gIG1lZGl1bXB1cnBsZTogMjQ3MzY0NzEwMyxcbiAgbWVkaXVtc2VhZ3JlZW46IDEwMTgzOTMwODcsXG4gIG1lZGl1bXNsYXRlYmx1ZTogMjA3MDQ3NDQ5NSxcbiAgbWVkaXVtc3ByaW5nZ3JlZW46IDE2NDIzNjc5LFxuICBtZWRpdW10dXJxdW9pc2U6IDEyMjE3MDkwNTUsXG4gIG1lZGl1bXZpb2xldHJlZDogMzM0MDA3NjU0MyxcbiAgbWlkbmlnaHRibHVlOiA0MjEwOTc3MjcsXG4gIG1pbnRjcmVhbTogNDEyNzE5Mzg1NSxcbiAgbWlzdHlyb3NlOiA0MjkzMTkwMTQzLFxuICBtb2NjYXNpbjogNDI5MzE3ODg3OSxcbiAgbmF2YWpvd2hpdGU6IDQyOTI3ODM2MTUsXG4gIG5hdnk6IDMzMDIzLFxuICBvbGRsYWNlOiA0MjYwNzUxMTAzLFxuICBvbGl2ZTogMjE1NTg3MjUxMSxcbiAgb2xpdmVkcmFiOiAxODA0NDc3NDM5LFxuICBvcmFuZ2U6IDQyODkwMDM3NzUsXG4gIG9yYW5nZXJlZDogNDI4MjcxMjMxOSxcbiAgb3JjaGlkOiAzNjY0ODI4MTU5LFxuICBwYWxlZ29sZGVucm9kOiA0MDA4MjI1NTM1LFxuICBwYWxlZ3JlZW46IDI1NjY2MjU1MzUsXG4gIHBhbGV0dXJxdW9pc2U6IDI5NTE2NzE1NTEsXG4gIHBhbGV2aW9sZXRyZWQ6IDM2ODE1ODgyMjMsXG4gIHBhcGF5YXdoaXA6IDQyOTM5MDc5NjcsXG4gIHBlYWNocHVmZjogNDI5MjUyNDU0MyxcbiAgcGVydTogMzQ0ODA2MTk1MSxcbiAgcGluazogNDI5MDgyNTIxNSxcbiAgcGx1bTogMzcxODMwNzMyNyxcbiAgcG93ZGVyYmx1ZTogMjk2NzUyOTIxNSxcbiAgcHVycGxlOiAyMTQ3NTE2NjcxLFxuICByZWJlY2NhcHVycGxlOiAxNzE0NjU3NzkxLFxuICByZWQ6IDQyNzgxOTAzMzUsXG4gIHJvc3licm93bjogMzE2MzUyNTExOSxcbiAgcm95YWxibHVlOiAxMDk3NDU4MTc1LFxuICBzYWRkbGVicm93bjogMjMzNjU2MDEyNyxcbiAgc2FsbW9uOiA0MjAyNzIyMDQ3LFxuICBzYW5keWJyb3duOiA0MTA0NDEzNDM5LFxuICBzZWFncmVlbjogNzgwODgzOTY3LFxuICBzZWFzaGVsbDogNDI5NDMwNzU4MyxcbiAgc2llbm5hOiAyNjg5NzQwMjg3LFxuICBzaWx2ZXI6IDMyMzM4NTc3OTEsXG4gIHNreWJsdWU6IDIyNzg0ODQ5OTEsXG4gIHNsYXRlYmx1ZTogMTc4NDMzNTg3MSxcbiAgc2xhdGVncmF5OiAxODg3NDczOTE5LFxuICBzbGF0ZWdyZXk6IDE4ODc0NzM5MTksXG4gIHNub3c6IDQyOTQ2MzgzMzUsXG4gIHNwcmluZ2dyZWVuOiAxNjc0NDQ0NyxcbiAgc3RlZWxibHVlOiAxMTgyOTcxMTM1LFxuICB0YW46IDM1MzUwNDc5MzUsXG4gIHRlYWw6IDg0MjE2MzEsXG4gIHRoaXN0bGU6IDM2MzY0NTE1ODMsXG4gIHRvbWF0bzogNDI4NDY5NjU3NSxcbiAgdHVycXVvaXNlOiAxMDg4NDc1MzkxLFxuICB2aW9sZXQ6IDQwMDE1NTgyNzEsXG4gIHdoZWF0OiA0MTI1MDEyOTkxLFxuICB3aGl0ZTogNDI5NDk2NzI5NSxcbiAgd2hpdGVzbW9rZTogNDEyNjUzNzIxNSxcbiAgeWVsbG93OiA0Mjk0OTAyMDE1LFxuICB5ZWxsb3dncmVlbjogMjU5NzEzOTE5OVxufTtcblxuLy8gc3JjL3Y1LWZsYWcudHNcbnZhciBFTkFCTEVfVjVfQlJFQUtJTkdfQ0hBTkdFUyA9IGZhbHNlO1xuXG4vLyBzcmMvdmFsaWRhdGUtZnJhbWUudHNcbnZhciB2YWxpZGF0ZUZyYW1lID0gKHtcbiAgYWxsb3dGbG9hdHMsXG4gIGR1cmF0aW9uSW5GcmFtZXMsXG4gIGZyYW1lXG59KSA9PiB7XG4gIGlmICh0eXBlb2YgZnJhbWUgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBBcmd1bWVudCBtaXNzaW5nIGZvciBwYXJhbWV0ZXIgXCJmcmFtZVwiYCk7XG4gIH1cbiAgaWYgKHR5cGVvZiBmcmFtZSAhPT0gXCJudW1iZXJcIikge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYEFyZ3VtZW50IHBhc3NlZCBmb3IgXCJmcmFtZVwiIGlzIG5vdCBhIG51bWJlcjogJHtmcmFtZX1gKTtcbiAgfVxuICBpZiAoIU51bWJlci5pc0Zpbml0ZShmcmFtZSkpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihgRnJhbWUgJHtmcmFtZX0gaXMgbm90IGZpbml0ZWApO1xuICB9XG4gIGlmIChmcmFtZSAlIDEgIT09IDAgJiYgIWFsbG93RmxvYXRzKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoYEFyZ3VtZW50IGZvciBmcmFtZSBtdXN0IGJlIGFuIGludGVnZXIsIGJ1dCBnb3QgJHtmcmFtZX1gKTtcbiAgfVxuICBpZiAoZnJhbWUgPCAwICYmIGZyYW1lIDwgLWR1cmF0aW9uSW5GcmFtZXMpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihgQ2Fubm90IHVzZSBmcmFtZSAke2ZyYW1lfTogRHVyYXRpb24gb2YgY29tcG9zaXRpb24gaXMgJHtkdXJhdGlvbkluRnJhbWVzfSwgdGhlcmVmb3JlIHRoZSBsb3dlc3QgZnJhbWUgdGhhdCBjYW4gYmUgcmVuZGVyZWQgaXMgJHstZHVyYXRpb25JbkZyYW1lc31gKTtcbiAgfVxuICBpZiAoZnJhbWUgPiBkdXJhdGlvbkluRnJhbWVzIC0gMSkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKGBDYW5ub3QgdXNlIGZyYW1lICR7ZnJhbWV9OiBEdXJhdGlvbiBvZiBjb21wb3NpdGlvbiBpcyAke2R1cmF0aW9uSW5GcmFtZXN9LCB0aGVyZWZvcmUgdGhlIGhpZ2hlc3QgZnJhbWUgdGhhdCBjYW4gYmUgcmVuZGVyZWQgaXMgJHtkdXJhdGlvbkluRnJhbWVzIC0gMX1gKTtcbiAgfVxufTtcblxuLy8gc3JjL3ZhbGlkYXRpb24vdmFsaWRhdGUtZGVmYXVsdC1wcm9wcy50c1xudmFyIHZhbGlkYXRlRGVmYXVsdEFuZElucHV0UHJvcHMgPSAoZGVmYXVsdFByb3BzLCBuYW1lLCBjb21wb3NpdGlvbklkKSA9PiB7XG4gIGlmICghZGVmYXVsdFByb3BzKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGlmICh0eXBlb2YgZGVmYXVsdFByb3BzICE9PSBcIm9iamVjdFwiKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBcIiR7bmFtZX1cIiBtdXN0IGJlIGFuIG9iamVjdCwgYnV0IHlvdSBwYXNzZWQgYSB2YWx1ZSBvZiB0eXBlICR7dHlwZW9mIGRlZmF1bHRQcm9wc31gKTtcbiAgfVxuICBpZiAoQXJyYXkuaXNBcnJheShkZWZhdWx0UHJvcHMpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBcIiR7bmFtZX1cIiBtdXN0IGJlIGFuIG9iamVjdCwgYW4gYXJyYXkgd2FzIHBhc3NlZCAke2NvbXBvc2l0aW9uSWQgPyBgZm9yIGNvbXBvc2l0aW9uIFwiJHtjb21wb3NpdGlvbklkfVwiYCA6IFwiXCJ9YCk7XG4gIH1cbn07XG5cbi8vIHNyYy92YWxpZGF0aW9uL3ZhbGlkYXRlLWRpbWVuc2lvbnMudHNcbmZ1bmN0aW9uIHZhbGlkYXRlRGltZW5zaW9uKGFtb3VudCwgbmFtZU9mUHJvcCwgbG9jYXRpb24pIHtcbiAgaWYgKHR5cGVvZiBhbW91bnQgIT09IFwibnVtYmVyXCIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYFRoZSBcIiR7bmFtZU9mUHJvcH1cIiBwcm9wICR7bG9jYXRpb259IG11c3QgYmUgYSBudW1iZXIsIGJ1dCB5b3UgcGFzc2VkIGEgdmFsdWUgb2YgdHlwZSAke3R5cGVvZiBhbW91bnR9YCk7XG4gIH1cbiAgaWYgKGlzTmFOKGFtb3VudCkpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBUaGUgXCIke25hbWVPZlByb3B9XCIgcHJvcCAke2xvY2F0aW9ufSBtdXN0IG5vdCBiZSBOYU4sIGJ1dCBpcyBOYU4uYCk7XG4gIH1cbiAgaWYgKCFOdW1iZXIuaXNGaW5pdGUoYW1vdW50KSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYFRoZSBcIiR7bmFtZU9mUHJvcH1cIiBwcm9wICR7bG9jYXRpb259IG11c3QgYmUgZmluaXRlLCBidXQgaXMgJHthbW91bnR9LmApO1xuICB9XG4gIGlmIChhbW91bnQgJSAxICE9PSAwKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgVGhlIFwiJHtuYW1lT2ZQcm9wfVwiIHByb3AgJHtsb2NhdGlvbn0gbXVzdCBiZSBhbiBpbnRlZ2VyLCBidXQgaXMgJHthbW91bnR9LmApO1xuICB9XG4gIGlmIChhbW91bnQgPD0gMCkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYFRoZSBcIiR7bmFtZU9mUHJvcH1cIiBwcm9wICR7bG9jYXRpb259IG11c3QgYmUgcG9zaXRpdmUsIGJ1dCBnb3QgJHthbW91bnR9LmApO1xuICB9XG59XG5cbi8vIHNyYy92YWxpZGF0aW9uL3ZhbGlkYXRlLWR1cmF0aW9uLWluLWZyYW1lcy50c1xuZnVuY3Rpb24gdmFsaWRhdGVEdXJhdGlvbkluRnJhbWVzKGR1cmF0aW9uSW5GcmFtZXMsIG9wdGlvbnMpIHtcbiAgY29uc3QgeyBhbGxvd0Zsb2F0cywgY29tcG9uZW50IH0gPSBvcHRpb25zO1xuICBpZiAodHlwZW9mIGR1cmF0aW9uSW5GcmFtZXMgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYFRoZSBcImR1cmF0aW9uSW5GcmFtZXNcIiBwcm9wICR7Y29tcG9uZW50fSBpcyBtaXNzaW5nLmApO1xuICB9XG4gIGlmICh0eXBlb2YgZHVyYXRpb25JbkZyYW1lcyAhPT0gXCJudW1iZXJcIikge1xuICAgIHRocm93IG5ldyBFcnJvcihgVGhlIFwiZHVyYXRpb25JbkZyYW1lc1wiIHByb3AgJHtjb21wb25lbnR9IG11c3QgYmUgYSBudW1iZXIsIGJ1dCB5b3UgcGFzc2VkIGEgdmFsdWUgb2YgdHlwZSAke3R5cGVvZiBkdXJhdGlvbkluRnJhbWVzfWApO1xuICB9XG4gIGlmIChkdXJhdGlvbkluRnJhbWVzIDw9IDApIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBUaGUgXCJkdXJhdGlvbkluRnJhbWVzXCIgcHJvcCAke2NvbXBvbmVudH0gbXVzdCBiZSBwb3NpdGl2ZSwgYnV0IGdvdCAke2R1cmF0aW9uSW5GcmFtZXN9LmApO1xuICB9XG4gIGlmICghYWxsb3dGbG9hdHMgJiYgZHVyYXRpb25JbkZyYW1lcyAlIDEgIT09IDApIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBUaGUgXCJkdXJhdGlvbkluRnJhbWVzXCIgcHJvcCAke2NvbXBvbmVudH0gbXVzdCBiZSBhbiBpbnRlZ2VyLCBidXQgZ290ICR7ZHVyYXRpb25JbkZyYW1lc30uYCk7XG4gIH1cbiAgaWYgKCFOdW1iZXIuaXNGaW5pdGUoZHVyYXRpb25JbkZyYW1lcykpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBUaGUgXCJkdXJhdGlvbkluRnJhbWVzXCIgcHJvcCAke2NvbXBvbmVudH0gbXVzdCBiZSBmaW5pdGUsIGJ1dCBnb3QgJHtkdXJhdGlvbkluRnJhbWVzfS5gKTtcbiAgfVxufVxuXG4vLyBzcmMvdmFsaWRhdGlvbi92YWxpZGF0ZS1mcHMudHNcbmZ1bmN0aW9uIHZhbGlkYXRlRnBzKGZwcywgbG9jYXRpb24sIGlzR2lmKSB7XG4gIGlmICh0eXBlb2YgZnBzICE9PSBcIm51bWJlclwiKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBcImZwc1wiIG11c3QgYmUgYSBudW1iZXIsIGJ1dCB5b3UgcGFzc2VkIGEgdmFsdWUgb2YgdHlwZSAke3R5cGVvZiBmcHN9ICR7bG9jYXRpb259YCk7XG4gIH1cbiAgaWYgKCFOdW1iZXIuaXNGaW5pdGUoZnBzKSkge1xuICAgIHRocm93IG5ldyBFcnJvcihgXCJmcHNcIiBtdXN0IGJlIGEgZmluaXRlLCBidXQgeW91IHBhc3NlZCAke2Zwc30gJHtsb2NhdGlvbn1gKTtcbiAgfVxuICBpZiAoaXNOYU4oZnBzKSkge1xuICAgIHRocm93IG5ldyBFcnJvcihgXCJmcHNcIiBtdXN0IG5vdCBiZSBOYU4sIGJ1dCBnb3QgJHtmcHN9ICR7bG9jYXRpb259YCk7XG4gIH1cbiAgaWYgKGZwcyA8PSAwKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgXCJmcHNcIiBtdXN0IGJlIHBvc2l0aXZlLCBidXQgZ290ICR7ZnBzfSAke2xvY2F0aW9ufWApO1xuICB9XG4gIGlmIChpc0dpZiAmJiBmcHMgPiA1MCkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYFRoZSBGUFMgZm9yIGEgR0lGIGNhbm5vdCBiZSBoaWdoZXIgdGhhbiA1MC4gVXNlIHRoZSAtLWV2ZXJ5LW50aC1mcmFtZSBvcHRpb24gdG8gbG93ZXIgdGhlIEZQUzogaHR0cHM6Ly9yZW1vdGlvbi5kZXYvZG9jcy9yZW5kZXItYXMtZ2lmYCk7XG4gIH1cbn1cblxuLy8gc3JjL3ZpZGVvL2dldC1jdXJyZW50LXRpbWUudHNcbnZhciBnZXRFeHBlY3RlZE1lZGlhRnJhbWVVbmNvcnJlY3RlZCA9ICh7XG4gIGZyYW1lLFxuICBwbGF5YmFja1JhdGUsXG4gIHN0YXJ0RnJvbVxufSkgPT4ge1xuICByZXR1cm4gaW50ZXJwb2xhdGUoZnJhbWUsIFstMSwgc3RhcnRGcm9tLCBzdGFydEZyb20gKyAxXSwgWy0xLCBzdGFydEZyb20sIHN0YXJ0RnJvbSArIHBsYXliYWNrUmF0ZV0pO1xufTtcblxuLy8gc3JjL2Fic29sdXRlLXNyYy50c1xudmFyIGdldEFic29sdXRlU3JjID0gKHJlbGF0aXZlU3JjKSA9PiB7XG4gIGlmICh0eXBlb2Ygd2luZG93ID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgcmV0dXJuIHJlbGF0aXZlU3JjO1xuICB9XG4gIHJldHVybiBuZXcgVVJMKHJlbGF0aXZlU3JjLCB3aW5kb3cub3JpZ2luKS5ocmVmO1xufTtcblxuLy8gc3JjL3ZpZGVvL29mZnRocmVhZC12aWRlby1zb3VyY2UudHNcbnZhciBnZXRPZmZ0aHJlYWRWaWRlb1NvdXJjZSA9ICh7XG4gIHNyYyxcbiAgdHJhbnNwYXJlbnQsXG4gIGN1cnJlbnRUaW1lLFxuICB0b25lTWFwcGVkXG59KSA9PiB7XG4gIHJldHVybiBgaHR0cDovL2xvY2FsaG9zdDoke3dpbmRvdy5yZW1vdGlvbl9wcm94eVBvcnR9L3Byb3h5P3NyYz0ke2VuY29kZVVSSUNvbXBvbmVudChnZXRBYnNvbHV0ZVNyYyhzcmMpKX0mdGltZT0ke2VuY29kZVVSSUNvbXBvbmVudChjdXJyZW50VGltZSl9JnRyYW5zcGFyZW50PSR7U3RyaW5nKHRyYW5zcGFyZW50KX0mdG9uZU1hcHBlZD0ke1N0cmluZyh0b25lTWFwcGVkKX1gO1xufTtcblxuLy8gc3JjL25vLXJlYWN0LnRzXG52YXIgTm9SZWFjdEludGVybmFscyA9IHtcbiAgcHJvY2Vzc0NvbG9yLFxuICB0cnV0aHksXG4gIHZhbGlkYXRlRnBzLFxuICB2YWxpZGF0ZURpbWVuc2lvbixcbiAgdmFsaWRhdGVEdXJhdGlvbkluRnJhbWVzLFxuICB2YWxpZGF0ZURlZmF1bHRBbmRJbnB1dFByb3BzLFxuICB2YWxpZGF0ZUZyYW1lLFxuICBzZXJpYWxpemVKU09OV2l0aERhdGUsXG4gIGJ1bmRsZU5hbWU6IFwiYnVuZGxlLmpzXCIsXG4gIGJ1bmRsZU1hcE5hbWU6IFwiYnVuZGxlLmpzLm1hcFwiLFxuICBkZXNlcmlhbGl6ZUpTT05XaXRoQ3VzdG9tRmllbGRzLFxuICBERUxBWV9SRU5ERVJfQ0FMTFNUQUNLX1RPS0VOLFxuICBERUxBWV9SRU5ERVJfUkVUUllfVE9LRU4sXG4gIERFTEFZX1JFTkRFUl9BVFRFTVBUX1RPS0VOOiBERUxBWV9SRU5ERVJfUkVUUklFU19MRUZULFxuICBnZXRPZmZ0aHJlYWRWaWRlb1NvdXJjZSxcbiAgZ2V0RXhwZWN0ZWRNZWRpYUZyYW1lVW5jb3JyZWN0ZWQsXG4gIEVOQUJMRV9WNV9CUkVBS0lOR19DSEFOR0VTLFxuICBNSU5fTk9ERV9WRVJTSU9OOiBFTkFCTEVfVjVfQlJFQUtJTkdfQ0hBTkdFUyA/IDE4IDogMTYsXG4gIE1JTl9CVU5fVkVSU0lPTjogRU5BQkxFX1Y1X0JSRUFLSU5HX0NIQU5HRVMgPyBcIjEuMS4zXCIgOiBcIjEuMC4zXCIsXG4gIGNvbG9yTmFtZXMsXG4gIERBVEVfVE9LRU4sXG4gIEZJTEVfVE9LRU5cbn07XG5leHBvcnQge1xuICByYW5kb20sXG4gIGludGVycG9sYXRlLFxuICBOb1JlYWN0SW50ZXJuYWxzXG59O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/remotion/dist/esm/no-react.mjs\n");

/***/ })

};
;