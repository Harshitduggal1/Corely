"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/bull";
exports.ids = ["vendor-chunks/bull"];
exports.modules = {

/***/ "(rsc)/./node_modules/bull/index.js":
/*!************************************!*\
  !*** ./node_modules/bull/index.js ***!
  \************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\n\nmodule.exports = __webpack_require__(/*! ./lib/queue */ \"(rsc)/./node_modules/bull/lib/queue.js\");\nmodule.exports.Job = __webpack_require__(/*! ./lib/job */ \"(rsc)/./node_modules/bull/lib/job.js\");\nmodule.exports.utils = __webpack_require__(/*! ./lib/utils */ \"(rsc)/./node_modules/bull/lib/utils.js\");\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvYnVsbC9pbmRleC5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYixpR0FBdUM7QUFDdkMsaUdBQXlDO0FBQ3pDLHVHQUE2QyIsInNvdXJjZXMiOlsid2VicGFjazovL215LWFwcC8uL25vZGVfbW9kdWxlcy9idWxsL2luZGV4LmpzP2UxMjUiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vbGliL3F1ZXVlJyk7XG5tb2R1bGUuZXhwb3J0cy5Kb2IgPSByZXF1aXJlKCcuL2xpYi9qb2InKTtcbm1vZHVsZS5leHBvcnRzLnV0aWxzID0gcmVxdWlyZSgnLi9saWIvdXRpbHMnKTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/bull/index.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/bull/lib/backoffs.js":
/*!*******************************************!*\
  !*** ./node_modules/bull/lib/backoffs.js ***!
  \*******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\n\nconst _ = __webpack_require__(/*! lodash */ \"(rsc)/./node_modules/lodash/lodash.js\");\n\nconst builtinStrategies = {\n  fixed(delay) {\n    return function() {\n      return delay;\n    };\n  },\n\n  exponential(delay) {\n    return function(attemptsMade) {\n      return Math.round((Math.pow(2, attemptsMade) - 1) * delay);\n    };\n  }\n};\n\nfunction lookupStrategy(backoff, customStrategies) {\n  if (backoff.type in customStrategies) {\n    return customStrategies[backoff.type];\n  } else if (backoff.type in builtinStrategies) {\n    return builtinStrategies[backoff.type](backoff.delay);\n  } else {\n    throw new Error(\n      'Unknown backoff strategy ' +\n        backoff.type +\n        '. If a custom backoff strategy is used, specify it when the queue is created.'\n    );\n  }\n}\n\nmodule.exports = {\n  normalize(backoff) {\n    if (_.isFinite(backoff)) {\n      return {\n        type: 'fixed',\n        delay: backoff\n      };\n    } else if (backoff) {\n      return backoff;\n    }\n  },\n\n  calculate(backoff, attemptsMade, customStrategies, err, strategyOptions) {\n    if (backoff) {\n      const strategy = lookupStrategy(\n        backoff,\n        customStrategies,\n        strategyOptions\n      );\n\n      return strategy(attemptsMade, err, strategyOptions);\n    }\n  }\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvYnVsbC9saWIvYmFja29mZnMuanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWIsVUFBVSxtQkFBTyxDQUFDLHFEQUFROztBQUUxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbXktYXBwLy4vbm9kZV9tb2R1bGVzL2J1bGwvbGliL2JhY2tvZmZzLmpzP2U5OTciXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCBfID0gcmVxdWlyZSgnbG9kYXNoJyk7XG5cbmNvbnN0IGJ1aWx0aW5TdHJhdGVnaWVzID0ge1xuICBmaXhlZChkZWxheSkge1xuICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBkZWxheTtcbiAgICB9O1xuICB9LFxuXG4gIGV4cG9uZW50aWFsKGRlbGF5KSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKGF0dGVtcHRzTWFkZSkge1xuICAgICAgcmV0dXJuIE1hdGgucm91bmQoKE1hdGgucG93KDIsIGF0dGVtcHRzTWFkZSkgLSAxKSAqIGRlbGF5KTtcbiAgICB9O1xuICB9XG59O1xuXG5mdW5jdGlvbiBsb29rdXBTdHJhdGVneShiYWNrb2ZmLCBjdXN0b21TdHJhdGVnaWVzKSB7XG4gIGlmIChiYWNrb2ZmLnR5cGUgaW4gY3VzdG9tU3RyYXRlZ2llcykge1xuICAgIHJldHVybiBjdXN0b21TdHJhdGVnaWVzW2JhY2tvZmYudHlwZV07XG4gIH0gZWxzZSBpZiAoYmFja29mZi50eXBlIGluIGJ1aWx0aW5TdHJhdGVnaWVzKSB7XG4gICAgcmV0dXJuIGJ1aWx0aW5TdHJhdGVnaWVzW2JhY2tvZmYudHlwZV0oYmFja29mZi5kZWxheSk7XG4gIH0gZWxzZSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgJ1Vua25vd24gYmFja29mZiBzdHJhdGVneSAnICtcbiAgICAgICAgYmFja29mZi50eXBlICtcbiAgICAgICAgJy4gSWYgYSBjdXN0b20gYmFja29mZiBzdHJhdGVneSBpcyB1c2VkLCBzcGVjaWZ5IGl0IHdoZW4gdGhlIHF1ZXVlIGlzIGNyZWF0ZWQuJ1xuICAgICk7XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIG5vcm1hbGl6ZShiYWNrb2ZmKSB7XG4gICAgaWYgKF8uaXNGaW5pdGUoYmFja29mZikpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHR5cGU6ICdmaXhlZCcsXG4gICAgICAgIGRlbGF5OiBiYWNrb2ZmXG4gICAgICB9O1xuICAgIH0gZWxzZSBpZiAoYmFja29mZikge1xuICAgICAgcmV0dXJuIGJhY2tvZmY7XG4gICAgfVxuICB9LFxuXG4gIGNhbGN1bGF0ZShiYWNrb2ZmLCBhdHRlbXB0c01hZGUsIGN1c3RvbVN0cmF0ZWdpZXMsIGVyciwgc3RyYXRlZ3lPcHRpb25zKSB7XG4gICAgaWYgKGJhY2tvZmYpIHtcbiAgICAgIGNvbnN0IHN0cmF0ZWd5ID0gbG9va3VwU3RyYXRlZ3koXG4gICAgICAgIGJhY2tvZmYsXG4gICAgICAgIGN1c3RvbVN0cmF0ZWdpZXMsXG4gICAgICAgIHN0cmF0ZWd5T3B0aW9uc1xuICAgICAgKTtcblxuICAgICAgcmV0dXJuIHN0cmF0ZWd5KGF0dGVtcHRzTWFkZSwgZXJyLCBzdHJhdGVneU9wdGlvbnMpO1xuICAgIH1cbiAgfVxufTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/bull/lib/backoffs.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/bull/lib/errors.js":
/*!*****************************************!*\
  !*** ./node_modules/bull/lib/errors.js ***!
  \*****************************************/
/***/ ((module) => {

eval("\n\nmodule.exports.Messages = {\n  RETRY_JOB_NOT_EXIST: \"Couldn't retry job: The job doesn't exist\",\n  RETRY_JOB_IS_LOCKED: \"Couldn't retry job: The job is locked\",\n  RETRY_JOB_NOT_FAILED:\n    \"Couldn't retry job: The job has been already retried or has not failed\",\n  MISSING_REDIS_OPTS: `Using a redis instance with enableReadyCheck or maxRetriesPerRequest for bclient/subscriber is not permitted.\n  see https://github.com/OptimalBits/bull/issues/1873\n  `\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvYnVsbC9saWIvZXJyb3JzLmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViLHVCQUF1QjtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbXktYXBwLy4vbm9kZV9tb2R1bGVzL2J1bGwvbGliL2Vycm9ycy5qcz81OWRiIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMuTWVzc2FnZXMgPSB7XG4gIFJFVFJZX0pPQl9OT1RfRVhJU1Q6IFwiQ291bGRuJ3QgcmV0cnkgam9iOiBUaGUgam9iIGRvZXNuJ3QgZXhpc3RcIixcbiAgUkVUUllfSk9CX0lTX0xPQ0tFRDogXCJDb3VsZG4ndCByZXRyeSBqb2I6IFRoZSBqb2IgaXMgbG9ja2VkXCIsXG4gIFJFVFJZX0pPQl9OT1RfRkFJTEVEOlxuICAgIFwiQ291bGRuJ3QgcmV0cnkgam9iOiBUaGUgam9iIGhhcyBiZWVuIGFscmVhZHkgcmV0cmllZCBvciBoYXMgbm90IGZhaWxlZFwiLFxuICBNSVNTSU5HX1JFRElTX09QVFM6IGBVc2luZyBhIHJlZGlzIGluc3RhbmNlIHdpdGggZW5hYmxlUmVhZHlDaGVjayBvciBtYXhSZXRyaWVzUGVyUmVxdWVzdCBmb3IgYmNsaWVudC9zdWJzY3JpYmVyIGlzIG5vdCBwZXJtaXR0ZWQuXG4gIHNlZSBodHRwczovL2dpdGh1Yi5jb20vT3B0aW1hbEJpdHMvYnVsbC9pc3N1ZXMvMTg3M1xuICBgXG59O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/bull/lib/errors.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/bull/lib/getters.js":
/*!******************************************!*\
  !*** ./node_modules/bull/lib/getters.js ***!
  \******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\n\nconst _ = __webpack_require__(/*! lodash */ \"(rsc)/./node_modules/lodash/lodash.js\");\nconst Job = __webpack_require__(/*! ./job */ \"(rsc)/./node_modules/bull/lib/job.js\");\nconst scripts = __webpack_require__(/*! ./scripts */ \"(rsc)/./node_modules/bull/lib/scripts.js\");\n\nmodule.exports = function(Queue) {\n  Queue.prototype.getJob = async function(jobId) {\n    await this.isReady();\n    return Job.fromId(this, jobId);\n  };\n\n  Queue.prototype.getCountsPerPriority = async function(priorities) {\n    const uniquePriorities = [...new Set(priorities)];\n    const responses = await scripts.getCountsPerPriority(\n      this,\n      uniquePriorities\n    );\n\n    const counts = {};\n    responses.forEach((res, index) => {\n      counts[`${uniquePriorities[index]}`] = res || 0;\n    });\n\n    return counts;\n  };\n\n  Queue.prototype._commandByType = function(types, count, callback) {\n    return _.map(types, type => {\n      type = type === 'waiting' ? 'wait' : type; // alias\n\n      const key = this.toKey(type);\n\n      switch (type) {\n        case 'completed':\n        case 'failed':\n        case 'delayed':\n        case 'repeat':\n          return callback(key, count ? 'zcard' : 'zrange');\n        case 'active':\n        case 'wait':\n        case 'paused':\n          return callback(key, count ? 'llen' : 'lrange');\n      }\n    });\n  };\n\n  /**\n    Returns the number of jobs waiting to be processed.\n  */\n  Queue.prototype.count = function() {\n    return this.getJobCountByTypes('wait', 'paused', 'delayed');\n  };\n\n  // Job counts by type\n  // Queue#getJobCountByTypes('completed') => completed count\n  // Queue#getJobCountByTypes('completed,failed') => completed + failed count\n  // Queue#getJobCountByTypes('completed', 'failed') => completed + failed count\n  // Queue#getJobCountByTypes('completed,waiting', 'failed') => completed + waiting + failed count\n  Queue.prototype.getJobCountByTypes = function() {\n    return this.getJobCounts.apply(this, arguments).then(result => {\n      return _.chain(result)\n        .values()\n        .sum()\n        .value();\n    });\n  };\n\n  /**\n   * Returns the job counts for each type specified or every list/set in the queue by default.\n   *\n   */\n  Queue.prototype.getJobCounts = function() {\n    const types = parseTypeArg(arguments);\n    const multi = this.multi();\n\n    this._commandByType(types, true, (key, command) => {\n      multi[command](key);\n    });\n\n    return multi.exec().then(res => {\n      const counts = {};\n      res.forEach((res, index) => {\n        counts[types[index]] = res[1] || 0;\n      });\n      return counts;\n    });\n  };\n\n  Queue.prototype.getCompletedCount = function() {\n    return this.getJobCountByTypes('completed');\n  };\n\n  Queue.prototype.getFailedCount = function() {\n    return this.getJobCountByTypes('failed');\n  };\n\n  Queue.prototype.getDelayedCount = function() {\n    return this.getJobCountByTypes('delayed');\n  };\n\n  Queue.prototype.getActiveCount = function() {\n    return this.getJobCountByTypes('active');\n  };\n\n  Queue.prototype.getWaitingCount = function() {\n    return this.getJobCountByTypes('wait', 'paused');\n  };\n\n  /**\n   *\n   * @returns the potential stalled jobs. Only useful for tests.\n   */\n  Queue.prototype.getStalledCount = function() {\n    const key = this.toKey('stalled');\n    return this.client.scard(key);\n  };\n\n  // TO BE DEPRECATED --->\n  Queue.prototype.getPausedCount = function() {\n    return this.getJobCountByTypes('paused');\n  };\n  // <-----\n\n  Queue.prototype.getWaiting = function(start, end, opts) {\n    return this.getJobs(['wait', 'paused'], start, end, true, opts);\n  };\n\n  Queue.prototype.getActive = function(start, end, opts) {\n    return this.getJobs('active', start, end, true, opts);\n  };\n\n  Queue.prototype.getDelayed = function(start, end, opts) {\n    return this.getJobs('delayed', start, end, true, opts);\n  };\n\n  Queue.prototype.getCompleted = function(start, end, opts) {\n    return this.getJobs('completed', start, end, false, opts);\n  };\n\n  Queue.prototype.getFailed = function(start, end, opts) {\n    return this.getJobs('failed', start, end, false, opts);\n  };\n\n  Queue.prototype.getRanges = function(types, start, end, asc) {\n    start = _.isUndefined(start) ? 0 : start;\n    end = _.isUndefined(end) ? -1 : end;\n\n    const multi = this.multi();\n    const multiCommands = [];\n\n    this._commandByType(parseTypeArg(types), false, (key, command) => {\n      switch (command) {\n        case 'lrange':\n          if (asc) {\n            multiCommands.push('lrange');\n            multi.lrange(key, -(end + 1), -(start + 1));\n          } else {\n            multi.lrange(key, start, end);\n          }\n          break;\n        case 'zrange':\n          multiCommands.push('zrange');\n          if (asc) {\n            multi.zrange(key, start, end);\n          } else {\n            multi.zrevrange(key, start, end);\n          }\n          break;\n      }\n    });\n\n    return multi.exec().then(responses => {\n      let results = [];\n\n      responses.forEach((response, index) => {\n        const result = response[1] || [];\n\n        if (asc && multiCommands[index] === 'lrange') {\n          results = results.concat(result.reverse());\n        } else {\n          results = results.concat(result);\n        }\n      });\n      return results;\n    });\n  };\n\n  Queue.prototype.getJobs = function(types, start, end, asc, opts) {\n    return this.getRanges(types, start, end, asc).then(jobIds => {\n      return Promise.all(jobIds.map(jobId => this.getJobFromId(jobId, opts)));\n    });\n  };\n\n  Queue.prototype.getJobLogs = function(jobId, start, end, asc = true) {\n    start = _.isUndefined(start) ? 0 : start;\n    end = _.isUndefined(end) ? -1 : end;\n\n    const multi = this.multi();\n\n    const logsKey = this.toKey(jobId + ':logs');\n    if (asc) {\n      multi.lrange(logsKey, start, end);\n    } else {\n      multi.lrange(logsKey, -(end + 1), -(start + 1));\n    }\n    multi.llen(logsKey);\n    return multi.exec().then(result => {\n      if (!asc) {\n        result[0][1].reverse();\n      }\n      return {\n        logs: result[0][1],\n        count: result[1][1]\n      };\n    });\n  };\n\n  /**\n   * Get queue metrics related to the queue.\n   *\n   * This method returns the gathered metrics for the queue.\n   * The metrics are represented as an array of job counts\n   * per unit of time (1 minute).\n   *\n   * @param start - Start point of the metrics, where 0\n   * is the newest point to be returned.\n   * @param end - End poinf of the metrics, where -1 is the\n   * oldest point to be returned.\n   *\n   * @returns - Returns an object with queue metrics.\n   */\n  Queue.prototype.getMetrics = async function(type, start = 0, end = -1) {\n    const metricsKey = this.toKey(`metrics:${type}`);\n    const dataKey = `${metricsKey}:data`;\n\n    const multi = this.multi();\n    multi.hmget(metricsKey, 'count', 'prevTS', 'prevCount');\n    multi.lrange(dataKey, start, end);\n    multi.llen(dataKey);\n\n    const [hmget, range, len] = await multi.exec();\n    const [err, [count, prevTS, prevCount]] = hmget;\n    const [err2, data] = range;\n    const [err3, numPoints] = len;\n    if (err || err2) {\n      throw err || err2 || err3;\n    }\n\n    return {\n      meta: {\n        count: parseInt(count || '0', 10),\n        prevTS: parseInt(prevTS || '0', 10),\n        prevCount: parseInt(prevCount || '0', 10)\n      },\n      data,\n      count: numPoints\n    };\n  };\n};\n\nfunction parseTypeArg(args) {\n  const types = _.chain([])\n    .concat(args)\n    .join(',')\n    .split(/\\s*,\\s*/g)\n    .compact()\n    .value();\n\n  return types.length\n    ? types\n    : ['waiting', 'active', 'completed', 'failed', 'delayed', 'paused'];\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvYnVsbC9saWIvZ2V0dGVycy5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYixVQUFVLG1CQUFPLENBQUMscURBQVE7QUFDMUIsWUFBWSxtQkFBTyxDQUFDLG1EQUFPO0FBQzNCLGdCQUFnQixtQkFBTyxDQUFDLDJEQUFXOztBQUVuQztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZ0JBQWdCLHdCQUF3QjtBQUN4QyxLQUFLOztBQUVMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGlEQUFpRDs7QUFFakQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QyxLQUFLO0FBQ2xELHVCQUF1QixXQUFXOztBQUVsQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9teS1hcHAvLi9ub2RlX21vZHVsZXMvYnVsbC9saWIvZ2V0dGVycy5qcz83NjM0Il0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuY29uc3QgXyA9IHJlcXVpcmUoJ2xvZGFzaCcpO1xuY29uc3QgSm9iID0gcmVxdWlyZSgnLi9qb2InKTtcbmNvbnN0IHNjcmlwdHMgPSByZXF1aXJlKCcuL3NjcmlwdHMnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihRdWV1ZSkge1xuICBRdWV1ZS5wcm90b3R5cGUuZ2V0Sm9iID0gYXN5bmMgZnVuY3Rpb24oam9iSWQpIHtcbiAgICBhd2FpdCB0aGlzLmlzUmVhZHkoKTtcbiAgICByZXR1cm4gSm9iLmZyb21JZCh0aGlzLCBqb2JJZCk7XG4gIH07XG5cbiAgUXVldWUucHJvdG90eXBlLmdldENvdW50c1BlclByaW9yaXR5ID0gYXN5bmMgZnVuY3Rpb24ocHJpb3JpdGllcykge1xuICAgIGNvbnN0IHVuaXF1ZVByaW9yaXRpZXMgPSBbLi4ubmV3IFNldChwcmlvcml0aWVzKV07XG4gICAgY29uc3QgcmVzcG9uc2VzID0gYXdhaXQgc2NyaXB0cy5nZXRDb3VudHNQZXJQcmlvcml0eShcbiAgICAgIHRoaXMsXG4gICAgICB1bmlxdWVQcmlvcml0aWVzXG4gICAgKTtcblxuICAgIGNvbnN0IGNvdW50cyA9IHt9O1xuICAgIHJlc3BvbnNlcy5mb3JFYWNoKChyZXMsIGluZGV4KSA9PiB7XG4gICAgICBjb3VudHNbYCR7dW5pcXVlUHJpb3JpdGllc1tpbmRleF19YF0gPSByZXMgfHwgMDtcbiAgICB9KTtcblxuICAgIHJldHVybiBjb3VudHM7XG4gIH07XG5cbiAgUXVldWUucHJvdG90eXBlLl9jb21tYW5kQnlUeXBlID0gZnVuY3Rpb24odHlwZXMsIGNvdW50LCBjYWxsYmFjaykge1xuICAgIHJldHVybiBfLm1hcCh0eXBlcywgdHlwZSA9PiB7XG4gICAgICB0eXBlID0gdHlwZSA9PT0gJ3dhaXRpbmcnID8gJ3dhaXQnIDogdHlwZTsgLy8gYWxpYXNcblxuICAgICAgY29uc3Qga2V5ID0gdGhpcy50b0tleSh0eXBlKTtcblxuICAgICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICAgIGNhc2UgJ2NvbXBsZXRlZCc6XG4gICAgICAgIGNhc2UgJ2ZhaWxlZCc6XG4gICAgICAgIGNhc2UgJ2RlbGF5ZWQnOlxuICAgICAgICBjYXNlICdyZXBlYXQnOlxuICAgICAgICAgIHJldHVybiBjYWxsYmFjayhrZXksIGNvdW50ID8gJ3pjYXJkJyA6ICd6cmFuZ2UnKTtcbiAgICAgICAgY2FzZSAnYWN0aXZlJzpcbiAgICAgICAgY2FzZSAnd2FpdCc6XG4gICAgICAgIGNhc2UgJ3BhdXNlZCc6XG4gICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKGtleSwgY291bnQgPyAnbGxlbicgOiAnbHJhbmdlJyk7XG4gICAgICB9XG4gICAgfSk7XG4gIH07XG5cbiAgLyoqXG4gICAgUmV0dXJucyB0aGUgbnVtYmVyIG9mIGpvYnMgd2FpdGluZyB0byBiZSBwcm9jZXNzZWQuXG4gICovXG4gIFF1ZXVlLnByb3RvdHlwZS5jb3VudCA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLmdldEpvYkNvdW50QnlUeXBlcygnd2FpdCcsICdwYXVzZWQnLCAnZGVsYXllZCcpO1xuICB9O1xuXG4gIC8vIEpvYiBjb3VudHMgYnkgdHlwZVxuICAvLyBRdWV1ZSNnZXRKb2JDb3VudEJ5VHlwZXMoJ2NvbXBsZXRlZCcpID0+IGNvbXBsZXRlZCBjb3VudFxuICAvLyBRdWV1ZSNnZXRKb2JDb3VudEJ5VHlwZXMoJ2NvbXBsZXRlZCxmYWlsZWQnKSA9PiBjb21wbGV0ZWQgKyBmYWlsZWQgY291bnRcbiAgLy8gUXVldWUjZ2V0Sm9iQ291bnRCeVR5cGVzKCdjb21wbGV0ZWQnLCAnZmFpbGVkJykgPT4gY29tcGxldGVkICsgZmFpbGVkIGNvdW50XG4gIC8vIFF1ZXVlI2dldEpvYkNvdW50QnlUeXBlcygnY29tcGxldGVkLHdhaXRpbmcnLCAnZmFpbGVkJykgPT4gY29tcGxldGVkICsgd2FpdGluZyArIGZhaWxlZCBjb3VudFxuICBRdWV1ZS5wcm90b3R5cGUuZ2V0Sm9iQ291bnRCeVR5cGVzID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0Sm9iQ291bnRzLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykudGhlbihyZXN1bHQgPT4ge1xuICAgICAgcmV0dXJuIF8uY2hhaW4ocmVzdWx0KVxuICAgICAgICAudmFsdWVzKClcbiAgICAgICAgLnN1bSgpXG4gICAgICAgIC52YWx1ZSgpO1xuICAgIH0pO1xuICB9O1xuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBqb2IgY291bnRzIGZvciBlYWNoIHR5cGUgc3BlY2lmaWVkIG9yIGV2ZXJ5IGxpc3Qvc2V0IGluIHRoZSBxdWV1ZSBieSBkZWZhdWx0LlxuICAgKlxuICAgKi9cbiAgUXVldWUucHJvdG90eXBlLmdldEpvYkNvdW50cyA9IGZ1bmN0aW9uKCkge1xuICAgIGNvbnN0IHR5cGVzID0gcGFyc2VUeXBlQXJnKGFyZ3VtZW50cyk7XG4gICAgY29uc3QgbXVsdGkgPSB0aGlzLm11bHRpKCk7XG5cbiAgICB0aGlzLl9jb21tYW5kQnlUeXBlKHR5cGVzLCB0cnVlLCAoa2V5LCBjb21tYW5kKSA9PiB7XG4gICAgICBtdWx0aVtjb21tYW5kXShrZXkpO1xuICAgIH0pO1xuXG4gICAgcmV0dXJuIG11bHRpLmV4ZWMoKS50aGVuKHJlcyA9PiB7XG4gICAgICBjb25zdCBjb3VudHMgPSB7fTtcbiAgICAgIHJlcy5mb3JFYWNoKChyZXMsIGluZGV4KSA9PiB7XG4gICAgICAgIGNvdW50c1t0eXBlc1tpbmRleF1dID0gcmVzWzFdIHx8IDA7XG4gICAgICB9KTtcbiAgICAgIHJldHVybiBjb3VudHM7XG4gICAgfSk7XG4gIH07XG5cbiAgUXVldWUucHJvdG90eXBlLmdldENvbXBsZXRlZENvdW50ID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0Sm9iQ291bnRCeVR5cGVzKCdjb21wbGV0ZWQnKTtcbiAgfTtcblxuICBRdWV1ZS5wcm90b3R5cGUuZ2V0RmFpbGVkQ291bnQgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5nZXRKb2JDb3VudEJ5VHlwZXMoJ2ZhaWxlZCcpO1xuICB9O1xuXG4gIFF1ZXVlLnByb3RvdHlwZS5nZXREZWxheWVkQ291bnQgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5nZXRKb2JDb3VudEJ5VHlwZXMoJ2RlbGF5ZWQnKTtcbiAgfTtcblxuICBRdWV1ZS5wcm90b3R5cGUuZ2V0QWN0aXZlQ291bnQgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5nZXRKb2JDb3VudEJ5VHlwZXMoJ2FjdGl2ZScpO1xuICB9O1xuXG4gIFF1ZXVlLnByb3RvdHlwZS5nZXRXYWl0aW5nQ291bnQgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5nZXRKb2JDb3VudEJ5VHlwZXMoJ3dhaXQnLCAncGF1c2VkJyk7XG4gIH07XG5cbiAgLyoqXG4gICAqXG4gICAqIEByZXR1cm5zIHRoZSBwb3RlbnRpYWwgc3RhbGxlZCBqb2JzLiBPbmx5IHVzZWZ1bCBmb3IgdGVzdHMuXG4gICAqL1xuICBRdWV1ZS5wcm90b3R5cGUuZ2V0U3RhbGxlZENvdW50ID0gZnVuY3Rpb24oKSB7XG4gICAgY29uc3Qga2V5ID0gdGhpcy50b0tleSgnc3RhbGxlZCcpO1xuICAgIHJldHVybiB0aGlzLmNsaWVudC5zY2FyZChrZXkpO1xuICB9O1xuXG4gIC8vIFRPIEJFIERFUFJFQ0FURUQgLS0tPlxuICBRdWV1ZS5wcm90b3R5cGUuZ2V0UGF1c2VkQ291bnQgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5nZXRKb2JDb3VudEJ5VHlwZXMoJ3BhdXNlZCcpO1xuICB9O1xuICAvLyA8LS0tLS1cblxuICBRdWV1ZS5wcm90b3R5cGUuZ2V0V2FpdGluZyA9IGZ1bmN0aW9uKHN0YXJ0LCBlbmQsIG9wdHMpIHtcbiAgICByZXR1cm4gdGhpcy5nZXRKb2JzKFsnd2FpdCcsICdwYXVzZWQnXSwgc3RhcnQsIGVuZCwgdHJ1ZSwgb3B0cyk7XG4gIH07XG5cbiAgUXVldWUucHJvdG90eXBlLmdldEFjdGl2ZSA9IGZ1bmN0aW9uKHN0YXJ0LCBlbmQsIG9wdHMpIHtcbiAgICByZXR1cm4gdGhpcy5nZXRKb2JzKCdhY3RpdmUnLCBzdGFydCwgZW5kLCB0cnVlLCBvcHRzKTtcbiAgfTtcblxuICBRdWV1ZS5wcm90b3R5cGUuZ2V0RGVsYXllZCA9IGZ1bmN0aW9uKHN0YXJ0LCBlbmQsIG9wdHMpIHtcbiAgICByZXR1cm4gdGhpcy5nZXRKb2JzKCdkZWxheWVkJywgc3RhcnQsIGVuZCwgdHJ1ZSwgb3B0cyk7XG4gIH07XG5cbiAgUXVldWUucHJvdG90eXBlLmdldENvbXBsZXRlZCA9IGZ1bmN0aW9uKHN0YXJ0LCBlbmQsIG9wdHMpIHtcbiAgICByZXR1cm4gdGhpcy5nZXRKb2JzKCdjb21wbGV0ZWQnLCBzdGFydCwgZW5kLCBmYWxzZSwgb3B0cyk7XG4gIH07XG5cbiAgUXVldWUucHJvdG90eXBlLmdldEZhaWxlZCA9IGZ1bmN0aW9uKHN0YXJ0LCBlbmQsIG9wdHMpIHtcbiAgICByZXR1cm4gdGhpcy5nZXRKb2JzKCdmYWlsZWQnLCBzdGFydCwgZW5kLCBmYWxzZSwgb3B0cyk7XG4gIH07XG5cbiAgUXVldWUucHJvdG90eXBlLmdldFJhbmdlcyA9IGZ1bmN0aW9uKHR5cGVzLCBzdGFydCwgZW5kLCBhc2MpIHtcbiAgICBzdGFydCA9IF8uaXNVbmRlZmluZWQoc3RhcnQpID8gMCA6IHN0YXJ0O1xuICAgIGVuZCA9IF8uaXNVbmRlZmluZWQoZW5kKSA/IC0xIDogZW5kO1xuXG4gICAgY29uc3QgbXVsdGkgPSB0aGlzLm11bHRpKCk7XG4gICAgY29uc3QgbXVsdGlDb21tYW5kcyA9IFtdO1xuXG4gICAgdGhpcy5fY29tbWFuZEJ5VHlwZShwYXJzZVR5cGVBcmcodHlwZXMpLCBmYWxzZSwgKGtleSwgY29tbWFuZCkgPT4ge1xuICAgICAgc3dpdGNoIChjb21tYW5kKSB7XG4gICAgICAgIGNhc2UgJ2xyYW5nZSc6XG4gICAgICAgICAgaWYgKGFzYykge1xuICAgICAgICAgICAgbXVsdGlDb21tYW5kcy5wdXNoKCdscmFuZ2UnKTtcbiAgICAgICAgICAgIG11bHRpLmxyYW5nZShrZXksIC0oZW5kICsgMSksIC0oc3RhcnQgKyAxKSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG11bHRpLmxyYW5nZShrZXksIHN0YXJ0LCBlbmQpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnenJhbmdlJzpcbiAgICAgICAgICBtdWx0aUNvbW1hbmRzLnB1c2goJ3pyYW5nZScpO1xuICAgICAgICAgIGlmIChhc2MpIHtcbiAgICAgICAgICAgIG11bHRpLnpyYW5nZShrZXksIHN0YXJ0LCBlbmQpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBtdWx0aS56cmV2cmFuZ2Uoa2V5LCBzdGFydCwgZW5kKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICByZXR1cm4gbXVsdGkuZXhlYygpLnRoZW4ocmVzcG9uc2VzID0+IHtcbiAgICAgIGxldCByZXN1bHRzID0gW107XG5cbiAgICAgIHJlc3BvbnNlcy5mb3JFYWNoKChyZXNwb25zZSwgaW5kZXgpID0+IHtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gcmVzcG9uc2VbMV0gfHwgW107XG5cbiAgICAgICAgaWYgKGFzYyAmJiBtdWx0aUNvbW1hbmRzW2luZGV4XSA9PT0gJ2xyYW5nZScpIHtcbiAgICAgICAgICByZXN1bHRzID0gcmVzdWx0cy5jb25jYXQocmVzdWx0LnJldmVyc2UoKSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmVzdWx0cyA9IHJlc3VsdHMuY29uY2F0KHJlc3VsdCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIHJlc3VsdHM7XG4gICAgfSk7XG4gIH07XG5cbiAgUXVldWUucHJvdG90eXBlLmdldEpvYnMgPSBmdW5jdGlvbih0eXBlcywgc3RhcnQsIGVuZCwgYXNjLCBvcHRzKSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0UmFuZ2VzKHR5cGVzLCBzdGFydCwgZW5kLCBhc2MpLnRoZW4oam9iSWRzID0+IHtcbiAgICAgIHJldHVybiBQcm9taXNlLmFsbChqb2JJZHMubWFwKGpvYklkID0+IHRoaXMuZ2V0Sm9iRnJvbUlkKGpvYklkLCBvcHRzKSkpO1xuICAgIH0pO1xuICB9O1xuXG4gIFF1ZXVlLnByb3RvdHlwZS5nZXRKb2JMb2dzID0gZnVuY3Rpb24oam9iSWQsIHN0YXJ0LCBlbmQsIGFzYyA9IHRydWUpIHtcbiAgICBzdGFydCA9IF8uaXNVbmRlZmluZWQoc3RhcnQpID8gMCA6IHN0YXJ0O1xuICAgIGVuZCA9IF8uaXNVbmRlZmluZWQoZW5kKSA/IC0xIDogZW5kO1xuXG4gICAgY29uc3QgbXVsdGkgPSB0aGlzLm11bHRpKCk7XG5cbiAgICBjb25zdCBsb2dzS2V5ID0gdGhpcy50b0tleShqb2JJZCArICc6bG9ncycpO1xuICAgIGlmIChhc2MpIHtcbiAgICAgIG11bHRpLmxyYW5nZShsb2dzS2V5LCBzdGFydCwgZW5kKTtcbiAgICB9IGVsc2Uge1xuICAgICAgbXVsdGkubHJhbmdlKGxvZ3NLZXksIC0oZW5kICsgMSksIC0oc3RhcnQgKyAxKSk7XG4gICAgfVxuICAgIG11bHRpLmxsZW4obG9nc0tleSk7XG4gICAgcmV0dXJuIG11bHRpLmV4ZWMoKS50aGVuKHJlc3VsdCA9PiB7XG4gICAgICBpZiAoIWFzYykge1xuICAgICAgICByZXN1bHRbMF1bMV0ucmV2ZXJzZSgpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgbG9nczogcmVzdWx0WzBdWzFdLFxuICAgICAgICBjb3VudDogcmVzdWx0WzFdWzFdXG4gICAgICB9O1xuICAgIH0pO1xuICB9O1xuXG4gIC8qKlxuICAgKiBHZXQgcXVldWUgbWV0cmljcyByZWxhdGVkIHRvIHRoZSBxdWV1ZS5cbiAgICpcbiAgICogVGhpcyBtZXRob2QgcmV0dXJucyB0aGUgZ2F0aGVyZWQgbWV0cmljcyBmb3IgdGhlIHF1ZXVlLlxuICAgKiBUaGUgbWV0cmljcyBhcmUgcmVwcmVzZW50ZWQgYXMgYW4gYXJyYXkgb2Ygam9iIGNvdW50c1xuICAgKiBwZXIgdW5pdCBvZiB0aW1lICgxIG1pbnV0ZSkuXG4gICAqXG4gICAqIEBwYXJhbSBzdGFydCAtIFN0YXJ0IHBvaW50IG9mIHRoZSBtZXRyaWNzLCB3aGVyZSAwXG4gICAqIGlzIHRoZSBuZXdlc3QgcG9pbnQgdG8gYmUgcmV0dXJuZWQuXG4gICAqIEBwYXJhbSBlbmQgLSBFbmQgcG9pbmYgb2YgdGhlIG1ldHJpY3MsIHdoZXJlIC0xIGlzIHRoZVxuICAgKiBvbGRlc3QgcG9pbnQgdG8gYmUgcmV0dXJuZWQuXG4gICAqXG4gICAqIEByZXR1cm5zIC0gUmV0dXJucyBhbiBvYmplY3Qgd2l0aCBxdWV1ZSBtZXRyaWNzLlxuICAgKi9cbiAgUXVldWUucHJvdG90eXBlLmdldE1ldHJpY3MgPSBhc3luYyBmdW5jdGlvbih0eXBlLCBzdGFydCA9IDAsIGVuZCA9IC0xKSB7XG4gICAgY29uc3QgbWV0cmljc0tleSA9IHRoaXMudG9LZXkoYG1ldHJpY3M6JHt0eXBlfWApO1xuICAgIGNvbnN0IGRhdGFLZXkgPSBgJHttZXRyaWNzS2V5fTpkYXRhYDtcblxuICAgIGNvbnN0IG11bHRpID0gdGhpcy5tdWx0aSgpO1xuICAgIG11bHRpLmhtZ2V0KG1ldHJpY3NLZXksICdjb3VudCcsICdwcmV2VFMnLCAncHJldkNvdW50Jyk7XG4gICAgbXVsdGkubHJhbmdlKGRhdGFLZXksIHN0YXJ0LCBlbmQpO1xuICAgIG11bHRpLmxsZW4oZGF0YUtleSk7XG5cbiAgICBjb25zdCBbaG1nZXQsIHJhbmdlLCBsZW5dID0gYXdhaXQgbXVsdGkuZXhlYygpO1xuICAgIGNvbnN0IFtlcnIsIFtjb3VudCwgcHJldlRTLCBwcmV2Q291bnRdXSA9IGhtZ2V0O1xuICAgIGNvbnN0IFtlcnIyLCBkYXRhXSA9IHJhbmdlO1xuICAgIGNvbnN0IFtlcnIzLCBudW1Qb2ludHNdID0gbGVuO1xuICAgIGlmIChlcnIgfHwgZXJyMikge1xuICAgICAgdGhyb3cgZXJyIHx8IGVycjIgfHwgZXJyMztcbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgbWV0YToge1xuICAgICAgICBjb3VudDogcGFyc2VJbnQoY291bnQgfHwgJzAnLCAxMCksXG4gICAgICAgIHByZXZUUzogcGFyc2VJbnQocHJldlRTIHx8ICcwJywgMTApLFxuICAgICAgICBwcmV2Q291bnQ6IHBhcnNlSW50KHByZXZDb3VudCB8fCAnMCcsIDEwKVxuICAgICAgfSxcbiAgICAgIGRhdGEsXG4gICAgICBjb3VudDogbnVtUG9pbnRzXG4gICAgfTtcbiAgfTtcbn07XG5cbmZ1bmN0aW9uIHBhcnNlVHlwZUFyZyhhcmdzKSB7XG4gIGNvbnN0IHR5cGVzID0gXy5jaGFpbihbXSlcbiAgICAuY29uY2F0KGFyZ3MpXG4gICAgLmpvaW4oJywnKVxuICAgIC5zcGxpdCgvXFxzKixcXHMqL2cpXG4gICAgLmNvbXBhY3QoKVxuICAgIC52YWx1ZSgpO1xuXG4gIHJldHVybiB0eXBlcy5sZW5ndGhcbiAgICA/IHR5cGVzXG4gICAgOiBbJ3dhaXRpbmcnLCAnYWN0aXZlJywgJ2NvbXBsZXRlZCcsICdmYWlsZWQnLCAnZGVsYXllZCcsICdwYXVzZWQnXTtcbn1cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/bull/lib/getters.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/bull/lib/job.js":
/*!**************************************!*\
  !*** ./node_modules/bull/lib/job.js ***!
  \**************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\n\nconst _ = __webpack_require__(/*! lodash */ \"(rsc)/./node_modules/lodash/lodash.js\");\nconst utils = __webpack_require__(/*! ./utils */ \"(rsc)/./node_modules/bull/lib/utils.js\");\nconst scripts = __webpack_require__(/*! ./scripts */ \"(rsc)/./node_modules/bull/lib/scripts.js\");\nconst debuglog = (__webpack_require__(/*! util */ \"util\").debuglog)('bull');\nconst errors = __webpack_require__(/*! ./errors */ \"(rsc)/./node_modules/bull/lib/errors.js\");\nconst backoffs = __webpack_require__(/*! ./backoffs */ \"(rsc)/./node_modules/bull/lib/backoffs.js\");\n\nconst FINISHED_WATCHDOG = 5000;\nconst DEFAULT_JOB_NAME = '__default__';\n\n/**\ninterface JobOptions\n{\n  priority: Priority;\n  attempts: number;\n  delay: number;\n}\n*/\n\nconst jobFields = [\n  'opts',\n  'name',\n  'id',\n  'progress',\n  'delay',\n  'timestamp',\n  'finishedOn',\n  'processedOn',\n  'retriedOn',\n  'failedReason',\n  'attemptsMade',\n  'stacktrace',\n  'returnvalue'\n];\n\n// queue: Queue, data: {}, opts: JobOptions\nconst Job = function(queue, name, data, opts) {\n  if (typeof name !== 'string') {\n    opts = data;\n    data = name;\n    name = DEFAULT_JOB_NAME;\n  }\n\n  // defaults\n  this.opts = setDefaultOpts(opts);\n\n  this.name = name;\n  this.queue = queue;\n  this.data = data;\n  this._progress = 0;\n  this.delay = this.opts.delay < 0 ? 0 : this.opts.delay;\n  this.timestamp = this.opts.timestamp;\n  this.stacktrace = [];\n  this.returnvalue = null;\n  this.attemptsMade = 0;\n\n  this.toKey = _.bind(queue.toKey, queue);\n  this.debounceId = this.opts.debounce ? this.opts.debounce.id : undefined;\n};\n\nfunction setDefaultOpts(opts) {\n  const _opts = Object.assign({}, opts);\n\n  _opts.attempts = typeof _opts.attempts == 'undefined' ? 1 : _opts.attempts;\n  _opts.delay = typeof _opts.delay == 'undefined' ? 0 : Number(_opts.delay);\n  _opts.timestamp =\n    typeof _opts.timestamp == 'undefined' ? Date.now() : _opts.timestamp;\n\n  _opts.attempts = parseInt(_opts.attempts);\n  _opts.backoff = backoffs.normalize(_opts.backoff);\n\n  return _opts;\n}\n\nJob.DEFAULT_JOB_NAME = DEFAULT_JOB_NAME;\n\nfunction addJob(queue, client, job) {\n  const opts = job.opts;\n\n  const jobData = job.toData();\n  return scripts.addJob(client, queue, jobData, {\n    lifo: opts.lifo,\n    customJobId: opts.jobId,\n    priority: opts.priority,\n    debounce: opts.debounce\n  });\n}\n\nJob.create = function(queue, name, data, opts) {\n  const job = new Job(queue, name, data, opts);\n\n  return queue\n    .isReady()\n    .then(() => {\n      return addJob(queue, queue.client, job);\n    })\n    .then(jobId => {\n      job.id = jobId;\n      debuglog('Job added', jobId);\n      return job;\n    });\n};\n\nJob.createBulk = function(queue, jobs) {\n  jobs = jobs.map(job => new Job(queue, job.name, job.data, job.opts));\n\n  return queue\n    .isReady()\n    .then(() => {\n      const multi = queue.client.multi();\n\n      for (const job of jobs) {\n        addJob(queue, multi, job);\n      }\n\n      return multi.exec();\n    })\n    .then(res => {\n      res.forEach((res, index) => {\n        jobs[index].id = res[1];\n        debuglog('Job added', res[1]);\n      });\n\n      return jobs;\n    });\n};\n\nJob.fromId = async function(queue, jobId, opts) {\n  // jobId can be undefined if moveJob returns undefined\n  if (!jobId) {\n    return Promise.resolve();\n  }\n\n  const jobKey = queue.toKey(jobId);\n  let rawJob;\n\n  if (opts && opts.excludeData) {\n    rawJob = _.zipObject(\n      jobFields,\n      await queue.client.hmget(jobKey, jobFields)\n    );\n  } else {\n    rawJob = await queue.client.hgetall(jobKey);\n  }\n  return _.isEmpty(rawJob) ? null : Job.fromJSON(queue, rawJob, jobId);\n};\n\nJob.remove = async function(queue, pattern) {\n  await queue.isReady();\n  const removed = await scripts.removeWithPattern(queue, pattern);\n  removed.forEach(jobId => queue.emit('removed', jobId));\n};\n\nJob.prototype.progress = function(progress) {\n  if (_.isUndefined(progress)) {\n    return this._progress;\n  }\n  this._progress = progress;\n  return scripts.updateProgress(this, progress);\n};\n\nJob.prototype.update = async function(data) {\n  this.data = data;\n  const code = await scripts.updateData(this, data);\n\n  if (code < 0) {\n    throw scripts.finishedErrors(code, this.id, 'updateData');\n  }\n};\n\nJob.prototype.toJSON = function() {\n  const opts = Object.assign({}, this.opts);\n  return {\n    id: this.id,\n    name: this.name,\n    data: this.data || {},\n    opts: opts,\n    progress: this._progress,\n    delay: this.delay, // Move to opts\n    timestamp: this.timestamp,\n    attemptsMade: this.attemptsMade,\n    failedReason: this.failedReason,\n    stacktrace: this.stacktrace || null,\n    returnvalue: this.returnvalue || null,\n    debounceId: this.debounceId || null,\n    finishedOn: this.finishedOn || null,\n    processedOn: this.processedOn || null\n  };\n};\n\nJob.prototype.toData = function() {\n  const json = this.toJSON();\n\n  json.data = JSON.stringify(json.data);\n  json.opts = JSON.stringify(json.opts);\n  json.stacktrace = JSON.stringify(json.stacktrace);\n  json.failedReason = JSON.stringify(json.failedReason);\n  json.returnvalue = JSON.stringify(json.returnvalue);\n\n  return json;\n};\n\n/**\n  Return a unique key representing a lock for this Job\n*/\nJob.prototype.lockKey = function() {\n  return this.toKey(this.id) + ':lock';\n};\n\n/**\n  Takes a lock for this job so that no other queue worker can process it at the\n  same time.\n*/\nJob.prototype.takeLock = function() {\n  return scripts.takeLock(this.queue, this).then(lock => {\n    return lock || false;\n  });\n};\n\n/**\n  Releases the lock. Only locks owned by the queue instance can be released.\n*/\nJob.prototype.releaseLock = function() {\n  return scripts.releaseLock(this.queue, this.id).then(unlocked => {\n    if (unlocked != 1) {\n      throw new Error('Could not release lock for job ' + this.id);\n    }\n  });\n};\n\n/**\n * Extend the lock for this job.\n *\n * @param duration lock duration in milliseconds\n */\nJob.prototype.extendLock = function(duration) {\n  return scripts.extendLock(this.queue, this.id, duration);\n};\n\n/**\n * Moves a job to the completed queue.\n * Returned job to be used with Queue.prototype.nextJobFromJobData.\n * @param returnValue {string} The jobs success message.\n * @param ignoreLock {boolean} True when wanting to ignore the redis lock on this job.\n * @param notFetch {boolean} True when should not fetch next job from queue.\n * @returns {Promise} Returns the jobData of the next job in the waiting queue.\n */\nJob.prototype.moveToCompleted = function(\n  returnValue,\n  ignoreLock,\n  notFetch = false\n) {\n  return this.queue.isReady().then(() => {\n    this.returnvalue = returnValue || 0;\n\n    returnValue = utils.tryCatch(JSON.stringify, JSON, [returnValue]);\n    if (returnValue === utils.errorObject) {\n      const err = utils.errorObject.value;\n      return Promise.reject(err);\n    }\n    this.finishedOn = Date.now();\n\n    return scripts.moveToCompleted(\n      this,\n      returnValue,\n      this.opts.removeOnComplete,\n      ignoreLock,\n      notFetch\n    );\n  });\n};\n\nJob.prototype.discard = function() {\n  this._discarded = true;\n};\n\n/**\n * Moves a job to the failed queue.\n * @param err {string} The jobs error message.\n * @param ignoreLock {boolean} True when wanting to ignore the redis lock on this job.\n * @returns void\n */\nJob.prototype.moveToFailed = async function(err, ignoreLock) {\n  err = err || { message: 'Unknown reason' };\n\n  this.failedReason = err.message;\n\n  await this.queue.isReady();\n\n  let command;\n  const multi = this.queue.client.multi();\n  this._saveAttempt(multi, err);\n\n  // Check if an automatic retry should be performed\n  let moveToFailed = false;\n  if (this.attemptsMade < this.opts.attempts && !this._discarded) {\n    // Check if backoff is needed\n    const delay = await backoffs.calculate(\n      this.opts.backoff,\n      this.attemptsMade,\n      this.queue.settings.backoffStrategies,\n      err,\n      _.get(this, 'opts.backoff.options', null)\n    );\n\n    if (delay === -1) {\n      // If delay is -1, we should no continue retrying\n      moveToFailed = true;\n    } else if (delay) {\n      // If so, move to delayed (need to unlock job in this case!)\n      const args = scripts.moveToDelayedArgs(\n        this.queue,\n        this.id,\n        Date.now() + delay,\n        ignoreLock\n      );\n      multi.moveToDelayed(args);\n      command = 'delayed';\n    } else {\n      // If not, retry immediately\n      multi.retryJob(scripts.retryJobArgs(this, ignoreLock));\n      command = 'retry';\n    }\n  } else {\n    // If not, move to failed\n    moveToFailed = true;\n  }\n\n  if (moveToFailed) {\n    this.finishedOn = Date.now();\n    const args = scripts.moveToFailedArgs(\n      this,\n      err.message,\n      this.opts.removeOnFail,\n      ignoreLock\n    );\n    multi.moveToFinished(args);\n    command = 'failed';\n  }\n  const results = await multi.exec();\n  const code = _.last(results)[1];\n  if (code < 0) {\n    throw scripts.finishedErrors(code, this.id, command, 'active');\n  }\n};\n\nJob.prototype.moveToDelayed = function(timestamp, ignoreLock) {\n  return scripts.moveToDelayed(this.queue, this.id, timestamp, ignoreLock);\n};\n\nJob.prototype.promote = function() {\n  const queue = this.queue;\n  const jobId = this.id;\n  return queue.isReady().then(() =>\n    scripts.promote(queue, jobId).then(result => {\n      if (result === -1) {\n        throw new Error('Job ' + jobId + ' is not in a delayed state');\n      }\n    })\n  );\n};\n\n/**\n * Attempts to retry the job. Only a job that has failed can be retried.\n *\n * @return {Promise} If resolved and return code is 1, then the queue emits a waiting event\n * otherwise the operation was not a success and throw the corresponding error. If the promise\n * rejects, it indicates that the script failed to execute\n */\nJob.prototype.retry = function() {\n  return this.queue.isReady().then(() => {\n    this.failedReason = null;\n    this.finishedOn = null;\n    this.processedOn = null;\n    this.retriedOn = Date.now();\n\n    return scripts.reprocessJob(this, { state: 'failed' }).then(result => {\n      if (result === 1) {\n        return;\n      } else if (result === 0) {\n        throw new Error(errors.Messages.RETRY_JOB_NOT_EXIST);\n      } else if (result === -1) {\n        throw new Error(errors.Messages.RETRY_JOB_IS_LOCKED);\n      } else if (result === -2) {\n        throw new Error(errors.Messages.RETRY_JOB_NOT_FAILED);\n      }\n    });\n  });\n};\n\n/**\n * Logs one row of log data.\n *\n * @params logRow: string String with log data to be logged.\n *\n */\nJob.prototype.log = function(logRow) {\n  return scripts.addLog(this.queue, this.id, logRow);\n};\n\nJob.prototype.isCompleted = function() {\n  return this._isDone('completed');\n};\n\nJob.prototype.isFailed = function() {\n  return this._isDone('failed');\n};\n\nJob.prototype.isDelayed = function() {\n  return this._isDone('delayed');\n};\n\nJob.prototype.isActive = function() {\n  return this._isInList('active');\n};\n\nJob.prototype.isWaiting = function() {\n  return this._isInList('wait');\n};\n\nJob.prototype.isPaused = function() {\n  return this._isInList('paused');\n};\n\nJob.prototype.isStuck = function() {\n  return this.getState().then(state => {\n    return state === 'stuck';\n  });\n};\n\nJob.prototype.isDiscarded = function() {\n  return this._discarded;\n};\n\nJob.prototype.getState = function() {\n  const fns = [\n    { fn: 'isCompleted', state: 'completed' },\n    { fn: 'isFailed', state: 'failed' },\n    { fn: 'isDelayed', state: 'delayed' },\n    { fn: 'isActive', state: 'active' },\n    { fn: 'isWaiting', state: 'waiting' },\n    { fn: 'isPaused', state: 'paused' }\n  ];\n\n  return fns\n    .reduce((result, fn) => {\n      return result.then(state => {\n        if (state) {\n          return state;\n        }\n        return this[fn.fn]().then(result => {\n          return result ? fn.state : null;\n        });\n      });\n    }, Promise.resolve())\n    .then(result => {\n      return result ? result : 'stuck';\n    });\n};\n\nJob.prototype.remove = function() {\n  const queue = this.queue;\n  const job = this;\n\n  return queue.isReady().then(() => {\n    return scripts.remove(queue, job.id).then(removed => {\n      if (removed) {\n        queue.emit('removed', job);\n      } else {\n        throw new Error('Could not remove job ' + job.id);\n      }\n    });\n  });\n};\n\n/**\n * Returns a promise the resolves when the job has finished. (completed or failed).\n */\nJob.prototype.finished = async function() {\n  await Promise.all([\n    this.queue._registerEvent('global:completed'),\n    this.queue._registerEvent('global:failed')\n  ]);\n\n  await this.queue.isReady();\n\n  const status = await scripts.isFinished(this);\n  const finished = status > 0;\n  if (finished) {\n    const job = await Job.fromId(this.queue, this.id);\n    if (status == 2) {\n      throw new Error(job.failedReason);\n    } else {\n      return job.returnvalue;\n    }\n  } else {\n    return new Promise((resolve, reject) => {\n      const onCompleted = (jobId, resultValue) => {\n        if (String(jobId) === String(this.id)) {\n          let result = void 0;\n          try {\n            if (typeof resultValue === 'string') {\n              result = JSON.parse(resultValue);\n            }\n          } catch (err) {\n            //swallow exception because the resultValue got corrupted somehow.\n            debuglog('corrupted resultValue: ' + resultValue, err);\n          }\n          resolve(result);\n          removeListeners();\n        }\n      };\n\n      const onFailed = (jobId, failedReason) => {\n        if (String(jobId) === String(this.id)) {\n          reject(new Error(failedReason));\n          removeListeners();\n        }\n      };\n\n      this.queue.on('global:completed', onCompleted);\n      this.queue.on('global:failed', onFailed);\n\n      const removeListeners = () => {\n        clearInterval(interval);\n        this.queue.removeListener('global:completed', onCompleted);\n        this.queue.removeListener('global:failed', onFailed);\n      };\n\n      //\n      // Watchdog\n      //\n      const interval = setInterval(() => {\n        if (this._isQueueClosing()) {\n          removeListeners();\n          // TODO(manast) maybe we would need a more graceful way to get out of this interval.\n          reject(\n            new Error('cannot check if job is finished in a closing queue.')\n          );\n        } else {\n          scripts.isFinished(this).then(status => {\n            const finished = status > 0;\n            if (finished) {\n              Job.fromId(this.queue, this.id).then(job => {\n                removeListeners();\n                if (status == 2) {\n                  reject(new Error(job.failedReason));\n                } else {\n                  resolve(job.returnvalue);\n                }\n              });\n            }\n          });\n        }\n      }, FINISHED_WATCHDOG);\n    });\n  }\n};\n\n// -----------------------------------------------------------------------------\n// Private methods\n// -----------------------------------------------------------------------------\nJob.prototype._isQueueClosing = function() {\n  return this.queue.closing;\n};\n\nJob.prototype._isDone = function(list) {\n  return this.queue.client\n    .zscore(this.queue.toKey(list), this.id)\n    .then(score => {\n      return score !== null;\n    });\n};\n\nJob.prototype._isInList = function(list) {\n  return scripts.isJobInList(\n    this.queue.client,\n    this.queue.toKey(list),\n    this.id\n  );\n};\n\nJob.prototype._saveAttempt = function(multi, err) {\n  this.attemptsMade++;\n\n  this.stacktrace = this.stacktrace || [];\n\n  if (err && err.stack) {\n    this.stacktrace.push(err.stack);\n    if (this.opts.stackTraceLimit) {\n      this.stacktrace = this.stacktrace.slice(-this.opts.stackTraceLimit);\n    }\n  }\n\n  const args = scripts.saveStacktraceArgs(\n    this,\n    JSON.stringify(this.stacktrace),\n    err && err.message,\n  );\n\n  multi.saveStacktrace(args);\n};\n\nJob.fromJSON = function(queue, json, jobId) {\n  const opts = JSON.parse(json.opts || '{}');\n  const data = opts.preventParsingData\n    ? json.data\n    : JSON.parse(json.data || '{}');\n\n  const job = new Job(queue, json.name || Job.DEFAULT_JOB_NAME, data, opts);\n\n  job.id = json.id || jobId;\n\n  try {\n    job._progress = JSON.parse(json.progress || 0);\n  } catch (err) {\n    console.error(\n      `Error parsing progress ${json.progress} with ${err.message}`\n    );\n  }\n\n  job.delay = parseInt(json.delay);\n  job.timestamp = parseInt(json.timestamp);\n  if (json.finishedOn) {\n    job.finishedOn = parseInt(json.finishedOn);\n  }\n\n  if (json.processedOn) {\n    job.processedOn = parseInt(json.processedOn);\n  }\n\n  if (json.retriedOn) {\n    job.retriedOn = parseInt(json.retriedOn);\n  }\n\n  job.failedReason = json.failedReason;\n  job.attemptsMade = parseInt(json.attemptsMade || 0);\n\n  job.stacktrace = getTraces(json.stacktrace);\n\n  if (typeof json.returnvalue === 'string') {\n    job.returnvalue = getReturnValue(json.returnvalue);\n  }\n\n  if (json.deid) {\n    job.debounceId = json.deid;\n  }\n\n  return job;\n};\n\nfunction getTraces(stacktrace) {\n  const _traces = utils.tryCatch(JSON.parse, JSON, [stacktrace]);\n\n  if (_traces === utils.errorObject || !(_traces instanceof Array)) {\n    return [];\n  } else {\n    return _traces;\n  }\n}\n\nfunction getReturnValue(_value) {\n  const value = utils.tryCatch(JSON.parse, JSON, [_value]);\n  if (value !== utils.errorObject) {\n    return value;\n  } else {\n    debuglog('corrupted returnvalue: ' + _value, value);\n  }\n}\n\nmodule.exports = Job;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvYnVsbC9saWIvam9iLmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViLFVBQVUsbUJBQU8sQ0FBQyxxREFBUTtBQUMxQixjQUFjLG1CQUFPLENBQUMsdURBQVM7QUFDL0IsZ0JBQWdCLG1CQUFPLENBQUMsMkRBQVc7QUFDbkMsaUJBQWlCLGtEQUF3QjtBQUN6QyxlQUFlLG1CQUFPLENBQUMseURBQVU7QUFDakMsaUJBQWlCLG1CQUFPLENBQUMsNkRBQVk7O0FBRXJDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxnQ0FBZ0M7O0FBRWhDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLCtCQUErQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsUUFBUTtBQUMvQixzQkFBc0IsU0FBUztBQUMvQixvQkFBb0IsU0FBUztBQUM3QixhQUFhLFNBQVM7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkIsc0JBQXNCLFNBQVM7QUFDL0I7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCOztBQUVqQjs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsWUFBWSxTQUFTO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSx3Q0FBd0MsaUJBQWlCO0FBQ3pEO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQSxRQUFRO0FBQ1I7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE1BQU0sdUNBQXVDO0FBQzdDLE1BQU0saUNBQWlDO0FBQ3ZDLE1BQU0sbUNBQW1DO0FBQ3pDLE1BQU0saUNBQWlDO0FBQ3ZDLE1BQU0sbUNBQW1DO0FBQ3pDLE1BQU07QUFDTjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBLFdBQVc7QUFDWDtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSwwQ0FBMEM7QUFDMUM7QUFDQTtBQUNBLGlDQUFpQzs7QUFFakM7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBLGdDQUFnQyxlQUFlLE9BQU8sWUFBWTtBQUNsRTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFQSIsInNvdXJjZXMiOlsid2VicGFjazovL215LWFwcC8uL25vZGVfbW9kdWxlcy9idWxsL2xpYi9qb2IuanM/NjJjNiJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbmNvbnN0IF8gPSByZXF1aXJlKCdsb2Rhc2gnKTtcbmNvbnN0IHV0aWxzID0gcmVxdWlyZSgnLi91dGlscycpO1xuY29uc3Qgc2NyaXB0cyA9IHJlcXVpcmUoJy4vc2NyaXB0cycpO1xuY29uc3QgZGVidWdsb2cgPSByZXF1aXJlKCd1dGlsJykuZGVidWdsb2coJ2J1bGwnKTtcbmNvbnN0IGVycm9ycyA9IHJlcXVpcmUoJy4vZXJyb3JzJyk7XG5jb25zdCBiYWNrb2ZmcyA9IHJlcXVpcmUoJy4vYmFja29mZnMnKTtcblxuY29uc3QgRklOSVNIRURfV0FUQ0hET0cgPSA1MDAwO1xuY29uc3QgREVGQVVMVF9KT0JfTkFNRSA9ICdfX2RlZmF1bHRfXyc7XG5cbi8qKlxuaW50ZXJmYWNlIEpvYk9wdGlvbnNcbntcbiAgcHJpb3JpdHk6IFByaW9yaXR5O1xuICBhdHRlbXB0czogbnVtYmVyO1xuICBkZWxheTogbnVtYmVyO1xufVxuKi9cblxuY29uc3Qgam9iRmllbGRzID0gW1xuICAnb3B0cycsXG4gICduYW1lJyxcbiAgJ2lkJyxcbiAgJ3Byb2dyZXNzJyxcbiAgJ2RlbGF5JyxcbiAgJ3RpbWVzdGFtcCcsXG4gICdmaW5pc2hlZE9uJyxcbiAgJ3Byb2Nlc3NlZE9uJyxcbiAgJ3JldHJpZWRPbicsXG4gICdmYWlsZWRSZWFzb24nLFxuICAnYXR0ZW1wdHNNYWRlJyxcbiAgJ3N0YWNrdHJhY2UnLFxuICAncmV0dXJudmFsdWUnXG5dO1xuXG4vLyBxdWV1ZTogUXVldWUsIGRhdGE6IHt9LCBvcHRzOiBKb2JPcHRpb25zXG5jb25zdCBKb2IgPSBmdW5jdGlvbihxdWV1ZSwgbmFtZSwgZGF0YSwgb3B0cykge1xuICBpZiAodHlwZW9mIG5hbWUgIT09ICdzdHJpbmcnKSB7XG4gICAgb3B0cyA9IGRhdGE7XG4gICAgZGF0YSA9IG5hbWU7XG4gICAgbmFtZSA9IERFRkFVTFRfSk9CX05BTUU7XG4gIH1cblxuICAvLyBkZWZhdWx0c1xuICB0aGlzLm9wdHMgPSBzZXREZWZhdWx0T3B0cyhvcHRzKTtcblxuICB0aGlzLm5hbWUgPSBuYW1lO1xuICB0aGlzLnF1ZXVlID0gcXVldWU7XG4gIHRoaXMuZGF0YSA9IGRhdGE7XG4gIHRoaXMuX3Byb2dyZXNzID0gMDtcbiAgdGhpcy5kZWxheSA9IHRoaXMub3B0cy5kZWxheSA8IDAgPyAwIDogdGhpcy5vcHRzLmRlbGF5O1xuICB0aGlzLnRpbWVzdGFtcCA9IHRoaXMub3B0cy50aW1lc3RhbXA7XG4gIHRoaXMuc3RhY2t0cmFjZSA9IFtdO1xuICB0aGlzLnJldHVybnZhbHVlID0gbnVsbDtcbiAgdGhpcy5hdHRlbXB0c01hZGUgPSAwO1xuXG4gIHRoaXMudG9LZXkgPSBfLmJpbmQocXVldWUudG9LZXksIHF1ZXVlKTtcbiAgdGhpcy5kZWJvdW5jZUlkID0gdGhpcy5vcHRzLmRlYm91bmNlID8gdGhpcy5vcHRzLmRlYm91bmNlLmlkIDogdW5kZWZpbmVkO1xufTtcblxuZnVuY3Rpb24gc2V0RGVmYXVsdE9wdHMob3B0cykge1xuICBjb25zdCBfb3B0cyA9IE9iamVjdC5hc3NpZ24oe30sIG9wdHMpO1xuXG4gIF9vcHRzLmF0dGVtcHRzID0gdHlwZW9mIF9vcHRzLmF0dGVtcHRzID09ICd1bmRlZmluZWQnID8gMSA6IF9vcHRzLmF0dGVtcHRzO1xuICBfb3B0cy5kZWxheSA9IHR5cGVvZiBfb3B0cy5kZWxheSA9PSAndW5kZWZpbmVkJyA/IDAgOiBOdW1iZXIoX29wdHMuZGVsYXkpO1xuICBfb3B0cy50aW1lc3RhbXAgPVxuICAgIHR5cGVvZiBfb3B0cy50aW1lc3RhbXAgPT0gJ3VuZGVmaW5lZCcgPyBEYXRlLm5vdygpIDogX29wdHMudGltZXN0YW1wO1xuXG4gIF9vcHRzLmF0dGVtcHRzID0gcGFyc2VJbnQoX29wdHMuYXR0ZW1wdHMpO1xuICBfb3B0cy5iYWNrb2ZmID0gYmFja29mZnMubm9ybWFsaXplKF9vcHRzLmJhY2tvZmYpO1xuXG4gIHJldHVybiBfb3B0cztcbn1cblxuSm9iLkRFRkFVTFRfSk9CX05BTUUgPSBERUZBVUxUX0pPQl9OQU1FO1xuXG5mdW5jdGlvbiBhZGRKb2IocXVldWUsIGNsaWVudCwgam9iKSB7XG4gIGNvbnN0IG9wdHMgPSBqb2Iub3B0cztcblxuICBjb25zdCBqb2JEYXRhID0gam9iLnRvRGF0YSgpO1xuICByZXR1cm4gc2NyaXB0cy5hZGRKb2IoY2xpZW50LCBxdWV1ZSwgam9iRGF0YSwge1xuICAgIGxpZm86IG9wdHMubGlmbyxcbiAgICBjdXN0b21Kb2JJZDogb3B0cy5qb2JJZCxcbiAgICBwcmlvcml0eTogb3B0cy5wcmlvcml0eSxcbiAgICBkZWJvdW5jZTogb3B0cy5kZWJvdW5jZVxuICB9KTtcbn1cblxuSm9iLmNyZWF0ZSA9IGZ1bmN0aW9uKHF1ZXVlLCBuYW1lLCBkYXRhLCBvcHRzKSB7XG4gIGNvbnN0IGpvYiA9IG5ldyBKb2IocXVldWUsIG5hbWUsIGRhdGEsIG9wdHMpO1xuXG4gIHJldHVybiBxdWV1ZVxuICAgIC5pc1JlYWR5KClcbiAgICAudGhlbigoKSA9PiB7XG4gICAgICByZXR1cm4gYWRkSm9iKHF1ZXVlLCBxdWV1ZS5jbGllbnQsIGpvYik7XG4gICAgfSlcbiAgICAudGhlbihqb2JJZCA9PiB7XG4gICAgICBqb2IuaWQgPSBqb2JJZDtcbiAgICAgIGRlYnVnbG9nKCdKb2IgYWRkZWQnLCBqb2JJZCk7XG4gICAgICByZXR1cm4gam9iO1xuICAgIH0pO1xufTtcblxuSm9iLmNyZWF0ZUJ1bGsgPSBmdW5jdGlvbihxdWV1ZSwgam9icykge1xuICBqb2JzID0gam9icy5tYXAoam9iID0+IG5ldyBKb2IocXVldWUsIGpvYi5uYW1lLCBqb2IuZGF0YSwgam9iLm9wdHMpKTtcblxuICByZXR1cm4gcXVldWVcbiAgICAuaXNSZWFkeSgpXG4gICAgLnRoZW4oKCkgPT4ge1xuICAgICAgY29uc3QgbXVsdGkgPSBxdWV1ZS5jbGllbnQubXVsdGkoKTtcblxuICAgICAgZm9yIChjb25zdCBqb2Igb2Ygam9icykge1xuICAgICAgICBhZGRKb2IocXVldWUsIG11bHRpLCBqb2IpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gbXVsdGkuZXhlYygpO1xuICAgIH0pXG4gICAgLnRoZW4ocmVzID0+IHtcbiAgICAgIHJlcy5mb3JFYWNoKChyZXMsIGluZGV4KSA9PiB7XG4gICAgICAgIGpvYnNbaW5kZXhdLmlkID0gcmVzWzFdO1xuICAgICAgICBkZWJ1Z2xvZygnSm9iIGFkZGVkJywgcmVzWzFdKTtcbiAgICAgIH0pO1xuXG4gICAgICByZXR1cm4gam9icztcbiAgICB9KTtcbn07XG5cbkpvYi5mcm9tSWQgPSBhc3luYyBmdW5jdGlvbihxdWV1ZSwgam9iSWQsIG9wdHMpIHtcbiAgLy8gam9iSWQgY2FuIGJlIHVuZGVmaW5lZCBpZiBtb3ZlSm9iIHJldHVybnMgdW5kZWZpbmVkXG4gIGlmICgham9iSWQpIHtcbiAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCk7XG4gIH1cblxuICBjb25zdCBqb2JLZXkgPSBxdWV1ZS50b0tleShqb2JJZCk7XG4gIGxldCByYXdKb2I7XG5cbiAgaWYgKG9wdHMgJiYgb3B0cy5leGNsdWRlRGF0YSkge1xuICAgIHJhd0pvYiA9IF8uemlwT2JqZWN0KFxuICAgICAgam9iRmllbGRzLFxuICAgICAgYXdhaXQgcXVldWUuY2xpZW50LmhtZ2V0KGpvYktleSwgam9iRmllbGRzKVxuICAgICk7XG4gIH0gZWxzZSB7XG4gICAgcmF3Sm9iID0gYXdhaXQgcXVldWUuY2xpZW50LmhnZXRhbGwoam9iS2V5KTtcbiAgfVxuICByZXR1cm4gXy5pc0VtcHR5KHJhd0pvYikgPyBudWxsIDogSm9iLmZyb21KU09OKHF1ZXVlLCByYXdKb2IsIGpvYklkKTtcbn07XG5cbkpvYi5yZW1vdmUgPSBhc3luYyBmdW5jdGlvbihxdWV1ZSwgcGF0dGVybikge1xuICBhd2FpdCBxdWV1ZS5pc1JlYWR5KCk7XG4gIGNvbnN0IHJlbW92ZWQgPSBhd2FpdCBzY3JpcHRzLnJlbW92ZVdpdGhQYXR0ZXJuKHF1ZXVlLCBwYXR0ZXJuKTtcbiAgcmVtb3ZlZC5mb3JFYWNoKGpvYklkID0+IHF1ZXVlLmVtaXQoJ3JlbW92ZWQnLCBqb2JJZCkpO1xufTtcblxuSm9iLnByb3RvdHlwZS5wcm9ncmVzcyA9IGZ1bmN0aW9uKHByb2dyZXNzKSB7XG4gIGlmIChfLmlzVW5kZWZpbmVkKHByb2dyZXNzKSkge1xuICAgIHJldHVybiB0aGlzLl9wcm9ncmVzcztcbiAgfVxuICB0aGlzLl9wcm9ncmVzcyA9IHByb2dyZXNzO1xuICByZXR1cm4gc2NyaXB0cy51cGRhdGVQcm9ncmVzcyh0aGlzLCBwcm9ncmVzcyk7XG59O1xuXG5Kb2IucHJvdG90eXBlLnVwZGF0ZSA9IGFzeW5jIGZ1bmN0aW9uKGRhdGEpIHtcbiAgdGhpcy5kYXRhID0gZGF0YTtcbiAgY29uc3QgY29kZSA9IGF3YWl0IHNjcmlwdHMudXBkYXRlRGF0YSh0aGlzLCBkYXRhKTtcblxuICBpZiAoY29kZSA8IDApIHtcbiAgICB0aHJvdyBzY3JpcHRzLmZpbmlzaGVkRXJyb3JzKGNvZGUsIHRoaXMuaWQsICd1cGRhdGVEYXRhJyk7XG4gIH1cbn07XG5cbkpvYi5wcm90b3R5cGUudG9KU09OID0gZnVuY3Rpb24oKSB7XG4gIGNvbnN0IG9wdHMgPSBPYmplY3QuYXNzaWduKHt9LCB0aGlzLm9wdHMpO1xuICByZXR1cm4ge1xuICAgIGlkOiB0aGlzLmlkLFxuICAgIG5hbWU6IHRoaXMubmFtZSxcbiAgICBkYXRhOiB0aGlzLmRhdGEgfHwge30sXG4gICAgb3B0czogb3B0cyxcbiAgICBwcm9ncmVzczogdGhpcy5fcHJvZ3Jlc3MsXG4gICAgZGVsYXk6IHRoaXMuZGVsYXksIC8vIE1vdmUgdG8gb3B0c1xuICAgIHRpbWVzdGFtcDogdGhpcy50aW1lc3RhbXAsXG4gICAgYXR0ZW1wdHNNYWRlOiB0aGlzLmF0dGVtcHRzTWFkZSxcbiAgICBmYWlsZWRSZWFzb246IHRoaXMuZmFpbGVkUmVhc29uLFxuICAgIHN0YWNrdHJhY2U6IHRoaXMuc3RhY2t0cmFjZSB8fCBudWxsLFxuICAgIHJldHVybnZhbHVlOiB0aGlzLnJldHVybnZhbHVlIHx8IG51bGwsXG4gICAgZGVib3VuY2VJZDogdGhpcy5kZWJvdW5jZUlkIHx8IG51bGwsXG4gICAgZmluaXNoZWRPbjogdGhpcy5maW5pc2hlZE9uIHx8IG51bGwsXG4gICAgcHJvY2Vzc2VkT246IHRoaXMucHJvY2Vzc2VkT24gfHwgbnVsbFxuICB9O1xufTtcblxuSm9iLnByb3RvdHlwZS50b0RhdGEgPSBmdW5jdGlvbigpIHtcbiAgY29uc3QganNvbiA9IHRoaXMudG9KU09OKCk7XG5cbiAganNvbi5kYXRhID0gSlNPTi5zdHJpbmdpZnkoanNvbi5kYXRhKTtcbiAganNvbi5vcHRzID0gSlNPTi5zdHJpbmdpZnkoanNvbi5vcHRzKTtcbiAganNvbi5zdGFja3RyYWNlID0gSlNPTi5zdHJpbmdpZnkoanNvbi5zdGFja3RyYWNlKTtcbiAganNvbi5mYWlsZWRSZWFzb24gPSBKU09OLnN0cmluZ2lmeShqc29uLmZhaWxlZFJlYXNvbik7XG4gIGpzb24ucmV0dXJudmFsdWUgPSBKU09OLnN0cmluZ2lmeShqc29uLnJldHVybnZhbHVlKTtcblxuICByZXR1cm4ganNvbjtcbn07XG5cbi8qKlxuICBSZXR1cm4gYSB1bmlxdWUga2V5IHJlcHJlc2VudGluZyBhIGxvY2sgZm9yIHRoaXMgSm9iXG4qL1xuSm9iLnByb3RvdHlwZS5sb2NrS2V5ID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB0aGlzLnRvS2V5KHRoaXMuaWQpICsgJzpsb2NrJztcbn07XG5cbi8qKlxuICBUYWtlcyBhIGxvY2sgZm9yIHRoaXMgam9iIHNvIHRoYXQgbm8gb3RoZXIgcXVldWUgd29ya2VyIGNhbiBwcm9jZXNzIGl0IGF0IHRoZVxuICBzYW1lIHRpbWUuXG4qL1xuSm9iLnByb3RvdHlwZS50YWtlTG9jayA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gc2NyaXB0cy50YWtlTG9jayh0aGlzLnF1ZXVlLCB0aGlzKS50aGVuKGxvY2sgPT4ge1xuICAgIHJldHVybiBsb2NrIHx8IGZhbHNlO1xuICB9KTtcbn07XG5cbi8qKlxuICBSZWxlYXNlcyB0aGUgbG9jay4gT25seSBsb2NrcyBvd25lZCBieSB0aGUgcXVldWUgaW5zdGFuY2UgY2FuIGJlIHJlbGVhc2VkLlxuKi9cbkpvYi5wcm90b3R5cGUucmVsZWFzZUxvY2sgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHNjcmlwdHMucmVsZWFzZUxvY2sodGhpcy5xdWV1ZSwgdGhpcy5pZCkudGhlbih1bmxvY2tlZCA9PiB7XG4gICAgaWYgKHVubG9ja2VkICE9IDEpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignQ291bGQgbm90IHJlbGVhc2UgbG9jayBmb3Igam9iICcgKyB0aGlzLmlkKTtcbiAgICB9XG4gIH0pO1xufTtcblxuLyoqXG4gKiBFeHRlbmQgdGhlIGxvY2sgZm9yIHRoaXMgam9iLlxuICpcbiAqIEBwYXJhbSBkdXJhdGlvbiBsb2NrIGR1cmF0aW9uIGluIG1pbGxpc2Vjb25kc1xuICovXG5Kb2IucHJvdG90eXBlLmV4dGVuZExvY2sgPSBmdW5jdGlvbihkdXJhdGlvbikge1xuICByZXR1cm4gc2NyaXB0cy5leHRlbmRMb2NrKHRoaXMucXVldWUsIHRoaXMuaWQsIGR1cmF0aW9uKTtcbn07XG5cbi8qKlxuICogTW92ZXMgYSBqb2IgdG8gdGhlIGNvbXBsZXRlZCBxdWV1ZS5cbiAqIFJldHVybmVkIGpvYiB0byBiZSB1c2VkIHdpdGggUXVldWUucHJvdG90eXBlLm5leHRKb2JGcm9tSm9iRGF0YS5cbiAqIEBwYXJhbSByZXR1cm5WYWx1ZSB7c3RyaW5nfSBUaGUgam9icyBzdWNjZXNzIG1lc3NhZ2UuXG4gKiBAcGFyYW0gaWdub3JlTG9jayB7Ym9vbGVhbn0gVHJ1ZSB3aGVuIHdhbnRpbmcgdG8gaWdub3JlIHRoZSByZWRpcyBsb2NrIG9uIHRoaXMgam9iLlxuICogQHBhcmFtIG5vdEZldGNoIHtib29sZWFufSBUcnVlIHdoZW4gc2hvdWxkIG5vdCBmZXRjaCBuZXh0IGpvYiBmcm9tIHF1ZXVlLlxuICogQHJldHVybnMge1Byb21pc2V9IFJldHVybnMgdGhlIGpvYkRhdGEgb2YgdGhlIG5leHQgam9iIGluIHRoZSB3YWl0aW5nIHF1ZXVlLlxuICovXG5Kb2IucHJvdG90eXBlLm1vdmVUb0NvbXBsZXRlZCA9IGZ1bmN0aW9uKFxuICByZXR1cm5WYWx1ZSxcbiAgaWdub3JlTG9jayxcbiAgbm90RmV0Y2ggPSBmYWxzZVxuKSB7XG4gIHJldHVybiB0aGlzLnF1ZXVlLmlzUmVhZHkoKS50aGVuKCgpID0+IHtcbiAgICB0aGlzLnJldHVybnZhbHVlID0gcmV0dXJuVmFsdWUgfHwgMDtcblxuICAgIHJldHVyblZhbHVlID0gdXRpbHMudHJ5Q2F0Y2goSlNPTi5zdHJpbmdpZnksIEpTT04sIFtyZXR1cm5WYWx1ZV0pO1xuICAgIGlmIChyZXR1cm5WYWx1ZSA9PT0gdXRpbHMuZXJyb3JPYmplY3QpIHtcbiAgICAgIGNvbnN0IGVyciA9IHV0aWxzLmVycm9yT2JqZWN0LnZhbHVlO1xuICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KGVycik7XG4gICAgfVxuICAgIHRoaXMuZmluaXNoZWRPbiA9IERhdGUubm93KCk7XG5cbiAgICByZXR1cm4gc2NyaXB0cy5tb3ZlVG9Db21wbGV0ZWQoXG4gICAgICB0aGlzLFxuICAgICAgcmV0dXJuVmFsdWUsXG4gICAgICB0aGlzLm9wdHMucmVtb3ZlT25Db21wbGV0ZSxcbiAgICAgIGlnbm9yZUxvY2ssXG4gICAgICBub3RGZXRjaFxuICAgICk7XG4gIH0pO1xufTtcblxuSm9iLnByb3RvdHlwZS5kaXNjYXJkID0gZnVuY3Rpb24oKSB7XG4gIHRoaXMuX2Rpc2NhcmRlZCA9IHRydWU7XG59O1xuXG4vKipcbiAqIE1vdmVzIGEgam9iIHRvIHRoZSBmYWlsZWQgcXVldWUuXG4gKiBAcGFyYW0gZXJyIHtzdHJpbmd9IFRoZSBqb2JzIGVycm9yIG1lc3NhZ2UuXG4gKiBAcGFyYW0gaWdub3JlTG9jayB7Ym9vbGVhbn0gVHJ1ZSB3aGVuIHdhbnRpbmcgdG8gaWdub3JlIHRoZSByZWRpcyBsb2NrIG9uIHRoaXMgam9iLlxuICogQHJldHVybnMgdm9pZFxuICovXG5Kb2IucHJvdG90eXBlLm1vdmVUb0ZhaWxlZCA9IGFzeW5jIGZ1bmN0aW9uKGVyciwgaWdub3JlTG9jaykge1xuICBlcnIgPSBlcnIgfHwgeyBtZXNzYWdlOiAnVW5rbm93biByZWFzb24nIH07XG5cbiAgdGhpcy5mYWlsZWRSZWFzb24gPSBlcnIubWVzc2FnZTtcblxuICBhd2FpdCB0aGlzLnF1ZXVlLmlzUmVhZHkoKTtcblxuICBsZXQgY29tbWFuZDtcbiAgY29uc3QgbXVsdGkgPSB0aGlzLnF1ZXVlLmNsaWVudC5tdWx0aSgpO1xuICB0aGlzLl9zYXZlQXR0ZW1wdChtdWx0aSwgZXJyKTtcblxuICAvLyBDaGVjayBpZiBhbiBhdXRvbWF0aWMgcmV0cnkgc2hvdWxkIGJlIHBlcmZvcm1lZFxuICBsZXQgbW92ZVRvRmFpbGVkID0gZmFsc2U7XG4gIGlmICh0aGlzLmF0dGVtcHRzTWFkZSA8IHRoaXMub3B0cy5hdHRlbXB0cyAmJiAhdGhpcy5fZGlzY2FyZGVkKSB7XG4gICAgLy8gQ2hlY2sgaWYgYmFja29mZiBpcyBuZWVkZWRcbiAgICBjb25zdCBkZWxheSA9IGF3YWl0IGJhY2tvZmZzLmNhbGN1bGF0ZShcbiAgICAgIHRoaXMub3B0cy5iYWNrb2ZmLFxuICAgICAgdGhpcy5hdHRlbXB0c01hZGUsXG4gICAgICB0aGlzLnF1ZXVlLnNldHRpbmdzLmJhY2tvZmZTdHJhdGVnaWVzLFxuICAgICAgZXJyLFxuICAgICAgXy5nZXQodGhpcywgJ29wdHMuYmFja29mZi5vcHRpb25zJywgbnVsbClcbiAgICApO1xuXG4gICAgaWYgKGRlbGF5ID09PSAtMSkge1xuICAgICAgLy8gSWYgZGVsYXkgaXMgLTEsIHdlIHNob3VsZCBubyBjb250aW51ZSByZXRyeWluZ1xuICAgICAgbW92ZVRvRmFpbGVkID0gdHJ1ZTtcbiAgICB9IGVsc2UgaWYgKGRlbGF5KSB7XG4gICAgICAvLyBJZiBzbywgbW92ZSB0byBkZWxheWVkIChuZWVkIHRvIHVubG9jayBqb2IgaW4gdGhpcyBjYXNlISlcbiAgICAgIGNvbnN0IGFyZ3MgPSBzY3JpcHRzLm1vdmVUb0RlbGF5ZWRBcmdzKFxuICAgICAgICB0aGlzLnF1ZXVlLFxuICAgICAgICB0aGlzLmlkLFxuICAgICAgICBEYXRlLm5vdygpICsgZGVsYXksXG4gICAgICAgIGlnbm9yZUxvY2tcbiAgICAgICk7XG4gICAgICBtdWx0aS5tb3ZlVG9EZWxheWVkKGFyZ3MpO1xuICAgICAgY29tbWFuZCA9ICdkZWxheWVkJztcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gSWYgbm90LCByZXRyeSBpbW1lZGlhdGVseVxuICAgICAgbXVsdGkucmV0cnlKb2Ioc2NyaXB0cy5yZXRyeUpvYkFyZ3ModGhpcywgaWdub3JlTG9jaykpO1xuICAgICAgY29tbWFuZCA9ICdyZXRyeSc7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIC8vIElmIG5vdCwgbW92ZSB0byBmYWlsZWRcbiAgICBtb3ZlVG9GYWlsZWQgPSB0cnVlO1xuICB9XG5cbiAgaWYgKG1vdmVUb0ZhaWxlZCkge1xuICAgIHRoaXMuZmluaXNoZWRPbiA9IERhdGUubm93KCk7XG4gICAgY29uc3QgYXJncyA9IHNjcmlwdHMubW92ZVRvRmFpbGVkQXJncyhcbiAgICAgIHRoaXMsXG4gICAgICBlcnIubWVzc2FnZSxcbiAgICAgIHRoaXMub3B0cy5yZW1vdmVPbkZhaWwsXG4gICAgICBpZ25vcmVMb2NrXG4gICAgKTtcbiAgICBtdWx0aS5tb3ZlVG9GaW5pc2hlZChhcmdzKTtcbiAgICBjb21tYW5kID0gJ2ZhaWxlZCc7XG4gIH1cbiAgY29uc3QgcmVzdWx0cyA9IGF3YWl0IG11bHRpLmV4ZWMoKTtcbiAgY29uc3QgY29kZSA9IF8ubGFzdChyZXN1bHRzKVsxXTtcbiAgaWYgKGNvZGUgPCAwKSB7XG4gICAgdGhyb3cgc2NyaXB0cy5maW5pc2hlZEVycm9ycyhjb2RlLCB0aGlzLmlkLCBjb21tYW5kLCAnYWN0aXZlJyk7XG4gIH1cbn07XG5cbkpvYi5wcm90b3R5cGUubW92ZVRvRGVsYXllZCA9IGZ1bmN0aW9uKHRpbWVzdGFtcCwgaWdub3JlTG9jaykge1xuICByZXR1cm4gc2NyaXB0cy5tb3ZlVG9EZWxheWVkKHRoaXMucXVldWUsIHRoaXMuaWQsIHRpbWVzdGFtcCwgaWdub3JlTG9jayk7XG59O1xuXG5Kb2IucHJvdG90eXBlLnByb21vdGUgPSBmdW5jdGlvbigpIHtcbiAgY29uc3QgcXVldWUgPSB0aGlzLnF1ZXVlO1xuICBjb25zdCBqb2JJZCA9IHRoaXMuaWQ7XG4gIHJldHVybiBxdWV1ZS5pc1JlYWR5KCkudGhlbigoKSA9PlxuICAgIHNjcmlwdHMucHJvbW90ZShxdWV1ZSwgam9iSWQpLnRoZW4ocmVzdWx0ID0+IHtcbiAgICAgIGlmIChyZXN1bHQgPT09IC0xKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignSm9iICcgKyBqb2JJZCArICcgaXMgbm90IGluIGEgZGVsYXllZCBzdGF0ZScpO1xuICAgICAgfVxuICAgIH0pXG4gICk7XG59O1xuXG4vKipcbiAqIEF0dGVtcHRzIHRvIHJldHJ5IHRoZSBqb2IuIE9ubHkgYSBqb2IgdGhhdCBoYXMgZmFpbGVkIGNhbiBiZSByZXRyaWVkLlxuICpcbiAqIEByZXR1cm4ge1Byb21pc2V9IElmIHJlc29sdmVkIGFuZCByZXR1cm4gY29kZSBpcyAxLCB0aGVuIHRoZSBxdWV1ZSBlbWl0cyBhIHdhaXRpbmcgZXZlbnRcbiAqIG90aGVyd2lzZSB0aGUgb3BlcmF0aW9uIHdhcyBub3QgYSBzdWNjZXNzIGFuZCB0aHJvdyB0aGUgY29ycmVzcG9uZGluZyBlcnJvci4gSWYgdGhlIHByb21pc2VcbiAqIHJlamVjdHMsIGl0IGluZGljYXRlcyB0aGF0IHRoZSBzY3JpcHQgZmFpbGVkIHRvIGV4ZWN1dGVcbiAqL1xuSm9iLnByb3RvdHlwZS5yZXRyeSA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gdGhpcy5xdWV1ZS5pc1JlYWR5KCkudGhlbigoKSA9PiB7XG4gICAgdGhpcy5mYWlsZWRSZWFzb24gPSBudWxsO1xuICAgIHRoaXMuZmluaXNoZWRPbiA9IG51bGw7XG4gICAgdGhpcy5wcm9jZXNzZWRPbiA9IG51bGw7XG4gICAgdGhpcy5yZXRyaWVkT24gPSBEYXRlLm5vdygpO1xuXG4gICAgcmV0dXJuIHNjcmlwdHMucmVwcm9jZXNzSm9iKHRoaXMsIHsgc3RhdGU6ICdmYWlsZWQnIH0pLnRoZW4ocmVzdWx0ID0+IHtcbiAgICAgIGlmIChyZXN1bHQgPT09IDEpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfSBlbHNlIGlmIChyZXN1bHQgPT09IDApIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGVycm9ycy5NZXNzYWdlcy5SRVRSWV9KT0JfTk9UX0VYSVNUKTtcbiAgICAgIH0gZWxzZSBpZiAocmVzdWx0ID09PSAtMSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoZXJyb3JzLk1lc3NhZ2VzLlJFVFJZX0pPQl9JU19MT0NLRUQpO1xuICAgICAgfSBlbHNlIGlmIChyZXN1bHQgPT09IC0yKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihlcnJvcnMuTWVzc2FnZXMuUkVUUllfSk9CX05PVF9GQUlMRUQpO1xuICAgICAgfVxuICAgIH0pO1xuICB9KTtcbn07XG5cbi8qKlxuICogTG9ncyBvbmUgcm93IG9mIGxvZyBkYXRhLlxuICpcbiAqIEBwYXJhbXMgbG9nUm93OiBzdHJpbmcgU3RyaW5nIHdpdGggbG9nIGRhdGEgdG8gYmUgbG9nZ2VkLlxuICpcbiAqL1xuSm9iLnByb3RvdHlwZS5sb2cgPSBmdW5jdGlvbihsb2dSb3cpIHtcbiAgcmV0dXJuIHNjcmlwdHMuYWRkTG9nKHRoaXMucXVldWUsIHRoaXMuaWQsIGxvZ1Jvdyk7XG59O1xuXG5Kb2IucHJvdG90eXBlLmlzQ29tcGxldGVkID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB0aGlzLl9pc0RvbmUoJ2NvbXBsZXRlZCcpO1xufTtcblxuSm9iLnByb3RvdHlwZS5pc0ZhaWxlZCA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gdGhpcy5faXNEb25lKCdmYWlsZWQnKTtcbn07XG5cbkpvYi5wcm90b3R5cGUuaXNEZWxheWVkID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB0aGlzLl9pc0RvbmUoJ2RlbGF5ZWQnKTtcbn07XG5cbkpvYi5wcm90b3R5cGUuaXNBY3RpdmUgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHRoaXMuX2lzSW5MaXN0KCdhY3RpdmUnKTtcbn07XG5cbkpvYi5wcm90b3R5cGUuaXNXYWl0aW5nID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB0aGlzLl9pc0luTGlzdCgnd2FpdCcpO1xufTtcblxuSm9iLnByb3RvdHlwZS5pc1BhdXNlZCA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gdGhpcy5faXNJbkxpc3QoJ3BhdXNlZCcpO1xufTtcblxuSm9iLnByb3RvdHlwZS5pc1N0dWNrID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB0aGlzLmdldFN0YXRlKCkudGhlbihzdGF0ZSA9PiB7XG4gICAgcmV0dXJuIHN0YXRlID09PSAnc3R1Y2snO1xuICB9KTtcbn07XG5cbkpvYi5wcm90b3R5cGUuaXNEaXNjYXJkZWQgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHRoaXMuX2Rpc2NhcmRlZDtcbn07XG5cbkpvYi5wcm90b3R5cGUuZ2V0U3RhdGUgPSBmdW5jdGlvbigpIHtcbiAgY29uc3QgZm5zID0gW1xuICAgIHsgZm46ICdpc0NvbXBsZXRlZCcsIHN0YXRlOiAnY29tcGxldGVkJyB9LFxuICAgIHsgZm46ICdpc0ZhaWxlZCcsIHN0YXRlOiAnZmFpbGVkJyB9LFxuICAgIHsgZm46ICdpc0RlbGF5ZWQnLCBzdGF0ZTogJ2RlbGF5ZWQnIH0sXG4gICAgeyBmbjogJ2lzQWN0aXZlJywgc3RhdGU6ICdhY3RpdmUnIH0sXG4gICAgeyBmbjogJ2lzV2FpdGluZycsIHN0YXRlOiAnd2FpdGluZycgfSxcbiAgICB7IGZuOiAnaXNQYXVzZWQnLCBzdGF0ZTogJ3BhdXNlZCcgfVxuICBdO1xuXG4gIHJldHVybiBmbnNcbiAgICAucmVkdWNlKChyZXN1bHQsIGZuKSA9PiB7XG4gICAgICByZXR1cm4gcmVzdWx0LnRoZW4oc3RhdGUgPT4ge1xuICAgICAgICBpZiAoc3RhdGUpIHtcbiAgICAgICAgICByZXR1cm4gc3RhdGU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXNbZm4uZm5dKCkudGhlbihyZXN1bHQgPT4ge1xuICAgICAgICAgIHJldHVybiByZXN1bHQgPyBmbi5zdGF0ZSA6IG51bGw7XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgfSwgUHJvbWlzZS5yZXNvbHZlKCkpXG4gICAgLnRoZW4ocmVzdWx0ID0+IHtcbiAgICAgIHJldHVybiByZXN1bHQgPyByZXN1bHQgOiAnc3R1Y2snO1xuICAgIH0pO1xufTtcblxuSm9iLnByb3RvdHlwZS5yZW1vdmUgPSBmdW5jdGlvbigpIHtcbiAgY29uc3QgcXVldWUgPSB0aGlzLnF1ZXVlO1xuICBjb25zdCBqb2IgPSB0aGlzO1xuXG4gIHJldHVybiBxdWV1ZS5pc1JlYWR5KCkudGhlbigoKSA9PiB7XG4gICAgcmV0dXJuIHNjcmlwdHMucmVtb3ZlKHF1ZXVlLCBqb2IuaWQpLnRoZW4ocmVtb3ZlZCA9PiB7XG4gICAgICBpZiAocmVtb3ZlZCkge1xuICAgICAgICBxdWV1ZS5lbWl0KCdyZW1vdmVkJywgam9iKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignQ291bGQgbm90IHJlbW92ZSBqb2IgJyArIGpvYi5pZCk7XG4gICAgICB9XG4gICAgfSk7XG4gIH0pO1xufTtcblxuLyoqXG4gKiBSZXR1cm5zIGEgcHJvbWlzZSB0aGUgcmVzb2x2ZXMgd2hlbiB0aGUgam9iIGhhcyBmaW5pc2hlZC4gKGNvbXBsZXRlZCBvciBmYWlsZWQpLlxuICovXG5Kb2IucHJvdG90eXBlLmZpbmlzaGVkID0gYXN5bmMgZnVuY3Rpb24oKSB7XG4gIGF3YWl0IFByb21pc2UuYWxsKFtcbiAgICB0aGlzLnF1ZXVlLl9yZWdpc3RlckV2ZW50KCdnbG9iYWw6Y29tcGxldGVkJyksXG4gICAgdGhpcy5xdWV1ZS5fcmVnaXN0ZXJFdmVudCgnZ2xvYmFsOmZhaWxlZCcpXG4gIF0pO1xuXG4gIGF3YWl0IHRoaXMucXVldWUuaXNSZWFkeSgpO1xuXG4gIGNvbnN0IHN0YXR1cyA9IGF3YWl0IHNjcmlwdHMuaXNGaW5pc2hlZCh0aGlzKTtcbiAgY29uc3QgZmluaXNoZWQgPSBzdGF0dXMgPiAwO1xuICBpZiAoZmluaXNoZWQpIHtcbiAgICBjb25zdCBqb2IgPSBhd2FpdCBKb2IuZnJvbUlkKHRoaXMucXVldWUsIHRoaXMuaWQpO1xuICAgIGlmIChzdGF0dXMgPT0gMikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGpvYi5mYWlsZWRSZWFzb24pO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gam9iLnJldHVybnZhbHVlO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgY29uc3Qgb25Db21wbGV0ZWQgPSAoam9iSWQsIHJlc3VsdFZhbHVlKSA9PiB7XG4gICAgICAgIGlmIChTdHJpbmcoam9iSWQpID09PSBTdHJpbmcodGhpcy5pZCkpIHtcbiAgICAgICAgICBsZXQgcmVzdWx0ID0gdm9pZCAwO1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIHJlc3VsdFZhbHVlID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICByZXN1bHQgPSBKU09OLnBhcnNlKHJlc3VsdFZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgIC8vc3dhbGxvdyBleGNlcHRpb24gYmVjYXVzZSB0aGUgcmVzdWx0VmFsdWUgZ290IGNvcnJ1cHRlZCBzb21laG93LlxuICAgICAgICAgICAgZGVidWdsb2coJ2NvcnJ1cHRlZCByZXN1bHRWYWx1ZTogJyArIHJlc3VsdFZhbHVlLCBlcnIpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXNvbHZlKHJlc3VsdCk7XG4gICAgICAgICAgcmVtb3ZlTGlzdGVuZXJzKCk7XG4gICAgICAgIH1cbiAgICAgIH07XG5cbiAgICAgIGNvbnN0IG9uRmFpbGVkID0gKGpvYklkLCBmYWlsZWRSZWFzb24pID0+IHtcbiAgICAgICAgaWYgKFN0cmluZyhqb2JJZCkgPT09IFN0cmluZyh0aGlzLmlkKSkge1xuICAgICAgICAgIHJlamVjdChuZXcgRXJyb3IoZmFpbGVkUmVhc29uKSk7XG4gICAgICAgICAgcmVtb3ZlTGlzdGVuZXJzKCk7XG4gICAgICAgIH1cbiAgICAgIH07XG5cbiAgICAgIHRoaXMucXVldWUub24oJ2dsb2JhbDpjb21wbGV0ZWQnLCBvbkNvbXBsZXRlZCk7XG4gICAgICB0aGlzLnF1ZXVlLm9uKCdnbG9iYWw6ZmFpbGVkJywgb25GYWlsZWQpO1xuXG4gICAgICBjb25zdCByZW1vdmVMaXN0ZW5lcnMgPSAoKSA9PiB7XG4gICAgICAgIGNsZWFySW50ZXJ2YWwoaW50ZXJ2YWwpO1xuICAgICAgICB0aGlzLnF1ZXVlLnJlbW92ZUxpc3RlbmVyKCdnbG9iYWw6Y29tcGxldGVkJywgb25Db21wbGV0ZWQpO1xuICAgICAgICB0aGlzLnF1ZXVlLnJlbW92ZUxpc3RlbmVyKCdnbG9iYWw6ZmFpbGVkJywgb25GYWlsZWQpO1xuICAgICAgfTtcblxuICAgICAgLy9cbiAgICAgIC8vIFdhdGNoZG9nXG4gICAgICAvL1xuICAgICAgY29uc3QgaW50ZXJ2YWwgPSBzZXRJbnRlcnZhbCgoKSA9PiB7XG4gICAgICAgIGlmICh0aGlzLl9pc1F1ZXVlQ2xvc2luZygpKSB7XG4gICAgICAgICAgcmVtb3ZlTGlzdGVuZXJzKCk7XG4gICAgICAgICAgLy8gVE9ETyhtYW5hc3QpIG1heWJlIHdlIHdvdWxkIG5lZWQgYSBtb3JlIGdyYWNlZnVsIHdheSB0byBnZXQgb3V0IG9mIHRoaXMgaW50ZXJ2YWwuXG4gICAgICAgICAgcmVqZWN0KFxuICAgICAgICAgICAgbmV3IEVycm9yKCdjYW5ub3QgY2hlY2sgaWYgam9iIGlzIGZpbmlzaGVkIGluIGEgY2xvc2luZyBxdWV1ZS4nKVxuICAgICAgICAgICk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgc2NyaXB0cy5pc0ZpbmlzaGVkKHRoaXMpLnRoZW4oc3RhdHVzID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGZpbmlzaGVkID0gc3RhdHVzID4gMDtcbiAgICAgICAgICAgIGlmIChmaW5pc2hlZCkge1xuICAgICAgICAgICAgICBKb2IuZnJvbUlkKHRoaXMucXVldWUsIHRoaXMuaWQpLnRoZW4oam9iID0+IHtcbiAgICAgICAgICAgICAgICByZW1vdmVMaXN0ZW5lcnMoKTtcbiAgICAgICAgICAgICAgICBpZiAoc3RhdHVzID09IDIpIHtcbiAgICAgICAgICAgICAgICAgIHJlamVjdChuZXcgRXJyb3Ioam9iLmZhaWxlZFJlYXNvbikpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICByZXNvbHZlKGpvYi5yZXR1cm52YWx1ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfSwgRklOSVNIRURfV0FUQ0hET0cpO1xuICAgIH0pO1xuICB9XG59O1xuXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuLy8gUHJpdmF0ZSBtZXRob2RzXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuSm9iLnByb3RvdHlwZS5faXNRdWV1ZUNsb3NpbmcgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHRoaXMucXVldWUuY2xvc2luZztcbn07XG5cbkpvYi5wcm90b3R5cGUuX2lzRG9uZSA9IGZ1bmN0aW9uKGxpc3QpIHtcbiAgcmV0dXJuIHRoaXMucXVldWUuY2xpZW50XG4gICAgLnpzY29yZSh0aGlzLnF1ZXVlLnRvS2V5KGxpc3QpLCB0aGlzLmlkKVxuICAgIC50aGVuKHNjb3JlID0+IHtcbiAgICAgIHJldHVybiBzY29yZSAhPT0gbnVsbDtcbiAgICB9KTtcbn07XG5cbkpvYi5wcm90b3R5cGUuX2lzSW5MaXN0ID0gZnVuY3Rpb24obGlzdCkge1xuICByZXR1cm4gc2NyaXB0cy5pc0pvYkluTGlzdChcbiAgICB0aGlzLnF1ZXVlLmNsaWVudCxcbiAgICB0aGlzLnF1ZXVlLnRvS2V5KGxpc3QpLFxuICAgIHRoaXMuaWRcbiAgKTtcbn07XG5cbkpvYi5wcm90b3R5cGUuX3NhdmVBdHRlbXB0ID0gZnVuY3Rpb24obXVsdGksIGVycikge1xuICB0aGlzLmF0dGVtcHRzTWFkZSsrO1xuXG4gIHRoaXMuc3RhY2t0cmFjZSA9IHRoaXMuc3RhY2t0cmFjZSB8fCBbXTtcblxuICBpZiAoZXJyICYmIGVyci5zdGFjaykge1xuICAgIHRoaXMuc3RhY2t0cmFjZS5wdXNoKGVyci5zdGFjayk7XG4gICAgaWYgKHRoaXMub3B0cy5zdGFja1RyYWNlTGltaXQpIHtcbiAgICAgIHRoaXMuc3RhY2t0cmFjZSA9IHRoaXMuc3RhY2t0cmFjZS5zbGljZSgtdGhpcy5vcHRzLnN0YWNrVHJhY2VMaW1pdCk7XG4gICAgfVxuICB9XG5cbiAgY29uc3QgYXJncyA9IHNjcmlwdHMuc2F2ZVN0YWNrdHJhY2VBcmdzKFxuICAgIHRoaXMsXG4gICAgSlNPTi5zdHJpbmdpZnkodGhpcy5zdGFja3RyYWNlKSxcbiAgICBlcnIgJiYgZXJyLm1lc3NhZ2UsXG4gICk7XG5cbiAgbXVsdGkuc2F2ZVN0YWNrdHJhY2UoYXJncyk7XG59O1xuXG5Kb2IuZnJvbUpTT04gPSBmdW5jdGlvbihxdWV1ZSwganNvbiwgam9iSWQpIHtcbiAgY29uc3Qgb3B0cyA9IEpTT04ucGFyc2UoanNvbi5vcHRzIHx8ICd7fScpO1xuICBjb25zdCBkYXRhID0gb3B0cy5wcmV2ZW50UGFyc2luZ0RhdGFcbiAgICA/IGpzb24uZGF0YVxuICAgIDogSlNPTi5wYXJzZShqc29uLmRhdGEgfHwgJ3t9Jyk7XG5cbiAgY29uc3Qgam9iID0gbmV3IEpvYihxdWV1ZSwganNvbi5uYW1lIHx8IEpvYi5ERUZBVUxUX0pPQl9OQU1FLCBkYXRhLCBvcHRzKTtcblxuICBqb2IuaWQgPSBqc29uLmlkIHx8IGpvYklkO1xuXG4gIHRyeSB7XG4gICAgam9iLl9wcm9ncmVzcyA9IEpTT04ucGFyc2UoanNvbi5wcm9ncmVzcyB8fCAwKTtcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgY29uc29sZS5lcnJvcihcbiAgICAgIGBFcnJvciBwYXJzaW5nIHByb2dyZXNzICR7anNvbi5wcm9ncmVzc30gd2l0aCAke2Vyci5tZXNzYWdlfWBcbiAgICApO1xuICB9XG5cbiAgam9iLmRlbGF5ID0gcGFyc2VJbnQoanNvbi5kZWxheSk7XG4gIGpvYi50aW1lc3RhbXAgPSBwYXJzZUludChqc29uLnRpbWVzdGFtcCk7XG4gIGlmIChqc29uLmZpbmlzaGVkT24pIHtcbiAgICBqb2IuZmluaXNoZWRPbiA9IHBhcnNlSW50KGpzb24uZmluaXNoZWRPbik7XG4gIH1cblxuICBpZiAoanNvbi5wcm9jZXNzZWRPbikge1xuICAgIGpvYi5wcm9jZXNzZWRPbiA9IHBhcnNlSW50KGpzb24ucHJvY2Vzc2VkT24pO1xuICB9XG5cbiAgaWYgKGpzb24ucmV0cmllZE9uKSB7XG4gICAgam9iLnJldHJpZWRPbiA9IHBhcnNlSW50KGpzb24ucmV0cmllZE9uKTtcbiAgfVxuXG4gIGpvYi5mYWlsZWRSZWFzb24gPSBqc29uLmZhaWxlZFJlYXNvbjtcbiAgam9iLmF0dGVtcHRzTWFkZSA9IHBhcnNlSW50KGpzb24uYXR0ZW1wdHNNYWRlIHx8IDApO1xuXG4gIGpvYi5zdGFja3RyYWNlID0gZ2V0VHJhY2VzKGpzb24uc3RhY2t0cmFjZSk7XG5cbiAgaWYgKHR5cGVvZiBqc29uLnJldHVybnZhbHVlID09PSAnc3RyaW5nJykge1xuICAgIGpvYi5yZXR1cm52YWx1ZSA9IGdldFJldHVyblZhbHVlKGpzb24ucmV0dXJudmFsdWUpO1xuICB9XG5cbiAgaWYgKGpzb24uZGVpZCkge1xuICAgIGpvYi5kZWJvdW5jZUlkID0ganNvbi5kZWlkO1xuICB9XG5cbiAgcmV0dXJuIGpvYjtcbn07XG5cbmZ1bmN0aW9uIGdldFRyYWNlcyhzdGFja3RyYWNlKSB7XG4gIGNvbnN0IF90cmFjZXMgPSB1dGlscy50cnlDYXRjaChKU09OLnBhcnNlLCBKU09OLCBbc3RhY2t0cmFjZV0pO1xuXG4gIGlmIChfdHJhY2VzID09PSB1dGlscy5lcnJvck9iamVjdCB8fCAhKF90cmFjZXMgaW5zdGFuY2VvZiBBcnJheSkpIHtcbiAgICByZXR1cm4gW107XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIF90cmFjZXM7XG4gIH1cbn1cblxuZnVuY3Rpb24gZ2V0UmV0dXJuVmFsdWUoX3ZhbHVlKSB7XG4gIGNvbnN0IHZhbHVlID0gdXRpbHMudHJ5Q2F0Y2goSlNPTi5wYXJzZSwgSlNPTiwgW192YWx1ZV0pO1xuICBpZiAodmFsdWUgIT09IHV0aWxzLmVycm9yT2JqZWN0KSB7XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9IGVsc2Uge1xuICAgIGRlYnVnbG9nKCdjb3JydXB0ZWQgcmV0dXJudmFsdWU6ICcgKyBfdmFsdWUsIHZhbHVlKTtcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IEpvYjtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/bull/lib/job.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/bull/lib/p-timeout.js":
/*!********************************************!*\
  !*** ./node_modules/bull/lib/p-timeout.js ***!
  \********************************************/
/***/ ((module) => {

eval("// Extracted from p-timeout https://github.com/sindresorhus/p-timeout\n// as it is not commonjs compatible. This is version 5.0.2\n\n\nclass TimeoutError extends Error {\n  constructor(message) {\n    super(message);\n    this.name = 'TimeoutError';\n  }\n}\n\nmodule.exports.TimeoutError = TimeoutError;\n\nmodule.exports.pTimeout = function pTimeout(\n  promise,\n  milliseconds,\n  fallback,\n  options\n) {\n  let timer;\n  const cancelablePromise = new Promise((resolve, reject) => {\n    if (typeof milliseconds !== 'number' || Math.sign(milliseconds) !== 1) {\n      throw new TypeError(\n        `Expected \\`milliseconds\\` to be a positive number, got \\`${milliseconds}\\``\n      );\n    }\n\n    if (milliseconds === Number.POSITIVE_INFINITY) {\n      resolve(promise);\n      return;\n    }\n\n    options = {\n      customTimers: { setTimeout, clearTimeout },\n      ...options\n    };\n\n    timer = options.customTimers.setTimeout.call(\n      undefined,\n      () => {\n        if (typeof fallback === 'function') {\n          try {\n            resolve(fallback());\n          } catch (error) {\n            reject(error);\n          }\n\n          return;\n        }\n\n        const message =\n          typeof fallback === 'string'\n            ? fallback\n            : `Promise timed out after ${milliseconds} milliseconds`;\n        const timeoutError =\n          fallback instanceof Error ? fallback : new TimeoutError(message);\n\n        if (typeof promise.cancel === 'function') {\n          promise.cancel();\n        }\n\n        reject(timeoutError);\n      },\n      milliseconds\n    );\n\n    (async () => {\n      try {\n        resolve(await promise);\n      } catch (error) {\n        reject(error);\n      } finally {\n        options.customTimers.clearTimeout.call(undefined, timer);\n      }\n    })();\n  });\n\n  cancelablePromise['clear'] = () => {\n    clearTimeout(timer);\n    timer = undefined;\n  };\n\n  return cancelablePromise;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvYnVsbC9saWIvcC10aW1lb3V0LmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDYTs7QUFFYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsMkJBQTJCOztBQUUzQix1QkFBdUI7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0VBQW9FLGFBQWE7QUFDakY7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHNCQUFzQiwwQkFBMEI7QUFDaEQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QyxjQUFjO0FBQ3ZEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbXktYXBwLy4vbm9kZV9tb2R1bGVzL2J1bGwvbGliL3AtdGltZW91dC5qcz82MGEzIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIEV4dHJhY3RlZCBmcm9tIHAtdGltZW91dCBodHRwczovL2dpdGh1Yi5jb20vc2luZHJlc29yaHVzL3AtdGltZW91dFxuLy8gYXMgaXQgaXMgbm90IGNvbW1vbmpzIGNvbXBhdGlibGUuIFRoaXMgaXMgdmVyc2lvbiA1LjAuMlxuJ3VzZSBzdHJpY3QnO1xuXG5jbGFzcyBUaW1lb3V0RXJyb3IgZXh0ZW5kcyBFcnJvciB7XG4gIGNvbnN0cnVjdG9yKG1lc3NhZ2UpIHtcbiAgICBzdXBlcihtZXNzYWdlKTtcbiAgICB0aGlzLm5hbWUgPSAnVGltZW91dEVycm9yJztcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cy5UaW1lb3V0RXJyb3IgPSBUaW1lb3V0RXJyb3I7XG5cbm1vZHVsZS5leHBvcnRzLnBUaW1lb3V0ID0gZnVuY3Rpb24gcFRpbWVvdXQoXG4gIHByb21pc2UsXG4gIG1pbGxpc2Vjb25kcyxcbiAgZmFsbGJhY2ssXG4gIG9wdGlvbnNcbikge1xuICBsZXQgdGltZXI7XG4gIGNvbnN0IGNhbmNlbGFibGVQcm9taXNlID0gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgIGlmICh0eXBlb2YgbWlsbGlzZWNvbmRzICE9PSAnbnVtYmVyJyB8fCBNYXRoLnNpZ24obWlsbGlzZWNvbmRzKSAhPT0gMSkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcbiAgICAgICAgYEV4cGVjdGVkIFxcYG1pbGxpc2Vjb25kc1xcYCB0byBiZSBhIHBvc2l0aXZlIG51bWJlciwgZ290IFxcYCR7bWlsbGlzZWNvbmRzfVxcYGBcbiAgICAgICk7XG4gICAgfVxuXG4gICAgaWYgKG1pbGxpc2Vjb25kcyA9PT0gTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZKSB7XG4gICAgICByZXNvbHZlKHByb21pc2UpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIG9wdGlvbnMgPSB7XG4gICAgICBjdXN0b21UaW1lcnM6IHsgc2V0VGltZW91dCwgY2xlYXJUaW1lb3V0IH0sXG4gICAgICAuLi5vcHRpb25zXG4gICAgfTtcblxuICAgIHRpbWVyID0gb3B0aW9ucy5jdXN0b21UaW1lcnMuc2V0VGltZW91dC5jYWxsKFxuICAgICAgdW5kZWZpbmVkLFxuICAgICAgKCkgPT4ge1xuICAgICAgICBpZiAodHlwZW9mIGZhbGxiYWNrID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJlc29sdmUoZmFsbGJhY2soKSk7XG4gICAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIHJlamVjdChlcnJvcik7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgbWVzc2FnZSA9XG4gICAgICAgICAgdHlwZW9mIGZhbGxiYWNrID09PSAnc3RyaW5nJ1xuICAgICAgICAgICAgPyBmYWxsYmFja1xuICAgICAgICAgICAgOiBgUHJvbWlzZSB0aW1lZCBvdXQgYWZ0ZXIgJHttaWxsaXNlY29uZHN9IG1pbGxpc2Vjb25kc2A7XG4gICAgICAgIGNvbnN0IHRpbWVvdXRFcnJvciA9XG4gICAgICAgICAgZmFsbGJhY2sgaW5zdGFuY2VvZiBFcnJvciA/IGZhbGxiYWNrIDogbmV3IFRpbWVvdXRFcnJvcihtZXNzYWdlKTtcblxuICAgICAgICBpZiAodHlwZW9mIHByb21pc2UuY2FuY2VsID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgcHJvbWlzZS5jYW5jZWwoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJlamVjdCh0aW1lb3V0RXJyb3IpO1xuICAgICAgfSxcbiAgICAgIG1pbGxpc2Vjb25kc1xuICAgICk7XG5cbiAgICAoYXN5bmMgKCkgPT4ge1xuICAgICAgdHJ5IHtcbiAgICAgICAgcmVzb2x2ZShhd2FpdCBwcm9taXNlKTtcbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIHJlamVjdChlcnJvcik7XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICBvcHRpb25zLmN1c3RvbVRpbWVycy5jbGVhclRpbWVvdXQuY2FsbCh1bmRlZmluZWQsIHRpbWVyKTtcbiAgICAgIH1cbiAgICB9KSgpO1xuICB9KTtcblxuICBjYW5jZWxhYmxlUHJvbWlzZVsnY2xlYXInXSA9ICgpID0+IHtcbiAgICBjbGVhclRpbWVvdXQodGltZXIpO1xuICAgIHRpbWVyID0gdW5kZWZpbmVkO1xuICB9O1xuXG4gIHJldHVybiBjYW5jZWxhYmxlUHJvbWlzZTtcbn07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/bull/lib/p-timeout.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/bull/lib/process/child-pool.js":
/*!*****************************************************!*\
  !*** ./node_modules/bull/lib/process/child-pool.js ***!
  \*****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\n\nconst fork = (__webpack_require__(/*! child_process */ \"child_process\").fork);\nconst path = __webpack_require__(/*! path */ \"path\");\nconst _ = __webpack_require__(/*! lodash */ \"(rsc)/./node_modules/lodash/lodash.js\");\nconst getPort = __webpack_require__(/*! get-port */ \"(rsc)/./node_modules/get-port/index.js\");\nconst { killAsync } = __webpack_require__(/*! ./utils */ \"(rsc)/./node_modules/bull/lib/process/utils.js\");\n\nconst CHILD_KILL_TIMEOUT = 30000;\n\nconst ChildPool = function ChildPool() {\n  if (!(this instanceof ChildPool)) {\n    return new ChildPool();\n  }\n\n  this.retained = {};\n  this.free = {};\n};\n\nconst convertExecArgv = function(execArgv) {\n  const standard = [];\n  const promises = [];\n\n  _.forEach(execArgv, arg => {\n    if (arg.indexOf('--inspect') === -1) {\n      standard.push(arg);\n    } else {\n      const argName = arg.split('=')[0];\n      promises.push(\n        getPort().then(port => {\n          return `${argName}=${port}`;\n        })\n      );\n    }\n  });\n\n  return Promise.all(promises).then(convertedArgs => {\n    return standard.concat(convertedArgs);\n  });\n};\n\nChildPool.prototype.retain = function(processFile) {\n  const _this = this;\n  let child = _this.getFree(processFile).pop();\n\n  if (child) {\n    _this.retained[child.pid] = child;\n    return Promise.resolve(child);\n  }\n\n  return convertExecArgv(process.execArgv).then(execArgv => {\n    child = fork(path.join(__dirname, './master.js'), {\n      execArgv\n    });\n    child.processFile = processFile;\n\n    _this.retained[child.pid] = child;\n\n    child.on('exit', _this.remove.bind(_this, child));\n\n    return initChild(child, child.processFile)\n      .then(() => {\n        return child;\n      })\n      .catch(err => {\n        this.remove(child);\n        throw err;\n      });\n  });\n};\n\nChildPool.prototype.release = function(child) {\n  delete this.retained[child.pid];\n  this.getFree(child.processFile).push(child);\n};\n\nChildPool.prototype.remove = function(child) {\n  delete this.retained[child.pid];\n\n  const free = this.getFree(child.processFile);\n\n  const childIndex = free.indexOf(child);\n  if (childIndex > -1) {\n    free.splice(childIndex, 1);\n  }\n};\n\nChildPool.prototype.kill = function(child, signal) {\n  this.remove(child);\n  return killAsync(child, signal || 'SIGKILL', CHILD_KILL_TIMEOUT);\n};\n\nChildPool.prototype.clean = function() {\n  const children = _.values(this.retained).concat(this.getAllFree());\n  this.retained = {};\n  this.free = {};\n\n  const allKillPromises = [];\n  children.forEach(child => {\n    allKillPromises.push(this.kill(child, 'SIGTERM'));\n  });\n  return Promise.all(allKillPromises).then(() => {});\n};\n\nChildPool.prototype.getFree = function(id) {\n  return (this.free[id] = this.free[id] || []);\n};\n\nChildPool.prototype.getAllFree = function() {\n  return _.flatten(_.values(this.free));\n};\n\nasync function initChild(child, processFile) {\n  const onComplete = new Promise((resolve, reject) => {\n    const onMessageHandler = msg => {\n      if (msg.cmd === 'init-complete') {\n        resolve();\n      } else if (msg.cmd === 'error') {\n        reject(msg.error);\n      }\n      child.off('message', onMessageHandler);\n    };\n    child.on('message', onMessageHandler);\n  });\n\n  await new Promise(resolve =>\n    child.send({ cmd: 'init', value: processFile }, resolve)\n  );\n  await onComplete;\n}\nfunction ChildPoolSingleton(isSharedChildPool = false) {\n  if (isSharedChildPool === false) {\n    return new ChildPool();\n  } else if (\n    !(this instanceof ChildPool) &&\n    ChildPoolSingleton.instance === undefined\n  ) {\n    ChildPoolSingleton.instance = new ChildPool();\n  }\n\n  return ChildPoolSingleton.instance;\n}\n\nmodule.exports = ChildPoolSingleton;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvYnVsbC9saWIvcHJvY2Vzcy9jaGlsZC1wb29sLmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViLGFBQWEsZ0VBQTZCO0FBQzFDLGFBQWEsbUJBQU8sQ0FBQyxrQkFBTTtBQUMzQixVQUFVLG1CQUFPLENBQUMscURBQVE7QUFDMUIsZ0JBQWdCLG1CQUFPLENBQUMsd0RBQVU7QUFDbEMsUUFBUSxZQUFZLEVBQUUsbUJBQU8sQ0FBQywrREFBUzs7QUFFdkM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFFBQVEsR0FBRyxLQUFLO0FBQ3BDLFNBQVM7QUFDVDtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxtREFBbUQ7QUFDbkQ7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0EsaUJBQWlCLGlDQUFpQztBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbXktYXBwLy4vbm9kZV9tb2R1bGVzL2J1bGwvbGliL3Byb2Nlc3MvY2hpbGQtcG9vbC5qcz8wOGUxIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuY29uc3QgZm9yayA9IHJlcXVpcmUoJ2NoaWxkX3Byb2Nlc3MnKS5mb3JrO1xuY29uc3QgcGF0aCA9IHJlcXVpcmUoJ3BhdGgnKTtcbmNvbnN0IF8gPSByZXF1aXJlKCdsb2Rhc2gnKTtcbmNvbnN0IGdldFBvcnQgPSByZXF1aXJlKCdnZXQtcG9ydCcpO1xuY29uc3QgeyBraWxsQXN5bmMgfSA9IHJlcXVpcmUoJy4vdXRpbHMnKTtcblxuY29uc3QgQ0hJTERfS0lMTF9USU1FT1VUID0gMzAwMDA7XG5cbmNvbnN0IENoaWxkUG9vbCA9IGZ1bmN0aW9uIENoaWxkUG9vbCgpIHtcbiAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIENoaWxkUG9vbCkpIHtcbiAgICByZXR1cm4gbmV3IENoaWxkUG9vbCgpO1xuICB9XG5cbiAgdGhpcy5yZXRhaW5lZCA9IHt9O1xuICB0aGlzLmZyZWUgPSB7fTtcbn07XG5cbmNvbnN0IGNvbnZlcnRFeGVjQXJndiA9IGZ1bmN0aW9uKGV4ZWNBcmd2KSB7XG4gIGNvbnN0IHN0YW5kYXJkID0gW107XG4gIGNvbnN0IHByb21pc2VzID0gW107XG5cbiAgXy5mb3JFYWNoKGV4ZWNBcmd2LCBhcmcgPT4ge1xuICAgIGlmIChhcmcuaW5kZXhPZignLS1pbnNwZWN0JykgPT09IC0xKSB7XG4gICAgICBzdGFuZGFyZC5wdXNoKGFyZyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IGFyZ05hbWUgPSBhcmcuc3BsaXQoJz0nKVswXTtcbiAgICAgIHByb21pc2VzLnB1c2goXG4gICAgICAgIGdldFBvcnQoKS50aGVuKHBvcnQgPT4ge1xuICAgICAgICAgIHJldHVybiBgJHthcmdOYW1lfT0ke3BvcnR9YDtcbiAgICAgICAgfSlcbiAgICAgICk7XG4gICAgfVxuICB9KTtcblxuICByZXR1cm4gUHJvbWlzZS5hbGwocHJvbWlzZXMpLnRoZW4oY29udmVydGVkQXJncyA9PiB7XG4gICAgcmV0dXJuIHN0YW5kYXJkLmNvbmNhdChjb252ZXJ0ZWRBcmdzKTtcbiAgfSk7XG59O1xuXG5DaGlsZFBvb2wucHJvdG90eXBlLnJldGFpbiA9IGZ1bmN0aW9uKHByb2Nlc3NGaWxlKSB7XG4gIGNvbnN0IF90aGlzID0gdGhpcztcbiAgbGV0IGNoaWxkID0gX3RoaXMuZ2V0RnJlZShwcm9jZXNzRmlsZSkucG9wKCk7XG5cbiAgaWYgKGNoaWxkKSB7XG4gICAgX3RoaXMucmV0YWluZWRbY2hpbGQucGlkXSA9IGNoaWxkO1xuICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoY2hpbGQpO1xuICB9XG5cbiAgcmV0dXJuIGNvbnZlcnRFeGVjQXJndihwcm9jZXNzLmV4ZWNBcmd2KS50aGVuKGV4ZWNBcmd2ID0+IHtcbiAgICBjaGlsZCA9IGZvcmsocGF0aC5qb2luKF9fZGlybmFtZSwgJy4vbWFzdGVyLmpzJyksIHtcbiAgICAgIGV4ZWNBcmd2XG4gICAgfSk7XG4gICAgY2hpbGQucHJvY2Vzc0ZpbGUgPSBwcm9jZXNzRmlsZTtcblxuICAgIF90aGlzLnJldGFpbmVkW2NoaWxkLnBpZF0gPSBjaGlsZDtcblxuICAgIGNoaWxkLm9uKCdleGl0JywgX3RoaXMucmVtb3ZlLmJpbmQoX3RoaXMsIGNoaWxkKSk7XG5cbiAgICByZXR1cm4gaW5pdENoaWxkKGNoaWxkLCBjaGlsZC5wcm9jZXNzRmlsZSlcbiAgICAgIC50aGVuKCgpID0+IHtcbiAgICAgICAgcmV0dXJuIGNoaWxkO1xuICAgICAgfSlcbiAgICAgIC5jYXRjaChlcnIgPT4ge1xuICAgICAgICB0aGlzLnJlbW92ZShjaGlsZCk7XG4gICAgICAgIHRocm93IGVycjtcbiAgICAgIH0pO1xuICB9KTtcbn07XG5cbkNoaWxkUG9vbC5wcm90b3R5cGUucmVsZWFzZSA9IGZ1bmN0aW9uKGNoaWxkKSB7XG4gIGRlbGV0ZSB0aGlzLnJldGFpbmVkW2NoaWxkLnBpZF07XG4gIHRoaXMuZ2V0RnJlZShjaGlsZC5wcm9jZXNzRmlsZSkucHVzaChjaGlsZCk7XG59O1xuXG5DaGlsZFBvb2wucHJvdG90eXBlLnJlbW92ZSA9IGZ1bmN0aW9uKGNoaWxkKSB7XG4gIGRlbGV0ZSB0aGlzLnJldGFpbmVkW2NoaWxkLnBpZF07XG5cbiAgY29uc3QgZnJlZSA9IHRoaXMuZ2V0RnJlZShjaGlsZC5wcm9jZXNzRmlsZSk7XG5cbiAgY29uc3QgY2hpbGRJbmRleCA9IGZyZWUuaW5kZXhPZihjaGlsZCk7XG4gIGlmIChjaGlsZEluZGV4ID4gLTEpIHtcbiAgICBmcmVlLnNwbGljZShjaGlsZEluZGV4LCAxKTtcbiAgfVxufTtcblxuQ2hpbGRQb29sLnByb3RvdHlwZS5raWxsID0gZnVuY3Rpb24oY2hpbGQsIHNpZ25hbCkge1xuICB0aGlzLnJlbW92ZShjaGlsZCk7XG4gIHJldHVybiBraWxsQXN5bmMoY2hpbGQsIHNpZ25hbCB8fCAnU0lHS0lMTCcsIENISUxEX0tJTExfVElNRU9VVCk7XG59O1xuXG5DaGlsZFBvb2wucHJvdG90eXBlLmNsZWFuID0gZnVuY3Rpb24oKSB7XG4gIGNvbnN0IGNoaWxkcmVuID0gXy52YWx1ZXModGhpcy5yZXRhaW5lZCkuY29uY2F0KHRoaXMuZ2V0QWxsRnJlZSgpKTtcbiAgdGhpcy5yZXRhaW5lZCA9IHt9O1xuICB0aGlzLmZyZWUgPSB7fTtcblxuICBjb25zdCBhbGxLaWxsUHJvbWlzZXMgPSBbXTtcbiAgY2hpbGRyZW4uZm9yRWFjaChjaGlsZCA9PiB7XG4gICAgYWxsS2lsbFByb21pc2VzLnB1c2godGhpcy5raWxsKGNoaWxkLCAnU0lHVEVSTScpKTtcbiAgfSk7XG4gIHJldHVybiBQcm9taXNlLmFsbChhbGxLaWxsUHJvbWlzZXMpLnRoZW4oKCkgPT4ge30pO1xufTtcblxuQ2hpbGRQb29sLnByb3RvdHlwZS5nZXRGcmVlID0gZnVuY3Rpb24oaWQpIHtcbiAgcmV0dXJuICh0aGlzLmZyZWVbaWRdID0gdGhpcy5mcmVlW2lkXSB8fCBbXSk7XG59O1xuXG5DaGlsZFBvb2wucHJvdG90eXBlLmdldEFsbEZyZWUgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIF8uZmxhdHRlbihfLnZhbHVlcyh0aGlzLmZyZWUpKTtcbn07XG5cbmFzeW5jIGZ1bmN0aW9uIGluaXRDaGlsZChjaGlsZCwgcHJvY2Vzc0ZpbGUpIHtcbiAgY29uc3Qgb25Db21wbGV0ZSA9IG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICBjb25zdCBvbk1lc3NhZ2VIYW5kbGVyID0gbXNnID0+IHtcbiAgICAgIGlmIChtc2cuY21kID09PSAnaW5pdC1jb21wbGV0ZScpIHtcbiAgICAgICAgcmVzb2x2ZSgpO1xuICAgICAgfSBlbHNlIGlmIChtc2cuY21kID09PSAnZXJyb3InKSB7XG4gICAgICAgIHJlamVjdChtc2cuZXJyb3IpO1xuICAgICAgfVxuICAgICAgY2hpbGQub2ZmKCdtZXNzYWdlJywgb25NZXNzYWdlSGFuZGxlcik7XG4gICAgfTtcbiAgICBjaGlsZC5vbignbWVzc2FnZScsIG9uTWVzc2FnZUhhbmRsZXIpO1xuICB9KTtcblxuICBhd2FpdCBuZXcgUHJvbWlzZShyZXNvbHZlID0+XG4gICAgY2hpbGQuc2VuZCh7IGNtZDogJ2luaXQnLCB2YWx1ZTogcHJvY2Vzc0ZpbGUgfSwgcmVzb2x2ZSlcbiAgKTtcbiAgYXdhaXQgb25Db21wbGV0ZTtcbn1cbmZ1bmN0aW9uIENoaWxkUG9vbFNpbmdsZXRvbihpc1NoYXJlZENoaWxkUG9vbCA9IGZhbHNlKSB7XG4gIGlmIChpc1NoYXJlZENoaWxkUG9vbCA9PT0gZmFsc2UpIHtcbiAgICByZXR1cm4gbmV3IENoaWxkUG9vbCgpO1xuICB9IGVsc2UgaWYgKFxuICAgICEodGhpcyBpbnN0YW5jZW9mIENoaWxkUG9vbCkgJiZcbiAgICBDaGlsZFBvb2xTaW5nbGV0b24uaW5zdGFuY2UgPT09IHVuZGVmaW5lZFxuICApIHtcbiAgICBDaGlsZFBvb2xTaW5nbGV0b24uaW5zdGFuY2UgPSBuZXcgQ2hpbGRQb29sKCk7XG4gIH1cblxuICByZXR1cm4gQ2hpbGRQb29sU2luZ2xldG9uLmluc3RhbmNlO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IENoaWxkUG9vbFNpbmdsZXRvbjtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/bull/lib/process/child-pool.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/bull/lib/process/sandbox.js":
/*!**************************************************!*\
  !*** ./node_modules/bull/lib/process/sandbox.js ***!
  \**************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\n\nconst { asyncSend } = __webpack_require__(/*! ./utils */ \"(rsc)/./node_modules/bull/lib/process/utils.js\");\n\nmodule.exports = function(processFile, childPool) {\n  return function process(job) {\n    return childPool.retain(processFile).then(async child => {\n      let msgHandler;\n      let exitHandler;\n\n      await asyncSend(child, {\n        cmd: 'start',\n        job: job\n      });\n\n      const done = new Promise((resolve, reject) => {\n        msgHandler = function(msg) {\n          switch (msg.cmd) {\n            case 'completed':\n              resolve(msg.value);\n              break;\n            case 'failed':\n            case 'error': {\n              const err = new Error();\n              Object.assign(err, msg.value);\n              reject(err);\n              break;\n            }\n            case 'progress':\n              job.progress(msg.value);\n              break;\n            case 'update':\n              job.update(msg.value);\n              break;\n            case 'discard':\n              job.discard();\n              break;\n            case 'log':\n              job.log(msg.value);\n              break;\n          }\n        };\n\n        exitHandler = (exitCode, signal) => {\n          reject(\n            new Error(\n              'Unexpected exit code: ' + exitCode + ' signal: ' + signal\n            )\n          );\n        };\n\n        child.on('message', msgHandler);\n        child.on('exit', exitHandler);\n      });\n\n      return done.finally(() => {\n        child.removeListener('message', msgHandler);\n        child.removeListener('exit', exitHandler);\n\n        if (child.exitCode !== null || /SIG.*/.test(child.signalCode)) {\n          childPool.remove(child);\n        } else {\n          childPool.release(child);\n        }\n      });\n    });\n  };\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvYnVsbC9saWIvcHJvY2Vzcy9zYW5kYm94LmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViLFFBQVEsWUFBWSxFQUFFLG1CQUFPLENBQUMsK0RBQVM7O0FBRXZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE9BQU87O0FBRVA7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL215LWFwcC8uL25vZGVfbW9kdWxlcy9idWxsL2xpYi9wcm9jZXNzL3NhbmRib3guanM/MDE3ZSJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbmNvbnN0IHsgYXN5bmNTZW5kIH0gPSByZXF1aXJlKCcuL3V0aWxzJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24ocHJvY2Vzc0ZpbGUsIGNoaWxkUG9vbCkge1xuICByZXR1cm4gZnVuY3Rpb24gcHJvY2Vzcyhqb2IpIHtcbiAgICByZXR1cm4gY2hpbGRQb29sLnJldGFpbihwcm9jZXNzRmlsZSkudGhlbihhc3luYyBjaGlsZCA9PiB7XG4gICAgICBsZXQgbXNnSGFuZGxlcjtcbiAgICAgIGxldCBleGl0SGFuZGxlcjtcblxuICAgICAgYXdhaXQgYXN5bmNTZW5kKGNoaWxkLCB7XG4gICAgICAgIGNtZDogJ3N0YXJ0JyxcbiAgICAgICAgam9iOiBqb2JcbiAgICAgIH0pO1xuXG4gICAgICBjb25zdCBkb25lID0gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICBtc2dIYW5kbGVyID0gZnVuY3Rpb24obXNnKSB7XG4gICAgICAgICAgc3dpdGNoIChtc2cuY21kKSB7XG4gICAgICAgICAgICBjYXNlICdjb21wbGV0ZWQnOlxuICAgICAgICAgICAgICByZXNvbHZlKG1zZy52YWx1ZSk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnZmFpbGVkJzpcbiAgICAgICAgICAgIGNhc2UgJ2Vycm9yJzoge1xuICAgICAgICAgICAgICBjb25zdCBlcnIgPSBuZXcgRXJyb3IoKTtcbiAgICAgICAgICAgICAgT2JqZWN0LmFzc2lnbihlcnIsIG1zZy52YWx1ZSk7XG4gICAgICAgICAgICAgIHJlamVjdChlcnIpO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2UgJ3Byb2dyZXNzJzpcbiAgICAgICAgICAgICAgam9iLnByb2dyZXNzKG1zZy52YWx1ZSk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAndXBkYXRlJzpcbiAgICAgICAgICAgICAgam9iLnVwZGF0ZShtc2cudmFsdWUpO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ2Rpc2NhcmQnOlxuICAgICAgICAgICAgICBqb2IuZGlzY2FyZCgpO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ2xvZyc6XG4gICAgICAgICAgICAgIGpvYi5sb2cobXNnLnZhbHVlKTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9O1xuXG4gICAgICAgIGV4aXRIYW5kbGVyID0gKGV4aXRDb2RlLCBzaWduYWwpID0+IHtcbiAgICAgICAgICByZWplY3QoXG4gICAgICAgICAgICBuZXcgRXJyb3IoXG4gICAgICAgICAgICAgICdVbmV4cGVjdGVkIGV4aXQgY29kZTogJyArIGV4aXRDb2RlICsgJyBzaWduYWw6ICcgKyBzaWduYWxcbiAgICAgICAgICAgIClcbiAgICAgICAgICApO1xuICAgICAgICB9O1xuXG4gICAgICAgIGNoaWxkLm9uKCdtZXNzYWdlJywgbXNnSGFuZGxlcik7XG4gICAgICAgIGNoaWxkLm9uKCdleGl0JywgZXhpdEhhbmRsZXIpO1xuICAgICAgfSk7XG5cbiAgICAgIHJldHVybiBkb25lLmZpbmFsbHkoKCkgPT4ge1xuICAgICAgICBjaGlsZC5yZW1vdmVMaXN0ZW5lcignbWVzc2FnZScsIG1zZ0hhbmRsZXIpO1xuICAgICAgICBjaGlsZC5yZW1vdmVMaXN0ZW5lcignZXhpdCcsIGV4aXRIYW5kbGVyKTtcblxuICAgICAgICBpZiAoY2hpbGQuZXhpdENvZGUgIT09IG51bGwgfHwgL1NJRy4qLy50ZXN0KGNoaWxkLnNpZ25hbENvZGUpKSB7XG4gICAgICAgICAgY2hpbGRQb29sLnJlbW92ZShjaGlsZCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY2hpbGRQb29sLnJlbGVhc2UoY2hpbGQpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfTtcbn07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/bull/lib/process/sandbox.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/bull/lib/process/utils.js":
/*!************************************************!*\
  !*** ./node_modules/bull/lib/process/utils.js ***!
  \************************************************/
/***/ ((module) => {

eval("\n\nfunction hasProcessExited(child) {\n  return !!(child.exitCode !== null || child.signalCode);\n}\n\nfunction onExitOnce(child) {\n  return new Promise(resolve => {\n    child.once('exit', () => resolve());\n  });\n}\n\n/**\n * Sends a kill signal to a child resolving when the child has exited,\n * resorting to SIGKILL if the given timeout is reached\n *\n * @param {ChildProcess} child\n * @param {'SIGTERM' | 'SIGKILL'} [signal] initial signal to use\n * @param {number} [timeoutMs] time to wait until sending SIGKILL\n *\n * @returns {Promise<void>} the killed child\n */\nfunction killAsync(child, signal, timeoutMs) {\n  if (hasProcessExited(child)) {\n    return Promise.resolve(child);\n  }\n\n  // catch any new on exit\n  let onExit = onExitOnce(child);\n\n  child.kill(signal || 'SIGKILL');\n\n  if (timeoutMs === 0 || isFinite(timeoutMs)) {\n    const timeout = setTimeout(() => {\n      if (!hasProcessExited(child)) {\n        child.kill('SIGKILL');\n      }\n    }, timeoutMs);\n\n    onExit = onExit.then(() => {\n      clearTimeout(timeout);\n    });\n  }\n  return onExit;\n}\n\n/*\n asyncSend\n Same as process.send but waits until the send is complete\n the async version is used below because otherwise\n the termination handler may exit before the parent\n process has recived the messages it requires\n */\n\nconst asyncSend = (proc, msg) => {\n  return new Promise((resolve, reject) => {\n    proc.send(msg, err => {\n      if (err) {\n        reject(err);\n      } else {\n        resolve();\n      }\n    });\n  });\n};\n\nmodule.exports = {\n  killAsync,\n  asyncSend\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvYnVsbC9saWIvcHJvY2Vzcy91dGlscy5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxjQUFjO0FBQ3pCLFdBQVcsdUJBQXVCO0FBQ2xDLFdBQVcsUUFBUTtBQUNuQjtBQUNBLGFBQWEsZUFBZTtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL215LWFwcC8uL25vZGVfbW9kdWxlcy9idWxsL2xpYi9wcm9jZXNzL3V0aWxzLmpzPzJiYWUiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG5mdW5jdGlvbiBoYXNQcm9jZXNzRXhpdGVkKGNoaWxkKSB7XG4gIHJldHVybiAhIShjaGlsZC5leGl0Q29kZSAhPT0gbnVsbCB8fCBjaGlsZC5zaWduYWxDb2RlKTtcbn1cblxuZnVuY3Rpb24gb25FeGl0T25jZShjaGlsZCkge1xuICByZXR1cm4gbmV3IFByb21pc2UocmVzb2x2ZSA9PiB7XG4gICAgY2hpbGQub25jZSgnZXhpdCcsICgpID0+IHJlc29sdmUoKSk7XG4gIH0pO1xufVxuXG4vKipcbiAqIFNlbmRzIGEga2lsbCBzaWduYWwgdG8gYSBjaGlsZCByZXNvbHZpbmcgd2hlbiB0aGUgY2hpbGQgaGFzIGV4aXRlZCxcbiAqIHJlc29ydGluZyB0byBTSUdLSUxMIGlmIHRoZSBnaXZlbiB0aW1lb3V0IGlzIHJlYWNoZWRcbiAqXG4gKiBAcGFyYW0ge0NoaWxkUHJvY2Vzc30gY2hpbGRcbiAqIEBwYXJhbSB7J1NJR1RFUk0nIHwgJ1NJR0tJTEwnfSBbc2lnbmFsXSBpbml0aWFsIHNpZ25hbCB0byB1c2VcbiAqIEBwYXJhbSB7bnVtYmVyfSBbdGltZW91dE1zXSB0aW1lIHRvIHdhaXQgdW50aWwgc2VuZGluZyBTSUdLSUxMXG4gKlxuICogQHJldHVybnMge1Byb21pc2U8dm9pZD59IHRoZSBraWxsZWQgY2hpbGRcbiAqL1xuZnVuY3Rpb24ga2lsbEFzeW5jKGNoaWxkLCBzaWduYWwsIHRpbWVvdXRNcykge1xuICBpZiAoaGFzUHJvY2Vzc0V4aXRlZChjaGlsZCkpIHtcbiAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKGNoaWxkKTtcbiAgfVxuXG4gIC8vIGNhdGNoIGFueSBuZXcgb24gZXhpdFxuICBsZXQgb25FeGl0ID0gb25FeGl0T25jZShjaGlsZCk7XG5cbiAgY2hpbGQua2lsbChzaWduYWwgfHwgJ1NJR0tJTEwnKTtcblxuICBpZiAodGltZW91dE1zID09PSAwIHx8IGlzRmluaXRlKHRpbWVvdXRNcykpIHtcbiAgICBjb25zdCB0aW1lb3V0ID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICBpZiAoIWhhc1Byb2Nlc3NFeGl0ZWQoY2hpbGQpKSB7XG4gICAgICAgIGNoaWxkLmtpbGwoJ1NJR0tJTEwnKTtcbiAgICAgIH1cbiAgICB9LCB0aW1lb3V0TXMpO1xuXG4gICAgb25FeGl0ID0gb25FeGl0LnRoZW4oKCkgPT4ge1xuICAgICAgY2xlYXJUaW1lb3V0KHRpbWVvdXQpO1xuICAgIH0pO1xuICB9XG4gIHJldHVybiBvbkV4aXQ7XG59XG5cbi8qXG4gYXN5bmNTZW5kXG4gU2FtZSBhcyBwcm9jZXNzLnNlbmQgYnV0IHdhaXRzIHVudGlsIHRoZSBzZW5kIGlzIGNvbXBsZXRlXG4gdGhlIGFzeW5jIHZlcnNpb24gaXMgdXNlZCBiZWxvdyBiZWNhdXNlIG90aGVyd2lzZVxuIHRoZSB0ZXJtaW5hdGlvbiBoYW5kbGVyIG1heSBleGl0IGJlZm9yZSB0aGUgcGFyZW50XG4gcHJvY2VzcyBoYXMgcmVjaXZlZCB0aGUgbWVzc2FnZXMgaXQgcmVxdWlyZXNcbiAqL1xuXG5jb25zdCBhc3luY1NlbmQgPSAocHJvYywgbXNnKSA9PiB7XG4gIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgcHJvYy5zZW5kKG1zZywgZXJyID0+IHtcbiAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgcmVqZWN0KGVycik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXNvbHZlKCk7XG4gICAgICB9XG4gICAgfSk7XG4gIH0pO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIGtpbGxBc3luYyxcbiAgYXN5bmNTZW5kXG59O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/bull/lib/process/utils.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/bull/lib/queue.js":
/*!****************************************!*\
  !*** ./node_modules/bull/lib/queue.js ***!
  \****************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval("\n\nconst Redis = __webpack_require__(/*! ioredis */ \"(rsc)/./node_modules/ioredis/built/index.js\");\nconst EventEmitter = __webpack_require__(/*! events */ \"events\");\n\nconst _ = __webpack_require__(/*! lodash */ \"(rsc)/./node_modules/lodash/lodash.js\");\n\nconst fs = __webpack_require__(/*! fs */ \"fs\");\nconst path = __webpack_require__(/*! path */ \"path\");\nconst util = __webpack_require__(/*! util */ \"util\");\nconst url = __webpack_require__(/*! url */ \"url\");\nconst Job = __webpack_require__(/*! ./job */ \"(rsc)/./node_modules/bull/lib/job.js\");\nconst scripts = __webpack_require__(/*! ./scripts */ \"(rsc)/./node_modules/bull/lib/scripts.js\");\nconst errors = __webpack_require__(/*! ./errors */ \"(rsc)/./node_modules/bull/lib/errors.js\");\nconst utils = __webpack_require__(/*! ./utils */ \"(rsc)/./node_modules/bull/lib/utils.js\");\n\nconst TimerManager = __webpack_require__(/*! ./timer-manager */ \"(rsc)/./node_modules/bull/lib/timer-manager.js\");\nconst { promisify } = __webpack_require__(/*! util */ \"util\");\nconst { pTimeout } = __webpack_require__(/*! ./p-timeout */ \"(rsc)/./node_modules/bull/lib/p-timeout.js\");\nconst semver = __webpack_require__(/*! semver */ \"(rsc)/./node_modules/semver/index.js\");\nconst debuglog = (__webpack_require__(/*! util */ \"util\").debuglog)('bull');\nconst uuid = __webpack_require__(/*! uuid */ \"(rsc)/./node_modules/bull/node_modules/uuid/dist/esm-node/index.js\");\n\nconst commands = __webpack_require__(/*! ./scripts/ */ \"(rsc)/./node_modules/bull/lib/scripts/index.js\");\n\n/**\n  Gets or creates a new Queue with the given name.\n\n  The Queue keeps 6 data structures:\n    - wait (list)\n    - active (list)\n    - delayed (zset)\n    - priority (zset)\n    - completed (zset)\n    - failed (zset)\n\n        --> priorities      -- > completed\n       /     |            /\n    job -> wait -> active\n       \\     ^            \\\n        v    |             -- > failed\n        delayed\n*/\n\n/**\n  Delayed jobs are jobs that cannot be executed until a certain time in\n  ms has passed since they were added to the queue.\n  The mechanism is simple, a delayedTimestamp variable holds the next\n  known timestamp that is on the delayed set (or MAX_TIMEOUT_MS if none).\n\n  When the current job has finalized the variable is checked, if\n  no delayed job has to be executed yet a setTimeout is set so that a\n  delayed job is processed after timing out.\n*/\nconst MINIMUM_REDIS_VERSION = '2.8.18';\n\n/*\n  interface QueueOptions {\n    prefix?: string = 'bull',\n    limiter?: RateLimiter,\n    redis : RedisOpts, // ioredis defaults,\n    createClient?: (type: enum('client', 'subscriber'), redisOpts?: RedisOpts) => redisClient,\n    defaultJobOptions?: JobOptions,\n\n    // Advanced settings\n    settings?: QueueSettings {\n      lockDuration?: number = 30000,\n      lockRenewTime?: number = lockDuration / 2,\n      stalledInterval?: number = 30000,\n      maxStalledCount?: number = 1, // The maximum number of times a job can be recovered from the 'stalled' state\n      guardInterval?: number = 5000,\n      retryProcessDelay?: number = 5000,\n      drainDelay?: number = 5\n      isSharedChildPool?: boolean = false\n    }\n  }\n\n  interface RateLimiter {\n    max: number,      // Number of jobs\n    duration: number, // per duration milliseconds\n  }\n*/\n\n// Queue(name: string, url?, opts?)\nconst Queue = function Queue(name, url, opts) {\n  if (!(this instanceof Queue)) {\n    return new Queue(name, url, opts);\n  }\n\n  if (_.isString(url)) {\n    const clonedOpts = _.cloneDeep(opts || {});\n    opts = {\n      ...clonedOpts,\n      redis: {\n        ...redisOptsFromUrl(url),\n        ...clonedOpts.redis\n      }\n    };\n  } else {\n    opts = _.cloneDeep(url || {});\n  }\n\n  if (!_.isObject(opts)) {\n    throw TypeError('Options must be a valid object');\n  }\n\n  if (opts.limiter) {\n    if (opts.limiter.max && opts.limiter.duration) {\n      this.limiter = opts.limiter;\n    } else {\n      throw new TypeError('Limiter requires `max` and `duration` options');\n    }\n  }\n\n  if (opts.defaultJobOptions) {\n    this.defaultJobOptions = opts.defaultJobOptions;\n  }\n\n  this.name = name;\n  this.token = uuid.v4();\n\n  opts.redis = {\n    enableReadyCheck: false,\n    ...(_.isString(opts.redis)\n      ? { ...redisOptsFromUrl(opts.redis) }\n      : opts.redis)\n  };\n\n  _.defaults(opts.redis, {\n    port: 6379,\n    host: '127.0.0.1',\n    db: opts.redis.db || opts.redis.DB,\n    retryStrategy: function(times) {\n      return Math.min(Math.exp(times), 20000);\n    }\n  });\n\n  this.keyPrefix = opts.redis.keyPrefix || opts.prefix || 'bull';\n\n  //\n  // We cannot use ioredis keyPrefix feature since we\n  // create keys dynamically in lua scripts.\n  //\n  delete opts.redis.keyPrefix;\n\n  this.clients = [];\n\n  const loadCommands = (providedScripts, client) => {\n    const finalScripts = providedScripts || scripts;\n    for (const property in finalScripts) {\n      // Only define the command if not already defined\n      if (!client[finalScripts[property].name]) {\n        client.defineCommand(finalScripts[property].name, {\n          numberOfKeys: finalScripts[property].keys,\n          lua: finalScripts[property].content\n        });\n      }\n    }\n  };\n\n  const lazyClient = redisClientGetter(this, opts, (type, client) => {\n    // bubble up Redis error events\n    const handler = this.emit.bind(this, 'error');\n    client.on('error', handler);\n    this.once('close', () => client.removeListener('error', handler));\n\n    if (type === 'client') {\n      this._initializing = (async () => loadCommands(commands, client))().then(\n        () => {\n          debuglog(name + ' queue ready');\n        },\n        err => {\n          this.emit('error', new Error('Error initializing Lua scripts'));\n          throw err;\n        }\n      );\n\n      this._initializing.catch((/*err*/) => {});\n    }\n  });\n\n  Object.defineProperties(this, {\n    //\n    // Queue client (used to add jobs, pause queues, etc);\n    //\n    client: {\n      get: lazyClient('client')\n    },\n    //\n    // Event subscriber client (receive messages from other instance of the queue)\n    //\n    eclient: {\n      get: lazyClient('subscriber')\n    },\n    bclient: {\n      get: lazyClient('bclient')\n    }\n  });\n\n  if (opts.skipVersionCheck !== true) {\n    getRedisVersion(this.client)\n      .then(version => {\n        if (semver.lt(version, MINIMUM_REDIS_VERSION)) {\n          this.emit(\n            'error',\n            new Error(\n              'Redis version needs to be greater than ' +\n                MINIMUM_REDIS_VERSION +\n                '. Current: ' +\n                version\n            )\n          );\n        }\n      })\n      .catch((/*err*/) => {\n        // Ignore this error.\n      });\n  }\n\n  this.handlers = {};\n  this.delayTimer;\n  this.processing = [];\n  this.retrieving = 0;\n  this.drained = true;\n\n  this.settings = _.defaults(opts.settings, {\n    lockDuration: 30000,\n    stalledInterval: 30000,\n    maxStalledCount: 1,\n    guardInterval: 5000,\n    retryProcessDelay: 5000,\n    drainDelay: 5,\n    backoffStrategies: {},\n    isSharedChildPool: false\n  });\n\n  this.metrics = opts.metrics;\n\n  this.settings.lockRenewTime =\n    this.settings.lockRenewTime || this.settings.lockDuration / 2;\n\n  this.on('error', () => {\n    // Dummy handler to avoid process to exit with an unhandled exception.\n  });\n\n  // keeps track of active timers. used by close() to\n  // ensure that disconnect() is deferred until all\n  // scheduled redis commands have been executed\n  this.timers = new TimerManager();\n\n  // Bind these methods to avoid constant rebinding and/or creating closures\n  // in processJobs etc.\n  this.moveUnlockedJobsToWait = this.moveUnlockedJobsToWait.bind(this);\n  this.processJob = this.processJob.bind(this);\n  this.getJobFromId = Job.fromId.bind(null, this);\n\n  const keys = {};\n  _.each(\n    [\n      '',\n      'active',\n      'wait',\n      'waiting',\n      'paused',\n      'resumed',\n      'meta-paused',\n      'active',\n      'id',\n      'delayed',\n      'priority',\n      'stalled-check',\n      'completed',\n      'failed',\n      'stalled',\n      'repeat',\n      'limiter',\n      'drained',\n      'duplicated',\n      'progress',\n      'de' // debounce key\n    ],\n    key => {\n      keys[key] = this.toKey(key);\n    }\n  );\n  this.keys = keys;\n};\n\nfunction redisClientGetter(queue, options, initCallback) {\n  const createClient = _.isFunction(options.createClient)\n    ? options.createClient\n    : function(type, config) {\n        if (['bclient', 'subscriber'].includes(type)) {\n          return new Redis({ ...config, maxRetriesPerRequest: null });\n        } else {\n          return new Redis(config);\n        }\n      };\n\n  const connections = {};\n\n  return function(type) {\n    return function() {\n      // Memoized connection\n      if (connections[type] != null) {\n        return connections[type];\n      }\n      const clientOptions = _.assign({}, options.redis);\n\n      const client = (connections[type] = createClient(type, clientOptions));\n\n      const opts = client.options.redisOptions || client.options;\n\n      if (\n        ['bclient', 'subscriber'].includes(type) &&\n        (opts.enableReadyCheck || opts.maxRetriesPerRequest)\n      ) {\n        throw new Error(errors.Messages.MISSING_REDIS_OPTS);\n      }\n\n      // Since connections are lazily initialized, we can't check queue.client\n      // without initializing a connection. So expose a boolean we can safely\n      // query.\n      queue[type + 'Initialized'] = true;\n\n      if (!options.createClient) {\n        queue.clients.push(client);\n      }\n      return initCallback(type, client), client;\n    };\n  };\n}\n\nfunction redisOptsFromUrl(urlString) {\n  let redisOpts = {};\n  try {\n    const redisUrl = url.parse(urlString, true, true);\n    redisOpts.port = parseInt(redisUrl.port || '6379', 10);\n    redisOpts.host = redisUrl.hostname;\n    redisOpts.db = redisUrl.pathname ? redisUrl.pathname.split('/')[1] : 0;\n    if (redisUrl.auth) {\n      const columnIndex = redisUrl.auth.indexOf(':');\n      redisOpts.password = redisUrl.auth.slice(columnIndex + 1);\n      if (columnIndex > 0) {\n        redisOpts.username = redisUrl.auth.slice(0, columnIndex);\n      }\n    }\n\n    if (redisUrl.query) {\n      redisOpts = { ...redisOpts, ...redisUrl.query };\n    }\n  } catch (e) {\n    throw new Error(e.message);\n  }\n  return redisOpts;\n}\n\nutil.inherits(Queue, EventEmitter);\n\n//\n// Extend Queue with \"aspects\"\n//\n__webpack_require__(/*! ./getters */ \"(rsc)/./node_modules/bull/lib/getters.js\")(Queue);\n__webpack_require__(/*! ./worker */ \"(rsc)/./node_modules/bull/lib/worker.js\")(Queue);\n__webpack_require__(/*! ./repeatable */ \"(rsc)/./node_modules/bull/lib/repeatable.js\")(Queue);\n\n// --\nQueue.prototype.off = Queue.prototype.removeListener;\n\nconst _on = Queue.prototype.on;\n\nQueue.prototype.on = function(eventName) {\n  this._registerEvent(eventName);\n  return _on.apply(this, arguments);\n};\n\nconst _once = Queue.prototype.once;\n\nQueue.prototype.once = function(eventName) {\n  this._registerEvent(eventName);\n  return _once.apply(this, arguments);\n};\n\nQueue.prototype._initProcess = function() {\n  if (!this._initializingProcess) {\n    //\n    // Only setup listeners if .on/.addEventListener called, or process function defined.\n    //\n    this.delayedTimestamp = Number.MAX_VALUE;\n    this._initializingProcess = this.isReady()\n      .then(() => {\n        return this._registerEvent('delayed');\n      })\n      .then(() => {\n        return this.updateDelayTimer();\n      });\n\n    this.errorRetryTimer = {};\n  }\n\n  return this._initializingProcess;\n};\n\nQueue.prototype._setupQueueEventListeners = function() {\n  /*\n    if(eventName !== 'cleaned' && eventName !== 'error'){\n      args[0] = Job.fromJSON(this, args[0]);\n    }\n  */\n\n  const activeKey = this.keys.active;\n  const stalledKey = this.keys.stalled;\n  const progressKey = this.keys.progress;\n  const delayedKey = this.keys.delayed;\n  const pausedKey = this.keys.paused;\n  const resumedKey = this.keys.resumed;\n  const waitingKey = this.keys.waiting;\n  const completedKey = this.keys.completed;\n  const failedKey = this.keys.failed;\n  const drainedKey = this.keys.drained;\n  const duplicatedKey = this.keys.duplicated;\n  const debouncedKey = this.keys.de + 'bounced';\n\n  const pmessageHandler = (pattern, channel, message) => {\n    const keyAndToken = channel.split('@');\n    const key = keyAndToken[0];\n    const token = keyAndToken[1];\n    switch (key) {\n      case activeKey:\n        utils.emitSafe(this, 'global:active', message, 'waiting');\n        break;\n      case waitingKey:\n        if (this.token === token) {\n          utils.emitSafe(this, 'waiting', message, null);\n        }\n        token && utils.emitSafe(this, 'global:waiting', message, null);\n        break;\n      case stalledKey:\n        if (this.token === token) {\n          utils.emitSafe(this, 'stalled', message);\n        }\n        utils.emitSafe(this, 'global:stalled', message);\n        break;\n      case duplicatedKey:\n        if (this.token === token) {\n          utils.emitSafe(this, 'duplicated', message);\n        }\n        utils.emitSafe(this, 'global:duplicated', message);\n        break;\n      case debouncedKey:\n        if (this.token === token) {\n          utils.emitSafe(this, 'debounced', message);\n        }\n        utils.emitSafe(this, 'global:debounced', message);\n        break;\n    }\n  };\n\n  const messageHandler = (channel, message) => {\n    const key = channel.split('@')[0];\n    switch (key) {\n      case progressKey: {\n        // New way to send progress message data\n        try {\n          const { progress, jobId } = JSON.parse(message);\n          utils.emitSafe(this, 'global:progress', jobId, progress);\n        } catch (err) {\n          // If we fail we should try to parse the data using the deprecated method\n          const commaPos = message.indexOf(',');\n          const jobId = message.substring(0, commaPos);\n          const progress = message.substring(commaPos + 1);\n          utils.emitSafe(this, 'global:progress', jobId, JSON.parse(progress));\n        }\n        break;\n      }\n      case delayedKey: {\n        const newDelayedTimestamp = _.ceil(message);\n        if (newDelayedTimestamp < this.delayedTimestamp) {\n          // The new delayed timestamp is before the currently newest known delayed timestamp\n          // Assume this is the new delayed timestamp and call `updateDelayTimer()` to process any delayed jobs\n          // This will also update the `delayedTimestamp`\n          this.delayedTimestamp = newDelayedTimestamp;\n\n          this.updateDelayTimer();\n        }\n        break;\n      }\n      case pausedKey:\n      case resumedKey:\n        utils.emitSafe(this, 'global:' + message);\n        break;\n      case completedKey: {\n        const data = JSON.parse(message);\n        utils.emitSafe(\n          this,\n          'global:completed',\n          data.jobId,\n          data.val,\n          'active'\n        );\n        break;\n      }\n      case failedKey: {\n        const data = JSON.parse(message);\n        utils.emitSafe(this, 'global:failed', data.jobId, data.val, 'active');\n        break;\n      }\n      case drainedKey:\n        utils.emitSafe(this, 'global:drained');\n        break;\n    }\n  };\n\n  this.eclient.on('pmessage', pmessageHandler);\n  this.eclient.on('message', messageHandler);\n\n  this.once('close', () => {\n    this.eclient.removeListener('pmessage', pmessageHandler);\n    this.eclient.removeListener('message', messageHandler);\n  });\n};\n\nQueue.prototype._registerEvent = function(eventName) {\n  const internalEvents = ['waiting', 'delayed', 'duplicated', 'debounced'];\n\n  if (\n    eventName.startsWith('global:') ||\n    internalEvents.indexOf(eventName) !== -1\n  ) {\n    if (!this.registeredEvents) {\n      this._setupQueueEventListeners();\n      this.registeredEvents = this.registeredEvents || {};\n    }\n\n    const _eventName = eventName.replace('global:', '');\n\n    if (!this.registeredEvents[_eventName]) {\n      return utils\n        .isRedisReady(this.eclient)\n        .then(() => {\n          const channel = this.toKey(_eventName);\n          if (['active', 'waiting', 'stalled', 'duplicated', 'debounced'].indexOf(_eventName) !== -1) {\n            return (this.registeredEvents[_eventName] = this.eclient.psubscribe(\n              channel + '*'\n            ));\n          } else {\n            return (this.registeredEvents[_eventName] = this.eclient.subscribe(\n              channel\n            ));\n          }\n        })\n        .then(() => {\n          utils.emitSafe(this, 'registered:' + eventName);\n        });\n    } else {\n      return this.registeredEvents[_eventName];\n    }\n  }\n  return Promise.resolve();\n};\n\nQueue.ErrorMessages = errors.Messages;\n\nQueue.prototype.isReady = async function() {\n  await this._initializing;\n  return this;\n};\n\nasync function redisClientDisconnect(client) {\n  if (client.status !== 'end') {\n    let _resolve, _reject;\n    return new Promise((resolve, reject) => {\n      _resolve = resolve;\n      _reject = reject;\n      client.once('end', _resolve);\n\n      pTimeout(\n        client.quit().catch(err => {\n          if (err.message !== 'Connection is closed.') {\n            throw err;\n          }\n        }),\n        500\n      )\n        .catch(() => {\n          // Ignore timeout error\n        })\n        .finally(() => {\n          client.once('error', _reject);\n\n          client.disconnect();\n          if (['connecting', 'reconnecting'].includes(client.status)) {\n            resolve();\n          }\n        });\n    }).finally(() => {\n      client.removeListener('end', _resolve);\n      client.removeListener('error', _reject);\n    });\n  }\n}\n\nQueue.prototype.disconnect = async function() {\n  await Promise.all(\n    this.clients.map(client =>\n      client.blocked ? client.disconnect() : redisClientDisconnect(client)\n    )\n  );\n};\n\nQueue.prototype.removeJobs = function(pattern) {\n  return Job.remove(this, pattern);\n};\n\nQueue.prototype.close = function(doNotWaitJobs) {\n  let isReady = true;\n  if (this.closing) {\n    return this.closing;\n  }\n\n  return (this.closing = this.isReady()\n    .then(this._initializingProcess)\n    .catch(() => {\n      isReady = false;\n    })\n    .then(() => isReady && this.pause(true, doNotWaitJobs))\n    .catch(() => void 0) // Ignore possible error from pause\n    .finally(() => this._clearTimers())\n    .then(() => {\n      if (!this.childPool) {\n        return;\n      }\n      const cleanPromise = this.childPool.clean().catch(() => {\n        // Ignore this error and try to close anyway.\n      });\n      if (doNotWaitJobs) {\n        return;\n      }\n      return cleanPromise;\n    })\n    .then(\n      async () => this.disconnect(),\n      err => console.error(err)\n    )\n    .finally(() => {\n      this.closed = true;\n      utils.emitSafe(this, 'close');\n    }));\n};\n\nQueue.prototype._clearTimers = function() {\n  _.each(this.errorRetryTimer, timer => {\n    clearTimeout(timer);\n  });\n  clearTimeout(this.delayTimer);\n  clearInterval(this.guardianTimer);\n  clearInterval(this.moveUnlockedJobsToWaitInterval);\n  this.timers.clearAll();\n  return this.timers.whenIdle();\n};\n\n/**\n  Processes a job from the queue. The callback is called for every job that\n  is dequeued.\n\n  @method process\n*/\nQueue.prototype.process = function(name, concurrency, handler) {\n  switch (arguments.length) {\n    case 1:\n      handler = name;\n      concurrency = 1;\n      name = Job.DEFAULT_JOB_NAME;\n      break;\n    case 2: // (string, function) or (string, string) or (number, function) or (number, string)\n      handler = concurrency;\n      if (typeof name === 'string') {\n        concurrency = 1;\n      } else {\n        concurrency = name;\n        name = Job.DEFAULT_JOB_NAME;\n      }\n      break;\n  }\n\n  this.setHandler(name, handler);\n\n  return this._initProcess().then(() => {\n    return this.start(concurrency, name);\n  });\n};\n\nQueue.prototype.start = function(concurrency, name) {\n  return this.run(concurrency, name).catch(err => {\n    utils.emitSafe(this, 'error', err, 'error running queue');\n    throw err;\n  });\n};\n\nQueue.prototype.setHandler = function(name, handler) {\n  if (!handler) {\n    throw new Error('Cannot set an undefined handler');\n  }\n  if (this.handlers[name]) {\n    throw new Error('Cannot define the same handler twice ' + name);\n  }\n\n  this.setWorkerName();\n\n  if (typeof handler === 'string') {\n    const supportedFileTypes = ['.js', '.ts', '.flow', '.cjs'];\n    const processorFile =\n      handler +\n      (supportedFileTypes.includes(path.extname(handler)) ? '' : '.js');\n\n    if (!fs.existsSync(processorFile)) {\n      throw new Error('File ' + processorFile + ' does not exist');\n    }\n    const isSharedChildPool = this.settings.isSharedChildPool;\n    this.childPool =\n      this.childPool || __webpack_require__(/*! ./process/child-pool */ \"(rsc)/./node_modules/bull/lib/process/child-pool.js\")(isSharedChildPool);\n\n    const sandbox = __webpack_require__(/*! ./process/sandbox */ \"(rsc)/./node_modules/bull/lib/process/sandbox.js\");\n    this.handlers[name] = sandbox(handler, this.childPool).bind(this);\n  } else {\n    handler = handler.bind(this);\n\n    if (handler.length > 1) {\n      this.handlers[name] = promisify(handler);\n    } else {\n      this.handlers[name] = function() {\n        try {\n          return Promise.resolve(handler.apply(null, arguments));\n        } catch (err) {\n          return Promise.reject(err);\n        }\n      };\n    }\n  }\n};\n\n/**\ninterface JobOptions\n{\n  attempts: number;\n\n  repeat: {\n    tz?: string,\n    endDate?: Date | string | number\n  },\n  preventParsingData: boolean;\n}\n*/\n\n/**\n  Adds a job to the queue.\n  @method add\n  @param data: {} Custom data to store for this job. Should be JSON serializable.\n  @param opts: JobOptions Options for this job.\n*/\nQueue.prototype.add = function(name, data, opts) {\n  if (typeof name !== 'string') {\n    opts = data;\n    data = name;\n    name = Job.DEFAULT_JOB_NAME;\n  }\n  opts = _.cloneDeep({ ...this.defaultJobOptions, ...opts });\n\n  opts.jobId = jobIdForGroup(this.limiter, opts, data);\n\n  if (opts.repeat) {\n    return this.isReady().then(() => {\n      return this.nextRepeatableJob(name, data, opts, true);\n    });\n  } else {\n    return Job.create(this, name, data, opts);\n  }\n};\n\n/**\n * Retry all the failed jobs.\n *\n * @param opts.count - number to limit how many jobs will be moved to wait status per iteration\n * @returns\n */\nQueue.prototype.retryJobs = async function(opts = {}) {\n  let cursor = 0;\n  do {\n    cursor = await scripts.retryJobs(this, opts.count);\n  } while (cursor);\n};\n\n  /**\n   * Removes a debounce key.\n   *\n   * @param id - identifier\n   */\n  Queue.prototype.removeDebounceKey = (id) => {\n    return this.client.del(`${this.keys.de}:${id}`);\n  }\n\n/**\n  Adds an array of jobs to the queue.\n  @method add\n  @param jobs: [] The array of jobs to add to the queue. Each job is defined by 3 properties, 'name', 'data' and 'opts'. They follow the same signature as 'Queue.add'.\n*/\nQueue.prototype.addBulk = function(jobs) {\n  const decoratedJobs = jobs.map(job => {\n    const jobId = jobIdForGroup(this.limiter, job.opts, job.data);\n    return {\n      ...job,\n      name: typeof job.name !== 'string' ? Job.DEFAULT_JOB_NAME : job.name,\n      opts: {\n        ...this.defaultJobOptions,\n        ...job.opts,\n        jobId\n      }\n    };\n  });\n  return Job.createBulk(this, decoratedJobs);\n};\n/**\n  Empties the queue.\n\n  Returns a promise that is resolved after the operation has been completed.\n  Note that if some other process is adding jobs at the same time as emptying,\n  the queues may not be really empty after this method has executed completely.\n  Also, if the method does error between emptying the lists and removing all the\n  jobs, there will be zombie jobs left in redis.\n\n  TODO: Use EVAL to make this operation fully atomic.\n*/\nQueue.prototype.empty = function() {\n  const queueKeys = this.keys;\n\n  let multi = this.multi();\n\n  multi.lrange(queueKeys.wait, 0, -1);\n  multi.lrange(queueKeys.paused, 0, -1);\n  multi.keys(this.toKey('*:limited'));\n  multi.del(\n    queueKeys.wait,\n    queueKeys.paused,\n    queueKeys['meta-paused'],\n    queueKeys.delayed,\n    queueKeys.priority,\n    queueKeys.limiter,\n    `${queueKeys.limiter}:index`\n  );\n\n  return multi.exec().then(res => {\n    let [waiting, paused, limited] = res;\n\n    waiting = waiting[1];\n    paused = paused[1];\n    limited = limited[1];\n\n    const jobKeys = paused.concat(waiting).map(this.toKey, this);\n\n    if (jobKeys.length || limited.length) {\n      multi = this.multi();\n\n      for (let i = 0; i < jobKeys.length; i += 10000) {\n        multi.del.apply(multi, jobKeys.slice(i, i + 10000));\n      }\n\n      for (let i = 0; i < limited.length; i += 10000) {\n        multi.del.apply(multi, limited.slice(i, i + 10000));\n      }\n\n      return multi.exec();\n    }\n  });\n};\n\n/**\n  Pauses the processing of this queue, locally if true passed, otherwise globally.\n\n  For global pause, we use an atomic RENAME operation on the wait queue. Since\n  we have blocking calls with BRPOPLPUSH on the wait queue, as long as the queue\n  is renamed to 'paused', no new jobs will be processed (the current ones\n  will run until finalized).\n\n  Adding jobs requires a LUA script to check first if the paused list exist\n  and in that case it will add it there instead of the wait list.\n*/\nQueue.prototype.pause = function(isLocal, doNotWaitActive) {\n  return this.isReady()\n    .then(() => {\n      if (isLocal) {\n        if (!this.paused) {\n          this.paused = new Promise(resolve => {\n            this.resumeLocal = function() {\n              this.paused = null; // Allow pause to be checked externally for paused state.\n              resolve();\n            };\n          });\n        }\n\n        if (!this.bclientInitialized) {\n          // bclient not yet initialized, so no jobs to wait for\n          return;\n        }\n\n        if (doNotWaitActive) {\n          // Force reconnection of blocking connection to abort blocking redis call immediately.\n          return redisClientDisconnect(this.bclient).then(() =>\n            this.bclient.connect()\n          );\n        }\n        return this.whenCurrentJobsFinished();\n      } else {\n        return scripts.pause(this, true);\n      }\n    })\n    .then(() => {\n      return utils.emitSafe(this, 'paused');\n    });\n};\n\nQueue.prototype.resume = function(isLocal /* Optional */) {\n  return this.isReady()\n    .then(() => {\n      if (isLocal) {\n        if (this.resumeLocal) {\n          this.resumeLocal();\n        }\n      } else {\n        return scripts.pause(this, false);\n      }\n    })\n    .then(() => {\n      utils.emitSafe(this, 'resumed');\n    });\n};\n\nQueue.prototype.isPaused = async function(isLocal) {\n  if (isLocal) {\n    return !!this.paused;\n  } else {\n    await this.isReady();\n    const multi = this.multi();\n\n    multi.exists(this.keys['meta-paused']);\n\n    // For forward compatibility with BullMQ.\n    multi.hexists(this.toKey('meta'), 'paused');\n\n    const [[, isPaused], [, isPausedNew]] = await multi.exec();\n\n    return !!(isPaused || isPausedNew);\n  }\n};\n\nQueue.prototype.run = function(concurrency, handlerName) {\n  if (!Number.isInteger(concurrency)) {\n    throw new Error('Cannot set Float as concurrency');\n  }\n  const promises = [];\n\n  return this.isReady()\n    .then(() => {\n      return this.moveUnlockedJobsToWait();\n    })\n    .then(() => {\n      return utils.isRedisReady(this.bclient);\n    })\n    .then(() => {\n      while (concurrency--) {\n        promises.push(\n          new Promise(resolve => {\n            this.processJobs(`${handlerName}:${concurrency}`, resolve);\n          })\n        );\n      }\n\n      this.startMoveUnlockedJobsToWait();\n\n      return Promise.all(promises);\n    });\n};\n\n// ---------------------------------------------------------------------\n// Private methods\n// ---------------------------------------------------------------------\n\n/**\n  This function updates the delay timer, which is a timer that timeouts\n  at the next known delayed job.\n*/\nQueue.prototype.updateDelayTimer = function() {\n  if (this.closing) {\n    return Promise.resolve();\n  }\n\n  return scripts\n    .updateDelaySet(this, Date.now())\n    .then(nextTimestamp => {\n      this.delayedTimestamp = nextTimestamp\n        ? nextTimestamp / 4096\n        : Number.MAX_VALUE;\n\n      // Clear any existing update delay timer\n      if (this.delayTimer) {\n        clearTimeout(this.delayTimer);\n      }\n\n      // Delay for the next update of delay set\n      const delay = _.min([\n        this.delayedTimestamp - Date.now(),\n        this.settings.guardInterval\n      ]);\n\n      // Schedule next processing of the delayed jobs\n      if (delay <= 0) {\n        // Next set of jobs are due right now, process them also\n        this.updateDelayTimer();\n      } else {\n        // Update the delay set when the next job is due\n        // or the next guard time\n        this.delayTimer = setTimeout(() => this.updateDelayTimer(), delay);\n      }\n\n      // Silence warnings about promise created but not returned.\n      // This isn't an issue since we emit errors.\n      // See http://bluebirdjs.com/docs/warning-explanations.html#warning-a-promise-was-created-in-a-handler-but-was-not-returned-from-it\n      return null;\n    })\n    .catch(err => {\n      utils.emitSafe(this, 'error', err, 'Error updating the delay timer');\n      if (this.delayTimer) {\n        clearTimeout(this.delayTimer);\n      }\n\n      this.delayTimer = setTimeout(\n        () => this.updateDelayTimer(),\n        this.settings.guardInterval\n      );\n    });\n};\n\n/**\n * Process jobs that have been added to the active list but are not being\n * processed properly. This can happen due to a process crash in the middle\n * of processing a job, leaving it in 'active' but without a job lock.\n */\nQueue.prototype.moveUnlockedJobsToWait = function() {\n  if (this.closing) {\n    return Promise.resolve();\n  }\n\n  return scripts\n    .moveUnlockedJobsToWait(this)\n    .then(([failed, stalled]) => {\n      const handleFailedJobs = failed.map(jobId => {\n        return this.getJobFromId(jobId).then(job => {\n          utils.emitSafe(\n            this,\n            'failed',\n            job,\n            new Error('job stalled more than allowable limit'),\n            'active'\n          );\n          return null;\n        });\n      });\n      const handleStalledJobs = stalled.map(jobId => {\n        return this.getJobFromId(jobId).then(job => {\n          // Do not emit the event if the job was completed by another worker\n          if (job !== null) {\n            utils.emitSafe(this, 'stalled', job);\n          }\n          return null;\n        });\n      });\n      return Promise.all(handleFailedJobs.concat(handleStalledJobs));\n    })\n    .catch(err => {\n      utils.emitSafe(\n        this,\n        'error',\n        err,\n        'Failed to handle unlocked job in active'\n      );\n    });\n};\n\nQueue.prototype.startMoveUnlockedJobsToWait = function() {\n  clearInterval(this.moveUnlockedJobsToWaitInterval);\n  if (this.settings.stalledInterval > 0 && !this.closing) {\n    this.moveUnlockedJobsToWaitInterval = setInterval(\n      this.moveUnlockedJobsToWait,\n      this.settings.stalledInterval\n    );\n  }\n};\n\n/*\n  Process jobs. Note last argument 'job' is optional.\n*/\nQueue.prototype.processJobs = function(index, resolve, job) {\n  const processJobs = this.processJobs.bind(this, index, resolve);\n  process.nextTick(() => {\n    this._processJobOnNextTick(processJobs, index, resolve, job);\n  });\n};\n\nQueue.prototype._processJobOnNextTick = function(\n  processJobs,\n  index,\n  resolve,\n  job\n) {\n  if (!this.closing) {\n    (this.paused || Promise.resolve())\n      .then(() => {\n        const gettingNextJob = job ? Promise.resolve(job) : this.getNextJob();\n\n        return (this.processing[index] = gettingNextJob\n          .then(this.processJob)\n          .then(processJobs, err => {\n            if (!(this.closing && err.message === 'Connection is closed.')) {\n              utils.emitSafe(this, 'error', err, 'Error processing job');\n\n              //\n              // Wait before trying to process again.\n              //\n              clearTimeout(this.errorRetryTimer[index]);\n              this.errorRetryTimer[index] = setTimeout(() => {\n                processJobs();\n              }, this.settings.retryProcessDelay);\n            }\n            return null;\n          }));\n      })\n      .catch(err => {\n        utils.emitSafe(this, 'error', err, 'Error processing job');\n      });\n  } else {\n    resolve(this.closing);\n  }\n};\n\nQueue.prototype.processJob = function(job, notFetch = false) {\n  let lockRenewId;\n  let timerStopped = false;\n\n  if (!job) {\n    return Promise.resolve();\n  }\n\n  //\n  // There are two cases to take into consideration regarding locks.\n  // 1) The lock renewer fails to renew a lock, this should make this job\n  // unable to complete, since some other worker is also working on it.\n  // 2) The lock renewer is called more seldom than the check for stalled\n  // jobs, so we can assume the job has been stalled and is already being processed\n  // by another worker. See #308\n  //\n  const lockExtender = () => {\n    lockRenewId = this.timers.set(\n      'lockExtender',\n      this.settings.lockRenewTime,\n      () => {\n        scripts\n          .extendLock(this, job.id, this.settings.lockDuration)\n          .then(lock => {\n            if (lock && !timerStopped) {\n              lockExtender();\n            }\n          })\n          .catch(err => {\n            utils.emitSafe(this, 'lock-extension-failed', job, err);\n          });\n      }\n    );\n  };\n\n  const timeoutMs = job.opts.timeout;\n\n  const stopTimer = () => {\n    timerStopped = true;\n    this.timers.clear(lockRenewId);\n  };\n\n  const handleCompleted = result => {\n    return job.moveToCompleted(result, undefined, notFetch).then(jobData => {\n      utils.emitSafe(this, 'completed', job, result, 'active');\n      return jobData ? this.nextJobFromJobData(jobData[0], jobData[1]) : null;\n    });\n  };\n\n  const handleFailed = err => {\n    const error = err;\n\n    return job.moveToFailed(err).then(jobData => {\n      utils.emitSafe(this, 'failed', job, error, 'active');\n      return jobData ? this.nextJobFromJobData(jobData[0], jobData[1]) : null;\n    });\n  };\n\n  lockExtender();\n  const handler = this.handlers[job.name] || this.handlers['*'];\n\n  if (!handler) {\n    return handleFailed(\n      new Error('Missing process handler for job type ' + job.name)\n    );\n  } else {\n    let jobPromise = handler(job);\n\n    if (timeoutMs) {\n      jobPromise = pTimeout(jobPromise, timeoutMs);\n    }\n\n    // Local event with jobPromise so that we can cancel job.\n    utils.emitSafe(this, 'active', job, jobPromise, 'waiting');\n\n    return jobPromise\n      .then(handleCompleted)\n      .catch(handleFailed)\n      .finally(() => {\n        stopTimer();\n      });\n  }\n};\n\nQueue.prototype.multi = function() {\n  return this.client.multi();\n};\n\n/**\n  Returns a promise that resolves to the next job in queue.\n*/\nQueue.prototype.getNextJob = async function() {\n  if (this.closing) {\n    return Promise.resolve();\n  }\n\n  if (this.drained) {\n    //\n    // Waiting for new jobs to arrive\n    //\n    try {\n      this.bclient.blocked = true;\n      const jobId = await this.bclient.brpoplpush(\n        this.keys.wait,\n        this.keys.active,\n        this.settings.drainDelay\n      );\n      this.bclient.blocked = false;\n\n      if (jobId) {\n        return this.moveToActive(jobId);\n      }\n    } catch (err) {\n      // Swallow error if locally paused since we did force a disconnection\n      if (!(this.paused && err.message === 'Connection is closed.')) {\n        throw err;\n      }\n    }\n  } else {\n    return this.moveToActive();\n  }\n};\n\nQueue.prototype.moveToActive = async function(jobId) {\n  // For manual retrieving jobs we need to wait for the queue to be ready.\n  await this.isReady();\n\n  return scripts.moveToActive(this, jobId).then(([jobData, jobId]) => {\n    return this.nextJobFromJobData(jobData, jobId);\n  });\n};\n\nQueue.prototype.nextJobFromJobData = function(jobData, jobId) {\n  if (jobData) {\n    this.drained = false;\n    const job = Job.fromJSON(this, jobData, jobId);\n    if (job.opts.repeat) {\n      return this.nextRepeatableJob(job.name, job.data, job.opts).then(() => {\n        return job;\n      });\n    }\n    return job;\n  } else {\n    this.drained = true;\n    utils.emitSafe(this, 'drained');\n    return null;\n  }\n};\n\nQueue.prototype.retryJob = function(job) {\n  return job.retry();\n};\n\nQueue.prototype.toKey = function(queueType) {\n  return [this.keyPrefix, this.name, queueType].join(':');\n};\n\n/*@function clean\n *\n * Cleans jobs from a queue. Similar to remove but keeps jobs within a certain\n * grace period.\n *\n * @param {int} grace - The grace period\n * @param {string} [type=completed] - The type of job to clean. Possible values are completed, wait, active, paused, delayed, failed. Defaults to completed.\n * @param {int} The max number of jobs to clean\n */\nQueue.prototype.clean = function(grace, type, limit) {\n  return this.isReady().then(() => {\n    if (grace === undefined || grace === null) {\n      throw new Error('You must define a grace period.');\n    }\n\n    if (!type) {\n      type = 'completed';\n    }\n\n    if (\n      _.indexOf(\n        ['completed', 'wait', 'active', 'paused', 'delayed', 'failed'],\n        type\n      ) === -1\n    ) {\n      throw new Error('Cannot clean unknown queue type ' + type);\n    }\n\n    return scripts\n      .cleanJobsInSet(this, type, Date.now() - grace, limit)\n      .then(jobs => {\n        utils.emitSafe(this, 'cleaned', jobs, type);\n        return jobs;\n      })\n      .catch(err => {\n        utils.emitSafe(this, 'error', err);\n        throw err;\n      });\n  });\n};\n\n/* @method obliterate\n *\n * Completely destroys the queue and all of its contents irreversibly.\n * This method will the *pause* the queue and requires that there are no\n * active jobs. It is possible to bypass this requirement, i.e. not\n * having active jobs using the \"force\" option.\n *\n * Note: This operation requires to iterate on all the jobs stored in the queue\n * and can be slow for very large queues.\n *\n * @param { { force: boolean, count: number }} opts. Use force = true to force obliteration even\n * with active jobs in the queue.  Use count with the maximun number of deleted keys per iteration,\n * 1000 is the default.\n */\nQueue.prototype.obliterate = async function(opts) {\n  await this.pause();\n\n  let cursor = 0;\n  do {\n    cursor = await scripts.obliterate(this, {\n      force: false,\n      count: 1000,\n      ...opts\n    });\n  } while (cursor);\n};\n\n/**\n * Returns a promise that resolves when active jobs are finished\n *\n * @returns {Promise}\n */\nQueue.prototype.whenCurrentJobsFinished = function() {\n  if (!this.bclientInitialized) {\n    // bclient not yet initialized, so no jobs to wait for\n    return Promise.resolve();\n  }\n\n  //\n  // Force reconnection of blocking connection to abort blocking redis call immediately.\n  //\n  const forcedReconnection = redisClientDisconnect(this.bclient).then(() => {\n    return this.bclient.connect();\n  });\n\n  return Promise.all(Object.values(this.processing)).then(\n    () => forcedReconnection\n  );\n};\n\n//\n// Private local functions\n//\n\nfunction getRedisVersion(client) {\n  return client.info().then(doc => {\n    const prefix = 'redis_version:';\n    const lines = doc.split('\\r\\n');\n    for (let i = 0; i < lines.length; i++) {\n      if (lines[i].indexOf(prefix) === 0) {\n        return lines[i].substr(prefix.length);\n      }\n    }\n  });\n}\n\nfunction jobIdForGroup(limiter, opts, data) {\n  const jobId = opts && opts.jobId;\n  const groupKey = _.get(limiter, 'groupKey');\n  if (groupKey) {\n    return `${jobId || uuid.v4()}:${_.get(data, groupKey)}`;\n  }\n  return jobId;\n}\n\nmodule.exports = Queue;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvYnVsbC9saWIvcXVldWUuanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWIsY0FBYyxtQkFBTyxDQUFDLDREQUFTO0FBQy9CLHFCQUFxQixtQkFBTyxDQUFDLHNCQUFROztBQUVyQyxVQUFVLG1CQUFPLENBQUMscURBQVE7O0FBRTFCLFdBQVcsbUJBQU8sQ0FBQyxjQUFJO0FBQ3ZCLGFBQWEsbUJBQU8sQ0FBQyxrQkFBTTtBQUMzQixhQUFhLG1CQUFPLENBQUMsa0JBQU07QUFDM0IsWUFBWSxtQkFBTyxDQUFDLGdCQUFLO0FBQ3pCLFlBQVksbUJBQU8sQ0FBQyxtREFBTztBQUMzQixnQkFBZ0IsbUJBQU8sQ0FBQywyREFBVztBQUNuQyxlQUFlLG1CQUFPLENBQUMseURBQVU7QUFDakMsY0FBYyxtQkFBTyxDQUFDLHVEQUFTOztBQUUvQixxQkFBcUIsbUJBQU8sQ0FBQyx1RUFBaUI7QUFDOUMsUUFBUSxZQUFZLEVBQUUsbUJBQU8sQ0FBQyxrQkFBTTtBQUNwQyxRQUFRLFdBQVcsRUFBRSxtQkFBTyxDQUFDLCtEQUFhO0FBQzFDLGVBQWUsbUJBQU8sQ0FBQyxvREFBUTtBQUMvQixpQkFBaUIsa0RBQXdCO0FBQ3pDLGFBQWEsbUJBQU8sQ0FBQyxnRkFBTTs7QUFFM0IsaUJBQWlCLG1CQUFPLENBQUMsa0VBQVk7O0FBRXJDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSw2Q0FBNkM7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0osZ0NBQWdDO0FBQ2hDOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSw4Q0FBOEM7QUFDOUM7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQSxHQUFHOztBQUVIOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLHVDQUF1QztBQUNwRSxVQUFVO0FBQ1Y7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1Qzs7QUFFdkM7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsbUJBQU8sQ0FBQywyREFBVztBQUNuQixtQkFBTyxDQUFDLHlEQUFVO0FBQ2xCLG1CQUFPLENBQUMsaUVBQWM7O0FBRXRCO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPOztBQUVQO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixrQkFBa0I7QUFDcEM7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNULE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLG1CQUFPLENBQUMsaUZBQXNCOztBQUV0RCxvQkFBb0IsbUJBQU8sQ0FBQywyRUFBbUI7QUFDL0M7QUFDQSxJQUFJO0FBQ0o7O0FBRUE7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsb0NBQW9DOztBQUUzRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvREFBb0Q7QUFDcEQ7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QixhQUFhLEdBQUcsR0FBRztBQUNqRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPLGtCQUFrQjtBQUN6Qjs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBLHNCQUFzQixvQkFBb0I7QUFDMUM7QUFDQTs7QUFFQSxzQkFBc0Isb0JBQW9CO0FBQzFDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDO0FBQ2xDO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLFlBQVksR0FBRyxZQUFZO0FBQzNELFdBQVc7QUFDWDtBQUNBOztBQUVBOztBQUVBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxPQUFPO0FBQ1A7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQSxXQUFXO0FBQ1gsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLEtBQUs7QUFDaEIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsS0FBSztBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxpQ0FBaUM7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsSUFBSTtBQUNKOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGtCQUFrQjtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsbUJBQW1CLEdBQUcsc0JBQXNCO0FBQzFEO0FBQ0E7QUFDQTs7QUFFQSIsInNvdXJjZXMiOlsid2VicGFjazovL215LWFwcC8uL25vZGVfbW9kdWxlcy9idWxsL2xpYi9xdWV1ZS5qcz8yYzVkIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuY29uc3QgUmVkaXMgPSByZXF1aXJlKCdpb3JlZGlzJyk7XG5jb25zdCBFdmVudEVtaXR0ZXIgPSByZXF1aXJlKCdldmVudHMnKTtcblxuY29uc3QgXyA9IHJlcXVpcmUoJ2xvZGFzaCcpO1xuXG5jb25zdCBmcyA9IHJlcXVpcmUoJ2ZzJyk7XG5jb25zdCBwYXRoID0gcmVxdWlyZSgncGF0aCcpO1xuY29uc3QgdXRpbCA9IHJlcXVpcmUoJ3V0aWwnKTtcbmNvbnN0IHVybCA9IHJlcXVpcmUoJ3VybCcpO1xuY29uc3QgSm9iID0gcmVxdWlyZSgnLi9qb2InKTtcbmNvbnN0IHNjcmlwdHMgPSByZXF1aXJlKCcuL3NjcmlwdHMnKTtcbmNvbnN0IGVycm9ycyA9IHJlcXVpcmUoJy4vZXJyb3JzJyk7XG5jb25zdCB1dGlscyA9IHJlcXVpcmUoJy4vdXRpbHMnKTtcblxuY29uc3QgVGltZXJNYW5hZ2VyID0gcmVxdWlyZSgnLi90aW1lci1tYW5hZ2VyJyk7XG5jb25zdCB7IHByb21pc2lmeSB9ID0gcmVxdWlyZSgndXRpbCcpO1xuY29uc3QgeyBwVGltZW91dCB9ID0gcmVxdWlyZSgnLi9wLXRpbWVvdXQnKTtcbmNvbnN0IHNlbXZlciA9IHJlcXVpcmUoJ3NlbXZlcicpO1xuY29uc3QgZGVidWdsb2cgPSByZXF1aXJlKCd1dGlsJykuZGVidWdsb2coJ2J1bGwnKTtcbmNvbnN0IHV1aWQgPSByZXF1aXJlKCd1dWlkJyk7XG5cbmNvbnN0IGNvbW1hbmRzID0gcmVxdWlyZSgnLi9zY3JpcHRzLycpO1xuXG4vKipcbiAgR2V0cyBvciBjcmVhdGVzIGEgbmV3IFF1ZXVlIHdpdGggdGhlIGdpdmVuIG5hbWUuXG5cbiAgVGhlIFF1ZXVlIGtlZXBzIDYgZGF0YSBzdHJ1Y3R1cmVzOlxuICAgIC0gd2FpdCAobGlzdClcbiAgICAtIGFjdGl2ZSAobGlzdClcbiAgICAtIGRlbGF5ZWQgKHpzZXQpXG4gICAgLSBwcmlvcml0eSAoenNldClcbiAgICAtIGNvbXBsZXRlZCAoenNldClcbiAgICAtIGZhaWxlZCAoenNldClcblxuICAgICAgICAtLT4gcHJpb3JpdGllcyAgICAgIC0tID4gY29tcGxldGVkXG4gICAgICAgLyAgICAgfCAgICAgICAgICAgIC9cbiAgICBqb2IgLT4gd2FpdCAtPiBhY3RpdmVcbiAgICAgICBcXCAgICAgXiAgICAgICAgICAgIFxcXG4gICAgICAgIHYgICAgfCAgICAgICAgICAgICAtLSA+IGZhaWxlZFxuICAgICAgICBkZWxheWVkXG4qL1xuXG4vKipcbiAgRGVsYXllZCBqb2JzIGFyZSBqb2JzIHRoYXQgY2Fubm90IGJlIGV4ZWN1dGVkIHVudGlsIGEgY2VydGFpbiB0aW1lIGluXG4gIG1zIGhhcyBwYXNzZWQgc2luY2UgdGhleSB3ZXJlIGFkZGVkIHRvIHRoZSBxdWV1ZS5cbiAgVGhlIG1lY2hhbmlzbSBpcyBzaW1wbGUsIGEgZGVsYXllZFRpbWVzdGFtcCB2YXJpYWJsZSBob2xkcyB0aGUgbmV4dFxuICBrbm93biB0aW1lc3RhbXAgdGhhdCBpcyBvbiB0aGUgZGVsYXllZCBzZXQgKG9yIE1BWF9USU1FT1VUX01TIGlmIG5vbmUpLlxuXG4gIFdoZW4gdGhlIGN1cnJlbnQgam9iIGhhcyBmaW5hbGl6ZWQgdGhlIHZhcmlhYmxlIGlzIGNoZWNrZWQsIGlmXG4gIG5vIGRlbGF5ZWQgam9iIGhhcyB0byBiZSBleGVjdXRlZCB5ZXQgYSBzZXRUaW1lb3V0IGlzIHNldCBzbyB0aGF0IGFcbiAgZGVsYXllZCBqb2IgaXMgcHJvY2Vzc2VkIGFmdGVyIHRpbWluZyBvdXQuXG4qL1xuY29uc3QgTUlOSU1VTV9SRURJU19WRVJTSU9OID0gJzIuOC4xOCc7XG5cbi8qXG4gIGludGVyZmFjZSBRdWV1ZU9wdGlvbnMge1xuICAgIHByZWZpeD86IHN0cmluZyA9ICdidWxsJyxcbiAgICBsaW1pdGVyPzogUmF0ZUxpbWl0ZXIsXG4gICAgcmVkaXMgOiBSZWRpc09wdHMsIC8vIGlvcmVkaXMgZGVmYXVsdHMsXG4gICAgY3JlYXRlQ2xpZW50PzogKHR5cGU6IGVudW0oJ2NsaWVudCcsICdzdWJzY3JpYmVyJyksIHJlZGlzT3B0cz86IFJlZGlzT3B0cykgPT4gcmVkaXNDbGllbnQsXG4gICAgZGVmYXVsdEpvYk9wdGlvbnM/OiBKb2JPcHRpb25zLFxuXG4gICAgLy8gQWR2YW5jZWQgc2V0dGluZ3NcbiAgICBzZXR0aW5ncz86IFF1ZXVlU2V0dGluZ3Mge1xuICAgICAgbG9ja0R1cmF0aW9uPzogbnVtYmVyID0gMzAwMDAsXG4gICAgICBsb2NrUmVuZXdUaW1lPzogbnVtYmVyID0gbG9ja0R1cmF0aW9uIC8gMixcbiAgICAgIHN0YWxsZWRJbnRlcnZhbD86IG51bWJlciA9IDMwMDAwLFxuICAgICAgbWF4U3RhbGxlZENvdW50PzogbnVtYmVyID0gMSwgLy8gVGhlIG1heGltdW0gbnVtYmVyIG9mIHRpbWVzIGEgam9iIGNhbiBiZSByZWNvdmVyZWQgZnJvbSB0aGUgJ3N0YWxsZWQnIHN0YXRlXG4gICAgICBndWFyZEludGVydmFsPzogbnVtYmVyID0gNTAwMCxcbiAgICAgIHJldHJ5UHJvY2Vzc0RlbGF5PzogbnVtYmVyID0gNTAwMCxcbiAgICAgIGRyYWluRGVsYXk/OiBudW1iZXIgPSA1XG4gICAgICBpc1NoYXJlZENoaWxkUG9vbD86IGJvb2xlYW4gPSBmYWxzZVxuICAgIH1cbiAgfVxuXG4gIGludGVyZmFjZSBSYXRlTGltaXRlciB7XG4gICAgbWF4OiBudW1iZXIsICAgICAgLy8gTnVtYmVyIG9mIGpvYnNcbiAgICBkdXJhdGlvbjogbnVtYmVyLCAvLyBwZXIgZHVyYXRpb24gbWlsbGlzZWNvbmRzXG4gIH1cbiovXG5cbi8vIFF1ZXVlKG5hbWU6IHN0cmluZywgdXJsPywgb3B0cz8pXG5jb25zdCBRdWV1ZSA9IGZ1bmN0aW9uIFF1ZXVlKG5hbWUsIHVybCwgb3B0cykge1xuICBpZiAoISh0aGlzIGluc3RhbmNlb2YgUXVldWUpKSB7XG4gICAgcmV0dXJuIG5ldyBRdWV1ZShuYW1lLCB1cmwsIG9wdHMpO1xuICB9XG5cbiAgaWYgKF8uaXNTdHJpbmcodXJsKSkge1xuICAgIGNvbnN0IGNsb25lZE9wdHMgPSBfLmNsb25lRGVlcChvcHRzIHx8IHt9KTtcbiAgICBvcHRzID0ge1xuICAgICAgLi4uY2xvbmVkT3B0cyxcbiAgICAgIHJlZGlzOiB7XG4gICAgICAgIC4uLnJlZGlzT3B0c0Zyb21VcmwodXJsKSxcbiAgICAgICAgLi4uY2xvbmVkT3B0cy5yZWRpc1xuICAgICAgfVxuICAgIH07XG4gIH0gZWxzZSB7XG4gICAgb3B0cyA9IF8uY2xvbmVEZWVwKHVybCB8fCB7fSk7XG4gIH1cblxuICBpZiAoIV8uaXNPYmplY3Qob3B0cykpIHtcbiAgICB0aHJvdyBUeXBlRXJyb3IoJ09wdGlvbnMgbXVzdCBiZSBhIHZhbGlkIG9iamVjdCcpO1xuICB9XG5cbiAgaWYgKG9wdHMubGltaXRlcikge1xuICAgIGlmIChvcHRzLmxpbWl0ZXIubWF4ICYmIG9wdHMubGltaXRlci5kdXJhdGlvbikge1xuICAgICAgdGhpcy5saW1pdGVyID0gb3B0cy5saW1pdGVyO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdMaW1pdGVyIHJlcXVpcmVzIGBtYXhgIGFuZCBgZHVyYXRpb25gIG9wdGlvbnMnKTtcbiAgICB9XG4gIH1cblxuICBpZiAob3B0cy5kZWZhdWx0Sm9iT3B0aW9ucykge1xuICAgIHRoaXMuZGVmYXVsdEpvYk9wdGlvbnMgPSBvcHRzLmRlZmF1bHRKb2JPcHRpb25zO1xuICB9XG5cbiAgdGhpcy5uYW1lID0gbmFtZTtcbiAgdGhpcy50b2tlbiA9IHV1aWQudjQoKTtcblxuICBvcHRzLnJlZGlzID0ge1xuICAgIGVuYWJsZVJlYWR5Q2hlY2s6IGZhbHNlLFxuICAgIC4uLihfLmlzU3RyaW5nKG9wdHMucmVkaXMpXG4gICAgICA/IHsgLi4ucmVkaXNPcHRzRnJvbVVybChvcHRzLnJlZGlzKSB9XG4gICAgICA6IG9wdHMucmVkaXMpXG4gIH07XG5cbiAgXy5kZWZhdWx0cyhvcHRzLnJlZGlzLCB7XG4gICAgcG9ydDogNjM3OSxcbiAgICBob3N0OiAnMTI3LjAuMC4xJyxcbiAgICBkYjogb3B0cy5yZWRpcy5kYiB8fCBvcHRzLnJlZGlzLkRCLFxuICAgIHJldHJ5U3RyYXRlZ3k6IGZ1bmN0aW9uKHRpbWVzKSB7XG4gICAgICByZXR1cm4gTWF0aC5taW4oTWF0aC5leHAodGltZXMpLCAyMDAwMCk7XG4gICAgfVxuICB9KTtcblxuICB0aGlzLmtleVByZWZpeCA9IG9wdHMucmVkaXMua2V5UHJlZml4IHx8IG9wdHMucHJlZml4IHx8ICdidWxsJztcblxuICAvL1xuICAvLyBXZSBjYW5ub3QgdXNlIGlvcmVkaXMga2V5UHJlZml4IGZlYXR1cmUgc2luY2Ugd2VcbiAgLy8gY3JlYXRlIGtleXMgZHluYW1pY2FsbHkgaW4gbHVhIHNjcmlwdHMuXG4gIC8vXG4gIGRlbGV0ZSBvcHRzLnJlZGlzLmtleVByZWZpeDtcblxuICB0aGlzLmNsaWVudHMgPSBbXTtcblxuICBjb25zdCBsb2FkQ29tbWFuZHMgPSAocHJvdmlkZWRTY3JpcHRzLCBjbGllbnQpID0+IHtcbiAgICBjb25zdCBmaW5hbFNjcmlwdHMgPSBwcm92aWRlZFNjcmlwdHMgfHwgc2NyaXB0cztcbiAgICBmb3IgKGNvbnN0IHByb3BlcnR5IGluIGZpbmFsU2NyaXB0cykge1xuICAgICAgLy8gT25seSBkZWZpbmUgdGhlIGNvbW1hbmQgaWYgbm90IGFscmVhZHkgZGVmaW5lZFxuICAgICAgaWYgKCFjbGllbnRbZmluYWxTY3JpcHRzW3Byb3BlcnR5XS5uYW1lXSkge1xuICAgICAgICBjbGllbnQuZGVmaW5lQ29tbWFuZChmaW5hbFNjcmlwdHNbcHJvcGVydHldLm5hbWUsIHtcbiAgICAgICAgICBudW1iZXJPZktleXM6IGZpbmFsU2NyaXB0c1twcm9wZXJ0eV0ua2V5cyxcbiAgICAgICAgICBsdWE6IGZpbmFsU2NyaXB0c1twcm9wZXJ0eV0uY29udGVudFxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgY29uc3QgbGF6eUNsaWVudCA9IHJlZGlzQ2xpZW50R2V0dGVyKHRoaXMsIG9wdHMsICh0eXBlLCBjbGllbnQpID0+IHtcbiAgICAvLyBidWJibGUgdXAgUmVkaXMgZXJyb3IgZXZlbnRzXG4gICAgY29uc3QgaGFuZGxlciA9IHRoaXMuZW1pdC5iaW5kKHRoaXMsICdlcnJvcicpO1xuICAgIGNsaWVudC5vbignZXJyb3InLCBoYW5kbGVyKTtcbiAgICB0aGlzLm9uY2UoJ2Nsb3NlJywgKCkgPT4gY2xpZW50LnJlbW92ZUxpc3RlbmVyKCdlcnJvcicsIGhhbmRsZXIpKTtcblxuICAgIGlmICh0eXBlID09PSAnY2xpZW50Jykge1xuICAgICAgdGhpcy5faW5pdGlhbGl6aW5nID0gKGFzeW5jICgpID0+IGxvYWRDb21tYW5kcyhjb21tYW5kcywgY2xpZW50KSkoKS50aGVuKFxuICAgICAgICAoKSA9PiB7XG4gICAgICAgICAgZGVidWdsb2cobmFtZSArICcgcXVldWUgcmVhZHknKTtcbiAgICAgICAgfSxcbiAgICAgICAgZXJyID0+IHtcbiAgICAgICAgICB0aGlzLmVtaXQoJ2Vycm9yJywgbmV3IEVycm9yKCdFcnJvciBpbml0aWFsaXppbmcgTHVhIHNjcmlwdHMnKSk7XG4gICAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgICB9XG4gICAgICApO1xuXG4gICAgICB0aGlzLl9pbml0aWFsaXppbmcuY2F0Y2goKC8qZXJyKi8pID0+IHt9KTtcbiAgICB9XG4gIH0pO1xuXG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKHRoaXMsIHtcbiAgICAvL1xuICAgIC8vIFF1ZXVlIGNsaWVudCAodXNlZCB0byBhZGQgam9icywgcGF1c2UgcXVldWVzLCBldGMpO1xuICAgIC8vXG4gICAgY2xpZW50OiB7XG4gICAgICBnZXQ6IGxhenlDbGllbnQoJ2NsaWVudCcpXG4gICAgfSxcbiAgICAvL1xuICAgIC8vIEV2ZW50IHN1YnNjcmliZXIgY2xpZW50IChyZWNlaXZlIG1lc3NhZ2VzIGZyb20gb3RoZXIgaW5zdGFuY2Ugb2YgdGhlIHF1ZXVlKVxuICAgIC8vXG4gICAgZWNsaWVudDoge1xuICAgICAgZ2V0OiBsYXp5Q2xpZW50KCdzdWJzY3JpYmVyJylcbiAgICB9LFxuICAgIGJjbGllbnQ6IHtcbiAgICAgIGdldDogbGF6eUNsaWVudCgnYmNsaWVudCcpXG4gICAgfVxuICB9KTtcblxuICBpZiAob3B0cy5za2lwVmVyc2lvbkNoZWNrICE9PSB0cnVlKSB7XG4gICAgZ2V0UmVkaXNWZXJzaW9uKHRoaXMuY2xpZW50KVxuICAgICAgLnRoZW4odmVyc2lvbiA9PiB7XG4gICAgICAgIGlmIChzZW12ZXIubHQodmVyc2lvbiwgTUlOSU1VTV9SRURJU19WRVJTSU9OKSkge1xuICAgICAgICAgIHRoaXMuZW1pdChcbiAgICAgICAgICAgICdlcnJvcicsXG4gICAgICAgICAgICBuZXcgRXJyb3IoXG4gICAgICAgICAgICAgICdSZWRpcyB2ZXJzaW9uIG5lZWRzIHRvIGJlIGdyZWF0ZXIgdGhhbiAnICtcbiAgICAgICAgICAgICAgICBNSU5JTVVNX1JFRElTX1ZFUlNJT04gK1xuICAgICAgICAgICAgICAgICcuIEN1cnJlbnQ6ICcgK1xuICAgICAgICAgICAgICAgIHZlcnNpb25cbiAgICAgICAgICAgIClcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICB9KVxuICAgICAgLmNhdGNoKCgvKmVyciovKSA9PiB7XG4gICAgICAgIC8vIElnbm9yZSB0aGlzIGVycm9yLlxuICAgICAgfSk7XG4gIH1cblxuICB0aGlzLmhhbmRsZXJzID0ge307XG4gIHRoaXMuZGVsYXlUaW1lcjtcbiAgdGhpcy5wcm9jZXNzaW5nID0gW107XG4gIHRoaXMucmV0cmlldmluZyA9IDA7XG4gIHRoaXMuZHJhaW5lZCA9IHRydWU7XG5cbiAgdGhpcy5zZXR0aW5ncyA9IF8uZGVmYXVsdHMob3B0cy5zZXR0aW5ncywge1xuICAgIGxvY2tEdXJhdGlvbjogMzAwMDAsXG4gICAgc3RhbGxlZEludGVydmFsOiAzMDAwMCxcbiAgICBtYXhTdGFsbGVkQ291bnQ6IDEsXG4gICAgZ3VhcmRJbnRlcnZhbDogNTAwMCxcbiAgICByZXRyeVByb2Nlc3NEZWxheTogNTAwMCxcbiAgICBkcmFpbkRlbGF5OiA1LFxuICAgIGJhY2tvZmZTdHJhdGVnaWVzOiB7fSxcbiAgICBpc1NoYXJlZENoaWxkUG9vbDogZmFsc2VcbiAgfSk7XG5cbiAgdGhpcy5tZXRyaWNzID0gb3B0cy5tZXRyaWNzO1xuXG4gIHRoaXMuc2V0dGluZ3MubG9ja1JlbmV3VGltZSA9XG4gICAgdGhpcy5zZXR0aW5ncy5sb2NrUmVuZXdUaW1lIHx8IHRoaXMuc2V0dGluZ3MubG9ja0R1cmF0aW9uIC8gMjtcblxuICB0aGlzLm9uKCdlcnJvcicsICgpID0+IHtcbiAgICAvLyBEdW1teSBoYW5kbGVyIHRvIGF2b2lkIHByb2Nlc3MgdG8gZXhpdCB3aXRoIGFuIHVuaGFuZGxlZCBleGNlcHRpb24uXG4gIH0pO1xuXG4gIC8vIGtlZXBzIHRyYWNrIG9mIGFjdGl2ZSB0aW1lcnMuIHVzZWQgYnkgY2xvc2UoKSB0b1xuICAvLyBlbnN1cmUgdGhhdCBkaXNjb25uZWN0KCkgaXMgZGVmZXJyZWQgdW50aWwgYWxsXG4gIC8vIHNjaGVkdWxlZCByZWRpcyBjb21tYW5kcyBoYXZlIGJlZW4gZXhlY3V0ZWRcbiAgdGhpcy50aW1lcnMgPSBuZXcgVGltZXJNYW5hZ2VyKCk7XG5cbiAgLy8gQmluZCB0aGVzZSBtZXRob2RzIHRvIGF2b2lkIGNvbnN0YW50IHJlYmluZGluZyBhbmQvb3IgY3JlYXRpbmcgY2xvc3VyZXNcbiAgLy8gaW4gcHJvY2Vzc0pvYnMgZXRjLlxuICB0aGlzLm1vdmVVbmxvY2tlZEpvYnNUb1dhaXQgPSB0aGlzLm1vdmVVbmxvY2tlZEpvYnNUb1dhaXQuYmluZCh0aGlzKTtcbiAgdGhpcy5wcm9jZXNzSm9iID0gdGhpcy5wcm9jZXNzSm9iLmJpbmQodGhpcyk7XG4gIHRoaXMuZ2V0Sm9iRnJvbUlkID0gSm9iLmZyb21JZC5iaW5kKG51bGwsIHRoaXMpO1xuXG4gIGNvbnN0IGtleXMgPSB7fTtcbiAgXy5lYWNoKFxuICAgIFtcbiAgICAgICcnLFxuICAgICAgJ2FjdGl2ZScsXG4gICAgICAnd2FpdCcsXG4gICAgICAnd2FpdGluZycsXG4gICAgICAncGF1c2VkJyxcbiAgICAgICdyZXN1bWVkJyxcbiAgICAgICdtZXRhLXBhdXNlZCcsXG4gICAgICAnYWN0aXZlJyxcbiAgICAgICdpZCcsXG4gICAgICAnZGVsYXllZCcsXG4gICAgICAncHJpb3JpdHknLFxuICAgICAgJ3N0YWxsZWQtY2hlY2snLFxuICAgICAgJ2NvbXBsZXRlZCcsXG4gICAgICAnZmFpbGVkJyxcbiAgICAgICdzdGFsbGVkJyxcbiAgICAgICdyZXBlYXQnLFxuICAgICAgJ2xpbWl0ZXInLFxuICAgICAgJ2RyYWluZWQnLFxuICAgICAgJ2R1cGxpY2F0ZWQnLFxuICAgICAgJ3Byb2dyZXNzJyxcbiAgICAgICdkZScgLy8gZGVib3VuY2Uga2V5XG4gICAgXSxcbiAgICBrZXkgPT4ge1xuICAgICAga2V5c1trZXldID0gdGhpcy50b0tleShrZXkpO1xuICAgIH1cbiAgKTtcbiAgdGhpcy5rZXlzID0ga2V5cztcbn07XG5cbmZ1bmN0aW9uIHJlZGlzQ2xpZW50R2V0dGVyKHF1ZXVlLCBvcHRpb25zLCBpbml0Q2FsbGJhY2spIHtcbiAgY29uc3QgY3JlYXRlQ2xpZW50ID0gXy5pc0Z1bmN0aW9uKG9wdGlvbnMuY3JlYXRlQ2xpZW50KVxuICAgID8gb3B0aW9ucy5jcmVhdGVDbGllbnRcbiAgICA6IGZ1bmN0aW9uKHR5cGUsIGNvbmZpZykge1xuICAgICAgICBpZiAoWydiY2xpZW50JywgJ3N1YnNjcmliZXInXS5pbmNsdWRlcyh0eXBlKSkge1xuICAgICAgICAgIHJldHVybiBuZXcgUmVkaXMoeyAuLi5jb25maWcsIG1heFJldHJpZXNQZXJSZXF1ZXN0OiBudWxsIH0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiBuZXcgUmVkaXMoY29uZmlnKTtcbiAgICAgICAgfVxuICAgICAgfTtcblxuICBjb25zdCBjb25uZWN0aW9ucyA9IHt9O1xuXG4gIHJldHVybiBmdW5jdGlvbih0eXBlKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgLy8gTWVtb2l6ZWQgY29ubmVjdGlvblxuICAgICAgaWYgKGNvbm5lY3Rpb25zW3R5cGVdICE9IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIGNvbm5lY3Rpb25zW3R5cGVdO1xuICAgICAgfVxuICAgICAgY29uc3QgY2xpZW50T3B0aW9ucyA9IF8uYXNzaWduKHt9LCBvcHRpb25zLnJlZGlzKTtcblxuICAgICAgY29uc3QgY2xpZW50ID0gKGNvbm5lY3Rpb25zW3R5cGVdID0gY3JlYXRlQ2xpZW50KHR5cGUsIGNsaWVudE9wdGlvbnMpKTtcblxuICAgICAgY29uc3Qgb3B0cyA9IGNsaWVudC5vcHRpb25zLnJlZGlzT3B0aW9ucyB8fCBjbGllbnQub3B0aW9ucztcblxuICAgICAgaWYgKFxuICAgICAgICBbJ2JjbGllbnQnLCAnc3Vic2NyaWJlciddLmluY2x1ZGVzKHR5cGUpICYmXG4gICAgICAgIChvcHRzLmVuYWJsZVJlYWR5Q2hlY2sgfHwgb3B0cy5tYXhSZXRyaWVzUGVyUmVxdWVzdClcbiAgICAgICkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoZXJyb3JzLk1lc3NhZ2VzLk1JU1NJTkdfUkVESVNfT1BUUyk7XG4gICAgICB9XG5cbiAgICAgIC8vIFNpbmNlIGNvbm5lY3Rpb25zIGFyZSBsYXppbHkgaW5pdGlhbGl6ZWQsIHdlIGNhbid0IGNoZWNrIHF1ZXVlLmNsaWVudFxuICAgICAgLy8gd2l0aG91dCBpbml0aWFsaXppbmcgYSBjb25uZWN0aW9uLiBTbyBleHBvc2UgYSBib29sZWFuIHdlIGNhbiBzYWZlbHlcbiAgICAgIC8vIHF1ZXJ5LlxuICAgICAgcXVldWVbdHlwZSArICdJbml0aWFsaXplZCddID0gdHJ1ZTtcblxuICAgICAgaWYgKCFvcHRpb25zLmNyZWF0ZUNsaWVudCkge1xuICAgICAgICBxdWV1ZS5jbGllbnRzLnB1c2goY2xpZW50KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBpbml0Q2FsbGJhY2sodHlwZSwgY2xpZW50KSwgY2xpZW50O1xuICAgIH07XG4gIH07XG59XG5cbmZ1bmN0aW9uIHJlZGlzT3B0c0Zyb21VcmwodXJsU3RyaW5nKSB7XG4gIGxldCByZWRpc09wdHMgPSB7fTtcbiAgdHJ5IHtcbiAgICBjb25zdCByZWRpc1VybCA9IHVybC5wYXJzZSh1cmxTdHJpbmcsIHRydWUsIHRydWUpO1xuICAgIHJlZGlzT3B0cy5wb3J0ID0gcGFyc2VJbnQocmVkaXNVcmwucG9ydCB8fCAnNjM3OScsIDEwKTtcbiAgICByZWRpc09wdHMuaG9zdCA9IHJlZGlzVXJsLmhvc3RuYW1lO1xuICAgIHJlZGlzT3B0cy5kYiA9IHJlZGlzVXJsLnBhdGhuYW1lID8gcmVkaXNVcmwucGF0aG5hbWUuc3BsaXQoJy8nKVsxXSA6IDA7XG4gICAgaWYgKHJlZGlzVXJsLmF1dGgpIHtcbiAgICAgIGNvbnN0IGNvbHVtbkluZGV4ID0gcmVkaXNVcmwuYXV0aC5pbmRleE9mKCc6Jyk7XG4gICAgICByZWRpc09wdHMucGFzc3dvcmQgPSByZWRpc1VybC5hdXRoLnNsaWNlKGNvbHVtbkluZGV4ICsgMSk7XG4gICAgICBpZiAoY29sdW1uSW5kZXggPiAwKSB7XG4gICAgICAgIHJlZGlzT3B0cy51c2VybmFtZSA9IHJlZGlzVXJsLmF1dGguc2xpY2UoMCwgY29sdW1uSW5kZXgpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChyZWRpc1VybC5xdWVyeSkge1xuICAgICAgcmVkaXNPcHRzID0geyAuLi5yZWRpc09wdHMsIC4uLnJlZGlzVXJsLnF1ZXJ5IH07XG4gICAgfVxuICB9IGNhdGNoIChlKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGUubWVzc2FnZSk7XG4gIH1cbiAgcmV0dXJuIHJlZGlzT3B0cztcbn1cblxudXRpbC5pbmhlcml0cyhRdWV1ZSwgRXZlbnRFbWl0dGVyKTtcblxuLy9cbi8vIEV4dGVuZCBRdWV1ZSB3aXRoIFwiYXNwZWN0c1wiXG4vL1xucmVxdWlyZSgnLi9nZXR0ZXJzJykoUXVldWUpO1xucmVxdWlyZSgnLi93b3JrZXInKShRdWV1ZSk7XG5yZXF1aXJlKCcuL3JlcGVhdGFibGUnKShRdWV1ZSk7XG5cbi8vIC0tXG5RdWV1ZS5wcm90b3R5cGUub2ZmID0gUXVldWUucHJvdG90eXBlLnJlbW92ZUxpc3RlbmVyO1xuXG5jb25zdCBfb24gPSBRdWV1ZS5wcm90b3R5cGUub247XG5cblF1ZXVlLnByb3RvdHlwZS5vbiA9IGZ1bmN0aW9uKGV2ZW50TmFtZSkge1xuICB0aGlzLl9yZWdpc3RlckV2ZW50KGV2ZW50TmFtZSk7XG4gIHJldHVybiBfb24uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn07XG5cbmNvbnN0IF9vbmNlID0gUXVldWUucHJvdG90eXBlLm9uY2U7XG5cblF1ZXVlLnByb3RvdHlwZS5vbmNlID0gZnVuY3Rpb24oZXZlbnROYW1lKSB7XG4gIHRoaXMuX3JlZ2lzdGVyRXZlbnQoZXZlbnROYW1lKTtcbiAgcmV0dXJuIF9vbmNlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG59O1xuXG5RdWV1ZS5wcm90b3R5cGUuX2luaXRQcm9jZXNzID0gZnVuY3Rpb24oKSB7XG4gIGlmICghdGhpcy5faW5pdGlhbGl6aW5nUHJvY2Vzcykge1xuICAgIC8vXG4gICAgLy8gT25seSBzZXR1cCBsaXN0ZW5lcnMgaWYgLm9uLy5hZGRFdmVudExpc3RlbmVyIGNhbGxlZCwgb3IgcHJvY2VzcyBmdW5jdGlvbiBkZWZpbmVkLlxuICAgIC8vXG4gICAgdGhpcy5kZWxheWVkVGltZXN0YW1wID0gTnVtYmVyLk1BWF9WQUxVRTtcbiAgICB0aGlzLl9pbml0aWFsaXppbmdQcm9jZXNzID0gdGhpcy5pc1JlYWR5KClcbiAgICAgIC50aGVuKCgpID0+IHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3JlZ2lzdGVyRXZlbnQoJ2RlbGF5ZWQnKTtcbiAgICAgIH0pXG4gICAgICAudGhlbigoKSA9PiB7XG4gICAgICAgIHJldHVybiB0aGlzLnVwZGF0ZURlbGF5VGltZXIoKTtcbiAgICAgIH0pO1xuXG4gICAgdGhpcy5lcnJvclJldHJ5VGltZXIgPSB7fTtcbiAgfVxuXG4gIHJldHVybiB0aGlzLl9pbml0aWFsaXppbmdQcm9jZXNzO1xufTtcblxuUXVldWUucHJvdG90eXBlLl9zZXR1cFF1ZXVlRXZlbnRMaXN0ZW5lcnMgPSBmdW5jdGlvbigpIHtcbiAgLypcbiAgICBpZihldmVudE5hbWUgIT09ICdjbGVhbmVkJyAmJiBldmVudE5hbWUgIT09ICdlcnJvcicpe1xuICAgICAgYXJnc1swXSA9IEpvYi5mcm9tSlNPTih0aGlzLCBhcmdzWzBdKTtcbiAgICB9XG4gICovXG5cbiAgY29uc3QgYWN0aXZlS2V5ID0gdGhpcy5rZXlzLmFjdGl2ZTtcbiAgY29uc3Qgc3RhbGxlZEtleSA9IHRoaXMua2V5cy5zdGFsbGVkO1xuICBjb25zdCBwcm9ncmVzc0tleSA9IHRoaXMua2V5cy5wcm9ncmVzcztcbiAgY29uc3QgZGVsYXllZEtleSA9IHRoaXMua2V5cy5kZWxheWVkO1xuICBjb25zdCBwYXVzZWRLZXkgPSB0aGlzLmtleXMucGF1c2VkO1xuICBjb25zdCByZXN1bWVkS2V5ID0gdGhpcy5rZXlzLnJlc3VtZWQ7XG4gIGNvbnN0IHdhaXRpbmdLZXkgPSB0aGlzLmtleXMud2FpdGluZztcbiAgY29uc3QgY29tcGxldGVkS2V5ID0gdGhpcy5rZXlzLmNvbXBsZXRlZDtcbiAgY29uc3QgZmFpbGVkS2V5ID0gdGhpcy5rZXlzLmZhaWxlZDtcbiAgY29uc3QgZHJhaW5lZEtleSA9IHRoaXMua2V5cy5kcmFpbmVkO1xuICBjb25zdCBkdXBsaWNhdGVkS2V5ID0gdGhpcy5rZXlzLmR1cGxpY2F0ZWQ7XG4gIGNvbnN0IGRlYm91bmNlZEtleSA9IHRoaXMua2V5cy5kZSArICdib3VuY2VkJztcblxuICBjb25zdCBwbWVzc2FnZUhhbmRsZXIgPSAocGF0dGVybiwgY2hhbm5lbCwgbWVzc2FnZSkgPT4ge1xuICAgIGNvbnN0IGtleUFuZFRva2VuID0gY2hhbm5lbC5zcGxpdCgnQCcpO1xuICAgIGNvbnN0IGtleSA9IGtleUFuZFRva2VuWzBdO1xuICAgIGNvbnN0IHRva2VuID0ga2V5QW5kVG9rZW5bMV07XG4gICAgc3dpdGNoIChrZXkpIHtcbiAgICAgIGNhc2UgYWN0aXZlS2V5OlxuICAgICAgICB1dGlscy5lbWl0U2FmZSh0aGlzLCAnZ2xvYmFsOmFjdGl2ZScsIG1lc3NhZ2UsICd3YWl0aW5nJyk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSB3YWl0aW5nS2V5OlxuICAgICAgICBpZiAodGhpcy50b2tlbiA9PT0gdG9rZW4pIHtcbiAgICAgICAgICB1dGlscy5lbWl0U2FmZSh0aGlzLCAnd2FpdGluZycsIG1lc3NhZ2UsIG51bGwpO1xuICAgICAgICB9XG4gICAgICAgIHRva2VuICYmIHV0aWxzLmVtaXRTYWZlKHRoaXMsICdnbG9iYWw6d2FpdGluZycsIG1lc3NhZ2UsIG51bGwpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2Ugc3RhbGxlZEtleTpcbiAgICAgICAgaWYgKHRoaXMudG9rZW4gPT09IHRva2VuKSB7XG4gICAgICAgICAgdXRpbHMuZW1pdFNhZmUodGhpcywgJ3N0YWxsZWQnLCBtZXNzYWdlKTtcbiAgICAgICAgfVxuICAgICAgICB1dGlscy5lbWl0U2FmZSh0aGlzLCAnZ2xvYmFsOnN0YWxsZWQnLCBtZXNzYWdlKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIGR1cGxpY2F0ZWRLZXk6XG4gICAgICAgIGlmICh0aGlzLnRva2VuID09PSB0b2tlbikge1xuICAgICAgICAgIHV0aWxzLmVtaXRTYWZlKHRoaXMsICdkdXBsaWNhdGVkJywgbWVzc2FnZSk7XG4gICAgICAgIH1cbiAgICAgICAgdXRpbHMuZW1pdFNhZmUodGhpcywgJ2dsb2JhbDpkdXBsaWNhdGVkJywgbWVzc2FnZSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBkZWJvdW5jZWRLZXk6XG4gICAgICAgIGlmICh0aGlzLnRva2VuID09PSB0b2tlbikge1xuICAgICAgICAgIHV0aWxzLmVtaXRTYWZlKHRoaXMsICdkZWJvdW5jZWQnLCBtZXNzYWdlKTtcbiAgICAgICAgfVxuICAgICAgICB1dGlscy5lbWl0U2FmZSh0aGlzLCAnZ2xvYmFsOmRlYm91bmNlZCcsIG1lc3NhZ2UpO1xuICAgICAgICBicmVhaztcbiAgICB9XG4gIH07XG5cbiAgY29uc3QgbWVzc2FnZUhhbmRsZXIgPSAoY2hhbm5lbCwgbWVzc2FnZSkgPT4ge1xuICAgIGNvbnN0IGtleSA9IGNoYW5uZWwuc3BsaXQoJ0AnKVswXTtcbiAgICBzd2l0Y2ggKGtleSkge1xuICAgICAgY2FzZSBwcm9ncmVzc0tleToge1xuICAgICAgICAvLyBOZXcgd2F5IHRvIHNlbmQgcHJvZ3Jlc3MgbWVzc2FnZSBkYXRhXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgY29uc3QgeyBwcm9ncmVzcywgam9iSWQgfSA9IEpTT04ucGFyc2UobWVzc2FnZSk7XG4gICAgICAgICAgdXRpbHMuZW1pdFNhZmUodGhpcywgJ2dsb2JhbDpwcm9ncmVzcycsIGpvYklkLCBwcm9ncmVzcyk7XG4gICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgIC8vIElmIHdlIGZhaWwgd2Ugc2hvdWxkIHRyeSB0byBwYXJzZSB0aGUgZGF0YSB1c2luZyB0aGUgZGVwcmVjYXRlZCBtZXRob2RcbiAgICAgICAgICBjb25zdCBjb21tYVBvcyA9IG1lc3NhZ2UuaW5kZXhPZignLCcpO1xuICAgICAgICAgIGNvbnN0IGpvYklkID0gbWVzc2FnZS5zdWJzdHJpbmcoMCwgY29tbWFQb3MpO1xuICAgICAgICAgIGNvbnN0IHByb2dyZXNzID0gbWVzc2FnZS5zdWJzdHJpbmcoY29tbWFQb3MgKyAxKTtcbiAgICAgICAgICB1dGlscy5lbWl0U2FmZSh0aGlzLCAnZ2xvYmFsOnByb2dyZXNzJywgam9iSWQsIEpTT04ucGFyc2UocHJvZ3Jlc3MpKTtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGNhc2UgZGVsYXllZEtleToge1xuICAgICAgICBjb25zdCBuZXdEZWxheWVkVGltZXN0YW1wID0gXy5jZWlsKG1lc3NhZ2UpO1xuICAgICAgICBpZiAobmV3RGVsYXllZFRpbWVzdGFtcCA8IHRoaXMuZGVsYXllZFRpbWVzdGFtcCkge1xuICAgICAgICAgIC8vIFRoZSBuZXcgZGVsYXllZCB0aW1lc3RhbXAgaXMgYmVmb3JlIHRoZSBjdXJyZW50bHkgbmV3ZXN0IGtub3duIGRlbGF5ZWQgdGltZXN0YW1wXG4gICAgICAgICAgLy8gQXNzdW1lIHRoaXMgaXMgdGhlIG5ldyBkZWxheWVkIHRpbWVzdGFtcCBhbmQgY2FsbCBgdXBkYXRlRGVsYXlUaW1lcigpYCB0byBwcm9jZXNzIGFueSBkZWxheWVkIGpvYnNcbiAgICAgICAgICAvLyBUaGlzIHdpbGwgYWxzbyB1cGRhdGUgdGhlIGBkZWxheWVkVGltZXN0YW1wYFxuICAgICAgICAgIHRoaXMuZGVsYXllZFRpbWVzdGFtcCA9IG5ld0RlbGF5ZWRUaW1lc3RhbXA7XG5cbiAgICAgICAgICB0aGlzLnVwZGF0ZURlbGF5VGltZXIoKTtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGNhc2UgcGF1c2VkS2V5OlxuICAgICAgY2FzZSByZXN1bWVkS2V5OlxuICAgICAgICB1dGlscy5lbWl0U2FmZSh0aGlzLCAnZ2xvYmFsOicgKyBtZXNzYWdlKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIGNvbXBsZXRlZEtleToge1xuICAgICAgICBjb25zdCBkYXRhID0gSlNPTi5wYXJzZShtZXNzYWdlKTtcbiAgICAgICAgdXRpbHMuZW1pdFNhZmUoXG4gICAgICAgICAgdGhpcyxcbiAgICAgICAgICAnZ2xvYmFsOmNvbXBsZXRlZCcsXG4gICAgICAgICAgZGF0YS5qb2JJZCxcbiAgICAgICAgICBkYXRhLnZhbCxcbiAgICAgICAgICAnYWN0aXZlJ1xuICAgICAgICApO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGNhc2UgZmFpbGVkS2V5OiB7XG4gICAgICAgIGNvbnN0IGRhdGEgPSBKU09OLnBhcnNlKG1lc3NhZ2UpO1xuICAgICAgICB1dGlscy5lbWl0U2FmZSh0aGlzLCAnZ2xvYmFsOmZhaWxlZCcsIGRhdGEuam9iSWQsIGRhdGEudmFsLCAnYWN0aXZlJyk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgY2FzZSBkcmFpbmVkS2V5OlxuICAgICAgICB1dGlscy5lbWl0U2FmZSh0aGlzLCAnZ2xvYmFsOmRyYWluZWQnKTtcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICB9O1xuXG4gIHRoaXMuZWNsaWVudC5vbigncG1lc3NhZ2UnLCBwbWVzc2FnZUhhbmRsZXIpO1xuICB0aGlzLmVjbGllbnQub24oJ21lc3NhZ2UnLCBtZXNzYWdlSGFuZGxlcik7XG5cbiAgdGhpcy5vbmNlKCdjbG9zZScsICgpID0+IHtcbiAgICB0aGlzLmVjbGllbnQucmVtb3ZlTGlzdGVuZXIoJ3BtZXNzYWdlJywgcG1lc3NhZ2VIYW5kbGVyKTtcbiAgICB0aGlzLmVjbGllbnQucmVtb3ZlTGlzdGVuZXIoJ21lc3NhZ2UnLCBtZXNzYWdlSGFuZGxlcik7XG4gIH0pO1xufTtcblxuUXVldWUucHJvdG90eXBlLl9yZWdpc3RlckV2ZW50ID0gZnVuY3Rpb24oZXZlbnROYW1lKSB7XG4gIGNvbnN0IGludGVybmFsRXZlbnRzID0gWyd3YWl0aW5nJywgJ2RlbGF5ZWQnLCAnZHVwbGljYXRlZCcsICdkZWJvdW5jZWQnXTtcblxuICBpZiAoXG4gICAgZXZlbnROYW1lLnN0YXJ0c1dpdGgoJ2dsb2JhbDonKSB8fFxuICAgIGludGVybmFsRXZlbnRzLmluZGV4T2YoZXZlbnROYW1lKSAhPT0gLTFcbiAgKSB7XG4gICAgaWYgKCF0aGlzLnJlZ2lzdGVyZWRFdmVudHMpIHtcbiAgICAgIHRoaXMuX3NldHVwUXVldWVFdmVudExpc3RlbmVycygpO1xuICAgICAgdGhpcy5yZWdpc3RlcmVkRXZlbnRzID0gdGhpcy5yZWdpc3RlcmVkRXZlbnRzIHx8IHt9O1xuICAgIH1cblxuICAgIGNvbnN0IF9ldmVudE5hbWUgPSBldmVudE5hbWUucmVwbGFjZSgnZ2xvYmFsOicsICcnKTtcblxuICAgIGlmICghdGhpcy5yZWdpc3RlcmVkRXZlbnRzW19ldmVudE5hbWVdKSB7XG4gICAgICByZXR1cm4gdXRpbHNcbiAgICAgICAgLmlzUmVkaXNSZWFkeSh0aGlzLmVjbGllbnQpXG4gICAgICAgIC50aGVuKCgpID0+IHtcbiAgICAgICAgICBjb25zdCBjaGFubmVsID0gdGhpcy50b0tleShfZXZlbnROYW1lKTtcbiAgICAgICAgICBpZiAoWydhY3RpdmUnLCAnd2FpdGluZycsICdzdGFsbGVkJywgJ2R1cGxpY2F0ZWQnLCAnZGVib3VuY2VkJ10uaW5kZXhPZihfZXZlbnROYW1lKSAhPT0gLTEpIHtcbiAgICAgICAgICAgIHJldHVybiAodGhpcy5yZWdpc3RlcmVkRXZlbnRzW19ldmVudE5hbWVdID0gdGhpcy5lY2xpZW50LnBzdWJzY3JpYmUoXG4gICAgICAgICAgICAgIGNoYW5uZWwgKyAnKidcbiAgICAgICAgICAgICkpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gKHRoaXMucmVnaXN0ZXJlZEV2ZW50c1tfZXZlbnROYW1lXSA9IHRoaXMuZWNsaWVudC5zdWJzY3JpYmUoXG4gICAgICAgICAgICAgIGNoYW5uZWxcbiAgICAgICAgICAgICkpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSlcbiAgICAgICAgLnRoZW4oKCkgPT4ge1xuICAgICAgICAgIHV0aWxzLmVtaXRTYWZlKHRoaXMsICdyZWdpc3RlcmVkOicgKyBldmVudE5hbWUpO1xuICAgICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHRoaXMucmVnaXN0ZXJlZEV2ZW50c1tfZXZlbnROYW1lXTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpO1xufTtcblxuUXVldWUuRXJyb3JNZXNzYWdlcyA9IGVycm9ycy5NZXNzYWdlcztcblxuUXVldWUucHJvdG90eXBlLmlzUmVhZHkgPSBhc3luYyBmdW5jdGlvbigpIHtcbiAgYXdhaXQgdGhpcy5faW5pdGlhbGl6aW5nO1xuICByZXR1cm4gdGhpcztcbn07XG5cbmFzeW5jIGZ1bmN0aW9uIHJlZGlzQ2xpZW50RGlzY29ubmVjdChjbGllbnQpIHtcbiAgaWYgKGNsaWVudC5zdGF0dXMgIT09ICdlbmQnKSB7XG4gICAgbGV0IF9yZXNvbHZlLCBfcmVqZWN0O1xuICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICBfcmVzb2x2ZSA9IHJlc29sdmU7XG4gICAgICBfcmVqZWN0ID0gcmVqZWN0O1xuICAgICAgY2xpZW50Lm9uY2UoJ2VuZCcsIF9yZXNvbHZlKTtcblxuICAgICAgcFRpbWVvdXQoXG4gICAgICAgIGNsaWVudC5xdWl0KCkuY2F0Y2goZXJyID0+IHtcbiAgICAgICAgICBpZiAoZXJyLm1lc3NhZ2UgIT09ICdDb25uZWN0aW9uIGlzIGNsb3NlZC4nKSB7XG4gICAgICAgICAgICB0aHJvdyBlcnI7XG4gICAgICAgICAgfVxuICAgICAgICB9KSxcbiAgICAgICAgNTAwXG4gICAgICApXG4gICAgICAgIC5jYXRjaCgoKSA9PiB7XG4gICAgICAgICAgLy8gSWdub3JlIHRpbWVvdXQgZXJyb3JcbiAgICAgICAgfSlcbiAgICAgICAgLmZpbmFsbHkoKCkgPT4ge1xuICAgICAgICAgIGNsaWVudC5vbmNlKCdlcnJvcicsIF9yZWplY3QpO1xuXG4gICAgICAgICAgY2xpZW50LmRpc2Nvbm5lY3QoKTtcbiAgICAgICAgICBpZiAoWydjb25uZWN0aW5nJywgJ3JlY29ubmVjdGluZyddLmluY2x1ZGVzKGNsaWVudC5zdGF0dXMpKSB7XG4gICAgICAgICAgICByZXNvbHZlKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9KS5maW5hbGx5KCgpID0+IHtcbiAgICAgIGNsaWVudC5yZW1vdmVMaXN0ZW5lcignZW5kJywgX3Jlc29sdmUpO1xuICAgICAgY2xpZW50LnJlbW92ZUxpc3RlbmVyKCdlcnJvcicsIF9yZWplY3QpO1xuICAgIH0pO1xuICB9XG59XG5cblF1ZXVlLnByb3RvdHlwZS5kaXNjb25uZWN0ID0gYXN5bmMgZnVuY3Rpb24oKSB7XG4gIGF3YWl0IFByb21pc2UuYWxsKFxuICAgIHRoaXMuY2xpZW50cy5tYXAoY2xpZW50ID0+XG4gICAgICBjbGllbnQuYmxvY2tlZCA/IGNsaWVudC5kaXNjb25uZWN0KCkgOiByZWRpc0NsaWVudERpc2Nvbm5lY3QoY2xpZW50KVxuICAgIClcbiAgKTtcbn07XG5cblF1ZXVlLnByb3RvdHlwZS5yZW1vdmVKb2JzID0gZnVuY3Rpb24ocGF0dGVybikge1xuICByZXR1cm4gSm9iLnJlbW92ZSh0aGlzLCBwYXR0ZXJuKTtcbn07XG5cblF1ZXVlLnByb3RvdHlwZS5jbG9zZSA9IGZ1bmN0aW9uKGRvTm90V2FpdEpvYnMpIHtcbiAgbGV0IGlzUmVhZHkgPSB0cnVlO1xuICBpZiAodGhpcy5jbG9zaW5nKSB7XG4gICAgcmV0dXJuIHRoaXMuY2xvc2luZztcbiAgfVxuXG4gIHJldHVybiAodGhpcy5jbG9zaW5nID0gdGhpcy5pc1JlYWR5KClcbiAgICAudGhlbih0aGlzLl9pbml0aWFsaXppbmdQcm9jZXNzKVxuICAgIC5jYXRjaCgoKSA9PiB7XG4gICAgICBpc1JlYWR5ID0gZmFsc2U7XG4gICAgfSlcbiAgICAudGhlbigoKSA9PiBpc1JlYWR5ICYmIHRoaXMucGF1c2UodHJ1ZSwgZG9Ob3RXYWl0Sm9icykpXG4gICAgLmNhdGNoKCgpID0+IHZvaWQgMCkgLy8gSWdub3JlIHBvc3NpYmxlIGVycm9yIGZyb20gcGF1c2VcbiAgICAuZmluYWxseSgoKSA9PiB0aGlzLl9jbGVhclRpbWVycygpKVxuICAgIC50aGVuKCgpID0+IHtcbiAgICAgIGlmICghdGhpcy5jaGlsZFBvb2wpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgY29uc3QgY2xlYW5Qcm9taXNlID0gdGhpcy5jaGlsZFBvb2wuY2xlYW4oKS5jYXRjaCgoKSA9PiB7XG4gICAgICAgIC8vIElnbm9yZSB0aGlzIGVycm9yIGFuZCB0cnkgdG8gY2xvc2UgYW55d2F5LlxuICAgICAgfSk7XG4gICAgICBpZiAoZG9Ob3RXYWl0Sm9icykge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICByZXR1cm4gY2xlYW5Qcm9taXNlO1xuICAgIH0pXG4gICAgLnRoZW4oXG4gICAgICBhc3luYyAoKSA9PiB0aGlzLmRpc2Nvbm5lY3QoKSxcbiAgICAgIGVyciA9PiBjb25zb2xlLmVycm9yKGVycilcbiAgICApXG4gICAgLmZpbmFsbHkoKCkgPT4ge1xuICAgICAgdGhpcy5jbG9zZWQgPSB0cnVlO1xuICAgICAgdXRpbHMuZW1pdFNhZmUodGhpcywgJ2Nsb3NlJyk7XG4gICAgfSkpO1xufTtcblxuUXVldWUucHJvdG90eXBlLl9jbGVhclRpbWVycyA9IGZ1bmN0aW9uKCkge1xuICBfLmVhY2godGhpcy5lcnJvclJldHJ5VGltZXIsIHRpbWVyID0+IHtcbiAgICBjbGVhclRpbWVvdXQodGltZXIpO1xuICB9KTtcbiAgY2xlYXJUaW1lb3V0KHRoaXMuZGVsYXlUaW1lcik7XG4gIGNsZWFySW50ZXJ2YWwodGhpcy5ndWFyZGlhblRpbWVyKTtcbiAgY2xlYXJJbnRlcnZhbCh0aGlzLm1vdmVVbmxvY2tlZEpvYnNUb1dhaXRJbnRlcnZhbCk7XG4gIHRoaXMudGltZXJzLmNsZWFyQWxsKCk7XG4gIHJldHVybiB0aGlzLnRpbWVycy53aGVuSWRsZSgpO1xufTtcblxuLyoqXG4gIFByb2Nlc3NlcyBhIGpvYiBmcm9tIHRoZSBxdWV1ZS4gVGhlIGNhbGxiYWNrIGlzIGNhbGxlZCBmb3IgZXZlcnkgam9iIHRoYXRcbiAgaXMgZGVxdWV1ZWQuXG5cbiAgQG1ldGhvZCBwcm9jZXNzXG4qL1xuUXVldWUucHJvdG90eXBlLnByb2Nlc3MgPSBmdW5jdGlvbihuYW1lLCBjb25jdXJyZW5jeSwgaGFuZGxlcikge1xuICBzd2l0Y2ggKGFyZ3VtZW50cy5sZW5ndGgpIHtcbiAgICBjYXNlIDE6XG4gICAgICBoYW5kbGVyID0gbmFtZTtcbiAgICAgIGNvbmN1cnJlbmN5ID0gMTtcbiAgICAgIG5hbWUgPSBKb2IuREVGQVVMVF9KT0JfTkFNRTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgMjogLy8gKHN0cmluZywgZnVuY3Rpb24pIG9yIChzdHJpbmcsIHN0cmluZykgb3IgKG51bWJlciwgZnVuY3Rpb24pIG9yIChudW1iZXIsIHN0cmluZylcbiAgICAgIGhhbmRsZXIgPSBjb25jdXJyZW5jeTtcbiAgICAgIGlmICh0eXBlb2YgbmFtZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgY29uY3VycmVuY3kgPSAxO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uY3VycmVuY3kgPSBuYW1lO1xuICAgICAgICBuYW1lID0gSm9iLkRFRkFVTFRfSk9CX05BTUU7XG4gICAgICB9XG4gICAgICBicmVhaztcbiAgfVxuXG4gIHRoaXMuc2V0SGFuZGxlcihuYW1lLCBoYW5kbGVyKTtcblxuICByZXR1cm4gdGhpcy5faW5pdFByb2Nlc3MoKS50aGVuKCgpID0+IHtcbiAgICByZXR1cm4gdGhpcy5zdGFydChjb25jdXJyZW5jeSwgbmFtZSk7XG4gIH0pO1xufTtcblxuUXVldWUucHJvdG90eXBlLnN0YXJ0ID0gZnVuY3Rpb24oY29uY3VycmVuY3ksIG5hbWUpIHtcbiAgcmV0dXJuIHRoaXMucnVuKGNvbmN1cnJlbmN5LCBuYW1lKS5jYXRjaChlcnIgPT4ge1xuICAgIHV0aWxzLmVtaXRTYWZlKHRoaXMsICdlcnJvcicsIGVyciwgJ2Vycm9yIHJ1bm5pbmcgcXVldWUnKTtcbiAgICB0aHJvdyBlcnI7XG4gIH0pO1xufTtcblxuUXVldWUucHJvdG90eXBlLnNldEhhbmRsZXIgPSBmdW5jdGlvbihuYW1lLCBoYW5kbGVyKSB7XG4gIGlmICghaGFuZGxlcikge1xuICAgIHRocm93IG5ldyBFcnJvcignQ2Fubm90IHNldCBhbiB1bmRlZmluZWQgaGFuZGxlcicpO1xuICB9XG4gIGlmICh0aGlzLmhhbmRsZXJzW25hbWVdKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdDYW5ub3QgZGVmaW5lIHRoZSBzYW1lIGhhbmRsZXIgdHdpY2UgJyArIG5hbWUpO1xuICB9XG5cbiAgdGhpcy5zZXRXb3JrZXJOYW1lKCk7XG5cbiAgaWYgKHR5cGVvZiBoYW5kbGVyID09PSAnc3RyaW5nJykge1xuICAgIGNvbnN0IHN1cHBvcnRlZEZpbGVUeXBlcyA9IFsnLmpzJywgJy50cycsICcuZmxvdycsICcuY2pzJ107XG4gICAgY29uc3QgcHJvY2Vzc29yRmlsZSA9XG4gICAgICBoYW5kbGVyICtcbiAgICAgIChzdXBwb3J0ZWRGaWxlVHlwZXMuaW5jbHVkZXMocGF0aC5leHRuYW1lKGhhbmRsZXIpKSA/ICcnIDogJy5qcycpO1xuXG4gICAgaWYgKCFmcy5leGlzdHNTeW5jKHByb2Nlc3NvckZpbGUpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ZpbGUgJyArIHByb2Nlc3NvckZpbGUgKyAnIGRvZXMgbm90IGV4aXN0Jyk7XG4gICAgfVxuICAgIGNvbnN0IGlzU2hhcmVkQ2hpbGRQb29sID0gdGhpcy5zZXR0aW5ncy5pc1NoYXJlZENoaWxkUG9vbDtcbiAgICB0aGlzLmNoaWxkUG9vbCA9XG4gICAgICB0aGlzLmNoaWxkUG9vbCB8fCByZXF1aXJlKCcuL3Byb2Nlc3MvY2hpbGQtcG9vbCcpKGlzU2hhcmVkQ2hpbGRQb29sKTtcblxuICAgIGNvbnN0IHNhbmRib3ggPSByZXF1aXJlKCcuL3Byb2Nlc3Mvc2FuZGJveCcpO1xuICAgIHRoaXMuaGFuZGxlcnNbbmFtZV0gPSBzYW5kYm94KGhhbmRsZXIsIHRoaXMuY2hpbGRQb29sKS5iaW5kKHRoaXMpO1xuICB9IGVsc2Uge1xuICAgIGhhbmRsZXIgPSBoYW5kbGVyLmJpbmQodGhpcyk7XG5cbiAgICBpZiAoaGFuZGxlci5sZW5ndGggPiAxKSB7XG4gICAgICB0aGlzLmhhbmRsZXJzW25hbWVdID0gcHJvbWlzaWZ5KGhhbmRsZXIpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmhhbmRsZXJzW25hbWVdID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShoYW5kbGVyLmFwcGx5KG51bGwsIGFyZ3VtZW50cykpO1xuICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QoZXJyKTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9XG4gIH1cbn07XG5cbi8qKlxuaW50ZXJmYWNlIEpvYk9wdGlvbnNcbntcbiAgYXR0ZW1wdHM6IG51bWJlcjtcblxuICByZXBlYXQ6IHtcbiAgICB0ej86IHN0cmluZyxcbiAgICBlbmREYXRlPzogRGF0ZSB8IHN0cmluZyB8IG51bWJlclxuICB9LFxuICBwcmV2ZW50UGFyc2luZ0RhdGE6IGJvb2xlYW47XG59XG4qL1xuXG4vKipcbiAgQWRkcyBhIGpvYiB0byB0aGUgcXVldWUuXG4gIEBtZXRob2QgYWRkXG4gIEBwYXJhbSBkYXRhOiB7fSBDdXN0b20gZGF0YSB0byBzdG9yZSBmb3IgdGhpcyBqb2IuIFNob3VsZCBiZSBKU09OIHNlcmlhbGl6YWJsZS5cbiAgQHBhcmFtIG9wdHM6IEpvYk9wdGlvbnMgT3B0aW9ucyBmb3IgdGhpcyBqb2IuXG4qL1xuUXVldWUucHJvdG90eXBlLmFkZCA9IGZ1bmN0aW9uKG5hbWUsIGRhdGEsIG9wdHMpIHtcbiAgaWYgKHR5cGVvZiBuYW1lICE9PSAnc3RyaW5nJykge1xuICAgIG9wdHMgPSBkYXRhO1xuICAgIGRhdGEgPSBuYW1lO1xuICAgIG5hbWUgPSBKb2IuREVGQVVMVF9KT0JfTkFNRTtcbiAgfVxuICBvcHRzID0gXy5jbG9uZURlZXAoeyAuLi50aGlzLmRlZmF1bHRKb2JPcHRpb25zLCAuLi5vcHRzIH0pO1xuXG4gIG9wdHMuam9iSWQgPSBqb2JJZEZvckdyb3VwKHRoaXMubGltaXRlciwgb3B0cywgZGF0YSk7XG5cbiAgaWYgKG9wdHMucmVwZWF0KSB7XG4gICAgcmV0dXJuIHRoaXMuaXNSZWFkeSgpLnRoZW4oKCkgPT4ge1xuICAgICAgcmV0dXJuIHRoaXMubmV4dFJlcGVhdGFibGVKb2IobmFtZSwgZGF0YSwgb3B0cywgdHJ1ZSk7XG4gICAgfSk7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIEpvYi5jcmVhdGUodGhpcywgbmFtZSwgZGF0YSwgb3B0cyk7XG4gIH1cbn07XG5cbi8qKlxuICogUmV0cnkgYWxsIHRoZSBmYWlsZWQgam9icy5cbiAqXG4gKiBAcGFyYW0gb3B0cy5jb3VudCAtIG51bWJlciB0byBsaW1pdCBob3cgbWFueSBqb2JzIHdpbGwgYmUgbW92ZWQgdG8gd2FpdCBzdGF0dXMgcGVyIGl0ZXJhdGlvblxuICogQHJldHVybnNcbiAqL1xuUXVldWUucHJvdG90eXBlLnJldHJ5Sm9icyA9IGFzeW5jIGZ1bmN0aW9uKG9wdHMgPSB7fSkge1xuICBsZXQgY3Vyc29yID0gMDtcbiAgZG8ge1xuICAgIGN1cnNvciA9IGF3YWl0IHNjcmlwdHMucmV0cnlKb2JzKHRoaXMsIG9wdHMuY291bnQpO1xuICB9IHdoaWxlIChjdXJzb3IpO1xufTtcblxuICAvKipcbiAgICogUmVtb3ZlcyBhIGRlYm91bmNlIGtleS5cbiAgICpcbiAgICogQHBhcmFtIGlkIC0gaWRlbnRpZmllclxuICAgKi9cbiAgUXVldWUucHJvdG90eXBlLnJlbW92ZURlYm91bmNlS2V5ID0gKGlkKSA9PiB7XG4gICAgcmV0dXJuIHRoaXMuY2xpZW50LmRlbChgJHt0aGlzLmtleXMuZGV9OiR7aWR9YCk7XG4gIH1cblxuLyoqXG4gIEFkZHMgYW4gYXJyYXkgb2Ygam9icyB0byB0aGUgcXVldWUuXG4gIEBtZXRob2QgYWRkXG4gIEBwYXJhbSBqb2JzOiBbXSBUaGUgYXJyYXkgb2Ygam9icyB0byBhZGQgdG8gdGhlIHF1ZXVlLiBFYWNoIGpvYiBpcyBkZWZpbmVkIGJ5IDMgcHJvcGVydGllcywgJ25hbWUnLCAnZGF0YScgYW5kICdvcHRzJy4gVGhleSBmb2xsb3cgdGhlIHNhbWUgc2lnbmF0dXJlIGFzICdRdWV1ZS5hZGQnLlxuKi9cblF1ZXVlLnByb3RvdHlwZS5hZGRCdWxrID0gZnVuY3Rpb24oam9icykge1xuICBjb25zdCBkZWNvcmF0ZWRKb2JzID0gam9icy5tYXAoam9iID0+IHtcbiAgICBjb25zdCBqb2JJZCA9IGpvYklkRm9yR3JvdXAodGhpcy5saW1pdGVyLCBqb2Iub3B0cywgam9iLmRhdGEpO1xuICAgIHJldHVybiB7XG4gICAgICAuLi5qb2IsXG4gICAgICBuYW1lOiB0eXBlb2Ygam9iLm5hbWUgIT09ICdzdHJpbmcnID8gSm9iLkRFRkFVTFRfSk9CX05BTUUgOiBqb2IubmFtZSxcbiAgICAgIG9wdHM6IHtcbiAgICAgICAgLi4udGhpcy5kZWZhdWx0Sm9iT3B0aW9ucyxcbiAgICAgICAgLi4uam9iLm9wdHMsXG4gICAgICAgIGpvYklkXG4gICAgICB9XG4gICAgfTtcbiAgfSk7XG4gIHJldHVybiBKb2IuY3JlYXRlQnVsayh0aGlzLCBkZWNvcmF0ZWRKb2JzKTtcbn07XG4vKipcbiAgRW1wdGllcyB0aGUgcXVldWUuXG5cbiAgUmV0dXJucyBhIHByb21pc2UgdGhhdCBpcyByZXNvbHZlZCBhZnRlciB0aGUgb3BlcmF0aW9uIGhhcyBiZWVuIGNvbXBsZXRlZC5cbiAgTm90ZSB0aGF0IGlmIHNvbWUgb3RoZXIgcHJvY2VzcyBpcyBhZGRpbmcgam9icyBhdCB0aGUgc2FtZSB0aW1lIGFzIGVtcHR5aW5nLFxuICB0aGUgcXVldWVzIG1heSBub3QgYmUgcmVhbGx5IGVtcHR5IGFmdGVyIHRoaXMgbWV0aG9kIGhhcyBleGVjdXRlZCBjb21wbGV0ZWx5LlxuICBBbHNvLCBpZiB0aGUgbWV0aG9kIGRvZXMgZXJyb3IgYmV0d2VlbiBlbXB0eWluZyB0aGUgbGlzdHMgYW5kIHJlbW92aW5nIGFsbCB0aGVcbiAgam9icywgdGhlcmUgd2lsbCBiZSB6b21iaWUgam9icyBsZWZ0IGluIHJlZGlzLlxuXG4gIFRPRE86IFVzZSBFVkFMIHRvIG1ha2UgdGhpcyBvcGVyYXRpb24gZnVsbHkgYXRvbWljLlxuKi9cblF1ZXVlLnByb3RvdHlwZS5lbXB0eSA9IGZ1bmN0aW9uKCkge1xuICBjb25zdCBxdWV1ZUtleXMgPSB0aGlzLmtleXM7XG5cbiAgbGV0IG11bHRpID0gdGhpcy5tdWx0aSgpO1xuXG4gIG11bHRpLmxyYW5nZShxdWV1ZUtleXMud2FpdCwgMCwgLTEpO1xuICBtdWx0aS5scmFuZ2UocXVldWVLZXlzLnBhdXNlZCwgMCwgLTEpO1xuICBtdWx0aS5rZXlzKHRoaXMudG9LZXkoJyo6bGltaXRlZCcpKTtcbiAgbXVsdGkuZGVsKFxuICAgIHF1ZXVlS2V5cy53YWl0LFxuICAgIHF1ZXVlS2V5cy5wYXVzZWQsXG4gICAgcXVldWVLZXlzWydtZXRhLXBhdXNlZCddLFxuICAgIHF1ZXVlS2V5cy5kZWxheWVkLFxuICAgIHF1ZXVlS2V5cy5wcmlvcml0eSxcbiAgICBxdWV1ZUtleXMubGltaXRlcixcbiAgICBgJHtxdWV1ZUtleXMubGltaXRlcn06aW5kZXhgXG4gICk7XG5cbiAgcmV0dXJuIG11bHRpLmV4ZWMoKS50aGVuKHJlcyA9PiB7XG4gICAgbGV0IFt3YWl0aW5nLCBwYXVzZWQsIGxpbWl0ZWRdID0gcmVzO1xuXG4gICAgd2FpdGluZyA9IHdhaXRpbmdbMV07XG4gICAgcGF1c2VkID0gcGF1c2VkWzFdO1xuICAgIGxpbWl0ZWQgPSBsaW1pdGVkWzFdO1xuXG4gICAgY29uc3Qgam9iS2V5cyA9IHBhdXNlZC5jb25jYXQod2FpdGluZykubWFwKHRoaXMudG9LZXksIHRoaXMpO1xuXG4gICAgaWYgKGpvYktleXMubGVuZ3RoIHx8IGxpbWl0ZWQubGVuZ3RoKSB7XG4gICAgICBtdWx0aSA9IHRoaXMubXVsdGkoKTtcblxuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBqb2JLZXlzLmxlbmd0aDsgaSArPSAxMDAwMCkge1xuICAgICAgICBtdWx0aS5kZWwuYXBwbHkobXVsdGksIGpvYktleXMuc2xpY2UoaSwgaSArIDEwMDAwKSk7XG4gICAgICB9XG5cbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGltaXRlZC5sZW5ndGg7IGkgKz0gMTAwMDApIHtcbiAgICAgICAgbXVsdGkuZGVsLmFwcGx5KG11bHRpLCBsaW1pdGVkLnNsaWNlKGksIGkgKyAxMDAwMCkpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gbXVsdGkuZXhlYygpO1xuICAgIH1cbiAgfSk7XG59O1xuXG4vKipcbiAgUGF1c2VzIHRoZSBwcm9jZXNzaW5nIG9mIHRoaXMgcXVldWUsIGxvY2FsbHkgaWYgdHJ1ZSBwYXNzZWQsIG90aGVyd2lzZSBnbG9iYWxseS5cblxuICBGb3IgZ2xvYmFsIHBhdXNlLCB3ZSB1c2UgYW4gYXRvbWljIFJFTkFNRSBvcGVyYXRpb24gb24gdGhlIHdhaXQgcXVldWUuIFNpbmNlXG4gIHdlIGhhdmUgYmxvY2tpbmcgY2FsbHMgd2l0aCBCUlBPUExQVVNIIG9uIHRoZSB3YWl0IHF1ZXVlLCBhcyBsb25nIGFzIHRoZSBxdWV1ZVxuICBpcyByZW5hbWVkIHRvICdwYXVzZWQnLCBubyBuZXcgam9icyB3aWxsIGJlIHByb2Nlc3NlZCAodGhlIGN1cnJlbnQgb25lc1xuICB3aWxsIHJ1biB1bnRpbCBmaW5hbGl6ZWQpLlxuXG4gIEFkZGluZyBqb2JzIHJlcXVpcmVzIGEgTFVBIHNjcmlwdCB0byBjaGVjayBmaXJzdCBpZiB0aGUgcGF1c2VkIGxpc3QgZXhpc3RcbiAgYW5kIGluIHRoYXQgY2FzZSBpdCB3aWxsIGFkZCBpdCB0aGVyZSBpbnN0ZWFkIG9mIHRoZSB3YWl0IGxpc3QuXG4qL1xuUXVldWUucHJvdG90eXBlLnBhdXNlID0gZnVuY3Rpb24oaXNMb2NhbCwgZG9Ob3RXYWl0QWN0aXZlKSB7XG4gIHJldHVybiB0aGlzLmlzUmVhZHkoKVxuICAgIC50aGVuKCgpID0+IHtcbiAgICAgIGlmIChpc0xvY2FsKSB7XG4gICAgICAgIGlmICghdGhpcy5wYXVzZWQpIHtcbiAgICAgICAgICB0aGlzLnBhdXNlZCA9IG5ldyBQcm9taXNlKHJlc29sdmUgPT4ge1xuICAgICAgICAgICAgdGhpcy5yZXN1bWVMb2NhbCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICB0aGlzLnBhdXNlZCA9IG51bGw7IC8vIEFsbG93IHBhdXNlIHRvIGJlIGNoZWNrZWQgZXh0ZXJuYWxseSBmb3IgcGF1c2VkIHN0YXRlLlxuICAgICAgICAgICAgICByZXNvbHZlKCk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCF0aGlzLmJjbGllbnRJbml0aWFsaXplZCkge1xuICAgICAgICAgIC8vIGJjbGllbnQgbm90IHlldCBpbml0aWFsaXplZCwgc28gbm8gam9icyB0byB3YWl0IGZvclxuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChkb05vdFdhaXRBY3RpdmUpIHtcbiAgICAgICAgICAvLyBGb3JjZSByZWNvbm5lY3Rpb24gb2YgYmxvY2tpbmcgY29ubmVjdGlvbiB0byBhYm9ydCBibG9ja2luZyByZWRpcyBjYWxsIGltbWVkaWF0ZWx5LlxuICAgICAgICAgIHJldHVybiByZWRpc0NsaWVudERpc2Nvbm5lY3QodGhpcy5iY2xpZW50KS50aGVuKCgpID0+XG4gICAgICAgICAgICB0aGlzLmJjbGllbnQuY29ubmVjdCgpXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy53aGVuQ3VycmVudEpvYnNGaW5pc2hlZCgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHNjcmlwdHMucGF1c2UodGhpcywgdHJ1ZSk7XG4gICAgICB9XG4gICAgfSlcbiAgICAudGhlbigoKSA9PiB7XG4gICAgICByZXR1cm4gdXRpbHMuZW1pdFNhZmUodGhpcywgJ3BhdXNlZCcpO1xuICAgIH0pO1xufTtcblxuUXVldWUucHJvdG90eXBlLnJlc3VtZSA9IGZ1bmN0aW9uKGlzTG9jYWwgLyogT3B0aW9uYWwgKi8pIHtcbiAgcmV0dXJuIHRoaXMuaXNSZWFkeSgpXG4gICAgLnRoZW4oKCkgPT4ge1xuICAgICAgaWYgKGlzTG9jYWwpIHtcbiAgICAgICAgaWYgKHRoaXMucmVzdW1lTG9jYWwpIHtcbiAgICAgICAgICB0aGlzLnJlc3VtZUxvY2FsKCk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBzY3JpcHRzLnBhdXNlKHRoaXMsIGZhbHNlKTtcbiAgICAgIH1cbiAgICB9KVxuICAgIC50aGVuKCgpID0+IHtcbiAgICAgIHV0aWxzLmVtaXRTYWZlKHRoaXMsICdyZXN1bWVkJyk7XG4gICAgfSk7XG59O1xuXG5RdWV1ZS5wcm90b3R5cGUuaXNQYXVzZWQgPSBhc3luYyBmdW5jdGlvbihpc0xvY2FsKSB7XG4gIGlmIChpc0xvY2FsKSB7XG4gICAgcmV0dXJuICEhdGhpcy5wYXVzZWQ7XG4gIH0gZWxzZSB7XG4gICAgYXdhaXQgdGhpcy5pc1JlYWR5KCk7XG4gICAgY29uc3QgbXVsdGkgPSB0aGlzLm11bHRpKCk7XG5cbiAgICBtdWx0aS5leGlzdHModGhpcy5rZXlzWydtZXRhLXBhdXNlZCddKTtcblxuICAgIC8vIEZvciBmb3J3YXJkIGNvbXBhdGliaWxpdHkgd2l0aCBCdWxsTVEuXG4gICAgbXVsdGkuaGV4aXN0cyh0aGlzLnRvS2V5KCdtZXRhJyksICdwYXVzZWQnKTtcblxuICAgIGNvbnN0IFtbLCBpc1BhdXNlZF0sIFssIGlzUGF1c2VkTmV3XV0gPSBhd2FpdCBtdWx0aS5leGVjKCk7XG5cbiAgICByZXR1cm4gISEoaXNQYXVzZWQgfHwgaXNQYXVzZWROZXcpO1xuICB9XG59O1xuXG5RdWV1ZS5wcm90b3R5cGUucnVuID0gZnVuY3Rpb24oY29uY3VycmVuY3ksIGhhbmRsZXJOYW1lKSB7XG4gIGlmICghTnVtYmVyLmlzSW50ZWdlcihjb25jdXJyZW5jeSkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCBzZXQgRmxvYXQgYXMgY29uY3VycmVuY3knKTtcbiAgfVxuICBjb25zdCBwcm9taXNlcyA9IFtdO1xuXG4gIHJldHVybiB0aGlzLmlzUmVhZHkoKVxuICAgIC50aGVuKCgpID0+IHtcbiAgICAgIHJldHVybiB0aGlzLm1vdmVVbmxvY2tlZEpvYnNUb1dhaXQoKTtcbiAgICB9KVxuICAgIC50aGVuKCgpID0+IHtcbiAgICAgIHJldHVybiB1dGlscy5pc1JlZGlzUmVhZHkodGhpcy5iY2xpZW50KTtcbiAgICB9KVxuICAgIC50aGVuKCgpID0+IHtcbiAgICAgIHdoaWxlIChjb25jdXJyZW5jeS0tKSB7XG4gICAgICAgIHByb21pc2VzLnB1c2goXG4gICAgICAgICAgbmV3IFByb21pc2UocmVzb2x2ZSA9PiB7XG4gICAgICAgICAgICB0aGlzLnByb2Nlc3NKb2JzKGAke2hhbmRsZXJOYW1lfToke2NvbmN1cnJlbmN5fWAsIHJlc29sdmUpO1xuICAgICAgICAgIH0pXG4gICAgICAgICk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuc3RhcnRNb3ZlVW5sb2NrZWRKb2JzVG9XYWl0KCk7XG5cbiAgICAgIHJldHVybiBQcm9taXNlLmFsbChwcm9taXNlcyk7XG4gICAgfSk7XG59O1xuXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbi8vIFByaXZhdGUgbWV0aG9kc1xuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbi8qKlxuICBUaGlzIGZ1bmN0aW9uIHVwZGF0ZXMgdGhlIGRlbGF5IHRpbWVyLCB3aGljaCBpcyBhIHRpbWVyIHRoYXQgdGltZW91dHNcbiAgYXQgdGhlIG5leHQga25vd24gZGVsYXllZCBqb2IuXG4qL1xuUXVldWUucHJvdG90eXBlLnVwZGF0ZURlbGF5VGltZXIgPSBmdW5jdGlvbigpIHtcbiAgaWYgKHRoaXMuY2xvc2luZykge1xuICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoKTtcbiAgfVxuXG4gIHJldHVybiBzY3JpcHRzXG4gICAgLnVwZGF0ZURlbGF5U2V0KHRoaXMsIERhdGUubm93KCkpXG4gICAgLnRoZW4obmV4dFRpbWVzdGFtcCA9PiB7XG4gICAgICB0aGlzLmRlbGF5ZWRUaW1lc3RhbXAgPSBuZXh0VGltZXN0YW1wXG4gICAgICAgID8gbmV4dFRpbWVzdGFtcCAvIDQwOTZcbiAgICAgICAgOiBOdW1iZXIuTUFYX1ZBTFVFO1xuXG4gICAgICAvLyBDbGVhciBhbnkgZXhpc3RpbmcgdXBkYXRlIGRlbGF5IHRpbWVyXG4gICAgICBpZiAodGhpcy5kZWxheVRpbWVyKSB7XG4gICAgICAgIGNsZWFyVGltZW91dCh0aGlzLmRlbGF5VGltZXIpO1xuICAgICAgfVxuXG4gICAgICAvLyBEZWxheSBmb3IgdGhlIG5leHQgdXBkYXRlIG9mIGRlbGF5IHNldFxuICAgICAgY29uc3QgZGVsYXkgPSBfLm1pbihbXG4gICAgICAgIHRoaXMuZGVsYXllZFRpbWVzdGFtcCAtIERhdGUubm93KCksXG4gICAgICAgIHRoaXMuc2V0dGluZ3MuZ3VhcmRJbnRlcnZhbFxuICAgICAgXSk7XG5cbiAgICAgIC8vIFNjaGVkdWxlIG5leHQgcHJvY2Vzc2luZyBvZiB0aGUgZGVsYXllZCBqb2JzXG4gICAgICBpZiAoZGVsYXkgPD0gMCkge1xuICAgICAgICAvLyBOZXh0IHNldCBvZiBqb2JzIGFyZSBkdWUgcmlnaHQgbm93LCBwcm9jZXNzIHRoZW0gYWxzb1xuICAgICAgICB0aGlzLnVwZGF0ZURlbGF5VGltZXIoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIFVwZGF0ZSB0aGUgZGVsYXkgc2V0IHdoZW4gdGhlIG5leHQgam9iIGlzIGR1ZVxuICAgICAgICAvLyBvciB0aGUgbmV4dCBndWFyZCB0aW1lXG4gICAgICAgIHRoaXMuZGVsYXlUaW1lciA9IHNldFRpbWVvdXQoKCkgPT4gdGhpcy51cGRhdGVEZWxheVRpbWVyKCksIGRlbGF5KTtcbiAgICAgIH1cblxuICAgICAgLy8gU2lsZW5jZSB3YXJuaW5ncyBhYm91dCBwcm9taXNlIGNyZWF0ZWQgYnV0IG5vdCByZXR1cm5lZC5cbiAgICAgIC8vIFRoaXMgaXNuJ3QgYW4gaXNzdWUgc2luY2Ugd2UgZW1pdCBlcnJvcnMuXG4gICAgICAvLyBTZWUgaHR0cDovL2JsdWViaXJkanMuY29tL2RvY3Mvd2FybmluZy1leHBsYW5hdGlvbnMuaHRtbCN3YXJuaW5nLWEtcHJvbWlzZS13YXMtY3JlYXRlZC1pbi1hLWhhbmRsZXItYnV0LXdhcy1ub3QtcmV0dXJuZWQtZnJvbS1pdFxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfSlcbiAgICAuY2F0Y2goZXJyID0+IHtcbiAgICAgIHV0aWxzLmVtaXRTYWZlKHRoaXMsICdlcnJvcicsIGVyciwgJ0Vycm9yIHVwZGF0aW5nIHRoZSBkZWxheSB0aW1lcicpO1xuICAgICAgaWYgKHRoaXMuZGVsYXlUaW1lcikge1xuICAgICAgICBjbGVhclRpbWVvdXQodGhpcy5kZWxheVRpbWVyKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5kZWxheVRpbWVyID0gc2V0VGltZW91dChcbiAgICAgICAgKCkgPT4gdGhpcy51cGRhdGVEZWxheVRpbWVyKCksXG4gICAgICAgIHRoaXMuc2V0dGluZ3MuZ3VhcmRJbnRlcnZhbFxuICAgICAgKTtcbiAgICB9KTtcbn07XG5cbi8qKlxuICogUHJvY2VzcyBqb2JzIHRoYXQgaGF2ZSBiZWVuIGFkZGVkIHRvIHRoZSBhY3RpdmUgbGlzdCBidXQgYXJlIG5vdCBiZWluZ1xuICogcHJvY2Vzc2VkIHByb3Blcmx5LiBUaGlzIGNhbiBoYXBwZW4gZHVlIHRvIGEgcHJvY2VzcyBjcmFzaCBpbiB0aGUgbWlkZGxlXG4gKiBvZiBwcm9jZXNzaW5nIGEgam9iLCBsZWF2aW5nIGl0IGluICdhY3RpdmUnIGJ1dCB3aXRob3V0IGEgam9iIGxvY2suXG4gKi9cblF1ZXVlLnByb3RvdHlwZS5tb3ZlVW5sb2NrZWRKb2JzVG9XYWl0ID0gZnVuY3Rpb24oKSB7XG4gIGlmICh0aGlzLmNsb3NpbmcpIHtcbiAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCk7XG4gIH1cblxuICByZXR1cm4gc2NyaXB0c1xuICAgIC5tb3ZlVW5sb2NrZWRKb2JzVG9XYWl0KHRoaXMpXG4gICAgLnRoZW4oKFtmYWlsZWQsIHN0YWxsZWRdKSA9PiB7XG4gICAgICBjb25zdCBoYW5kbGVGYWlsZWRKb2JzID0gZmFpbGVkLm1hcChqb2JJZCA9PiB7XG4gICAgICAgIHJldHVybiB0aGlzLmdldEpvYkZyb21JZChqb2JJZCkudGhlbihqb2IgPT4ge1xuICAgICAgICAgIHV0aWxzLmVtaXRTYWZlKFxuICAgICAgICAgICAgdGhpcyxcbiAgICAgICAgICAgICdmYWlsZWQnLFxuICAgICAgICAgICAgam9iLFxuICAgICAgICAgICAgbmV3IEVycm9yKCdqb2Igc3RhbGxlZCBtb3JlIHRoYW4gYWxsb3dhYmxlIGxpbWl0JyksXG4gICAgICAgICAgICAnYWN0aXZlJ1xuICAgICAgICAgICk7XG4gICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgICBjb25zdCBoYW5kbGVTdGFsbGVkSm9icyA9IHN0YWxsZWQubWFwKGpvYklkID0+IHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0Sm9iRnJvbUlkKGpvYklkKS50aGVuKGpvYiA9PiB7XG4gICAgICAgICAgLy8gRG8gbm90IGVtaXQgdGhlIGV2ZW50IGlmIHRoZSBqb2Igd2FzIGNvbXBsZXRlZCBieSBhbm90aGVyIHdvcmtlclxuICAgICAgICAgIGlmIChqb2IgIT09IG51bGwpIHtcbiAgICAgICAgICAgIHV0aWxzLmVtaXRTYWZlKHRoaXMsICdzdGFsbGVkJywgam9iKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgICByZXR1cm4gUHJvbWlzZS5hbGwoaGFuZGxlRmFpbGVkSm9icy5jb25jYXQoaGFuZGxlU3RhbGxlZEpvYnMpKTtcbiAgICB9KVxuICAgIC5jYXRjaChlcnIgPT4ge1xuICAgICAgdXRpbHMuZW1pdFNhZmUoXG4gICAgICAgIHRoaXMsXG4gICAgICAgICdlcnJvcicsXG4gICAgICAgIGVycixcbiAgICAgICAgJ0ZhaWxlZCB0byBoYW5kbGUgdW5sb2NrZWQgam9iIGluIGFjdGl2ZSdcbiAgICAgICk7XG4gICAgfSk7XG59O1xuXG5RdWV1ZS5wcm90b3R5cGUuc3RhcnRNb3ZlVW5sb2NrZWRKb2JzVG9XYWl0ID0gZnVuY3Rpb24oKSB7XG4gIGNsZWFySW50ZXJ2YWwodGhpcy5tb3ZlVW5sb2NrZWRKb2JzVG9XYWl0SW50ZXJ2YWwpO1xuICBpZiAodGhpcy5zZXR0aW5ncy5zdGFsbGVkSW50ZXJ2YWwgPiAwICYmICF0aGlzLmNsb3NpbmcpIHtcbiAgICB0aGlzLm1vdmVVbmxvY2tlZEpvYnNUb1dhaXRJbnRlcnZhbCA9IHNldEludGVydmFsKFxuICAgICAgdGhpcy5tb3ZlVW5sb2NrZWRKb2JzVG9XYWl0LFxuICAgICAgdGhpcy5zZXR0aW5ncy5zdGFsbGVkSW50ZXJ2YWxcbiAgICApO1xuICB9XG59O1xuXG4vKlxuICBQcm9jZXNzIGpvYnMuIE5vdGUgbGFzdCBhcmd1bWVudCAnam9iJyBpcyBvcHRpb25hbC5cbiovXG5RdWV1ZS5wcm90b3R5cGUucHJvY2Vzc0pvYnMgPSBmdW5jdGlvbihpbmRleCwgcmVzb2x2ZSwgam9iKSB7XG4gIGNvbnN0IHByb2Nlc3NKb2JzID0gdGhpcy5wcm9jZXNzSm9icy5iaW5kKHRoaXMsIGluZGV4LCByZXNvbHZlKTtcbiAgcHJvY2Vzcy5uZXh0VGljaygoKSA9PiB7XG4gICAgdGhpcy5fcHJvY2Vzc0pvYk9uTmV4dFRpY2socHJvY2Vzc0pvYnMsIGluZGV4LCByZXNvbHZlLCBqb2IpO1xuICB9KTtcbn07XG5cblF1ZXVlLnByb3RvdHlwZS5fcHJvY2Vzc0pvYk9uTmV4dFRpY2sgPSBmdW5jdGlvbihcbiAgcHJvY2Vzc0pvYnMsXG4gIGluZGV4LFxuICByZXNvbHZlLFxuICBqb2Jcbikge1xuICBpZiAoIXRoaXMuY2xvc2luZykge1xuICAgICh0aGlzLnBhdXNlZCB8fCBQcm9taXNlLnJlc29sdmUoKSlcbiAgICAgIC50aGVuKCgpID0+IHtcbiAgICAgICAgY29uc3QgZ2V0dGluZ05leHRKb2IgPSBqb2IgPyBQcm9taXNlLnJlc29sdmUoam9iKSA6IHRoaXMuZ2V0TmV4dEpvYigpO1xuXG4gICAgICAgIHJldHVybiAodGhpcy5wcm9jZXNzaW5nW2luZGV4XSA9IGdldHRpbmdOZXh0Sm9iXG4gICAgICAgICAgLnRoZW4odGhpcy5wcm9jZXNzSm9iKVxuICAgICAgICAgIC50aGVuKHByb2Nlc3NKb2JzLCBlcnIgPT4ge1xuICAgICAgICAgICAgaWYgKCEodGhpcy5jbG9zaW5nICYmIGVyci5tZXNzYWdlID09PSAnQ29ubmVjdGlvbiBpcyBjbG9zZWQuJykpIHtcbiAgICAgICAgICAgICAgdXRpbHMuZW1pdFNhZmUodGhpcywgJ2Vycm9yJywgZXJyLCAnRXJyb3IgcHJvY2Vzc2luZyBqb2InKTtcblxuICAgICAgICAgICAgICAvL1xuICAgICAgICAgICAgICAvLyBXYWl0IGJlZm9yZSB0cnlpbmcgdG8gcHJvY2VzcyBhZ2Fpbi5cbiAgICAgICAgICAgICAgLy9cbiAgICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHRoaXMuZXJyb3JSZXRyeVRpbWVyW2luZGV4XSk7XG4gICAgICAgICAgICAgIHRoaXMuZXJyb3JSZXRyeVRpbWVyW2luZGV4XSA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgICAgIHByb2Nlc3NKb2JzKCk7XG4gICAgICAgICAgICAgIH0sIHRoaXMuc2V0dGluZ3MucmV0cnlQcm9jZXNzRGVsYXkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgfSkpO1xuICAgICAgfSlcbiAgICAgIC5jYXRjaChlcnIgPT4ge1xuICAgICAgICB1dGlscy5lbWl0U2FmZSh0aGlzLCAnZXJyb3InLCBlcnIsICdFcnJvciBwcm9jZXNzaW5nIGpvYicpO1xuICAgICAgfSk7XG4gIH0gZWxzZSB7XG4gICAgcmVzb2x2ZSh0aGlzLmNsb3NpbmcpO1xuICB9XG59O1xuXG5RdWV1ZS5wcm90b3R5cGUucHJvY2Vzc0pvYiA9IGZ1bmN0aW9uKGpvYiwgbm90RmV0Y2ggPSBmYWxzZSkge1xuICBsZXQgbG9ja1JlbmV3SWQ7XG4gIGxldCB0aW1lclN0b3BwZWQgPSBmYWxzZTtcblxuICBpZiAoIWpvYikge1xuICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoKTtcbiAgfVxuXG4gIC8vXG4gIC8vIFRoZXJlIGFyZSB0d28gY2FzZXMgdG8gdGFrZSBpbnRvIGNvbnNpZGVyYXRpb24gcmVnYXJkaW5nIGxvY2tzLlxuICAvLyAxKSBUaGUgbG9jayByZW5ld2VyIGZhaWxzIHRvIHJlbmV3IGEgbG9jaywgdGhpcyBzaG91bGQgbWFrZSB0aGlzIGpvYlxuICAvLyB1bmFibGUgdG8gY29tcGxldGUsIHNpbmNlIHNvbWUgb3RoZXIgd29ya2VyIGlzIGFsc28gd29ya2luZyBvbiBpdC5cbiAgLy8gMikgVGhlIGxvY2sgcmVuZXdlciBpcyBjYWxsZWQgbW9yZSBzZWxkb20gdGhhbiB0aGUgY2hlY2sgZm9yIHN0YWxsZWRcbiAgLy8gam9icywgc28gd2UgY2FuIGFzc3VtZSB0aGUgam9iIGhhcyBiZWVuIHN0YWxsZWQgYW5kIGlzIGFscmVhZHkgYmVpbmcgcHJvY2Vzc2VkXG4gIC8vIGJ5IGFub3RoZXIgd29ya2VyLiBTZWUgIzMwOFxuICAvL1xuICBjb25zdCBsb2NrRXh0ZW5kZXIgPSAoKSA9PiB7XG4gICAgbG9ja1JlbmV3SWQgPSB0aGlzLnRpbWVycy5zZXQoXG4gICAgICAnbG9ja0V4dGVuZGVyJyxcbiAgICAgIHRoaXMuc2V0dGluZ3MubG9ja1JlbmV3VGltZSxcbiAgICAgICgpID0+IHtcbiAgICAgICAgc2NyaXB0c1xuICAgICAgICAgIC5leHRlbmRMb2NrKHRoaXMsIGpvYi5pZCwgdGhpcy5zZXR0aW5ncy5sb2NrRHVyYXRpb24pXG4gICAgICAgICAgLnRoZW4obG9jayA9PiB7XG4gICAgICAgICAgICBpZiAobG9jayAmJiAhdGltZXJTdG9wcGVkKSB7XG4gICAgICAgICAgICAgIGxvY2tFeHRlbmRlcigpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pXG4gICAgICAgICAgLmNhdGNoKGVyciA9PiB7XG4gICAgICAgICAgICB1dGlscy5lbWl0U2FmZSh0aGlzLCAnbG9jay1leHRlbnNpb24tZmFpbGVkJywgam9iLCBlcnIpO1xuICAgICAgICAgIH0pO1xuICAgICAgfVxuICAgICk7XG4gIH07XG5cbiAgY29uc3QgdGltZW91dE1zID0gam9iLm9wdHMudGltZW91dDtcblxuICBjb25zdCBzdG9wVGltZXIgPSAoKSA9PiB7XG4gICAgdGltZXJTdG9wcGVkID0gdHJ1ZTtcbiAgICB0aGlzLnRpbWVycy5jbGVhcihsb2NrUmVuZXdJZCk7XG4gIH07XG5cbiAgY29uc3QgaGFuZGxlQ29tcGxldGVkID0gcmVzdWx0ID0+IHtcbiAgICByZXR1cm4gam9iLm1vdmVUb0NvbXBsZXRlZChyZXN1bHQsIHVuZGVmaW5lZCwgbm90RmV0Y2gpLnRoZW4oam9iRGF0YSA9PiB7XG4gICAgICB1dGlscy5lbWl0U2FmZSh0aGlzLCAnY29tcGxldGVkJywgam9iLCByZXN1bHQsICdhY3RpdmUnKTtcbiAgICAgIHJldHVybiBqb2JEYXRhID8gdGhpcy5uZXh0Sm9iRnJvbUpvYkRhdGEoam9iRGF0YVswXSwgam9iRGF0YVsxXSkgOiBudWxsO1xuICAgIH0pO1xuICB9O1xuXG4gIGNvbnN0IGhhbmRsZUZhaWxlZCA9IGVyciA9PiB7XG4gICAgY29uc3QgZXJyb3IgPSBlcnI7XG5cbiAgICByZXR1cm4gam9iLm1vdmVUb0ZhaWxlZChlcnIpLnRoZW4oam9iRGF0YSA9PiB7XG4gICAgICB1dGlscy5lbWl0U2FmZSh0aGlzLCAnZmFpbGVkJywgam9iLCBlcnJvciwgJ2FjdGl2ZScpO1xuICAgICAgcmV0dXJuIGpvYkRhdGEgPyB0aGlzLm5leHRKb2JGcm9tSm9iRGF0YShqb2JEYXRhWzBdLCBqb2JEYXRhWzFdKSA6IG51bGw7XG4gICAgfSk7XG4gIH07XG5cbiAgbG9ja0V4dGVuZGVyKCk7XG4gIGNvbnN0IGhhbmRsZXIgPSB0aGlzLmhhbmRsZXJzW2pvYi5uYW1lXSB8fCB0aGlzLmhhbmRsZXJzWycqJ107XG5cbiAgaWYgKCFoYW5kbGVyKSB7XG4gICAgcmV0dXJuIGhhbmRsZUZhaWxlZChcbiAgICAgIG5ldyBFcnJvcignTWlzc2luZyBwcm9jZXNzIGhhbmRsZXIgZm9yIGpvYiB0eXBlICcgKyBqb2IubmFtZSlcbiAgICApO1xuICB9IGVsc2Uge1xuICAgIGxldCBqb2JQcm9taXNlID0gaGFuZGxlcihqb2IpO1xuXG4gICAgaWYgKHRpbWVvdXRNcykge1xuICAgICAgam9iUHJvbWlzZSA9IHBUaW1lb3V0KGpvYlByb21pc2UsIHRpbWVvdXRNcyk7XG4gICAgfVxuXG4gICAgLy8gTG9jYWwgZXZlbnQgd2l0aCBqb2JQcm9taXNlIHNvIHRoYXQgd2UgY2FuIGNhbmNlbCBqb2IuXG4gICAgdXRpbHMuZW1pdFNhZmUodGhpcywgJ2FjdGl2ZScsIGpvYiwgam9iUHJvbWlzZSwgJ3dhaXRpbmcnKTtcblxuICAgIHJldHVybiBqb2JQcm9taXNlXG4gICAgICAudGhlbihoYW5kbGVDb21wbGV0ZWQpXG4gICAgICAuY2F0Y2goaGFuZGxlRmFpbGVkKVxuICAgICAgLmZpbmFsbHkoKCkgPT4ge1xuICAgICAgICBzdG9wVGltZXIoKTtcbiAgICAgIH0pO1xuICB9XG59O1xuXG5RdWV1ZS5wcm90b3R5cGUubXVsdGkgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHRoaXMuY2xpZW50Lm11bHRpKCk7XG59O1xuXG4vKipcbiAgUmV0dXJucyBhIHByb21pc2UgdGhhdCByZXNvbHZlcyB0byB0aGUgbmV4dCBqb2IgaW4gcXVldWUuXG4qL1xuUXVldWUucHJvdG90eXBlLmdldE5leHRKb2IgPSBhc3luYyBmdW5jdGlvbigpIHtcbiAgaWYgKHRoaXMuY2xvc2luZykge1xuICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoKTtcbiAgfVxuXG4gIGlmICh0aGlzLmRyYWluZWQpIHtcbiAgICAvL1xuICAgIC8vIFdhaXRpbmcgZm9yIG5ldyBqb2JzIHRvIGFycml2ZVxuICAgIC8vXG4gICAgdHJ5IHtcbiAgICAgIHRoaXMuYmNsaWVudC5ibG9ja2VkID0gdHJ1ZTtcbiAgICAgIGNvbnN0IGpvYklkID0gYXdhaXQgdGhpcy5iY2xpZW50LmJycG9wbHB1c2goXG4gICAgICAgIHRoaXMua2V5cy53YWl0LFxuICAgICAgICB0aGlzLmtleXMuYWN0aXZlLFxuICAgICAgICB0aGlzLnNldHRpbmdzLmRyYWluRGVsYXlcbiAgICAgICk7XG4gICAgICB0aGlzLmJjbGllbnQuYmxvY2tlZCA9IGZhbHNlO1xuXG4gICAgICBpZiAoam9iSWQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubW92ZVRvQWN0aXZlKGpvYklkKTtcbiAgICAgIH1cbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIC8vIFN3YWxsb3cgZXJyb3IgaWYgbG9jYWxseSBwYXVzZWQgc2luY2Ugd2UgZGlkIGZvcmNlIGEgZGlzY29ubmVjdGlvblxuICAgICAgaWYgKCEodGhpcy5wYXVzZWQgJiYgZXJyLm1lc3NhZ2UgPT09ICdDb25uZWN0aW9uIGlzIGNsb3NlZC4nKSkge1xuICAgICAgICB0aHJvdyBlcnI7XG4gICAgICB9XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHJldHVybiB0aGlzLm1vdmVUb0FjdGl2ZSgpO1xuICB9XG59O1xuXG5RdWV1ZS5wcm90b3R5cGUubW92ZVRvQWN0aXZlID0gYXN5bmMgZnVuY3Rpb24oam9iSWQpIHtcbiAgLy8gRm9yIG1hbnVhbCByZXRyaWV2aW5nIGpvYnMgd2UgbmVlZCB0byB3YWl0IGZvciB0aGUgcXVldWUgdG8gYmUgcmVhZHkuXG4gIGF3YWl0IHRoaXMuaXNSZWFkeSgpO1xuXG4gIHJldHVybiBzY3JpcHRzLm1vdmVUb0FjdGl2ZSh0aGlzLCBqb2JJZCkudGhlbigoW2pvYkRhdGEsIGpvYklkXSkgPT4ge1xuICAgIHJldHVybiB0aGlzLm5leHRKb2JGcm9tSm9iRGF0YShqb2JEYXRhLCBqb2JJZCk7XG4gIH0pO1xufTtcblxuUXVldWUucHJvdG90eXBlLm5leHRKb2JGcm9tSm9iRGF0YSA9IGZ1bmN0aW9uKGpvYkRhdGEsIGpvYklkKSB7XG4gIGlmIChqb2JEYXRhKSB7XG4gICAgdGhpcy5kcmFpbmVkID0gZmFsc2U7XG4gICAgY29uc3Qgam9iID0gSm9iLmZyb21KU09OKHRoaXMsIGpvYkRhdGEsIGpvYklkKTtcbiAgICBpZiAoam9iLm9wdHMucmVwZWF0KSB7XG4gICAgICByZXR1cm4gdGhpcy5uZXh0UmVwZWF0YWJsZUpvYihqb2IubmFtZSwgam9iLmRhdGEsIGpvYi5vcHRzKS50aGVuKCgpID0+IHtcbiAgICAgICAgcmV0dXJuIGpvYjtcbiAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gam9iO1xuICB9IGVsc2Uge1xuICAgIHRoaXMuZHJhaW5lZCA9IHRydWU7XG4gICAgdXRpbHMuZW1pdFNhZmUodGhpcywgJ2RyYWluZWQnKTtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxufTtcblxuUXVldWUucHJvdG90eXBlLnJldHJ5Sm9iID0gZnVuY3Rpb24oam9iKSB7XG4gIHJldHVybiBqb2IucmV0cnkoKTtcbn07XG5cblF1ZXVlLnByb3RvdHlwZS50b0tleSA9IGZ1bmN0aW9uKHF1ZXVlVHlwZSkge1xuICByZXR1cm4gW3RoaXMua2V5UHJlZml4LCB0aGlzLm5hbWUsIHF1ZXVlVHlwZV0uam9pbignOicpO1xufTtcblxuLypAZnVuY3Rpb24gY2xlYW5cbiAqXG4gKiBDbGVhbnMgam9icyBmcm9tIGEgcXVldWUuIFNpbWlsYXIgdG8gcmVtb3ZlIGJ1dCBrZWVwcyBqb2JzIHdpdGhpbiBhIGNlcnRhaW5cbiAqIGdyYWNlIHBlcmlvZC5cbiAqXG4gKiBAcGFyYW0ge2ludH0gZ3JhY2UgLSBUaGUgZ3JhY2UgcGVyaW9kXG4gKiBAcGFyYW0ge3N0cmluZ30gW3R5cGU9Y29tcGxldGVkXSAtIFRoZSB0eXBlIG9mIGpvYiB0byBjbGVhbi4gUG9zc2libGUgdmFsdWVzIGFyZSBjb21wbGV0ZWQsIHdhaXQsIGFjdGl2ZSwgcGF1c2VkLCBkZWxheWVkLCBmYWlsZWQuIERlZmF1bHRzIHRvIGNvbXBsZXRlZC5cbiAqIEBwYXJhbSB7aW50fSBUaGUgbWF4IG51bWJlciBvZiBqb2JzIHRvIGNsZWFuXG4gKi9cblF1ZXVlLnByb3RvdHlwZS5jbGVhbiA9IGZ1bmN0aW9uKGdyYWNlLCB0eXBlLCBsaW1pdCkge1xuICByZXR1cm4gdGhpcy5pc1JlYWR5KCkudGhlbigoKSA9PiB7XG4gICAgaWYgKGdyYWNlID09PSB1bmRlZmluZWQgfHwgZ3JhY2UgPT09IG51bGwpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignWW91IG11c3QgZGVmaW5lIGEgZ3JhY2UgcGVyaW9kLicpO1xuICAgIH1cblxuICAgIGlmICghdHlwZSkge1xuICAgICAgdHlwZSA9ICdjb21wbGV0ZWQnO1xuICAgIH1cblxuICAgIGlmIChcbiAgICAgIF8uaW5kZXhPZihcbiAgICAgICAgWydjb21wbGV0ZWQnLCAnd2FpdCcsICdhY3RpdmUnLCAncGF1c2VkJywgJ2RlbGF5ZWQnLCAnZmFpbGVkJ10sXG4gICAgICAgIHR5cGVcbiAgICAgICkgPT09IC0xXG4gICAgKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCBjbGVhbiB1bmtub3duIHF1ZXVlIHR5cGUgJyArIHR5cGUpO1xuICAgIH1cblxuICAgIHJldHVybiBzY3JpcHRzXG4gICAgICAuY2xlYW5Kb2JzSW5TZXQodGhpcywgdHlwZSwgRGF0ZS5ub3coKSAtIGdyYWNlLCBsaW1pdClcbiAgICAgIC50aGVuKGpvYnMgPT4ge1xuICAgICAgICB1dGlscy5lbWl0U2FmZSh0aGlzLCAnY2xlYW5lZCcsIGpvYnMsIHR5cGUpO1xuICAgICAgICByZXR1cm4gam9icztcbiAgICAgIH0pXG4gICAgICAuY2F0Y2goZXJyID0+IHtcbiAgICAgICAgdXRpbHMuZW1pdFNhZmUodGhpcywgJ2Vycm9yJywgZXJyKTtcbiAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgfSk7XG4gIH0pO1xufTtcblxuLyogQG1ldGhvZCBvYmxpdGVyYXRlXG4gKlxuICogQ29tcGxldGVseSBkZXN0cm95cyB0aGUgcXVldWUgYW5kIGFsbCBvZiBpdHMgY29udGVudHMgaXJyZXZlcnNpYmx5LlxuICogVGhpcyBtZXRob2Qgd2lsbCB0aGUgKnBhdXNlKiB0aGUgcXVldWUgYW5kIHJlcXVpcmVzIHRoYXQgdGhlcmUgYXJlIG5vXG4gKiBhY3RpdmUgam9icy4gSXQgaXMgcG9zc2libGUgdG8gYnlwYXNzIHRoaXMgcmVxdWlyZW1lbnQsIGkuZS4gbm90XG4gKiBoYXZpbmcgYWN0aXZlIGpvYnMgdXNpbmcgdGhlIFwiZm9yY2VcIiBvcHRpb24uXG4gKlxuICogTm90ZTogVGhpcyBvcGVyYXRpb24gcmVxdWlyZXMgdG8gaXRlcmF0ZSBvbiBhbGwgdGhlIGpvYnMgc3RvcmVkIGluIHRoZSBxdWV1ZVxuICogYW5kIGNhbiBiZSBzbG93IGZvciB2ZXJ5IGxhcmdlIHF1ZXVlcy5cbiAqXG4gKiBAcGFyYW0geyB7IGZvcmNlOiBib29sZWFuLCBjb3VudDogbnVtYmVyIH19IG9wdHMuIFVzZSBmb3JjZSA9IHRydWUgdG8gZm9yY2Ugb2JsaXRlcmF0aW9uIGV2ZW5cbiAqIHdpdGggYWN0aXZlIGpvYnMgaW4gdGhlIHF1ZXVlLiAgVXNlIGNvdW50IHdpdGggdGhlIG1heGltdW4gbnVtYmVyIG9mIGRlbGV0ZWQga2V5cyBwZXIgaXRlcmF0aW9uLFxuICogMTAwMCBpcyB0aGUgZGVmYXVsdC5cbiAqL1xuUXVldWUucHJvdG90eXBlLm9ibGl0ZXJhdGUgPSBhc3luYyBmdW5jdGlvbihvcHRzKSB7XG4gIGF3YWl0IHRoaXMucGF1c2UoKTtcblxuICBsZXQgY3Vyc29yID0gMDtcbiAgZG8ge1xuICAgIGN1cnNvciA9IGF3YWl0IHNjcmlwdHMub2JsaXRlcmF0ZSh0aGlzLCB7XG4gICAgICBmb3JjZTogZmFsc2UsXG4gICAgICBjb3VudDogMTAwMCxcbiAgICAgIC4uLm9wdHNcbiAgICB9KTtcbiAgfSB3aGlsZSAoY3Vyc29yKTtcbn07XG5cbi8qKlxuICogUmV0dXJucyBhIHByb21pc2UgdGhhdCByZXNvbHZlcyB3aGVuIGFjdGl2ZSBqb2JzIGFyZSBmaW5pc2hlZFxuICpcbiAqIEByZXR1cm5zIHtQcm9taXNlfVxuICovXG5RdWV1ZS5wcm90b3R5cGUud2hlbkN1cnJlbnRKb2JzRmluaXNoZWQgPSBmdW5jdGlvbigpIHtcbiAgaWYgKCF0aGlzLmJjbGllbnRJbml0aWFsaXplZCkge1xuICAgIC8vIGJjbGllbnQgbm90IHlldCBpbml0aWFsaXplZCwgc28gbm8gam9icyB0byB3YWl0IGZvclxuICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoKTtcbiAgfVxuXG4gIC8vXG4gIC8vIEZvcmNlIHJlY29ubmVjdGlvbiBvZiBibG9ja2luZyBjb25uZWN0aW9uIHRvIGFib3J0IGJsb2NraW5nIHJlZGlzIGNhbGwgaW1tZWRpYXRlbHkuXG4gIC8vXG4gIGNvbnN0IGZvcmNlZFJlY29ubmVjdGlvbiA9IHJlZGlzQ2xpZW50RGlzY29ubmVjdCh0aGlzLmJjbGllbnQpLnRoZW4oKCkgPT4ge1xuICAgIHJldHVybiB0aGlzLmJjbGllbnQuY29ubmVjdCgpO1xuICB9KTtcblxuICByZXR1cm4gUHJvbWlzZS5hbGwoT2JqZWN0LnZhbHVlcyh0aGlzLnByb2Nlc3NpbmcpKS50aGVuKFxuICAgICgpID0+IGZvcmNlZFJlY29ubmVjdGlvblxuICApO1xufTtcblxuLy9cbi8vIFByaXZhdGUgbG9jYWwgZnVuY3Rpb25zXG4vL1xuXG5mdW5jdGlvbiBnZXRSZWRpc1ZlcnNpb24oY2xpZW50KSB7XG4gIHJldHVybiBjbGllbnQuaW5mbygpLnRoZW4oZG9jID0+IHtcbiAgICBjb25zdCBwcmVmaXggPSAncmVkaXNfdmVyc2lvbjonO1xuICAgIGNvbnN0IGxpbmVzID0gZG9jLnNwbGl0KCdcXHJcXG4nKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxpbmVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAobGluZXNbaV0uaW5kZXhPZihwcmVmaXgpID09PSAwKSB7XG4gICAgICAgIHJldHVybiBsaW5lc1tpXS5zdWJzdHIocHJlZml4Lmxlbmd0aCk7XG4gICAgICB9XG4gICAgfVxuICB9KTtcbn1cblxuZnVuY3Rpb24gam9iSWRGb3JHcm91cChsaW1pdGVyLCBvcHRzLCBkYXRhKSB7XG4gIGNvbnN0IGpvYklkID0gb3B0cyAmJiBvcHRzLmpvYklkO1xuICBjb25zdCBncm91cEtleSA9IF8uZ2V0KGxpbWl0ZXIsICdncm91cEtleScpO1xuICBpZiAoZ3JvdXBLZXkpIHtcbiAgICByZXR1cm4gYCR7am9iSWQgfHwgdXVpZC52NCgpfToke18uZ2V0KGRhdGEsIGdyb3VwS2V5KX1gO1xuICB9XG4gIHJldHVybiBqb2JJZDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBRdWV1ZTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/bull/lib/queue.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/bull/lib/repeatable.js":
/*!*********************************************!*\
  !*** ./node_modules/bull/lib/repeatable.js ***!
  \*********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\n\nconst _ = __webpack_require__(/*! lodash */ \"(rsc)/./node_modules/lodash/lodash.js\");\nconst parser = __webpack_require__(/*! cron-parser */ \"(rsc)/./node_modules/cron-parser/lib/parser.js\");\nconst crypto = __webpack_require__(/*! crypto */ \"crypto\");\n\nconst Job = __webpack_require__(/*! ./job */ \"(rsc)/./node_modules/bull/lib/job.js\");\n\nmodule.exports = function(Queue) {\n  Queue.prototype.nextRepeatableJob = function(\n    name,\n    data,\n    opts,\n    skipCheckExists\n  ) {\n    const client = this.client;\n    const repeat = opts.repeat;\n    const prevMillis = opts.prevMillis || 0;\n\n    if (!prevMillis && opts.jobId) {\n      repeat.jobId = opts.jobId;\n    }\n\n    const currentCount = repeat.count ? repeat.count + 1 : 1;\n\n    if (!_.isUndefined(repeat.limit) && currentCount > repeat.limit) {\n      return Promise.resolve();\n    }\n\n    let now = Date.now();\n\n    if (!_.isUndefined(repeat.endDate) && now > new Date(repeat.endDate)) {\n      return Promise.resolve();\n    }\n\n    now = prevMillis < now ? now : prevMillis;\n\n    const nextMillis = getNextMillis(now, repeat);\n    if (nextMillis) {\n      const jobId = repeat.jobId ? repeat.jobId + ':' : ':';\n      const repeatKey = getRepeatKey(name, repeat, jobId);\n\n      const createNextJob = () => {\n        return client.zadd(this.keys.repeat, nextMillis, repeatKey).then(() => {\n          //\n          // Generate unique job id for this iteration.\n          //\n          const customId = getRepeatJobId(\n            name,\n            jobId,\n            nextMillis,\n            md5(repeatKey)\n          );\n          now = Date.now();\n          const delay = nextMillis - now;\n\n          return Job.create(\n            this,\n            name,\n            data,\n            _.defaultsDeep(\n              {\n                repeat: {\n                  count: currentCount,\n                  key: repeatKey\n                },\n                jobId: customId,\n                delay: delay < 0 ? 0 : delay,\n                timestamp: now,\n                prevMillis: nextMillis\n              },\n              opts\n            )\n          );\n        });\n      };\n\n      if (skipCheckExists) {\n        return createNextJob();\n      }\n\n      // Check that the repeatable job hasn't been removed\n      // TODO: a lua script would be better here\n      return client\n        .zscore(this.keys.repeat, repeatKey)\n        .then(repeatableExists => {\n          // The job could have been deleted since this check\n          if (repeatableExists) {\n            return createNextJob();\n          }\n          return Promise.resolve();\n        });\n    } else {\n      return Promise.resolve();\n    }\n  };\n\n  Queue.prototype.removeRepeatable = function(name, repeat) {\n    if (typeof name !== 'string') {\n      repeat = name;\n      name = Job.DEFAULT_JOB_NAME;\n    }\n\n    return this.isReady().then(() => {\n      const jobId = repeat.jobId ? repeat.jobId + ':' : ':';\n      const repeatJobKey = getRepeatKey(name, repeat, jobId);\n      const repeatJobId = getRepeatJobId(name, jobId, '', md5(repeatJobKey));\n      const queueKey = this.keys[''];\n      return this.client.removeRepeatable(\n        this.keys.repeat,\n        this.keys.delayed,\n        repeatJobId,\n        repeatJobKey,\n        queueKey\n      );\n    });\n  };\n\n  Queue.prototype.removeRepeatableByKey = function(repeatJobKey) {\n    const repeatMeta = this._keyToData(repeatJobKey);\n    const queueKey = this.keys[''];\n\n    const jobId = repeatMeta.id ? repeatMeta.id + ':' : ':';\n    const repeatJobId = getRepeatJobId(\n      repeatMeta.name || Job.DEFAULT_JOB_NAME,\n      jobId,\n      '',\n      md5(repeatJobKey)\n    );\n\n    return this.isReady().then(() => {\n      return this.client.removeRepeatable(\n        this.keys.repeat,\n        this.keys.delayed,\n        repeatJobId,\n        repeatJobKey,\n        queueKey\n      );\n    });\n  };\n\n  Queue.prototype._keyToData = function(key) {\n    const data = key.split(':');\n\n    return {\n      key: key,\n      name: data[0],\n      id: data[1] || null,\n      endDate: parseInt(data[2]) || null,\n      tz: data[3] || null,\n      cron: data[4]\n    };\n  };\n\n  Queue.prototype.getRepeatableJobs = function(start, end, asc) {\n    const key = this.keys.repeat;\n    start = start || 0;\n    end = end || -1;\n    return (asc\n      ? this.client.zrange(key, start, end, 'WITHSCORES')\n      : this.client.zrevrange(key, start, end, 'WITHSCORES')\n    ).then(result => {\n      const jobs = [];\n      for (let i = 0; i < result.length; i += 2) {\n        const data = this._keyToData(result[i]);\n        jobs.push({\n          key: data.key,\n          name: data.name,\n          id: data.id,\n          endDate: data.endDate,\n          tz: data.cron ? data.tz : null,\n          cron: data.cron || null,\n          every: !data.cron ? parseInt(data.tz) : null,\n          next: parseInt(result[i + 1])\n        });\n      }\n      return jobs;\n    });\n  };\n\n  Queue.prototype.getRepeatableCount = function() {\n    return this.client.zcard(this.toKey('repeat'));\n  };\n\n  function getRepeatJobId(name, jobId, nextMillis, namespace) {\n    return 'repeat:' + md5(name + jobId + namespace) + ':' + nextMillis;\n  }\n\n  function getRepeatKey(name, repeat, jobId) {\n    const endDate = repeat.endDate\n      ? new Date(repeat.endDate).getTime() + ':'\n      : ':';\n    const tz = repeat.tz ? repeat.tz + ':' : ':';\n    const suffix = repeat.cron ? tz + repeat.cron : String(repeat.every);\n\n    return name + ':' + jobId + endDate + suffix;\n  }\n\n  function getNextMillis(millis, opts) {\n    if (opts.cron && opts.every) {\n      throw new Error(\n        'Both .cron and .every options are defined for this repeatable job'\n      );\n    }\n\n    if (opts.every) {\n      return Math.floor(millis / opts.every) * opts.every + opts.every;\n    }\n\n    const currentDate =\n      opts.startDate && new Date(opts.startDate) > new Date(millis)\n        ? new Date(opts.startDate)\n        : new Date(millis);\n    const interval = parser.parseExpression(\n      opts.cron,\n      _.defaults(\n        {\n          currentDate\n        },\n        opts\n      )\n    );\n\n    try {\n      return interval.next().getTime();\n    } catch (e) {\n      // Ignore error\n    }\n  }\n\n  function md5(str) {\n    return crypto\n      .createHash('md5')\n      .update(str)\n      .digest('hex');\n  }\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvYnVsbC9saWIvcmVwZWF0YWJsZS5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYixVQUFVLG1CQUFPLENBQUMscURBQVE7QUFDMUIsZUFBZSxtQkFBTyxDQUFDLG1FQUFhO0FBQ3BDLGVBQWUsbUJBQU8sQ0FBQyxzQkFBUTs7QUFFL0IsWUFBWSxtQkFBTyxDQUFDLG1EQUFPOztBQUUzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixtQkFBbUI7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL215LWFwcC8uL25vZGVfbW9kdWxlcy9idWxsL2xpYi9yZXBlYXRhYmxlLmpzP2EwNDgiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCBfID0gcmVxdWlyZSgnbG9kYXNoJyk7XG5jb25zdCBwYXJzZXIgPSByZXF1aXJlKCdjcm9uLXBhcnNlcicpO1xuY29uc3QgY3J5cHRvID0gcmVxdWlyZSgnY3J5cHRvJyk7XG5cbmNvbnN0IEpvYiA9IHJlcXVpcmUoJy4vam9iJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oUXVldWUpIHtcbiAgUXVldWUucHJvdG90eXBlLm5leHRSZXBlYXRhYmxlSm9iID0gZnVuY3Rpb24oXG4gICAgbmFtZSxcbiAgICBkYXRhLFxuICAgIG9wdHMsXG4gICAgc2tpcENoZWNrRXhpc3RzXG4gICkge1xuICAgIGNvbnN0IGNsaWVudCA9IHRoaXMuY2xpZW50O1xuICAgIGNvbnN0IHJlcGVhdCA9IG9wdHMucmVwZWF0O1xuICAgIGNvbnN0IHByZXZNaWxsaXMgPSBvcHRzLnByZXZNaWxsaXMgfHwgMDtcblxuICAgIGlmICghcHJldk1pbGxpcyAmJiBvcHRzLmpvYklkKSB7XG4gICAgICByZXBlYXQuam9iSWQgPSBvcHRzLmpvYklkO1xuICAgIH1cblxuICAgIGNvbnN0IGN1cnJlbnRDb3VudCA9IHJlcGVhdC5jb3VudCA/IHJlcGVhdC5jb3VudCArIDEgOiAxO1xuXG4gICAgaWYgKCFfLmlzVW5kZWZpbmVkKHJlcGVhdC5saW1pdCkgJiYgY3VycmVudENvdW50ID4gcmVwZWF0LmxpbWl0KSB7XG4gICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCk7XG4gICAgfVxuXG4gICAgbGV0IG5vdyA9IERhdGUubm93KCk7XG5cbiAgICBpZiAoIV8uaXNVbmRlZmluZWQocmVwZWF0LmVuZERhdGUpICYmIG5vdyA+IG5ldyBEYXRlKHJlcGVhdC5lbmREYXRlKSkge1xuICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpO1xuICAgIH1cblxuICAgIG5vdyA9IHByZXZNaWxsaXMgPCBub3cgPyBub3cgOiBwcmV2TWlsbGlzO1xuXG4gICAgY29uc3QgbmV4dE1pbGxpcyA9IGdldE5leHRNaWxsaXMobm93LCByZXBlYXQpO1xuICAgIGlmIChuZXh0TWlsbGlzKSB7XG4gICAgICBjb25zdCBqb2JJZCA9IHJlcGVhdC5qb2JJZCA/IHJlcGVhdC5qb2JJZCArICc6JyA6ICc6JztcbiAgICAgIGNvbnN0IHJlcGVhdEtleSA9IGdldFJlcGVhdEtleShuYW1lLCByZXBlYXQsIGpvYklkKTtcblxuICAgICAgY29uc3QgY3JlYXRlTmV4dEpvYiA9ICgpID0+IHtcbiAgICAgICAgcmV0dXJuIGNsaWVudC56YWRkKHRoaXMua2V5cy5yZXBlYXQsIG5leHRNaWxsaXMsIHJlcGVhdEtleSkudGhlbigoKSA9PiB7XG4gICAgICAgICAgLy9cbiAgICAgICAgICAvLyBHZW5lcmF0ZSB1bmlxdWUgam9iIGlkIGZvciB0aGlzIGl0ZXJhdGlvbi5cbiAgICAgICAgICAvL1xuICAgICAgICAgIGNvbnN0IGN1c3RvbUlkID0gZ2V0UmVwZWF0Sm9iSWQoXG4gICAgICAgICAgICBuYW1lLFxuICAgICAgICAgICAgam9iSWQsXG4gICAgICAgICAgICBuZXh0TWlsbGlzLFxuICAgICAgICAgICAgbWQ1KHJlcGVhdEtleSlcbiAgICAgICAgICApO1xuICAgICAgICAgIG5vdyA9IERhdGUubm93KCk7XG4gICAgICAgICAgY29uc3QgZGVsYXkgPSBuZXh0TWlsbGlzIC0gbm93O1xuXG4gICAgICAgICAgcmV0dXJuIEpvYi5jcmVhdGUoXG4gICAgICAgICAgICB0aGlzLFxuICAgICAgICAgICAgbmFtZSxcbiAgICAgICAgICAgIGRhdGEsXG4gICAgICAgICAgICBfLmRlZmF1bHRzRGVlcChcbiAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHJlcGVhdDoge1xuICAgICAgICAgICAgICAgICAgY291bnQ6IGN1cnJlbnRDb3VudCxcbiAgICAgICAgICAgICAgICAgIGtleTogcmVwZWF0S2V5XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBqb2JJZDogY3VzdG9tSWQsXG4gICAgICAgICAgICAgICAgZGVsYXk6IGRlbGF5IDwgMCA/IDAgOiBkZWxheSxcbiAgICAgICAgICAgICAgICB0aW1lc3RhbXA6IG5vdyxcbiAgICAgICAgICAgICAgICBwcmV2TWlsbGlzOiBuZXh0TWlsbGlzXG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgIG9wdHNcbiAgICAgICAgICAgIClcbiAgICAgICAgICApO1xuICAgICAgICB9KTtcbiAgICAgIH07XG5cbiAgICAgIGlmIChza2lwQ2hlY2tFeGlzdHMpIHtcbiAgICAgICAgcmV0dXJuIGNyZWF0ZU5leHRKb2IoKTtcbiAgICAgIH1cblxuICAgICAgLy8gQ2hlY2sgdGhhdCB0aGUgcmVwZWF0YWJsZSBqb2IgaGFzbid0IGJlZW4gcmVtb3ZlZFxuICAgICAgLy8gVE9ETzogYSBsdWEgc2NyaXB0IHdvdWxkIGJlIGJldHRlciBoZXJlXG4gICAgICByZXR1cm4gY2xpZW50XG4gICAgICAgIC56c2NvcmUodGhpcy5rZXlzLnJlcGVhdCwgcmVwZWF0S2V5KVxuICAgICAgICAudGhlbihyZXBlYXRhYmxlRXhpc3RzID0+IHtcbiAgICAgICAgICAvLyBUaGUgam9iIGNvdWxkIGhhdmUgYmVlbiBkZWxldGVkIHNpbmNlIHRoaXMgY2hlY2tcbiAgICAgICAgICBpZiAocmVwZWF0YWJsZUV4aXN0cykge1xuICAgICAgICAgICAgcmV0dXJuIGNyZWF0ZU5leHRKb2IoKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpO1xuICAgICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpO1xuICAgIH1cbiAgfTtcblxuICBRdWV1ZS5wcm90b3R5cGUucmVtb3ZlUmVwZWF0YWJsZSA9IGZ1bmN0aW9uKG5hbWUsIHJlcGVhdCkge1xuICAgIGlmICh0eXBlb2YgbmFtZSAhPT0gJ3N0cmluZycpIHtcbiAgICAgIHJlcGVhdCA9IG5hbWU7XG4gICAgICBuYW1lID0gSm9iLkRFRkFVTFRfSk9CX05BTUU7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuaXNSZWFkeSgpLnRoZW4oKCkgPT4ge1xuICAgICAgY29uc3Qgam9iSWQgPSByZXBlYXQuam9iSWQgPyByZXBlYXQuam9iSWQgKyAnOicgOiAnOic7XG4gICAgICBjb25zdCByZXBlYXRKb2JLZXkgPSBnZXRSZXBlYXRLZXkobmFtZSwgcmVwZWF0LCBqb2JJZCk7XG4gICAgICBjb25zdCByZXBlYXRKb2JJZCA9IGdldFJlcGVhdEpvYklkKG5hbWUsIGpvYklkLCAnJywgbWQ1KHJlcGVhdEpvYktleSkpO1xuICAgICAgY29uc3QgcXVldWVLZXkgPSB0aGlzLmtleXNbJyddO1xuICAgICAgcmV0dXJuIHRoaXMuY2xpZW50LnJlbW92ZVJlcGVhdGFibGUoXG4gICAgICAgIHRoaXMua2V5cy5yZXBlYXQsXG4gICAgICAgIHRoaXMua2V5cy5kZWxheWVkLFxuICAgICAgICByZXBlYXRKb2JJZCxcbiAgICAgICAgcmVwZWF0Sm9iS2V5LFxuICAgICAgICBxdWV1ZUtleVxuICAgICAgKTtcbiAgICB9KTtcbiAgfTtcblxuICBRdWV1ZS5wcm90b3R5cGUucmVtb3ZlUmVwZWF0YWJsZUJ5S2V5ID0gZnVuY3Rpb24ocmVwZWF0Sm9iS2V5KSB7XG4gICAgY29uc3QgcmVwZWF0TWV0YSA9IHRoaXMuX2tleVRvRGF0YShyZXBlYXRKb2JLZXkpO1xuICAgIGNvbnN0IHF1ZXVlS2V5ID0gdGhpcy5rZXlzWycnXTtcblxuICAgIGNvbnN0IGpvYklkID0gcmVwZWF0TWV0YS5pZCA/IHJlcGVhdE1ldGEuaWQgKyAnOicgOiAnOic7XG4gICAgY29uc3QgcmVwZWF0Sm9iSWQgPSBnZXRSZXBlYXRKb2JJZChcbiAgICAgIHJlcGVhdE1ldGEubmFtZSB8fCBKb2IuREVGQVVMVF9KT0JfTkFNRSxcbiAgICAgIGpvYklkLFxuICAgICAgJycsXG4gICAgICBtZDUocmVwZWF0Sm9iS2V5KVxuICAgICk7XG5cbiAgICByZXR1cm4gdGhpcy5pc1JlYWR5KCkudGhlbigoKSA9PiB7XG4gICAgICByZXR1cm4gdGhpcy5jbGllbnQucmVtb3ZlUmVwZWF0YWJsZShcbiAgICAgICAgdGhpcy5rZXlzLnJlcGVhdCxcbiAgICAgICAgdGhpcy5rZXlzLmRlbGF5ZWQsXG4gICAgICAgIHJlcGVhdEpvYklkLFxuICAgICAgICByZXBlYXRKb2JLZXksXG4gICAgICAgIHF1ZXVlS2V5XG4gICAgICApO1xuICAgIH0pO1xuICB9O1xuXG4gIFF1ZXVlLnByb3RvdHlwZS5fa2V5VG9EYXRhID0gZnVuY3Rpb24oa2V5KSB7XG4gICAgY29uc3QgZGF0YSA9IGtleS5zcGxpdCgnOicpO1xuXG4gICAgcmV0dXJuIHtcbiAgICAgIGtleToga2V5LFxuICAgICAgbmFtZTogZGF0YVswXSxcbiAgICAgIGlkOiBkYXRhWzFdIHx8IG51bGwsXG4gICAgICBlbmREYXRlOiBwYXJzZUludChkYXRhWzJdKSB8fCBudWxsLFxuICAgICAgdHo6IGRhdGFbM10gfHwgbnVsbCxcbiAgICAgIGNyb246IGRhdGFbNF1cbiAgICB9O1xuICB9O1xuXG4gIFF1ZXVlLnByb3RvdHlwZS5nZXRSZXBlYXRhYmxlSm9icyA9IGZ1bmN0aW9uKHN0YXJ0LCBlbmQsIGFzYykge1xuICAgIGNvbnN0IGtleSA9IHRoaXMua2V5cy5yZXBlYXQ7XG4gICAgc3RhcnQgPSBzdGFydCB8fCAwO1xuICAgIGVuZCA9IGVuZCB8fCAtMTtcbiAgICByZXR1cm4gKGFzY1xuICAgICAgPyB0aGlzLmNsaWVudC56cmFuZ2Uoa2V5LCBzdGFydCwgZW5kLCAnV0lUSFNDT1JFUycpXG4gICAgICA6IHRoaXMuY2xpZW50LnpyZXZyYW5nZShrZXksIHN0YXJ0LCBlbmQsICdXSVRIU0NPUkVTJylcbiAgICApLnRoZW4ocmVzdWx0ID0+IHtcbiAgICAgIGNvbnN0IGpvYnMgPSBbXTtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcmVzdWx0Lmxlbmd0aDsgaSArPSAyKSB7XG4gICAgICAgIGNvbnN0IGRhdGEgPSB0aGlzLl9rZXlUb0RhdGEocmVzdWx0W2ldKTtcbiAgICAgICAgam9icy5wdXNoKHtcbiAgICAgICAgICBrZXk6IGRhdGEua2V5LFxuICAgICAgICAgIG5hbWU6IGRhdGEubmFtZSxcbiAgICAgICAgICBpZDogZGF0YS5pZCxcbiAgICAgICAgICBlbmREYXRlOiBkYXRhLmVuZERhdGUsXG4gICAgICAgICAgdHo6IGRhdGEuY3JvbiA/IGRhdGEudHogOiBudWxsLFxuICAgICAgICAgIGNyb246IGRhdGEuY3JvbiB8fCBudWxsLFxuICAgICAgICAgIGV2ZXJ5OiAhZGF0YS5jcm9uID8gcGFyc2VJbnQoZGF0YS50eikgOiBudWxsLFxuICAgICAgICAgIG5leHQ6IHBhcnNlSW50KHJlc3VsdFtpICsgMV0pXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGpvYnM7XG4gICAgfSk7XG4gIH07XG5cbiAgUXVldWUucHJvdG90eXBlLmdldFJlcGVhdGFibGVDb3VudCA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLmNsaWVudC56Y2FyZCh0aGlzLnRvS2V5KCdyZXBlYXQnKSk7XG4gIH07XG5cbiAgZnVuY3Rpb24gZ2V0UmVwZWF0Sm9iSWQobmFtZSwgam9iSWQsIG5leHRNaWxsaXMsIG5hbWVzcGFjZSkge1xuICAgIHJldHVybiAncmVwZWF0OicgKyBtZDUobmFtZSArIGpvYklkICsgbmFtZXNwYWNlKSArICc6JyArIG5leHRNaWxsaXM7XG4gIH1cblxuICBmdW5jdGlvbiBnZXRSZXBlYXRLZXkobmFtZSwgcmVwZWF0LCBqb2JJZCkge1xuICAgIGNvbnN0IGVuZERhdGUgPSByZXBlYXQuZW5kRGF0ZVxuICAgICAgPyBuZXcgRGF0ZShyZXBlYXQuZW5kRGF0ZSkuZ2V0VGltZSgpICsgJzonXG4gICAgICA6ICc6JztcbiAgICBjb25zdCB0eiA9IHJlcGVhdC50eiA/IHJlcGVhdC50eiArICc6JyA6ICc6JztcbiAgICBjb25zdCBzdWZmaXggPSByZXBlYXQuY3JvbiA/IHR6ICsgcmVwZWF0LmNyb24gOiBTdHJpbmcocmVwZWF0LmV2ZXJ5KTtcblxuICAgIHJldHVybiBuYW1lICsgJzonICsgam9iSWQgKyBlbmREYXRlICsgc3VmZml4O1xuICB9XG5cbiAgZnVuY3Rpb24gZ2V0TmV4dE1pbGxpcyhtaWxsaXMsIG9wdHMpIHtcbiAgICBpZiAob3B0cy5jcm9uICYmIG9wdHMuZXZlcnkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgJ0JvdGggLmNyb24gYW5kIC5ldmVyeSBvcHRpb25zIGFyZSBkZWZpbmVkIGZvciB0aGlzIHJlcGVhdGFibGUgam9iJ1xuICAgICAgKTtcbiAgICB9XG5cbiAgICBpZiAob3B0cy5ldmVyeSkge1xuICAgICAgcmV0dXJuIE1hdGguZmxvb3IobWlsbGlzIC8gb3B0cy5ldmVyeSkgKiBvcHRzLmV2ZXJ5ICsgb3B0cy5ldmVyeTtcbiAgICB9XG5cbiAgICBjb25zdCBjdXJyZW50RGF0ZSA9XG4gICAgICBvcHRzLnN0YXJ0RGF0ZSAmJiBuZXcgRGF0ZShvcHRzLnN0YXJ0RGF0ZSkgPiBuZXcgRGF0ZShtaWxsaXMpXG4gICAgICAgID8gbmV3IERhdGUob3B0cy5zdGFydERhdGUpXG4gICAgICAgIDogbmV3IERhdGUobWlsbGlzKTtcbiAgICBjb25zdCBpbnRlcnZhbCA9IHBhcnNlci5wYXJzZUV4cHJlc3Npb24oXG4gICAgICBvcHRzLmNyb24sXG4gICAgICBfLmRlZmF1bHRzKFxuICAgICAgICB7XG4gICAgICAgICAgY3VycmVudERhdGVcbiAgICAgICAgfSxcbiAgICAgICAgb3B0c1xuICAgICAgKVxuICAgICk7XG5cbiAgICB0cnkge1xuICAgICAgcmV0dXJuIGludGVydmFsLm5leHQoKS5nZXRUaW1lKCk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgLy8gSWdub3JlIGVycm9yXG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gbWQ1KHN0cikge1xuICAgIHJldHVybiBjcnlwdG9cbiAgICAgIC5jcmVhdGVIYXNoKCdtZDUnKVxuICAgICAgLnVwZGF0ZShzdHIpXG4gICAgICAuZGlnZXN0KCdoZXgnKTtcbiAgfVxufTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/bull/lib/repeatable.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/bull/lib/scripts.js":
/*!******************************************!*\
  !*** ./node_modules/bull/lib/scripts.js ***!
  \******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/**\n * Includes all the scripts needed by the queue and jobs.\n */\n\n\n\nconst _ = __webpack_require__(/*! lodash */ \"(rsc)/./node_modules/lodash/lodash.js\");\nconst msgpackr = __webpack_require__(/*! msgpackr */ \"(rsc)/./node_modules/msgpackr/dist/node.cjs\");\n\nconst packer = new msgpackr.Packr({\n  useRecords: false,\n  encodeUndefinedAsNil: true\n});\n\nconst pack = packer.pack;\n\nconst scripts = {\n  isJobInList(client, listKey, jobId) {\n    return client.isJobInList([listKey, jobId]).then(result => {\n      return result === 1;\n    });\n  },\n\n  addJob(client, queue, job, opts) {\n    const queueKeys = queue.keys;\n    let keys = [\n      queueKeys.wait,\n      queueKeys.paused,\n      queueKeys['meta-paused'],\n      queueKeys.id,\n      queueKeys.delayed,\n      queueKeys.priority\n    ];\n\n    const args = [\n      queueKeys[''],\n      _.isUndefined(opts.customJobId) ? '' : opts.customJobId,\n      job.name,\n      job.data,\n      pack(job.opts),\n      job.timestamp,\n      job.delay,\n      job.delay ? job.timestamp + job.delay : 0,\n      opts.priority || 0,\n      opts.lifo ? 'RPUSH' : 'LPUSH',\n      queue.token,\n      job.debounceId ? `${queueKeys.de}:${job.debounceId}` : null,\n      opts.debounce ? opts.debounce.id : null,\n      opts.debounce ? opts.debounce.ttl : null,\n    ];\n    keys = keys.concat(args);\n    return client.addJob(keys);\n  },\n\n  pause(queue, pause) {\n    let src = 'wait',\n      dst = 'paused';\n    if (!pause) {\n      src = 'paused';\n      dst = 'wait';\n    }\n\n    const keys = _.map(\n      [src, dst, 'meta-paused', pause ? 'paused' : 'resumed', 'meta'],\n      name => {\n        return queue.toKey(name);\n      }\n    );\n\n    return queue.client.pause(keys.concat([pause ? 'paused' : 'resumed']));\n  },\n\n  async addLog(queue, jobId, logRow, keepLogs) {\n    const client = await queue.client;\n\n    const keys = [queue.toKey(jobId), queue.toKey(jobId) + ':logs'];\n\n    const result = await client.addLog(\n      keys.concat([jobId, logRow, keepLogs ? keepLogs : ''])\n    );\n\n    if (result < 0) {\n      throw scripts.finishedErrors(result, jobId, 'addLog');\n    }\n\n    return result;\n  },\n\n  getCountsPerPriorityArgs(queue, priorities) {\n    const keys = [\n      queue.keys.wait,\n      queue.keys.paused,\n      queue.keys['meta-paused'],\n      queue.keys.priority\n    ];\n\n    const args = priorities;\n\n    return keys.concat(args);\n  },\n\n  async getCountsPerPriority(queue, priorities) {\n    const client = await queue.client;\n    const args = this.getCountsPerPriorityArgs(queue, priorities);\n\n    return client.getCountsPerPriority(args);\n  },\n\n  moveToActive(queue, jobId) {\n    const queueKeys = queue.keys;\n    const keys = [queueKeys.wait, queueKeys.active, queueKeys.priority];\n\n    keys[3] = keys[1] + '@' + queue.token;\n    keys[4] = queueKeys.stalled;\n    keys[5] = queueKeys.limiter;\n    keys[6] = queueKeys.delayed;\n    keys[7] = queueKeys.drained;\n\n    const args = [\n      queueKeys[''],\n      queue.token,\n      queue.settings.lockDuration,\n      Date.now(),\n      jobId\n    ];\n\n    if (queue.limiter) {\n      args.push(\n        queue.limiter.max,\n        queue.limiter.duration,\n        !!queue.limiter.bounceBack\n      );\n      queue.limiter.groupKey && args.push(true);\n    }\n\n    return queue.client.moveToActive(keys.concat(args)).then(raw2jobData);\n  },\n\n  updateProgress(job, progress) {\n    const queue = job.queue;\n    const keys = [job.id, 'progress'].map(name => {\n      return queue.toKey(name);\n    });\n\n    const progressJson = JSON.stringify(progress);\n    return queue.client\n      .updateProgress(keys, [\n        progressJson,\n        JSON.stringify({ jobId: job.id, progress })\n      ])\n      .then(code => {\n        if (code < 0) {\n          throw scripts.finishedErrors(code, job.id, 'updateProgress');\n        }\n        queue.emit('progress', job, progress);\n      });\n  },\n\n  updateData(job, data) {\n    const queue = job.queue;\n    const keys = [job.id].map(name => {\n      return queue.toKey(name);\n    });\n    const dataJson = JSON.stringify(data);\n\n    return queue.client.updateData(keys, [dataJson]);\n  },\n\n  saveStacktraceArgs(\n    job,\n    stacktrace,\n    failedReason\n  ) {\n    const queue = job.queue;\n\n    const keys = [queue.toKey(job.id)];\n\n    return keys.concat([stacktrace, failedReason, job.attemptsMade]);\n  },\n\n  retryJobsArgs(queue, count) {\n    const keys = [\n      queue.toKey(''),\n      queue.toKey('failed'),\n      queue.toKey('wait'),\n      queue.toKey('meta-paused'),\n      queue.toKey('paused')\n    ];\n\n    const args = [count];\n\n    return keys.concat(args);\n  },\n\n  async retryJobs(queue, count = 1000) {\n    const client = await queue.client;\n\n    const args = this.retryJobsArgs(queue, count);\n\n    return client.retryJobs(args);\n  },\n\n  moveToFinishedArgs(\n    job,\n    val,\n    propVal,\n    shouldRemove,\n    target,\n    ignoreLock,\n    notFetch\n  ) {\n    const queue = job.queue;\n    const queueKeys = queue.keys;\n\n    const metricsKey = queue.toKey(`metrics:${target}`);\n\n    const keys = [\n      queueKeys.active,\n      queueKeys[target],\n      queue.toKey(job.id),\n      queueKeys.wait,\n      queueKeys.priority,\n      queueKeys.active + '@' + queue.token,\n      queueKeys.delayed,\n      queueKeys.stalled,\n      metricsKey\n    ];\n\n    const keepJobs = pack(\n      typeof shouldRemove === 'object'\n        ? shouldRemove\n        : typeof shouldRemove === 'number'\n        ? { count: shouldRemove }\n        : { count: shouldRemove ? 0 : -1 }\n    );\n\n    const args = [\n      job.id,\n      job.finishedOn,\n      propVal,\n      _.isUndefined(val) ? 'null' : val,\n      ignoreLock ? '0' : queue.token,\n      keepJobs,\n      JSON.stringify({ jobId: job.id, val: val }),\n      notFetch || queue.paused || queue.closing || queue.limiter ? 0 : 1,\n      queueKeys[''],\n      queue.settings.lockDuration,\n      queue.token,\n      queue.metrics && queue.metrics.maxDataPoints\n    ];\n\n    return keys.concat(args);\n  },\n\n  moveToFinished(\n    job,\n    val,\n    propVal,\n    shouldRemove,\n    target,\n    ignoreLock,\n    notFetch = false\n  ) {\n    const args = scripts.moveToFinishedArgs(\n      job,\n      val,\n      propVal,\n      shouldRemove,\n      target,\n      ignoreLock,\n      notFetch,\n      job.queue.toKey('')\n    );\n    return job.queue.client.moveToFinished(args).then(result => {\n      if (result < 0) {\n        throw scripts.finishedErrors(result, job.id, 'finished', 'active');\n      } else if (result) {\n        return raw2jobData(result);\n      }\n      return 0;\n    });\n  },\n\n  finishedErrors(code, jobId, command, state) {\n    switch (code) {\n      case -1:\n        return new Error('Missing key for job ' + jobId + ' ' + command);\n      case -2:\n        return new Error('Missing lock for job ' + jobId + ' ' + command);\n      case -3:\n        return new Error(\n          `Job ${jobId} is not in the ${state} state. ${command}`\n        );\n      case -6:\n        return new Error(\n          `Lock mismatch for job ${jobId}. Cmd ${command} from ${state}`\n        );\n    }\n  },\n\n  // TODO: add a retention argument for completed and finished jobs (in time).\n  moveToCompleted(\n    job,\n    returnvalue,\n    removeOnComplete,\n    ignoreLock,\n    notFetch = false\n  ) {\n    return scripts.moveToFinished(\n      job,\n      returnvalue,\n      'returnvalue',\n      removeOnComplete,\n      'completed',\n      ignoreLock,\n      notFetch\n    );\n  },\n\n  moveToFailedArgs(job, failedReason, removeOnFailed, ignoreLock) {\n    return scripts.moveToFinishedArgs(\n      job,\n      failedReason,\n      'failedReason',\n      removeOnFailed,\n      'failed',\n      ignoreLock,\n      true\n    );\n  },\n\n  moveToFailed(job, failedReason, removeOnFailed, ignoreLock) {\n    const args = scripts.moveToFailedArgs(\n      job,\n      failedReason,\n      removeOnFailed,\n      ignoreLock\n    );\n    return scripts.moveToFinished(args);\n  },\n\n  isFinished(job) {\n    const keys = _.map(['completed', 'failed'], key => {\n      return job.queue.toKey(key);\n    });\n\n    return job.queue.client.isFinished(keys.concat([job.id]));\n  },\n\n  moveToDelayedArgs(queue, jobId, timestamp, ignoreLock) {\n    //\n    // Bake in the job id first 12 bits into the timestamp\n    // to guarantee correct execution order of delayed jobs\n    // (up to 4096 jobs per given timestamp or 4096 jobs apart per timestamp)\n    //\n    // WARNING: Jobs that are so far apart that they wrap around will cause FIFO to fail\n    //\n    timestamp = _.isUndefined(timestamp) ? 0 : timestamp;\n\n    timestamp = +timestamp || 0;\n    timestamp = timestamp < 0 ? 0 : timestamp;\n    if (timestamp > 0) {\n      timestamp = timestamp * 0x1000 + (jobId & 0xfff);\n    }\n\n    const keys = _.map(['active', 'delayed', jobId, 'stalled'], name => {\n      return queue.toKey(name);\n    });\n    return keys.concat([\n      JSON.stringify(timestamp),\n      jobId,\n      ignoreLock ? '0' : queue.token\n    ]);\n  },\n\n  moveToDelayed(queue, jobId, timestamp, ignoreLock) {\n    const args = scripts.moveToDelayedArgs(queue, jobId, timestamp, ignoreLock);\n    return queue.client.moveToDelayed(args).then(result => {\n      switch (result) {\n        case -1:\n          throw new Error(\n            'Missing Job ' +\n              jobId +\n              ' when trying to move from active to delayed'\n          );\n        case -2:\n          throw new Error(\n            'Job ' +\n              jobId +\n              ' was locked when trying to move from active to delayed'\n          );\n      }\n    });\n  },\n\n  remove(queue, jobId) {\n    const keys = [\n      queue.keys.active,\n      queue.keys.wait,\n      queue.keys.delayed,\n      queue.keys.paused,\n      queue.keys.completed,\n      queue.keys.failed,\n      queue.keys.priority,\n      queue.toKey(jobId),\n      queue.toKey(`${jobId}:logs`),\n      queue.keys.limiter,\n      queue.toKey(''),\n    ];\n    return queue.client.removeJob(keys.concat([jobId, queue.token]));\n  },\n\n  async removeWithPattern(queue, pattern) {\n    const keys = [\n      queue.keys.active,\n      queue.keys.wait,\n      queue.keys.delayed,\n      queue.keys.paused,\n      queue.keys.completed,\n      queue.keys.failed,\n      queue.keys.priority,\n      queue.keys.limiter\n    ];\n\n    const allRemoved = [];\n    let cursor = '0',\n      removed;\n    do {\n      [cursor, removed] = await queue.client.removeJobs(\n        keys.concat([queue.toKey(''), pattern, cursor])\n      );\n      allRemoved.push.apply(allRemoved, removed);\n    } while (cursor !== '0');\n\n    return allRemoved;\n  },\n\n  extendLock(queue, jobId, duration) {\n    return queue.client.extendLock([\n      queue.toKey(jobId) + ':lock',\n      queue.keys.stalled,\n      queue.token,\n      duration,\n      jobId\n    ]);\n  },\n\n  releaseLock(queue, jobId) {\n    return queue.client.releaseLock([\n      queue.toKey(jobId) + ':lock',\n      queue.token\n    ]);\n  },\n\n  takeLock(queue, job) {\n    return queue.client.takeLock([\n      job.lockKey(),\n      queue.token,\n      queue.settings.lockDuration\n    ]);\n  },\n\n  /**\n    It checks if the job in the top of the delay set should be moved back to the\n    top of the  wait queue (so that it will be processed as soon as possible)\n  */\n  updateDelaySet(queue, delayedTimestamp) {\n    const keys = [\n      queue.keys.delayed,\n      queue.keys.active,\n      queue.keys.wait,\n      queue.keys.priority,\n      queue.keys.paused,\n      queue.keys['meta-paused']\n    ];\n\n    const args = [queue.toKey(''), delayedTimestamp, queue.token];\n    return queue.client.updateDelaySet(keys.concat(args));\n  },\n\n  promote(queue, jobId) {\n    const keys = [\n      queue.keys.delayed,\n      queue.keys.wait,\n      queue.keys.paused,\n      queue.keys['meta-paused'],\n      queue.keys.priority\n    ];\n\n    const args = [queue.toKey(''), jobId, queue.token];\n\n    return queue.client.promote(keys.concat(args));\n  },\n\n  /**\n   * Looks for unlocked jobs in the active queue.\n   *\n   *    The job was being worked on, but the worker process died and it failed to renew the lock.\n   *    We call these jobs 'stalled'. This is the most common case. We resolve these by moving them\n   *    back to wait to be re-processed. To prevent jobs from cycling endlessly between active and wait,\n   *    (e.g. if the job handler keeps crashing), we limit the number stalled job recoveries to settings.maxStalledCount.\n   */\n  moveUnlockedJobsToWait(queue) {\n    const keys = [\n      queue.keys.stalled,\n      queue.keys.wait,\n      queue.keys.active,\n      queue.keys.failed,\n      queue.keys['stalled-check'],\n      queue.keys['meta-paused'],\n      queue.keys.paused\n    ];\n    const args = [\n      queue.settings.maxStalledCount,\n      queue.toKey(''),\n      Date.now(),\n      queue.settings.stalledInterval\n    ];\n    return queue.client.moveStalledJobsToWait(keys.concat(args));\n  },\n\n  cleanJobsInSet(queue, set, ts, limit) {\n    return queue.client.cleanJobsInSet([\n      queue.toKey(set),\n      queue.toKey('priority'),\n      queue.keys.limiter,\n      queue.toKey(''),\n      ts,\n      limit || 0,\n      set\n    ]);\n  },\n\n  retryJobArgs(job, ignoreLock) {\n    const queue = job.queue;\n    const jobId = job.id;\n\n    const keys = _.map(\n      ['active', 'wait', jobId, 'meta-paused', 'paused', 'stalled', 'priority'],\n      name => {\n        return queue.toKey(name);\n      }\n    );\n\n    const pushCmd = (job.opts.lifo ? 'R' : 'L') + 'PUSH';\n\n    return keys.concat([pushCmd, jobId, ignoreLock ? '0' : job.queue.token]);\n  },\n\n  /**\n   * Attempts to reprocess a job\n   *\n   * @param {Job} job\n   * @param {Object} options\n   * @param {String} options.state The expected job state. If the job is not found\n   * on the provided state, then it's not reprocessed. Supported states: 'failed', 'completed'\n   *\n   * @return {Promise<Number>} Returns a promise that evaluates to a return code:\n   * 1 means the operation was a success\n   * 0 means the job does not exist\n   * -1 means the job is currently locked and can't be retried.\n   * -2 means the job was not found in the expected set\n   */\n  reprocessJob(job, options) {\n    const queue = job.queue;\n\n    const keys = [\n      queue.toKey(job.id),\n      queue.toKey(job.id) + ':lock',\n      queue.toKey(options.state),\n      queue.toKey('wait'),\n      queue.toKey('meta-paused'),\n      queue.toKey('paused')\n    ];\n\n    const args = [\n      job.id,\n      (job.opts.lifo ? 'R' : 'L') + 'PUSH',\n      queue.token,\n      Date.now()\n    ];\n\n    return queue.client.reprocessJob(keys.concat(args));\n  },\n\n  obliterate(queue, opts) {\n    const client = queue.client;\n\n    const keys = [queue.keys['meta-paused'], queue.toKey('')];\n    const args = [opts.count, opts.force ? 'force' : null];\n\n    return client.obliterate(keys.concat(args)).then(result => {\n      if (result < 0) {\n        switch (result) {\n          case -1:\n            throw new Error('Cannot obliterate non-paused queue');\n          case -2:\n            throw new Error('Cannot obliterate queue with active jobs');\n        }\n      }\n      return result;\n    });\n  }\n};\n\nmodule.exports = scripts;\n\nfunction array2obj(arr) {\n  const obj = {};\n  for (let i = 0; i < arr.length; i += 2) {\n    obj[arr[i]] = arr[i + 1];\n  }\n  return obj;\n}\n\nfunction raw2jobData(raw) {\n  if (raw) {\n    const jobData = raw[0];\n    if (jobData.length) {\n      const job = array2obj(jobData);\n      return [job, raw[1]];\n    }\n  }\n  return [];\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvYnVsbC9saWIvc2NyaXB0cy5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7O0FBRWE7O0FBRWIsVUFBVSxtQkFBTyxDQUFDLHFEQUFRO0FBQzFCLGlCQUFpQixtQkFBTyxDQUFDLDZEQUFVOztBQUVuQztBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLGFBQWEsR0FBRyxlQUFlO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBOztBQUVBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIseUJBQXlCO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxHQUFHOztBQUVIO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsOENBQThDLE9BQU87O0FBRXJEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1osWUFBWTtBQUNaOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLHlCQUF5QjtBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsT0FBTyxnQkFBZ0IsT0FBTyxTQUFTLFFBQVE7QUFDaEU7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DLE1BQU0sUUFBUSxTQUFTLE9BQU8sTUFBTTtBQUN2RTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsTUFBTTtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTs7QUFFTjtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBLGFBQWEsS0FBSztBQUNsQixhQUFhLFFBQVE7QUFDckIsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQSxjQUFjLGlCQUFpQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLGtCQUFrQixnQkFBZ0I7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9teS1hcHAvLi9ub2RlX21vZHVsZXMvYnVsbC9saWIvc2NyaXB0cy5qcz9hNzA4Il0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogSW5jbHVkZXMgYWxsIHRoZSBzY3JpcHRzIG5lZWRlZCBieSB0aGUgcXVldWUgYW5kIGpvYnMuXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCBfID0gcmVxdWlyZSgnbG9kYXNoJyk7XG5jb25zdCBtc2dwYWNrciA9IHJlcXVpcmUoJ21zZ3BhY2tyJyk7XG5cbmNvbnN0IHBhY2tlciA9IG5ldyBtc2dwYWNrci5QYWNrcih7XG4gIHVzZVJlY29yZHM6IGZhbHNlLFxuICBlbmNvZGVVbmRlZmluZWRBc05pbDogdHJ1ZVxufSk7XG5cbmNvbnN0IHBhY2sgPSBwYWNrZXIucGFjaztcblxuY29uc3Qgc2NyaXB0cyA9IHtcbiAgaXNKb2JJbkxpc3QoY2xpZW50LCBsaXN0S2V5LCBqb2JJZCkge1xuICAgIHJldHVybiBjbGllbnQuaXNKb2JJbkxpc3QoW2xpc3RLZXksIGpvYklkXSkudGhlbihyZXN1bHQgPT4ge1xuICAgICAgcmV0dXJuIHJlc3VsdCA9PT0gMTtcbiAgICB9KTtcbiAgfSxcblxuICBhZGRKb2IoY2xpZW50LCBxdWV1ZSwgam9iLCBvcHRzKSB7XG4gICAgY29uc3QgcXVldWVLZXlzID0gcXVldWUua2V5cztcbiAgICBsZXQga2V5cyA9IFtcbiAgICAgIHF1ZXVlS2V5cy53YWl0LFxuICAgICAgcXVldWVLZXlzLnBhdXNlZCxcbiAgICAgIHF1ZXVlS2V5c1snbWV0YS1wYXVzZWQnXSxcbiAgICAgIHF1ZXVlS2V5cy5pZCxcbiAgICAgIHF1ZXVlS2V5cy5kZWxheWVkLFxuICAgICAgcXVldWVLZXlzLnByaW9yaXR5XG4gICAgXTtcblxuICAgIGNvbnN0IGFyZ3MgPSBbXG4gICAgICBxdWV1ZUtleXNbJyddLFxuICAgICAgXy5pc1VuZGVmaW5lZChvcHRzLmN1c3RvbUpvYklkKSA/ICcnIDogb3B0cy5jdXN0b21Kb2JJZCxcbiAgICAgIGpvYi5uYW1lLFxuICAgICAgam9iLmRhdGEsXG4gICAgICBwYWNrKGpvYi5vcHRzKSxcbiAgICAgIGpvYi50aW1lc3RhbXAsXG4gICAgICBqb2IuZGVsYXksXG4gICAgICBqb2IuZGVsYXkgPyBqb2IudGltZXN0YW1wICsgam9iLmRlbGF5IDogMCxcbiAgICAgIG9wdHMucHJpb3JpdHkgfHwgMCxcbiAgICAgIG9wdHMubGlmbyA/ICdSUFVTSCcgOiAnTFBVU0gnLFxuICAgICAgcXVldWUudG9rZW4sXG4gICAgICBqb2IuZGVib3VuY2VJZCA/IGAke3F1ZXVlS2V5cy5kZX06JHtqb2IuZGVib3VuY2VJZH1gIDogbnVsbCxcbiAgICAgIG9wdHMuZGVib3VuY2UgPyBvcHRzLmRlYm91bmNlLmlkIDogbnVsbCxcbiAgICAgIG9wdHMuZGVib3VuY2UgPyBvcHRzLmRlYm91bmNlLnR0bCA6IG51bGwsXG4gICAgXTtcbiAgICBrZXlzID0ga2V5cy5jb25jYXQoYXJncyk7XG4gICAgcmV0dXJuIGNsaWVudC5hZGRKb2Ioa2V5cyk7XG4gIH0sXG5cbiAgcGF1c2UocXVldWUsIHBhdXNlKSB7XG4gICAgbGV0IHNyYyA9ICd3YWl0JyxcbiAgICAgIGRzdCA9ICdwYXVzZWQnO1xuICAgIGlmICghcGF1c2UpIHtcbiAgICAgIHNyYyA9ICdwYXVzZWQnO1xuICAgICAgZHN0ID0gJ3dhaXQnO1xuICAgIH1cblxuICAgIGNvbnN0IGtleXMgPSBfLm1hcChcbiAgICAgIFtzcmMsIGRzdCwgJ21ldGEtcGF1c2VkJywgcGF1c2UgPyAncGF1c2VkJyA6ICdyZXN1bWVkJywgJ21ldGEnXSxcbiAgICAgIG5hbWUgPT4ge1xuICAgICAgICByZXR1cm4gcXVldWUudG9LZXkobmFtZSk7XG4gICAgICB9XG4gICAgKTtcblxuICAgIHJldHVybiBxdWV1ZS5jbGllbnQucGF1c2Uoa2V5cy5jb25jYXQoW3BhdXNlID8gJ3BhdXNlZCcgOiAncmVzdW1lZCddKSk7XG4gIH0sXG5cbiAgYXN5bmMgYWRkTG9nKHF1ZXVlLCBqb2JJZCwgbG9nUm93LCBrZWVwTG9ncykge1xuICAgIGNvbnN0IGNsaWVudCA9IGF3YWl0IHF1ZXVlLmNsaWVudDtcblxuICAgIGNvbnN0IGtleXMgPSBbcXVldWUudG9LZXkoam9iSWQpLCBxdWV1ZS50b0tleShqb2JJZCkgKyAnOmxvZ3MnXTtcblxuICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IGNsaWVudC5hZGRMb2coXG4gICAgICBrZXlzLmNvbmNhdChbam9iSWQsIGxvZ1Jvdywga2VlcExvZ3MgPyBrZWVwTG9ncyA6ICcnXSlcbiAgICApO1xuXG4gICAgaWYgKHJlc3VsdCA8IDApIHtcbiAgICAgIHRocm93IHNjcmlwdHMuZmluaXNoZWRFcnJvcnMocmVzdWx0LCBqb2JJZCwgJ2FkZExvZycpO1xuICAgIH1cblxuICAgIHJldHVybiByZXN1bHQ7XG4gIH0sXG5cbiAgZ2V0Q291bnRzUGVyUHJpb3JpdHlBcmdzKHF1ZXVlLCBwcmlvcml0aWVzKSB7XG4gICAgY29uc3Qga2V5cyA9IFtcbiAgICAgIHF1ZXVlLmtleXMud2FpdCxcbiAgICAgIHF1ZXVlLmtleXMucGF1c2VkLFxuICAgICAgcXVldWUua2V5c1snbWV0YS1wYXVzZWQnXSxcbiAgICAgIHF1ZXVlLmtleXMucHJpb3JpdHlcbiAgICBdO1xuXG4gICAgY29uc3QgYXJncyA9IHByaW9yaXRpZXM7XG5cbiAgICByZXR1cm4ga2V5cy5jb25jYXQoYXJncyk7XG4gIH0sXG5cbiAgYXN5bmMgZ2V0Q291bnRzUGVyUHJpb3JpdHkocXVldWUsIHByaW9yaXRpZXMpIHtcbiAgICBjb25zdCBjbGllbnQgPSBhd2FpdCBxdWV1ZS5jbGllbnQ7XG4gICAgY29uc3QgYXJncyA9IHRoaXMuZ2V0Q291bnRzUGVyUHJpb3JpdHlBcmdzKHF1ZXVlLCBwcmlvcml0aWVzKTtcblxuICAgIHJldHVybiBjbGllbnQuZ2V0Q291bnRzUGVyUHJpb3JpdHkoYXJncyk7XG4gIH0sXG5cbiAgbW92ZVRvQWN0aXZlKHF1ZXVlLCBqb2JJZCkge1xuICAgIGNvbnN0IHF1ZXVlS2V5cyA9IHF1ZXVlLmtleXM7XG4gICAgY29uc3Qga2V5cyA9IFtxdWV1ZUtleXMud2FpdCwgcXVldWVLZXlzLmFjdGl2ZSwgcXVldWVLZXlzLnByaW9yaXR5XTtcblxuICAgIGtleXNbM10gPSBrZXlzWzFdICsgJ0AnICsgcXVldWUudG9rZW47XG4gICAga2V5c1s0XSA9IHF1ZXVlS2V5cy5zdGFsbGVkO1xuICAgIGtleXNbNV0gPSBxdWV1ZUtleXMubGltaXRlcjtcbiAgICBrZXlzWzZdID0gcXVldWVLZXlzLmRlbGF5ZWQ7XG4gICAga2V5c1s3XSA9IHF1ZXVlS2V5cy5kcmFpbmVkO1xuXG4gICAgY29uc3QgYXJncyA9IFtcbiAgICAgIHF1ZXVlS2V5c1snJ10sXG4gICAgICBxdWV1ZS50b2tlbixcbiAgICAgIHF1ZXVlLnNldHRpbmdzLmxvY2tEdXJhdGlvbixcbiAgICAgIERhdGUubm93KCksXG4gICAgICBqb2JJZFxuICAgIF07XG5cbiAgICBpZiAocXVldWUubGltaXRlcikge1xuICAgICAgYXJncy5wdXNoKFxuICAgICAgICBxdWV1ZS5saW1pdGVyLm1heCxcbiAgICAgICAgcXVldWUubGltaXRlci5kdXJhdGlvbixcbiAgICAgICAgISFxdWV1ZS5saW1pdGVyLmJvdW5jZUJhY2tcbiAgICAgICk7XG4gICAgICBxdWV1ZS5saW1pdGVyLmdyb3VwS2V5ICYmIGFyZ3MucHVzaCh0cnVlKTtcbiAgICB9XG5cbiAgICByZXR1cm4gcXVldWUuY2xpZW50Lm1vdmVUb0FjdGl2ZShrZXlzLmNvbmNhdChhcmdzKSkudGhlbihyYXcyam9iRGF0YSk7XG4gIH0sXG5cbiAgdXBkYXRlUHJvZ3Jlc3Moam9iLCBwcm9ncmVzcykge1xuICAgIGNvbnN0IHF1ZXVlID0gam9iLnF1ZXVlO1xuICAgIGNvbnN0IGtleXMgPSBbam9iLmlkLCAncHJvZ3Jlc3MnXS5tYXAobmFtZSA9PiB7XG4gICAgICByZXR1cm4gcXVldWUudG9LZXkobmFtZSk7XG4gICAgfSk7XG5cbiAgICBjb25zdCBwcm9ncmVzc0pzb24gPSBKU09OLnN0cmluZ2lmeShwcm9ncmVzcyk7XG4gICAgcmV0dXJuIHF1ZXVlLmNsaWVudFxuICAgICAgLnVwZGF0ZVByb2dyZXNzKGtleXMsIFtcbiAgICAgICAgcHJvZ3Jlc3NKc29uLFxuICAgICAgICBKU09OLnN0cmluZ2lmeSh7IGpvYklkOiBqb2IuaWQsIHByb2dyZXNzIH0pXG4gICAgICBdKVxuICAgICAgLnRoZW4oY29kZSA9PiB7XG4gICAgICAgIGlmIChjb2RlIDwgMCkge1xuICAgICAgICAgIHRocm93IHNjcmlwdHMuZmluaXNoZWRFcnJvcnMoY29kZSwgam9iLmlkLCAndXBkYXRlUHJvZ3Jlc3MnKTtcbiAgICAgICAgfVxuICAgICAgICBxdWV1ZS5lbWl0KCdwcm9ncmVzcycsIGpvYiwgcHJvZ3Jlc3MpO1xuICAgICAgfSk7XG4gIH0sXG5cbiAgdXBkYXRlRGF0YShqb2IsIGRhdGEpIHtcbiAgICBjb25zdCBxdWV1ZSA9IGpvYi5xdWV1ZTtcbiAgICBjb25zdCBrZXlzID0gW2pvYi5pZF0ubWFwKG5hbWUgPT4ge1xuICAgICAgcmV0dXJuIHF1ZXVlLnRvS2V5KG5hbWUpO1xuICAgIH0pO1xuICAgIGNvbnN0IGRhdGFKc29uID0gSlNPTi5zdHJpbmdpZnkoZGF0YSk7XG5cbiAgICByZXR1cm4gcXVldWUuY2xpZW50LnVwZGF0ZURhdGEoa2V5cywgW2RhdGFKc29uXSk7XG4gIH0sXG5cbiAgc2F2ZVN0YWNrdHJhY2VBcmdzKFxuICAgIGpvYixcbiAgICBzdGFja3RyYWNlLFxuICAgIGZhaWxlZFJlYXNvblxuICApIHtcbiAgICBjb25zdCBxdWV1ZSA9IGpvYi5xdWV1ZTtcblxuICAgIGNvbnN0IGtleXMgPSBbcXVldWUudG9LZXkoam9iLmlkKV07XG5cbiAgICByZXR1cm4ga2V5cy5jb25jYXQoW3N0YWNrdHJhY2UsIGZhaWxlZFJlYXNvbiwgam9iLmF0dGVtcHRzTWFkZV0pO1xuICB9LFxuXG4gIHJldHJ5Sm9ic0FyZ3MocXVldWUsIGNvdW50KSB7XG4gICAgY29uc3Qga2V5cyA9IFtcbiAgICAgIHF1ZXVlLnRvS2V5KCcnKSxcbiAgICAgIHF1ZXVlLnRvS2V5KCdmYWlsZWQnKSxcbiAgICAgIHF1ZXVlLnRvS2V5KCd3YWl0JyksXG4gICAgICBxdWV1ZS50b0tleSgnbWV0YS1wYXVzZWQnKSxcbiAgICAgIHF1ZXVlLnRvS2V5KCdwYXVzZWQnKVxuICAgIF07XG5cbiAgICBjb25zdCBhcmdzID0gW2NvdW50XTtcblxuICAgIHJldHVybiBrZXlzLmNvbmNhdChhcmdzKTtcbiAgfSxcblxuICBhc3luYyByZXRyeUpvYnMocXVldWUsIGNvdW50ID0gMTAwMCkge1xuICAgIGNvbnN0IGNsaWVudCA9IGF3YWl0IHF1ZXVlLmNsaWVudDtcblxuICAgIGNvbnN0IGFyZ3MgPSB0aGlzLnJldHJ5Sm9ic0FyZ3MocXVldWUsIGNvdW50KTtcblxuICAgIHJldHVybiBjbGllbnQucmV0cnlKb2JzKGFyZ3MpO1xuICB9LFxuXG4gIG1vdmVUb0ZpbmlzaGVkQXJncyhcbiAgICBqb2IsXG4gICAgdmFsLFxuICAgIHByb3BWYWwsXG4gICAgc2hvdWxkUmVtb3ZlLFxuICAgIHRhcmdldCxcbiAgICBpZ25vcmVMb2NrLFxuICAgIG5vdEZldGNoXG4gICkge1xuICAgIGNvbnN0IHF1ZXVlID0gam9iLnF1ZXVlO1xuICAgIGNvbnN0IHF1ZXVlS2V5cyA9IHF1ZXVlLmtleXM7XG5cbiAgICBjb25zdCBtZXRyaWNzS2V5ID0gcXVldWUudG9LZXkoYG1ldHJpY3M6JHt0YXJnZXR9YCk7XG5cbiAgICBjb25zdCBrZXlzID0gW1xuICAgICAgcXVldWVLZXlzLmFjdGl2ZSxcbiAgICAgIHF1ZXVlS2V5c1t0YXJnZXRdLFxuICAgICAgcXVldWUudG9LZXkoam9iLmlkKSxcbiAgICAgIHF1ZXVlS2V5cy53YWl0LFxuICAgICAgcXVldWVLZXlzLnByaW9yaXR5LFxuICAgICAgcXVldWVLZXlzLmFjdGl2ZSArICdAJyArIHF1ZXVlLnRva2VuLFxuICAgICAgcXVldWVLZXlzLmRlbGF5ZWQsXG4gICAgICBxdWV1ZUtleXMuc3RhbGxlZCxcbiAgICAgIG1ldHJpY3NLZXlcbiAgICBdO1xuXG4gICAgY29uc3Qga2VlcEpvYnMgPSBwYWNrKFxuICAgICAgdHlwZW9mIHNob3VsZFJlbW92ZSA9PT0gJ29iamVjdCdcbiAgICAgICAgPyBzaG91bGRSZW1vdmVcbiAgICAgICAgOiB0eXBlb2Ygc2hvdWxkUmVtb3ZlID09PSAnbnVtYmVyJ1xuICAgICAgICA/IHsgY291bnQ6IHNob3VsZFJlbW92ZSB9XG4gICAgICAgIDogeyBjb3VudDogc2hvdWxkUmVtb3ZlID8gMCA6IC0xIH1cbiAgICApO1xuXG4gICAgY29uc3QgYXJncyA9IFtcbiAgICAgIGpvYi5pZCxcbiAgICAgIGpvYi5maW5pc2hlZE9uLFxuICAgICAgcHJvcFZhbCxcbiAgICAgIF8uaXNVbmRlZmluZWQodmFsKSA/ICdudWxsJyA6IHZhbCxcbiAgICAgIGlnbm9yZUxvY2sgPyAnMCcgOiBxdWV1ZS50b2tlbixcbiAgICAgIGtlZXBKb2JzLFxuICAgICAgSlNPTi5zdHJpbmdpZnkoeyBqb2JJZDogam9iLmlkLCB2YWw6IHZhbCB9KSxcbiAgICAgIG5vdEZldGNoIHx8IHF1ZXVlLnBhdXNlZCB8fCBxdWV1ZS5jbG9zaW5nIHx8IHF1ZXVlLmxpbWl0ZXIgPyAwIDogMSxcbiAgICAgIHF1ZXVlS2V5c1snJ10sXG4gICAgICBxdWV1ZS5zZXR0aW5ncy5sb2NrRHVyYXRpb24sXG4gICAgICBxdWV1ZS50b2tlbixcbiAgICAgIHF1ZXVlLm1ldHJpY3MgJiYgcXVldWUubWV0cmljcy5tYXhEYXRhUG9pbnRzXG4gICAgXTtcblxuICAgIHJldHVybiBrZXlzLmNvbmNhdChhcmdzKTtcbiAgfSxcblxuICBtb3ZlVG9GaW5pc2hlZChcbiAgICBqb2IsXG4gICAgdmFsLFxuICAgIHByb3BWYWwsXG4gICAgc2hvdWxkUmVtb3ZlLFxuICAgIHRhcmdldCxcbiAgICBpZ25vcmVMb2NrLFxuICAgIG5vdEZldGNoID0gZmFsc2VcbiAgKSB7XG4gICAgY29uc3QgYXJncyA9IHNjcmlwdHMubW92ZVRvRmluaXNoZWRBcmdzKFxuICAgICAgam9iLFxuICAgICAgdmFsLFxuICAgICAgcHJvcFZhbCxcbiAgICAgIHNob3VsZFJlbW92ZSxcbiAgICAgIHRhcmdldCxcbiAgICAgIGlnbm9yZUxvY2ssXG4gICAgICBub3RGZXRjaCxcbiAgICAgIGpvYi5xdWV1ZS50b0tleSgnJylcbiAgICApO1xuICAgIHJldHVybiBqb2IucXVldWUuY2xpZW50Lm1vdmVUb0ZpbmlzaGVkKGFyZ3MpLnRoZW4ocmVzdWx0ID0+IHtcbiAgICAgIGlmIChyZXN1bHQgPCAwKSB7XG4gICAgICAgIHRocm93IHNjcmlwdHMuZmluaXNoZWRFcnJvcnMocmVzdWx0LCBqb2IuaWQsICdmaW5pc2hlZCcsICdhY3RpdmUnKTtcbiAgICAgIH0gZWxzZSBpZiAocmVzdWx0KSB7XG4gICAgICAgIHJldHVybiByYXcyam9iRGF0YShyZXN1bHQpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIDA7XG4gICAgfSk7XG4gIH0sXG5cbiAgZmluaXNoZWRFcnJvcnMoY29kZSwgam9iSWQsIGNvbW1hbmQsIHN0YXRlKSB7XG4gICAgc3dpdGNoIChjb2RlKSB7XG4gICAgICBjYXNlIC0xOlxuICAgICAgICByZXR1cm4gbmV3IEVycm9yKCdNaXNzaW5nIGtleSBmb3Igam9iICcgKyBqb2JJZCArICcgJyArIGNvbW1hbmQpO1xuICAgICAgY2FzZSAtMjpcbiAgICAgICAgcmV0dXJuIG5ldyBFcnJvcignTWlzc2luZyBsb2NrIGZvciBqb2IgJyArIGpvYklkICsgJyAnICsgY29tbWFuZCk7XG4gICAgICBjYXNlIC0zOlxuICAgICAgICByZXR1cm4gbmV3IEVycm9yKFxuICAgICAgICAgIGBKb2IgJHtqb2JJZH0gaXMgbm90IGluIHRoZSAke3N0YXRlfSBzdGF0ZS4gJHtjb21tYW5kfWBcbiAgICAgICAgKTtcbiAgICAgIGNhc2UgLTY6XG4gICAgICAgIHJldHVybiBuZXcgRXJyb3IoXG4gICAgICAgICAgYExvY2sgbWlzbWF0Y2ggZm9yIGpvYiAke2pvYklkfS4gQ21kICR7Y29tbWFuZH0gZnJvbSAke3N0YXRlfWBcbiAgICAgICAgKTtcbiAgICB9XG4gIH0sXG5cbiAgLy8gVE9ETzogYWRkIGEgcmV0ZW50aW9uIGFyZ3VtZW50IGZvciBjb21wbGV0ZWQgYW5kIGZpbmlzaGVkIGpvYnMgKGluIHRpbWUpLlxuICBtb3ZlVG9Db21wbGV0ZWQoXG4gICAgam9iLFxuICAgIHJldHVybnZhbHVlLFxuICAgIHJlbW92ZU9uQ29tcGxldGUsXG4gICAgaWdub3JlTG9jayxcbiAgICBub3RGZXRjaCA9IGZhbHNlXG4gICkge1xuICAgIHJldHVybiBzY3JpcHRzLm1vdmVUb0ZpbmlzaGVkKFxuICAgICAgam9iLFxuICAgICAgcmV0dXJudmFsdWUsXG4gICAgICAncmV0dXJudmFsdWUnLFxuICAgICAgcmVtb3ZlT25Db21wbGV0ZSxcbiAgICAgICdjb21wbGV0ZWQnLFxuICAgICAgaWdub3JlTG9jayxcbiAgICAgIG5vdEZldGNoXG4gICAgKTtcbiAgfSxcblxuICBtb3ZlVG9GYWlsZWRBcmdzKGpvYiwgZmFpbGVkUmVhc29uLCByZW1vdmVPbkZhaWxlZCwgaWdub3JlTG9jaykge1xuICAgIHJldHVybiBzY3JpcHRzLm1vdmVUb0ZpbmlzaGVkQXJncyhcbiAgICAgIGpvYixcbiAgICAgIGZhaWxlZFJlYXNvbixcbiAgICAgICdmYWlsZWRSZWFzb24nLFxuICAgICAgcmVtb3ZlT25GYWlsZWQsXG4gICAgICAnZmFpbGVkJyxcbiAgICAgIGlnbm9yZUxvY2ssXG4gICAgICB0cnVlXG4gICAgKTtcbiAgfSxcblxuICBtb3ZlVG9GYWlsZWQoam9iLCBmYWlsZWRSZWFzb24sIHJlbW92ZU9uRmFpbGVkLCBpZ25vcmVMb2NrKSB7XG4gICAgY29uc3QgYXJncyA9IHNjcmlwdHMubW92ZVRvRmFpbGVkQXJncyhcbiAgICAgIGpvYixcbiAgICAgIGZhaWxlZFJlYXNvbixcbiAgICAgIHJlbW92ZU9uRmFpbGVkLFxuICAgICAgaWdub3JlTG9ja1xuICAgICk7XG4gICAgcmV0dXJuIHNjcmlwdHMubW92ZVRvRmluaXNoZWQoYXJncyk7XG4gIH0sXG5cbiAgaXNGaW5pc2hlZChqb2IpIHtcbiAgICBjb25zdCBrZXlzID0gXy5tYXAoWydjb21wbGV0ZWQnLCAnZmFpbGVkJ10sIGtleSA9PiB7XG4gICAgICByZXR1cm4gam9iLnF1ZXVlLnRvS2V5KGtleSk7XG4gICAgfSk7XG5cbiAgICByZXR1cm4gam9iLnF1ZXVlLmNsaWVudC5pc0ZpbmlzaGVkKGtleXMuY29uY2F0KFtqb2IuaWRdKSk7XG4gIH0sXG5cbiAgbW92ZVRvRGVsYXllZEFyZ3MocXVldWUsIGpvYklkLCB0aW1lc3RhbXAsIGlnbm9yZUxvY2spIHtcbiAgICAvL1xuICAgIC8vIEJha2UgaW4gdGhlIGpvYiBpZCBmaXJzdCAxMiBiaXRzIGludG8gdGhlIHRpbWVzdGFtcFxuICAgIC8vIHRvIGd1YXJhbnRlZSBjb3JyZWN0IGV4ZWN1dGlvbiBvcmRlciBvZiBkZWxheWVkIGpvYnNcbiAgICAvLyAodXAgdG8gNDA5NiBqb2JzIHBlciBnaXZlbiB0aW1lc3RhbXAgb3IgNDA5NiBqb2JzIGFwYXJ0IHBlciB0aW1lc3RhbXApXG4gICAgLy9cbiAgICAvLyBXQVJOSU5HOiBKb2JzIHRoYXQgYXJlIHNvIGZhciBhcGFydCB0aGF0IHRoZXkgd3JhcCBhcm91bmQgd2lsbCBjYXVzZSBGSUZPIHRvIGZhaWxcbiAgICAvL1xuICAgIHRpbWVzdGFtcCA9IF8uaXNVbmRlZmluZWQodGltZXN0YW1wKSA/IDAgOiB0aW1lc3RhbXA7XG5cbiAgICB0aW1lc3RhbXAgPSArdGltZXN0YW1wIHx8IDA7XG4gICAgdGltZXN0YW1wID0gdGltZXN0YW1wIDwgMCA/IDAgOiB0aW1lc3RhbXA7XG4gICAgaWYgKHRpbWVzdGFtcCA+IDApIHtcbiAgICAgIHRpbWVzdGFtcCA9IHRpbWVzdGFtcCAqIDB4MTAwMCArIChqb2JJZCAmIDB4ZmZmKTtcbiAgICB9XG5cbiAgICBjb25zdCBrZXlzID0gXy5tYXAoWydhY3RpdmUnLCAnZGVsYXllZCcsIGpvYklkLCAnc3RhbGxlZCddLCBuYW1lID0+IHtcbiAgICAgIHJldHVybiBxdWV1ZS50b0tleShuYW1lKTtcbiAgICB9KTtcbiAgICByZXR1cm4ga2V5cy5jb25jYXQoW1xuICAgICAgSlNPTi5zdHJpbmdpZnkodGltZXN0YW1wKSxcbiAgICAgIGpvYklkLFxuICAgICAgaWdub3JlTG9jayA/ICcwJyA6IHF1ZXVlLnRva2VuXG4gICAgXSk7XG4gIH0sXG5cbiAgbW92ZVRvRGVsYXllZChxdWV1ZSwgam9iSWQsIHRpbWVzdGFtcCwgaWdub3JlTG9jaykge1xuICAgIGNvbnN0IGFyZ3MgPSBzY3JpcHRzLm1vdmVUb0RlbGF5ZWRBcmdzKHF1ZXVlLCBqb2JJZCwgdGltZXN0YW1wLCBpZ25vcmVMb2NrKTtcbiAgICByZXR1cm4gcXVldWUuY2xpZW50Lm1vdmVUb0RlbGF5ZWQoYXJncykudGhlbihyZXN1bHQgPT4ge1xuICAgICAgc3dpdGNoIChyZXN1bHQpIHtcbiAgICAgICAgY2FzZSAtMTpcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgICAnTWlzc2luZyBKb2IgJyArXG4gICAgICAgICAgICAgIGpvYklkICtcbiAgICAgICAgICAgICAgJyB3aGVuIHRyeWluZyB0byBtb3ZlIGZyb20gYWN0aXZlIHRvIGRlbGF5ZWQnXG4gICAgICAgICAgKTtcbiAgICAgICAgY2FzZSAtMjpcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgICAnSm9iICcgK1xuICAgICAgICAgICAgICBqb2JJZCArXG4gICAgICAgICAgICAgICcgd2FzIGxvY2tlZCB3aGVuIHRyeWluZyB0byBtb3ZlIGZyb20gYWN0aXZlIHRvIGRlbGF5ZWQnXG4gICAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfSxcblxuICByZW1vdmUocXVldWUsIGpvYklkKSB7XG4gICAgY29uc3Qga2V5cyA9IFtcbiAgICAgIHF1ZXVlLmtleXMuYWN0aXZlLFxuICAgICAgcXVldWUua2V5cy53YWl0LFxuICAgICAgcXVldWUua2V5cy5kZWxheWVkLFxuICAgICAgcXVldWUua2V5cy5wYXVzZWQsXG4gICAgICBxdWV1ZS5rZXlzLmNvbXBsZXRlZCxcbiAgICAgIHF1ZXVlLmtleXMuZmFpbGVkLFxuICAgICAgcXVldWUua2V5cy5wcmlvcml0eSxcbiAgICAgIHF1ZXVlLnRvS2V5KGpvYklkKSxcbiAgICAgIHF1ZXVlLnRvS2V5KGAke2pvYklkfTpsb2dzYCksXG4gICAgICBxdWV1ZS5rZXlzLmxpbWl0ZXIsXG4gICAgICBxdWV1ZS50b0tleSgnJyksXG4gICAgXTtcbiAgICByZXR1cm4gcXVldWUuY2xpZW50LnJlbW92ZUpvYihrZXlzLmNvbmNhdChbam9iSWQsIHF1ZXVlLnRva2VuXSkpO1xuICB9LFxuXG4gIGFzeW5jIHJlbW92ZVdpdGhQYXR0ZXJuKHF1ZXVlLCBwYXR0ZXJuKSB7XG4gICAgY29uc3Qga2V5cyA9IFtcbiAgICAgIHF1ZXVlLmtleXMuYWN0aXZlLFxuICAgICAgcXVldWUua2V5cy53YWl0LFxuICAgICAgcXVldWUua2V5cy5kZWxheWVkLFxuICAgICAgcXVldWUua2V5cy5wYXVzZWQsXG4gICAgICBxdWV1ZS5rZXlzLmNvbXBsZXRlZCxcbiAgICAgIHF1ZXVlLmtleXMuZmFpbGVkLFxuICAgICAgcXVldWUua2V5cy5wcmlvcml0eSxcbiAgICAgIHF1ZXVlLmtleXMubGltaXRlclxuICAgIF07XG5cbiAgICBjb25zdCBhbGxSZW1vdmVkID0gW107XG4gICAgbGV0IGN1cnNvciA9ICcwJyxcbiAgICAgIHJlbW92ZWQ7XG4gICAgZG8ge1xuICAgICAgW2N1cnNvciwgcmVtb3ZlZF0gPSBhd2FpdCBxdWV1ZS5jbGllbnQucmVtb3ZlSm9icyhcbiAgICAgICAga2V5cy5jb25jYXQoW3F1ZXVlLnRvS2V5KCcnKSwgcGF0dGVybiwgY3Vyc29yXSlcbiAgICAgICk7XG4gICAgICBhbGxSZW1vdmVkLnB1c2guYXBwbHkoYWxsUmVtb3ZlZCwgcmVtb3ZlZCk7XG4gICAgfSB3aGlsZSAoY3Vyc29yICE9PSAnMCcpO1xuXG4gICAgcmV0dXJuIGFsbFJlbW92ZWQ7XG4gIH0sXG5cbiAgZXh0ZW5kTG9jayhxdWV1ZSwgam9iSWQsIGR1cmF0aW9uKSB7XG4gICAgcmV0dXJuIHF1ZXVlLmNsaWVudC5leHRlbmRMb2NrKFtcbiAgICAgIHF1ZXVlLnRvS2V5KGpvYklkKSArICc6bG9jaycsXG4gICAgICBxdWV1ZS5rZXlzLnN0YWxsZWQsXG4gICAgICBxdWV1ZS50b2tlbixcbiAgICAgIGR1cmF0aW9uLFxuICAgICAgam9iSWRcbiAgICBdKTtcbiAgfSxcblxuICByZWxlYXNlTG9jayhxdWV1ZSwgam9iSWQpIHtcbiAgICByZXR1cm4gcXVldWUuY2xpZW50LnJlbGVhc2VMb2NrKFtcbiAgICAgIHF1ZXVlLnRvS2V5KGpvYklkKSArICc6bG9jaycsXG4gICAgICBxdWV1ZS50b2tlblxuICAgIF0pO1xuICB9LFxuXG4gIHRha2VMb2NrKHF1ZXVlLCBqb2IpIHtcbiAgICByZXR1cm4gcXVldWUuY2xpZW50LnRha2VMb2NrKFtcbiAgICAgIGpvYi5sb2NrS2V5KCksXG4gICAgICBxdWV1ZS50b2tlbixcbiAgICAgIHF1ZXVlLnNldHRpbmdzLmxvY2tEdXJhdGlvblxuICAgIF0pO1xuICB9LFxuXG4gIC8qKlxuICAgIEl0IGNoZWNrcyBpZiB0aGUgam9iIGluIHRoZSB0b3Agb2YgdGhlIGRlbGF5IHNldCBzaG91bGQgYmUgbW92ZWQgYmFjayB0byB0aGVcbiAgICB0b3Agb2YgdGhlICB3YWl0IHF1ZXVlIChzbyB0aGF0IGl0IHdpbGwgYmUgcHJvY2Vzc2VkIGFzIHNvb24gYXMgcG9zc2libGUpXG4gICovXG4gIHVwZGF0ZURlbGF5U2V0KHF1ZXVlLCBkZWxheWVkVGltZXN0YW1wKSB7XG4gICAgY29uc3Qga2V5cyA9IFtcbiAgICAgIHF1ZXVlLmtleXMuZGVsYXllZCxcbiAgICAgIHF1ZXVlLmtleXMuYWN0aXZlLFxuICAgICAgcXVldWUua2V5cy53YWl0LFxuICAgICAgcXVldWUua2V5cy5wcmlvcml0eSxcbiAgICAgIHF1ZXVlLmtleXMucGF1c2VkLFxuICAgICAgcXVldWUua2V5c1snbWV0YS1wYXVzZWQnXVxuICAgIF07XG5cbiAgICBjb25zdCBhcmdzID0gW3F1ZXVlLnRvS2V5KCcnKSwgZGVsYXllZFRpbWVzdGFtcCwgcXVldWUudG9rZW5dO1xuICAgIHJldHVybiBxdWV1ZS5jbGllbnQudXBkYXRlRGVsYXlTZXQoa2V5cy5jb25jYXQoYXJncykpO1xuICB9LFxuXG4gIHByb21vdGUocXVldWUsIGpvYklkKSB7XG4gICAgY29uc3Qga2V5cyA9IFtcbiAgICAgIHF1ZXVlLmtleXMuZGVsYXllZCxcbiAgICAgIHF1ZXVlLmtleXMud2FpdCxcbiAgICAgIHF1ZXVlLmtleXMucGF1c2VkLFxuICAgICAgcXVldWUua2V5c1snbWV0YS1wYXVzZWQnXSxcbiAgICAgIHF1ZXVlLmtleXMucHJpb3JpdHlcbiAgICBdO1xuXG4gICAgY29uc3QgYXJncyA9IFtxdWV1ZS50b0tleSgnJyksIGpvYklkLCBxdWV1ZS50b2tlbl07XG5cbiAgICByZXR1cm4gcXVldWUuY2xpZW50LnByb21vdGUoa2V5cy5jb25jYXQoYXJncykpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBMb29rcyBmb3IgdW5sb2NrZWQgam9icyBpbiB0aGUgYWN0aXZlIHF1ZXVlLlxuICAgKlxuICAgKiAgICBUaGUgam9iIHdhcyBiZWluZyB3b3JrZWQgb24sIGJ1dCB0aGUgd29ya2VyIHByb2Nlc3MgZGllZCBhbmQgaXQgZmFpbGVkIHRvIHJlbmV3IHRoZSBsb2NrLlxuICAgKiAgICBXZSBjYWxsIHRoZXNlIGpvYnMgJ3N0YWxsZWQnLiBUaGlzIGlzIHRoZSBtb3N0IGNvbW1vbiBjYXNlLiBXZSByZXNvbHZlIHRoZXNlIGJ5IG1vdmluZyB0aGVtXG4gICAqICAgIGJhY2sgdG8gd2FpdCB0byBiZSByZS1wcm9jZXNzZWQuIFRvIHByZXZlbnQgam9icyBmcm9tIGN5Y2xpbmcgZW5kbGVzc2x5IGJldHdlZW4gYWN0aXZlIGFuZCB3YWl0LFxuICAgKiAgICAoZS5nLiBpZiB0aGUgam9iIGhhbmRsZXIga2VlcHMgY3Jhc2hpbmcpLCB3ZSBsaW1pdCB0aGUgbnVtYmVyIHN0YWxsZWQgam9iIHJlY292ZXJpZXMgdG8gc2V0dGluZ3MubWF4U3RhbGxlZENvdW50LlxuICAgKi9cbiAgbW92ZVVubG9ja2VkSm9ic1RvV2FpdChxdWV1ZSkge1xuICAgIGNvbnN0IGtleXMgPSBbXG4gICAgICBxdWV1ZS5rZXlzLnN0YWxsZWQsXG4gICAgICBxdWV1ZS5rZXlzLndhaXQsXG4gICAgICBxdWV1ZS5rZXlzLmFjdGl2ZSxcbiAgICAgIHF1ZXVlLmtleXMuZmFpbGVkLFxuICAgICAgcXVldWUua2V5c1snc3RhbGxlZC1jaGVjayddLFxuICAgICAgcXVldWUua2V5c1snbWV0YS1wYXVzZWQnXSxcbiAgICAgIHF1ZXVlLmtleXMucGF1c2VkXG4gICAgXTtcbiAgICBjb25zdCBhcmdzID0gW1xuICAgICAgcXVldWUuc2V0dGluZ3MubWF4U3RhbGxlZENvdW50LFxuICAgICAgcXVldWUudG9LZXkoJycpLFxuICAgICAgRGF0ZS5ub3coKSxcbiAgICAgIHF1ZXVlLnNldHRpbmdzLnN0YWxsZWRJbnRlcnZhbFxuICAgIF07XG4gICAgcmV0dXJuIHF1ZXVlLmNsaWVudC5tb3ZlU3RhbGxlZEpvYnNUb1dhaXQoa2V5cy5jb25jYXQoYXJncykpO1xuICB9LFxuXG4gIGNsZWFuSm9ic0luU2V0KHF1ZXVlLCBzZXQsIHRzLCBsaW1pdCkge1xuICAgIHJldHVybiBxdWV1ZS5jbGllbnQuY2xlYW5Kb2JzSW5TZXQoW1xuICAgICAgcXVldWUudG9LZXkoc2V0KSxcbiAgICAgIHF1ZXVlLnRvS2V5KCdwcmlvcml0eScpLFxuICAgICAgcXVldWUua2V5cy5saW1pdGVyLFxuICAgICAgcXVldWUudG9LZXkoJycpLFxuICAgICAgdHMsXG4gICAgICBsaW1pdCB8fCAwLFxuICAgICAgc2V0XG4gICAgXSk7XG4gIH0sXG5cbiAgcmV0cnlKb2JBcmdzKGpvYiwgaWdub3JlTG9jaykge1xuICAgIGNvbnN0IHF1ZXVlID0gam9iLnF1ZXVlO1xuICAgIGNvbnN0IGpvYklkID0gam9iLmlkO1xuXG4gICAgY29uc3Qga2V5cyA9IF8ubWFwKFxuICAgICAgWydhY3RpdmUnLCAnd2FpdCcsIGpvYklkLCAnbWV0YS1wYXVzZWQnLCAncGF1c2VkJywgJ3N0YWxsZWQnLCAncHJpb3JpdHknXSxcbiAgICAgIG5hbWUgPT4ge1xuICAgICAgICByZXR1cm4gcXVldWUudG9LZXkobmFtZSk7XG4gICAgICB9XG4gICAgKTtcblxuICAgIGNvbnN0IHB1c2hDbWQgPSAoam9iLm9wdHMubGlmbyA/ICdSJyA6ICdMJykgKyAnUFVTSCc7XG5cbiAgICByZXR1cm4ga2V5cy5jb25jYXQoW3B1c2hDbWQsIGpvYklkLCBpZ25vcmVMb2NrID8gJzAnIDogam9iLnF1ZXVlLnRva2VuXSk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEF0dGVtcHRzIHRvIHJlcHJvY2VzcyBhIGpvYlxuICAgKlxuICAgKiBAcGFyYW0ge0pvYn0gam9iXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBvcHRpb25zLnN0YXRlIFRoZSBleHBlY3RlZCBqb2Igc3RhdGUuIElmIHRoZSBqb2IgaXMgbm90IGZvdW5kXG4gICAqIG9uIHRoZSBwcm92aWRlZCBzdGF0ZSwgdGhlbiBpdCdzIG5vdCByZXByb2Nlc3NlZC4gU3VwcG9ydGVkIHN0YXRlczogJ2ZhaWxlZCcsICdjb21wbGV0ZWQnXG4gICAqXG4gICAqIEByZXR1cm4ge1Byb21pc2U8TnVtYmVyPn0gUmV0dXJucyBhIHByb21pc2UgdGhhdCBldmFsdWF0ZXMgdG8gYSByZXR1cm4gY29kZTpcbiAgICogMSBtZWFucyB0aGUgb3BlcmF0aW9uIHdhcyBhIHN1Y2Nlc3NcbiAgICogMCBtZWFucyB0aGUgam9iIGRvZXMgbm90IGV4aXN0XG4gICAqIC0xIG1lYW5zIHRoZSBqb2IgaXMgY3VycmVudGx5IGxvY2tlZCBhbmQgY2FuJ3QgYmUgcmV0cmllZC5cbiAgICogLTIgbWVhbnMgdGhlIGpvYiB3YXMgbm90IGZvdW5kIGluIHRoZSBleHBlY3RlZCBzZXRcbiAgICovXG4gIHJlcHJvY2Vzc0pvYihqb2IsIG9wdGlvbnMpIHtcbiAgICBjb25zdCBxdWV1ZSA9IGpvYi5xdWV1ZTtcblxuICAgIGNvbnN0IGtleXMgPSBbXG4gICAgICBxdWV1ZS50b0tleShqb2IuaWQpLFxuICAgICAgcXVldWUudG9LZXkoam9iLmlkKSArICc6bG9jaycsXG4gICAgICBxdWV1ZS50b0tleShvcHRpb25zLnN0YXRlKSxcbiAgICAgIHF1ZXVlLnRvS2V5KCd3YWl0JyksXG4gICAgICBxdWV1ZS50b0tleSgnbWV0YS1wYXVzZWQnKSxcbiAgICAgIHF1ZXVlLnRvS2V5KCdwYXVzZWQnKVxuICAgIF07XG5cbiAgICBjb25zdCBhcmdzID0gW1xuICAgICAgam9iLmlkLFxuICAgICAgKGpvYi5vcHRzLmxpZm8gPyAnUicgOiAnTCcpICsgJ1BVU0gnLFxuICAgICAgcXVldWUudG9rZW4sXG4gICAgICBEYXRlLm5vdygpXG4gICAgXTtcblxuICAgIHJldHVybiBxdWV1ZS5jbGllbnQucmVwcm9jZXNzSm9iKGtleXMuY29uY2F0KGFyZ3MpKTtcbiAgfSxcblxuICBvYmxpdGVyYXRlKHF1ZXVlLCBvcHRzKSB7XG4gICAgY29uc3QgY2xpZW50ID0gcXVldWUuY2xpZW50O1xuXG4gICAgY29uc3Qga2V5cyA9IFtxdWV1ZS5rZXlzWydtZXRhLXBhdXNlZCddLCBxdWV1ZS50b0tleSgnJyldO1xuICAgIGNvbnN0IGFyZ3MgPSBbb3B0cy5jb3VudCwgb3B0cy5mb3JjZSA/ICdmb3JjZScgOiBudWxsXTtcblxuICAgIHJldHVybiBjbGllbnQub2JsaXRlcmF0ZShrZXlzLmNvbmNhdChhcmdzKSkudGhlbihyZXN1bHQgPT4ge1xuICAgICAgaWYgKHJlc3VsdCA8IDApIHtcbiAgICAgICAgc3dpdGNoIChyZXN1bHQpIHtcbiAgICAgICAgICBjYXNlIC0xOlxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDYW5ub3Qgb2JsaXRlcmF0ZSBub24tcGF1c2VkIHF1ZXVlJyk7XG4gICAgICAgICAgY2FzZSAtMjpcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQ2Fubm90IG9ibGl0ZXJhdGUgcXVldWUgd2l0aCBhY3RpdmUgam9icycpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH0pO1xuICB9XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IHNjcmlwdHM7XG5cbmZ1bmN0aW9uIGFycmF5Mm9iaihhcnIpIHtcbiAgY29uc3Qgb2JqID0ge307XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgYXJyLmxlbmd0aDsgaSArPSAyKSB7XG4gICAgb2JqW2FycltpXV0gPSBhcnJbaSArIDFdO1xuICB9XG4gIHJldHVybiBvYmo7XG59XG5cbmZ1bmN0aW9uIHJhdzJqb2JEYXRhKHJhdykge1xuICBpZiAocmF3KSB7XG4gICAgY29uc3Qgam9iRGF0YSA9IHJhd1swXTtcbiAgICBpZiAoam9iRGF0YS5sZW5ndGgpIHtcbiAgICAgIGNvbnN0IGpvYiA9IGFycmF5Mm9iaihqb2JEYXRhKTtcbiAgICAgIHJldHVybiBbam9iLCByYXdbMV1dO1xuICAgIH1cbiAgfVxuICByZXR1cm4gW107XG59XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/bull/lib/scripts.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/bull/lib/scripts/addJob-6.js":
/*!***************************************************!*\
  !*** ./node_modules/bull/lib/scripts/addJob-6.js ***!
  \***************************************************/
/***/ ((module) => {

eval("\nconst content = `--[[\n  Adds a job to the queue by doing the following:\n    - Increases the job counter if needed.\n    - Creates a new job key with the job data.\n    - if delayed:\n      - computes timestamp.\n      - adds to delayed zset.\n      - Emits a global event 'delayed' if the job is delayed.\n    - if not delayed\n      - Adds the jobId to the wait/paused list in one of three ways:\n         - LIFO\n         - FIFO\n         - prioritized.\n      - Adds the job to the \"added\" list so that workers gets notified.\n    Input:\n      KEYS[1] 'wait',\n      KEYS[2] 'paused'\n      KEYS[3] 'meta-paused'\n      KEYS[4] 'id'\n      KEYS[5] 'delayed'\n      KEYS[6] 'priority'\n      ARGV[1]  key prefix,\n      ARGV[2]  custom id (will not generate one automatically)\n      ARGV[3]  name\n      ARGV[4]  data (json stringified job data)\n      ARGV[5]  opts (json stringified job opts)\n      ARGV[6]  timestamp\n      ARGV[7]  delay\n      ARGV[8]  delayedTimestamp\n      ARGV[9]  priority\n      ARGV[10] LIFO\n      ARGV[11] token\n      ARGV[12] debounce key\n      ARGV[13] debounceId\n      ARGV[14] debounceTtl\n]]\nlocal jobId\nlocal jobIdKey\nlocal rcall = redis.call\n-- Includes\n--[[\n  Function to add job considering priority.\n]]\nlocal function addJobWithPriority(priorityKey, priority, jobId, targetKey)\n  rcall(\"ZADD\", priorityKey, priority, jobId)\n  local count = rcall(\"ZCOUNT\", priorityKey, 0, priority)\n  local len = rcall(\"LLEN\", targetKey)\n  local id = rcall(\"LINDEX\", targetKey, len - (count - 1))\n  if id then\n    rcall(\"LINSERT\", targetKey, \"BEFORE\", id, jobId)\n  else\n    rcall(\"RPUSH\", targetKey, jobId)\n  end\nend\n--[[\n  Function to debounce a job.\n]]\nlocal function debounceJob(prefixKey, debounceId, ttl, jobId, debounceKey, token)\n  if debounceId ~= \"\" then\n    local debounceKeyExists\n    if ttl ~= \"\" then\n      debounceKeyExists = not rcall('SET', debounceKey, jobId, 'PX', ttl, 'NX')\n    else\n      debounceKeyExists = not rcall('SET', debounceKey, jobId, 'NX')\n    end\n    if debounceKeyExists then\n      local currentDebounceJobId = rcall('GET', debounceKey)\n      rcall(\"PUBLISH\", prefixKey .. \"debounced@\" .. token, currentDebounceJobId)\n      return currentDebounceJobId\n    end\n  end\nend\n--[[\n  Function to check for the meta.paused key to decide if we are paused or not\n  (since an empty list and !EXISTS are not really the same).\n]]\nlocal function getTargetQueueList(queueMetaKey, waitKey, pausedKey)\n  if rcall(\"EXISTS\", queueMetaKey) ~= 1 then\n    return waitKey, false\n  else\n    return pausedKey, true\n  end\nend\nlocal jobCounter = rcall(\"INCR\", KEYS[4])\nif ARGV[2] == \"\" then\n  jobId = jobCounter\n  jobIdKey = ARGV[1] .. jobId\nelse\n  jobId = ARGV[2]\n  jobIdKey = ARGV[1] .. jobId\n  if rcall(\"EXISTS\", jobIdKey) == 1 then\n    rcall(\"PUBLISH\", ARGV[1] .. \"duplicated@\" .. ARGV[11], jobId)\n    return jobId .. \"\" -- convert to string\n  end\nend\nlocal debounceKey = ARGV[12]\nlocal opts = cmsgpack.unpack(ARGV[5])\nlocal debouncedJobId = debounceJob(ARGV[1], ARGV[13], ARGV[14],\n  jobId, debounceKey, ARGV[11])\nif debouncedJobId then\n  return debouncedJobId\nend\nlocal debounceId = ARGV[13]\nlocal optionalValues = {}\nif debounceId ~= \"\" then\n  table.insert(optionalValues, \"deid\")\n  table.insert(optionalValues, debounceId)\nend\n    -- Store the job.\nrcall(\"HMSET\", jobIdKey, \"name\", ARGV[3], \"data\", ARGV[4], \"opts\", opts, \"timestamp\",\n  ARGV[6], \"delay\", ARGV[7], \"priority\", ARGV[9], unpack(optionalValues))\n-- Check if job is delayed\nlocal delayedTimestamp = tonumber(ARGV[8])\nif(delayedTimestamp ~= 0) then\n  local timestamp = delayedTimestamp * 0x1000 + bit.band(jobCounter, 0xfff)\n  rcall(\"ZADD\", KEYS[5], timestamp, jobId)\n  rcall(\"PUBLISH\", KEYS[5], delayedTimestamp)\nelse\n  local target\n  -- Whe check for the meta-paused key to decide if we are paused or not\n  -- (since an empty list and !EXISTS are not really the same)\n  local target, paused = getTargetQueueList(KEYS[3], KEYS[1], KEYS[2])\n  -- Standard or priority add\n  local priority = tonumber(ARGV[9])\n  if priority == 0 then\n      -- LIFO or FIFO\n    rcall(ARGV[10], target, jobId)\n  else\n    addJobWithPriority(KEYS[6], priority, jobId, target)\n  end\n  -- Emit waiting event (wait..ing@token)\n  rcall(\"PUBLISH\", KEYS[1] .. \"ing@\" .. ARGV[11], jobId)\nend\nreturn jobId .. \"\" -- convert to string\n`;\nmodule.exports = {\n  name: 'addJob',\n  content,\n  keys: 6,\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvYnVsbC9saWIvc2NyaXB0cy9hZGRKb2ItNi5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9teS1hcHAvLi9ub2RlX21vZHVsZXMvYnVsbC9saWIvc2NyaXB0cy9hZGRKb2ItNi5qcz9jOWFiIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcbmNvbnN0IGNvbnRlbnQgPSBgLS1bW1xuICBBZGRzIGEgam9iIHRvIHRoZSBxdWV1ZSBieSBkb2luZyB0aGUgZm9sbG93aW5nOlxuICAgIC0gSW5jcmVhc2VzIHRoZSBqb2IgY291bnRlciBpZiBuZWVkZWQuXG4gICAgLSBDcmVhdGVzIGEgbmV3IGpvYiBrZXkgd2l0aCB0aGUgam9iIGRhdGEuXG4gICAgLSBpZiBkZWxheWVkOlxuICAgICAgLSBjb21wdXRlcyB0aW1lc3RhbXAuXG4gICAgICAtIGFkZHMgdG8gZGVsYXllZCB6c2V0LlxuICAgICAgLSBFbWl0cyBhIGdsb2JhbCBldmVudCAnZGVsYXllZCcgaWYgdGhlIGpvYiBpcyBkZWxheWVkLlxuICAgIC0gaWYgbm90IGRlbGF5ZWRcbiAgICAgIC0gQWRkcyB0aGUgam9iSWQgdG8gdGhlIHdhaXQvcGF1c2VkIGxpc3QgaW4gb25lIG9mIHRocmVlIHdheXM6XG4gICAgICAgICAtIExJRk9cbiAgICAgICAgIC0gRklGT1xuICAgICAgICAgLSBwcmlvcml0aXplZC5cbiAgICAgIC0gQWRkcyB0aGUgam9iIHRvIHRoZSBcImFkZGVkXCIgbGlzdCBzbyB0aGF0IHdvcmtlcnMgZ2V0cyBub3RpZmllZC5cbiAgICBJbnB1dDpcbiAgICAgIEtFWVNbMV0gJ3dhaXQnLFxuICAgICAgS0VZU1syXSAncGF1c2VkJ1xuICAgICAgS0VZU1szXSAnbWV0YS1wYXVzZWQnXG4gICAgICBLRVlTWzRdICdpZCdcbiAgICAgIEtFWVNbNV0gJ2RlbGF5ZWQnXG4gICAgICBLRVlTWzZdICdwcmlvcml0eSdcbiAgICAgIEFSR1ZbMV0gIGtleSBwcmVmaXgsXG4gICAgICBBUkdWWzJdICBjdXN0b20gaWQgKHdpbGwgbm90IGdlbmVyYXRlIG9uZSBhdXRvbWF0aWNhbGx5KVxuICAgICAgQVJHVlszXSAgbmFtZVxuICAgICAgQVJHVls0XSAgZGF0YSAoanNvbiBzdHJpbmdpZmllZCBqb2IgZGF0YSlcbiAgICAgIEFSR1ZbNV0gIG9wdHMgKGpzb24gc3RyaW5naWZpZWQgam9iIG9wdHMpXG4gICAgICBBUkdWWzZdICB0aW1lc3RhbXBcbiAgICAgIEFSR1ZbN10gIGRlbGF5XG4gICAgICBBUkdWWzhdICBkZWxheWVkVGltZXN0YW1wXG4gICAgICBBUkdWWzldICBwcmlvcml0eVxuICAgICAgQVJHVlsxMF0gTElGT1xuICAgICAgQVJHVlsxMV0gdG9rZW5cbiAgICAgIEFSR1ZbMTJdIGRlYm91bmNlIGtleVxuICAgICAgQVJHVlsxM10gZGVib3VuY2VJZFxuICAgICAgQVJHVlsxNF0gZGVib3VuY2VUdGxcbl1dXG5sb2NhbCBqb2JJZFxubG9jYWwgam9iSWRLZXlcbmxvY2FsIHJjYWxsID0gcmVkaXMuY2FsbFxuLS0gSW5jbHVkZXNcbi0tW1tcbiAgRnVuY3Rpb24gdG8gYWRkIGpvYiBjb25zaWRlcmluZyBwcmlvcml0eS5cbl1dXG5sb2NhbCBmdW5jdGlvbiBhZGRKb2JXaXRoUHJpb3JpdHkocHJpb3JpdHlLZXksIHByaW9yaXR5LCBqb2JJZCwgdGFyZ2V0S2V5KVxuICByY2FsbChcIlpBRERcIiwgcHJpb3JpdHlLZXksIHByaW9yaXR5LCBqb2JJZClcbiAgbG9jYWwgY291bnQgPSByY2FsbChcIlpDT1VOVFwiLCBwcmlvcml0eUtleSwgMCwgcHJpb3JpdHkpXG4gIGxvY2FsIGxlbiA9IHJjYWxsKFwiTExFTlwiLCB0YXJnZXRLZXkpXG4gIGxvY2FsIGlkID0gcmNhbGwoXCJMSU5ERVhcIiwgdGFyZ2V0S2V5LCBsZW4gLSAoY291bnQgLSAxKSlcbiAgaWYgaWQgdGhlblxuICAgIHJjYWxsKFwiTElOU0VSVFwiLCB0YXJnZXRLZXksIFwiQkVGT1JFXCIsIGlkLCBqb2JJZClcbiAgZWxzZVxuICAgIHJjYWxsKFwiUlBVU0hcIiwgdGFyZ2V0S2V5LCBqb2JJZClcbiAgZW5kXG5lbmRcbi0tW1tcbiAgRnVuY3Rpb24gdG8gZGVib3VuY2UgYSBqb2IuXG5dXVxubG9jYWwgZnVuY3Rpb24gZGVib3VuY2VKb2IocHJlZml4S2V5LCBkZWJvdW5jZUlkLCB0dGwsIGpvYklkLCBkZWJvdW5jZUtleSwgdG9rZW4pXG4gIGlmIGRlYm91bmNlSWQgfj0gXCJcIiB0aGVuXG4gICAgbG9jYWwgZGVib3VuY2VLZXlFeGlzdHNcbiAgICBpZiB0dGwgfj0gXCJcIiB0aGVuXG4gICAgICBkZWJvdW5jZUtleUV4aXN0cyA9IG5vdCByY2FsbCgnU0VUJywgZGVib3VuY2VLZXksIGpvYklkLCAnUFgnLCB0dGwsICdOWCcpXG4gICAgZWxzZVxuICAgICAgZGVib3VuY2VLZXlFeGlzdHMgPSBub3QgcmNhbGwoJ1NFVCcsIGRlYm91bmNlS2V5LCBqb2JJZCwgJ05YJylcbiAgICBlbmRcbiAgICBpZiBkZWJvdW5jZUtleUV4aXN0cyB0aGVuXG4gICAgICBsb2NhbCBjdXJyZW50RGVib3VuY2VKb2JJZCA9IHJjYWxsKCdHRVQnLCBkZWJvdW5jZUtleSlcbiAgICAgIHJjYWxsKFwiUFVCTElTSFwiLCBwcmVmaXhLZXkgLi4gXCJkZWJvdW5jZWRAXCIgLi4gdG9rZW4sIGN1cnJlbnREZWJvdW5jZUpvYklkKVxuICAgICAgcmV0dXJuIGN1cnJlbnREZWJvdW5jZUpvYklkXG4gICAgZW5kXG4gIGVuZFxuZW5kXG4tLVtbXG4gIEZ1bmN0aW9uIHRvIGNoZWNrIGZvciB0aGUgbWV0YS5wYXVzZWQga2V5IHRvIGRlY2lkZSBpZiB3ZSBhcmUgcGF1c2VkIG9yIG5vdFxuICAoc2luY2UgYW4gZW1wdHkgbGlzdCBhbmQgIUVYSVNUUyBhcmUgbm90IHJlYWxseSB0aGUgc2FtZSkuXG5dXVxubG9jYWwgZnVuY3Rpb24gZ2V0VGFyZ2V0UXVldWVMaXN0KHF1ZXVlTWV0YUtleSwgd2FpdEtleSwgcGF1c2VkS2V5KVxuICBpZiByY2FsbChcIkVYSVNUU1wiLCBxdWV1ZU1ldGFLZXkpIH49IDEgdGhlblxuICAgIHJldHVybiB3YWl0S2V5LCBmYWxzZVxuICBlbHNlXG4gICAgcmV0dXJuIHBhdXNlZEtleSwgdHJ1ZVxuICBlbmRcbmVuZFxubG9jYWwgam9iQ291bnRlciA9IHJjYWxsKFwiSU5DUlwiLCBLRVlTWzRdKVxuaWYgQVJHVlsyXSA9PSBcIlwiIHRoZW5cbiAgam9iSWQgPSBqb2JDb3VudGVyXG4gIGpvYklkS2V5ID0gQVJHVlsxXSAuLiBqb2JJZFxuZWxzZVxuICBqb2JJZCA9IEFSR1ZbMl1cbiAgam9iSWRLZXkgPSBBUkdWWzFdIC4uIGpvYklkXG4gIGlmIHJjYWxsKFwiRVhJU1RTXCIsIGpvYklkS2V5KSA9PSAxIHRoZW5cbiAgICByY2FsbChcIlBVQkxJU0hcIiwgQVJHVlsxXSAuLiBcImR1cGxpY2F0ZWRAXCIgLi4gQVJHVlsxMV0sIGpvYklkKVxuICAgIHJldHVybiBqb2JJZCAuLiBcIlwiIC0tIGNvbnZlcnQgdG8gc3RyaW5nXG4gIGVuZFxuZW5kXG5sb2NhbCBkZWJvdW5jZUtleSA9IEFSR1ZbMTJdXG5sb2NhbCBvcHRzID0gY21zZ3BhY2sudW5wYWNrKEFSR1ZbNV0pXG5sb2NhbCBkZWJvdW5jZWRKb2JJZCA9IGRlYm91bmNlSm9iKEFSR1ZbMV0sIEFSR1ZbMTNdLCBBUkdWWzE0XSxcbiAgam9iSWQsIGRlYm91bmNlS2V5LCBBUkdWWzExXSlcbmlmIGRlYm91bmNlZEpvYklkIHRoZW5cbiAgcmV0dXJuIGRlYm91bmNlZEpvYklkXG5lbmRcbmxvY2FsIGRlYm91bmNlSWQgPSBBUkdWWzEzXVxubG9jYWwgb3B0aW9uYWxWYWx1ZXMgPSB7fVxuaWYgZGVib3VuY2VJZCB+PSBcIlwiIHRoZW5cbiAgdGFibGUuaW5zZXJ0KG9wdGlvbmFsVmFsdWVzLCBcImRlaWRcIilcbiAgdGFibGUuaW5zZXJ0KG9wdGlvbmFsVmFsdWVzLCBkZWJvdW5jZUlkKVxuZW5kXG4gICAgLS0gU3RvcmUgdGhlIGpvYi5cbnJjYWxsKFwiSE1TRVRcIiwgam9iSWRLZXksIFwibmFtZVwiLCBBUkdWWzNdLCBcImRhdGFcIiwgQVJHVls0XSwgXCJvcHRzXCIsIG9wdHMsIFwidGltZXN0YW1wXCIsXG4gIEFSR1ZbNl0sIFwiZGVsYXlcIiwgQVJHVls3XSwgXCJwcmlvcml0eVwiLCBBUkdWWzldLCB1bnBhY2sob3B0aW9uYWxWYWx1ZXMpKVxuLS0gQ2hlY2sgaWYgam9iIGlzIGRlbGF5ZWRcbmxvY2FsIGRlbGF5ZWRUaW1lc3RhbXAgPSB0b251bWJlcihBUkdWWzhdKVxuaWYoZGVsYXllZFRpbWVzdGFtcCB+PSAwKSB0aGVuXG4gIGxvY2FsIHRpbWVzdGFtcCA9IGRlbGF5ZWRUaW1lc3RhbXAgKiAweDEwMDAgKyBiaXQuYmFuZChqb2JDb3VudGVyLCAweGZmZilcbiAgcmNhbGwoXCJaQUREXCIsIEtFWVNbNV0sIHRpbWVzdGFtcCwgam9iSWQpXG4gIHJjYWxsKFwiUFVCTElTSFwiLCBLRVlTWzVdLCBkZWxheWVkVGltZXN0YW1wKVxuZWxzZVxuICBsb2NhbCB0YXJnZXRcbiAgLS0gV2hlIGNoZWNrIGZvciB0aGUgbWV0YS1wYXVzZWQga2V5IHRvIGRlY2lkZSBpZiB3ZSBhcmUgcGF1c2VkIG9yIG5vdFxuICAtLSAoc2luY2UgYW4gZW1wdHkgbGlzdCBhbmQgIUVYSVNUUyBhcmUgbm90IHJlYWxseSB0aGUgc2FtZSlcbiAgbG9jYWwgdGFyZ2V0LCBwYXVzZWQgPSBnZXRUYXJnZXRRdWV1ZUxpc3QoS0VZU1szXSwgS0VZU1sxXSwgS0VZU1syXSlcbiAgLS0gU3RhbmRhcmQgb3IgcHJpb3JpdHkgYWRkXG4gIGxvY2FsIHByaW9yaXR5ID0gdG9udW1iZXIoQVJHVls5XSlcbiAgaWYgcHJpb3JpdHkgPT0gMCB0aGVuXG4gICAgICAtLSBMSUZPIG9yIEZJRk9cbiAgICByY2FsbChBUkdWWzEwXSwgdGFyZ2V0LCBqb2JJZClcbiAgZWxzZVxuICAgIGFkZEpvYldpdGhQcmlvcml0eShLRVlTWzZdLCBwcmlvcml0eSwgam9iSWQsIHRhcmdldClcbiAgZW5kXG4gIC0tIEVtaXQgd2FpdGluZyBldmVudCAod2FpdC4uaW5nQHRva2VuKVxuICByY2FsbChcIlBVQkxJU0hcIiwgS0VZU1sxXSAuLiBcImluZ0BcIiAuLiBBUkdWWzExXSwgam9iSWQpXG5lbmRcbnJldHVybiBqb2JJZCAuLiBcIlwiIC0tIGNvbnZlcnQgdG8gc3RyaW5nXG5gO1xubW9kdWxlLmV4cG9ydHMgPSB7XG4gIG5hbWU6ICdhZGRKb2InLFxuICBjb250ZW50LFxuICBrZXlzOiA2LFxufTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/bull/lib/scripts/addJob-6.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/bull/lib/scripts/addLog-2.js":
/*!***************************************************!*\
  !*** ./node_modules/bull/lib/scripts/addLog-2.js ***!
  \***************************************************/
/***/ ((module) => {

eval("\nconst content = `--[[\n  Add job log\n  Input:\n    KEYS[1] job id key\n    KEYS[2] job logs key\n    ARGV[1] id\n    ARGV[2] log\n    ARGV[3] keepLogs\n  Output:\n    -1 - Missing job.\n]]\nlocal rcall = redis.call\nif rcall(\"EXISTS\", KEYS[1]) == 1 then -- // Make sure job exists\n  local logCount = rcall(\"RPUSH\", KEYS[2], ARGV[2])\n  if ARGV[3] ~= '' then\n    local keepLogs = tonumber(ARGV[3])\n    rcall(\"LTRIM\", KEYS[2], -keepLogs, -1)\n    return math.min(keepLogs, logCount)\n  end\n  return logCount\nelse\n  return -1\nend\n`;\nmodule.exports = {\n  name: 'addLog',\n  content,\n  keys: 2,\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvYnVsbC9saWIvc2NyaXB0cy9hZGRMb2ctMi5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9teS1hcHAvLi9ub2RlX21vZHVsZXMvYnVsbC9saWIvc2NyaXB0cy9hZGRMb2ctMi5qcz9jZTBkIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcbmNvbnN0IGNvbnRlbnQgPSBgLS1bW1xuICBBZGQgam9iIGxvZ1xuICBJbnB1dDpcbiAgICBLRVlTWzFdIGpvYiBpZCBrZXlcbiAgICBLRVlTWzJdIGpvYiBsb2dzIGtleVxuICAgIEFSR1ZbMV0gaWRcbiAgICBBUkdWWzJdIGxvZ1xuICAgIEFSR1ZbM10ga2VlcExvZ3NcbiAgT3V0cHV0OlxuICAgIC0xIC0gTWlzc2luZyBqb2IuXG5dXVxubG9jYWwgcmNhbGwgPSByZWRpcy5jYWxsXG5pZiByY2FsbChcIkVYSVNUU1wiLCBLRVlTWzFdKSA9PSAxIHRoZW4gLS0gLy8gTWFrZSBzdXJlIGpvYiBleGlzdHNcbiAgbG9jYWwgbG9nQ291bnQgPSByY2FsbChcIlJQVVNIXCIsIEtFWVNbMl0sIEFSR1ZbMl0pXG4gIGlmIEFSR1ZbM10gfj0gJycgdGhlblxuICAgIGxvY2FsIGtlZXBMb2dzID0gdG9udW1iZXIoQVJHVlszXSlcbiAgICByY2FsbChcIkxUUklNXCIsIEtFWVNbMl0sIC1rZWVwTG9ncywgLTEpXG4gICAgcmV0dXJuIG1hdGgubWluKGtlZXBMb2dzLCBsb2dDb3VudClcbiAgZW5kXG4gIHJldHVybiBsb2dDb3VudFxuZWxzZVxuICByZXR1cm4gLTFcbmVuZFxuYDtcbm1vZHVsZS5leHBvcnRzID0ge1xuICBuYW1lOiAnYWRkTG9nJyxcbiAgY29udGVudCxcbiAga2V5czogMixcbn07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/bull/lib/scripts/addLog-2.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/bull/lib/scripts/cleanJobsInSet-3.js":
/*!***********************************************************!*\
  !*** ./node_modules/bull/lib/scripts/cleanJobsInSet-3.js ***!
  \***********************************************************/
/***/ ((module) => {

eval("\nconst content = `--[[\n  Remove jobs from the specific set.\n  Input:\n    KEYS[1]  set key,\n    KEYS[2]  priority key\n    KEYS[3]  rate limiter key\n    ARGV[1]  prefix key\n    ARGV[2]  maxTimestamp\n    ARGV[3]  limit the number of jobs to be removed. 0 is unlimited\n    ARGV[4]  set name, can be any of 'wait', 'active', 'paused', 'delayed', 'completed', or 'failed'\n]]\nlocal setKey = KEYS[1]\nlocal priorityKey = KEYS[2]\nlocal rateLimiterKey = KEYS[3]\nlocal prefixKey = ARGV[1]\nlocal maxTimestamp = ARGV[2]\nlocal limitStr = ARGV[3]\nlocal setName = ARGV[4]\nlocal isList = false\nlocal rcall = redis.call\n-- Includes\n--[[\n  Function to remove debounce key.\n]]\nlocal function removeDebounceKey(prefixKey, jobKey)\n  local debounceId = rcall(\"HGET\", jobKey, \"deid\")\n  if debounceId then\n    local debounceKey = prefixKey .. \"de:\" .. debounceId\n    rcall(\"DEL\", debounceKey)\n  end\nend\nif setName == \"wait\" or setName == \"active\" or setName == \"paused\" then\n  isList = true\nend\n-- We use ZRANGEBYSCORE to make the case where we're deleting a limited number\n-- of items in a sorted set only run a single iteration. If we simply used\n-- ZRANGE, we may take a long time traversing through jobs that are within the\n-- grace period.\nlocal function shouldUseZRangeByScore(isList, limit)\n  return not isList and limit > 0\nend\nlocal function getJobs(setKey, isList, rangeStart, rangeEnd, maxTimestamp, limit)\n  if isList then\n    return rcall(\"LRANGE\", setKey, rangeStart, rangeEnd)\n  elseif shouldUseZRangeByScore(isList, limit) then\n    return rcall(\"ZRANGEBYSCORE\", setKey, 0, maxTimestamp, \"LIMIT\", 0, limit)\n  else\n    return rcall(\"ZRANGE\", setKey, rangeStart, rangeEnd)\n  end\nend\nlocal limit = tonumber(limitStr)\nlocal rangeStart = 0\nlocal rangeEnd = -1\n-- If we're only deleting _n_ items, avoid retrieving all items\n-- for faster performance\n--\n-- Start from the tail of the list, since that's where oldest elements\n-- are generally added for FIFO lists\nif limit > 0 then\n  rangeStart = -1 - limit + 1\n  rangeEnd = -1\nend\nlocal jobIds = getJobs(setKey, isList, rangeStart, rangeEnd, maxTimestamp, limit)\nlocal deleted = {}\nlocal deletedCount = 0\nlocal jobTS\n-- Run this loop:\n-- - Once, if limit is -1 or 0\n-- - As many times as needed if limit is positive\nwhile ((limit <= 0 or deletedCount < limit) and next(jobIds, nil) ~= nil) do\n  local jobIdsLen = #jobIds\n  for i, jobId in ipairs(jobIds) do\n    if limit > 0 and deletedCount >= limit then\n      break\n    end\n    local jobKey = prefixKey .. jobId\n    if (rcall(\"EXISTS\", jobKey .. \":lock\") == 0) then\n      -- Find the right timestamp of the job to compare to maxTimestamp:\n      -- * finishedOn says when the job was completed, but it isn't set unless the job has actually completed\n      -- * processedOn represents when the job was last attempted, but it doesn't get populated until the job is first tried\n      -- * timestamp is the original job submission time\n      -- Fetch all three of these (in that order) and use the first one that is set so that we'll leave jobs that have been active within the grace period:\n      for _, ts in ipairs(rcall(\"HMGET\", jobKey, \"finishedOn\", \"processedOn\", \"timestamp\")) do\n        if (ts) then\n          jobTS = ts\n          break\n        end\n      end\n      if (not jobTS or jobTS < maxTimestamp) then\n        if isList then\n          -- Job ids can't be the empty string. Use the empty string as a\n          -- deletion marker. The actual deletion will occur at the end of the\n          -- script.\n          rcall(\"LSET\", setKey, rangeEnd - jobIdsLen + i, \"\")\n        else\n          rcall(\"ZREM\", setKey, jobId)\n        end\n        rcall(\"ZREM\", priorityKey, jobId)\n        if setName ~= \"completed\" and setName ~= \"failed\" then\n          removeDebounceKey(prefixKey, jobKey)\n        end\n        rcall(\"DEL\", jobKey)\n        rcall(\"DEL\", jobKey .. \":logs\")\n        -- delete keys related to rate limiter\n        -- NOTE: this code is unncessary for other sets than wait, paused and delayed.\n        local limiterIndexTable = rateLimiterKey .. \":index\"\n        local limitedSetKey = rcall(\"HGET\", limiterIndexTable, jobId)\n        if limitedSetKey then\n          rcall(\"SREM\", limitedSetKey, jobId)\n          rcall(\"HDEL\", limiterIndexTable, jobId)\n        end\n        deletedCount = deletedCount + 1\n        table.insert(deleted, jobId)\n      end\n    end\n  end\n  -- If we didn't have a limit or used the single-iteration ZRANGEBYSCORE\n  -- function, return immediately. We should have deleted all the jobs we can\n  if limit <= 0 or shouldUseZRangeByScore(isList, limit) then\n    break\n  end\n  if deletedCount < limit then\n    -- We didn't delete enough. Look for more to delete\n    rangeStart = rangeStart - limit\n    rangeEnd = rangeEnd - limit\n    jobIds = getJobs(setKey, isList, rangeStart, rangeEnd, maxTimestamp, limit)\n  end\nend\nif isList then\n  rcall(\"LREM\", setKey, 0, \"\")\nend\nreturn deleted\n`;\nmodule.exports = {\n  name: 'cleanJobsInSet',\n  content,\n  keys: 3,\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvYnVsbC9saWIvc2NyaXB0cy9jbGVhbkpvYnNJblNldC0zLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbXktYXBwLy4vbm9kZV9tb2R1bGVzL2J1bGwvbGliL3NjcmlwdHMvY2xlYW5Kb2JzSW5TZXQtMy5qcz9iMTdhIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcbmNvbnN0IGNvbnRlbnQgPSBgLS1bW1xuICBSZW1vdmUgam9icyBmcm9tIHRoZSBzcGVjaWZpYyBzZXQuXG4gIElucHV0OlxuICAgIEtFWVNbMV0gIHNldCBrZXksXG4gICAgS0VZU1syXSAgcHJpb3JpdHkga2V5XG4gICAgS0VZU1szXSAgcmF0ZSBsaW1pdGVyIGtleVxuICAgIEFSR1ZbMV0gIHByZWZpeCBrZXlcbiAgICBBUkdWWzJdICBtYXhUaW1lc3RhbXBcbiAgICBBUkdWWzNdICBsaW1pdCB0aGUgbnVtYmVyIG9mIGpvYnMgdG8gYmUgcmVtb3ZlZC4gMCBpcyB1bmxpbWl0ZWRcbiAgICBBUkdWWzRdICBzZXQgbmFtZSwgY2FuIGJlIGFueSBvZiAnd2FpdCcsICdhY3RpdmUnLCAncGF1c2VkJywgJ2RlbGF5ZWQnLCAnY29tcGxldGVkJywgb3IgJ2ZhaWxlZCdcbl1dXG5sb2NhbCBzZXRLZXkgPSBLRVlTWzFdXG5sb2NhbCBwcmlvcml0eUtleSA9IEtFWVNbMl1cbmxvY2FsIHJhdGVMaW1pdGVyS2V5ID0gS0VZU1szXVxubG9jYWwgcHJlZml4S2V5ID0gQVJHVlsxXVxubG9jYWwgbWF4VGltZXN0YW1wID0gQVJHVlsyXVxubG9jYWwgbGltaXRTdHIgPSBBUkdWWzNdXG5sb2NhbCBzZXROYW1lID0gQVJHVls0XVxubG9jYWwgaXNMaXN0ID0gZmFsc2VcbmxvY2FsIHJjYWxsID0gcmVkaXMuY2FsbFxuLS0gSW5jbHVkZXNcbi0tW1tcbiAgRnVuY3Rpb24gdG8gcmVtb3ZlIGRlYm91bmNlIGtleS5cbl1dXG5sb2NhbCBmdW5jdGlvbiByZW1vdmVEZWJvdW5jZUtleShwcmVmaXhLZXksIGpvYktleSlcbiAgbG9jYWwgZGVib3VuY2VJZCA9IHJjYWxsKFwiSEdFVFwiLCBqb2JLZXksIFwiZGVpZFwiKVxuICBpZiBkZWJvdW5jZUlkIHRoZW5cbiAgICBsb2NhbCBkZWJvdW5jZUtleSA9IHByZWZpeEtleSAuLiBcImRlOlwiIC4uIGRlYm91bmNlSWRcbiAgICByY2FsbChcIkRFTFwiLCBkZWJvdW5jZUtleSlcbiAgZW5kXG5lbmRcbmlmIHNldE5hbWUgPT0gXCJ3YWl0XCIgb3Igc2V0TmFtZSA9PSBcImFjdGl2ZVwiIG9yIHNldE5hbWUgPT0gXCJwYXVzZWRcIiB0aGVuXG4gIGlzTGlzdCA9IHRydWVcbmVuZFxuLS0gV2UgdXNlIFpSQU5HRUJZU0NPUkUgdG8gbWFrZSB0aGUgY2FzZSB3aGVyZSB3ZSdyZSBkZWxldGluZyBhIGxpbWl0ZWQgbnVtYmVyXG4tLSBvZiBpdGVtcyBpbiBhIHNvcnRlZCBzZXQgb25seSBydW4gYSBzaW5nbGUgaXRlcmF0aW9uLiBJZiB3ZSBzaW1wbHkgdXNlZFxuLS0gWlJBTkdFLCB3ZSBtYXkgdGFrZSBhIGxvbmcgdGltZSB0cmF2ZXJzaW5nIHRocm91Z2ggam9icyB0aGF0IGFyZSB3aXRoaW4gdGhlXG4tLSBncmFjZSBwZXJpb2QuXG5sb2NhbCBmdW5jdGlvbiBzaG91bGRVc2VaUmFuZ2VCeVNjb3JlKGlzTGlzdCwgbGltaXQpXG4gIHJldHVybiBub3QgaXNMaXN0IGFuZCBsaW1pdCA+IDBcbmVuZFxubG9jYWwgZnVuY3Rpb24gZ2V0Sm9icyhzZXRLZXksIGlzTGlzdCwgcmFuZ2VTdGFydCwgcmFuZ2VFbmQsIG1heFRpbWVzdGFtcCwgbGltaXQpXG4gIGlmIGlzTGlzdCB0aGVuXG4gICAgcmV0dXJuIHJjYWxsKFwiTFJBTkdFXCIsIHNldEtleSwgcmFuZ2VTdGFydCwgcmFuZ2VFbmQpXG4gIGVsc2VpZiBzaG91bGRVc2VaUmFuZ2VCeVNjb3JlKGlzTGlzdCwgbGltaXQpIHRoZW5cbiAgICByZXR1cm4gcmNhbGwoXCJaUkFOR0VCWVNDT1JFXCIsIHNldEtleSwgMCwgbWF4VGltZXN0YW1wLCBcIkxJTUlUXCIsIDAsIGxpbWl0KVxuICBlbHNlXG4gICAgcmV0dXJuIHJjYWxsKFwiWlJBTkdFXCIsIHNldEtleSwgcmFuZ2VTdGFydCwgcmFuZ2VFbmQpXG4gIGVuZFxuZW5kXG5sb2NhbCBsaW1pdCA9IHRvbnVtYmVyKGxpbWl0U3RyKVxubG9jYWwgcmFuZ2VTdGFydCA9IDBcbmxvY2FsIHJhbmdlRW5kID0gLTFcbi0tIElmIHdlJ3JlIG9ubHkgZGVsZXRpbmcgX25fIGl0ZW1zLCBhdm9pZCByZXRyaWV2aW5nIGFsbCBpdGVtc1xuLS0gZm9yIGZhc3RlciBwZXJmb3JtYW5jZVxuLS1cbi0tIFN0YXJ0IGZyb20gdGhlIHRhaWwgb2YgdGhlIGxpc3QsIHNpbmNlIHRoYXQncyB3aGVyZSBvbGRlc3QgZWxlbWVudHNcbi0tIGFyZSBnZW5lcmFsbHkgYWRkZWQgZm9yIEZJRk8gbGlzdHNcbmlmIGxpbWl0ID4gMCB0aGVuXG4gIHJhbmdlU3RhcnQgPSAtMSAtIGxpbWl0ICsgMVxuICByYW5nZUVuZCA9IC0xXG5lbmRcbmxvY2FsIGpvYklkcyA9IGdldEpvYnMoc2V0S2V5LCBpc0xpc3QsIHJhbmdlU3RhcnQsIHJhbmdlRW5kLCBtYXhUaW1lc3RhbXAsIGxpbWl0KVxubG9jYWwgZGVsZXRlZCA9IHt9XG5sb2NhbCBkZWxldGVkQ291bnQgPSAwXG5sb2NhbCBqb2JUU1xuLS0gUnVuIHRoaXMgbG9vcDpcbi0tIC0gT25jZSwgaWYgbGltaXQgaXMgLTEgb3IgMFxuLS0gLSBBcyBtYW55IHRpbWVzIGFzIG5lZWRlZCBpZiBsaW1pdCBpcyBwb3NpdGl2ZVxud2hpbGUgKChsaW1pdCA8PSAwIG9yIGRlbGV0ZWRDb3VudCA8IGxpbWl0KSBhbmQgbmV4dChqb2JJZHMsIG5pbCkgfj0gbmlsKSBkb1xuICBsb2NhbCBqb2JJZHNMZW4gPSAjam9iSWRzXG4gIGZvciBpLCBqb2JJZCBpbiBpcGFpcnMoam9iSWRzKSBkb1xuICAgIGlmIGxpbWl0ID4gMCBhbmQgZGVsZXRlZENvdW50ID49IGxpbWl0IHRoZW5cbiAgICAgIGJyZWFrXG4gICAgZW5kXG4gICAgbG9jYWwgam9iS2V5ID0gcHJlZml4S2V5IC4uIGpvYklkXG4gICAgaWYgKHJjYWxsKFwiRVhJU1RTXCIsIGpvYktleSAuLiBcIjpsb2NrXCIpID09IDApIHRoZW5cbiAgICAgIC0tIEZpbmQgdGhlIHJpZ2h0IHRpbWVzdGFtcCBvZiB0aGUgam9iIHRvIGNvbXBhcmUgdG8gbWF4VGltZXN0YW1wOlxuICAgICAgLS0gKiBmaW5pc2hlZE9uIHNheXMgd2hlbiB0aGUgam9iIHdhcyBjb21wbGV0ZWQsIGJ1dCBpdCBpc24ndCBzZXQgdW5sZXNzIHRoZSBqb2IgaGFzIGFjdHVhbGx5IGNvbXBsZXRlZFxuICAgICAgLS0gKiBwcm9jZXNzZWRPbiByZXByZXNlbnRzIHdoZW4gdGhlIGpvYiB3YXMgbGFzdCBhdHRlbXB0ZWQsIGJ1dCBpdCBkb2Vzbid0IGdldCBwb3B1bGF0ZWQgdW50aWwgdGhlIGpvYiBpcyBmaXJzdCB0cmllZFxuICAgICAgLS0gKiB0aW1lc3RhbXAgaXMgdGhlIG9yaWdpbmFsIGpvYiBzdWJtaXNzaW9uIHRpbWVcbiAgICAgIC0tIEZldGNoIGFsbCB0aHJlZSBvZiB0aGVzZSAoaW4gdGhhdCBvcmRlcikgYW5kIHVzZSB0aGUgZmlyc3Qgb25lIHRoYXQgaXMgc2V0IHNvIHRoYXQgd2UnbGwgbGVhdmUgam9icyB0aGF0IGhhdmUgYmVlbiBhY3RpdmUgd2l0aGluIHRoZSBncmFjZSBwZXJpb2Q6XG4gICAgICBmb3IgXywgdHMgaW4gaXBhaXJzKHJjYWxsKFwiSE1HRVRcIiwgam9iS2V5LCBcImZpbmlzaGVkT25cIiwgXCJwcm9jZXNzZWRPblwiLCBcInRpbWVzdGFtcFwiKSkgZG9cbiAgICAgICAgaWYgKHRzKSB0aGVuXG4gICAgICAgICAgam9iVFMgPSB0c1xuICAgICAgICAgIGJyZWFrXG4gICAgICAgIGVuZFxuICAgICAgZW5kXG4gICAgICBpZiAobm90IGpvYlRTIG9yIGpvYlRTIDwgbWF4VGltZXN0YW1wKSB0aGVuXG4gICAgICAgIGlmIGlzTGlzdCB0aGVuXG4gICAgICAgICAgLS0gSm9iIGlkcyBjYW4ndCBiZSB0aGUgZW1wdHkgc3RyaW5nLiBVc2UgdGhlIGVtcHR5IHN0cmluZyBhcyBhXG4gICAgICAgICAgLS0gZGVsZXRpb24gbWFya2VyLiBUaGUgYWN0dWFsIGRlbGV0aW9uIHdpbGwgb2NjdXIgYXQgdGhlIGVuZCBvZiB0aGVcbiAgICAgICAgICAtLSBzY3JpcHQuXG4gICAgICAgICAgcmNhbGwoXCJMU0VUXCIsIHNldEtleSwgcmFuZ2VFbmQgLSBqb2JJZHNMZW4gKyBpLCBcIlwiKVxuICAgICAgICBlbHNlXG4gICAgICAgICAgcmNhbGwoXCJaUkVNXCIsIHNldEtleSwgam9iSWQpXG4gICAgICAgIGVuZFxuICAgICAgICByY2FsbChcIlpSRU1cIiwgcHJpb3JpdHlLZXksIGpvYklkKVxuICAgICAgICBpZiBzZXROYW1lIH49IFwiY29tcGxldGVkXCIgYW5kIHNldE5hbWUgfj0gXCJmYWlsZWRcIiB0aGVuXG4gICAgICAgICAgcmVtb3ZlRGVib3VuY2VLZXkocHJlZml4S2V5LCBqb2JLZXkpXG4gICAgICAgIGVuZFxuICAgICAgICByY2FsbChcIkRFTFwiLCBqb2JLZXkpXG4gICAgICAgIHJjYWxsKFwiREVMXCIsIGpvYktleSAuLiBcIjpsb2dzXCIpXG4gICAgICAgIC0tIGRlbGV0ZSBrZXlzIHJlbGF0ZWQgdG8gcmF0ZSBsaW1pdGVyXG4gICAgICAgIC0tIE5PVEU6IHRoaXMgY29kZSBpcyB1bm5jZXNzYXJ5IGZvciBvdGhlciBzZXRzIHRoYW4gd2FpdCwgcGF1c2VkIGFuZCBkZWxheWVkLlxuICAgICAgICBsb2NhbCBsaW1pdGVySW5kZXhUYWJsZSA9IHJhdGVMaW1pdGVyS2V5IC4uIFwiOmluZGV4XCJcbiAgICAgICAgbG9jYWwgbGltaXRlZFNldEtleSA9IHJjYWxsKFwiSEdFVFwiLCBsaW1pdGVySW5kZXhUYWJsZSwgam9iSWQpXG4gICAgICAgIGlmIGxpbWl0ZWRTZXRLZXkgdGhlblxuICAgICAgICAgIHJjYWxsKFwiU1JFTVwiLCBsaW1pdGVkU2V0S2V5LCBqb2JJZClcbiAgICAgICAgICByY2FsbChcIkhERUxcIiwgbGltaXRlckluZGV4VGFibGUsIGpvYklkKVxuICAgICAgICBlbmRcbiAgICAgICAgZGVsZXRlZENvdW50ID0gZGVsZXRlZENvdW50ICsgMVxuICAgICAgICB0YWJsZS5pbnNlcnQoZGVsZXRlZCwgam9iSWQpXG4gICAgICBlbmRcbiAgICBlbmRcbiAgZW5kXG4gIC0tIElmIHdlIGRpZG4ndCBoYXZlIGEgbGltaXQgb3IgdXNlZCB0aGUgc2luZ2xlLWl0ZXJhdGlvbiBaUkFOR0VCWVNDT1JFXG4gIC0tIGZ1bmN0aW9uLCByZXR1cm4gaW1tZWRpYXRlbHkuIFdlIHNob3VsZCBoYXZlIGRlbGV0ZWQgYWxsIHRoZSBqb2JzIHdlIGNhblxuICBpZiBsaW1pdCA8PSAwIG9yIHNob3VsZFVzZVpSYW5nZUJ5U2NvcmUoaXNMaXN0LCBsaW1pdCkgdGhlblxuICAgIGJyZWFrXG4gIGVuZFxuICBpZiBkZWxldGVkQ291bnQgPCBsaW1pdCB0aGVuXG4gICAgLS0gV2UgZGlkbid0IGRlbGV0ZSBlbm91Z2guIExvb2sgZm9yIG1vcmUgdG8gZGVsZXRlXG4gICAgcmFuZ2VTdGFydCA9IHJhbmdlU3RhcnQgLSBsaW1pdFxuICAgIHJhbmdlRW5kID0gcmFuZ2VFbmQgLSBsaW1pdFxuICAgIGpvYklkcyA9IGdldEpvYnMoc2V0S2V5LCBpc0xpc3QsIHJhbmdlU3RhcnQsIHJhbmdlRW5kLCBtYXhUaW1lc3RhbXAsIGxpbWl0KVxuICBlbmRcbmVuZFxuaWYgaXNMaXN0IHRoZW5cbiAgcmNhbGwoXCJMUkVNXCIsIHNldEtleSwgMCwgXCJcIilcbmVuZFxucmV0dXJuIGRlbGV0ZWRcbmA7XG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgbmFtZTogJ2NsZWFuSm9ic0luU2V0JyxcbiAgY29udGVudCxcbiAga2V5czogMyxcbn07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/bull/lib/scripts/cleanJobsInSet-3.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/bull/lib/scripts/extendLock-2.js":
/*!*******************************************************!*\
  !*** ./node_modules/bull/lib/scripts/extendLock-2.js ***!
  \*******************************************************/
/***/ ((module) => {

eval("\nconst content = `--[[\n  Extend lock and removes the job from the stalled set.\n  Input:\n    KEYS[1] 'lock',\n    KEYS[2] 'stalled'\n    ARGV[1]  token\n    ARGV[2]  lock duration in milliseconds\n    ARGV[3]  jobid\n  Output:\n    \"1\" if lock extended succesfully.\n]]\nlocal rcall = redis.call\nif rcall(\"GET\", KEYS[1]) == ARGV[1] then\n  if rcall(\"SET\", KEYS[1], ARGV[1], \"PX\", ARGV[2]) then\n    rcall(\"SREM\", KEYS[2], ARGV[3])\n    return 1\n  end\nend\nreturn 0\n`;\nmodule.exports = {\n  name: 'extendLock',\n  content,\n  keys: 2,\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvYnVsbC9saWIvc2NyaXB0cy9leHRlbmRMb2NrLTIuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL215LWFwcC8uL25vZGVfbW9kdWxlcy9idWxsL2xpYi9zY3JpcHRzL2V4dGVuZExvY2stMi5qcz80YmFhIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcbmNvbnN0IGNvbnRlbnQgPSBgLS1bW1xuICBFeHRlbmQgbG9jayBhbmQgcmVtb3ZlcyB0aGUgam9iIGZyb20gdGhlIHN0YWxsZWQgc2V0LlxuICBJbnB1dDpcbiAgICBLRVlTWzFdICdsb2NrJyxcbiAgICBLRVlTWzJdICdzdGFsbGVkJ1xuICAgIEFSR1ZbMV0gIHRva2VuXG4gICAgQVJHVlsyXSAgbG9jayBkdXJhdGlvbiBpbiBtaWxsaXNlY29uZHNcbiAgICBBUkdWWzNdICBqb2JpZFxuICBPdXRwdXQ6XG4gICAgXCIxXCIgaWYgbG9jayBleHRlbmRlZCBzdWNjZXNmdWxseS5cbl1dXG5sb2NhbCByY2FsbCA9IHJlZGlzLmNhbGxcbmlmIHJjYWxsKFwiR0VUXCIsIEtFWVNbMV0pID09IEFSR1ZbMV0gdGhlblxuICBpZiByY2FsbChcIlNFVFwiLCBLRVlTWzFdLCBBUkdWWzFdLCBcIlBYXCIsIEFSR1ZbMl0pIHRoZW5cbiAgICByY2FsbChcIlNSRU1cIiwgS0VZU1syXSwgQVJHVlszXSlcbiAgICByZXR1cm4gMVxuICBlbmRcbmVuZFxucmV0dXJuIDBcbmA7XG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgbmFtZTogJ2V4dGVuZExvY2snLFxuICBjb250ZW50LFxuICBrZXlzOiAyLFxufTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/bull/lib/scripts/extendLock-2.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/bull/lib/scripts/getCountsPerPriority-4.js":
/*!*****************************************************************!*\
  !*** ./node_modules/bull/lib/scripts/getCountsPerPriority-4.js ***!
  \*****************************************************************/
/***/ ((module) => {

eval("\nconst content = `--[[\n  Get counts per provided states\n    Input:\n      KEYS[1] wait key\n      KEYS[2] paused key\n      KEYS[3] meta-paused key\n      KEYS[4] priority key\n      ARGV[1...] priorities\n]]\nlocal rcall = redis.call\nlocal results = {}\nlocal prioritizedKey = KEYS[4]\n-- Includes\n--[[\n  Function to check for the meta.paused key to decide if we are paused or not\n  (since an empty list and !EXISTS are not really the same).\n]]\nlocal function getTargetQueueList(queueMetaKey, waitKey, pausedKey)\n  if rcall(\"EXISTS\", queueMetaKey) ~= 1 then\n    return waitKey, false\n  else\n    return pausedKey, true\n  end\nend\nfor i = 1, #ARGV do\n  local priority = tonumber(ARGV[i])\n  if priority == 0 then\n    local target = getTargetQueueList(KEYS[3], KEYS[1], KEYS[2])\n    local count = rcall(\"LLEN\", target) - rcall(\"ZCARD\", prioritizedKey)\n    if count < 0 then\n      -- considering when last waiting job is moved to active before\n      -- removing priority reference\n      results[#results+1] = 0\n    else\n      results[#results+1] = count\n    end\n  else\n    results[#results+1] = rcall(\"ZCOUNT\", prioritizedKey,\n      priority, priority)\n  end\nend\nreturn results\n`;\nmodule.exports = {\n  name: 'getCountsPerPriority',\n  content,\n  keys: 4,\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvYnVsbC9saWIvc2NyaXB0cy9nZXRDb3VudHNQZXJQcmlvcml0eS00LmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbXktYXBwLy4vbm9kZV9tb2R1bGVzL2J1bGwvbGliL3NjcmlwdHMvZ2V0Q291bnRzUGVyUHJpb3JpdHktNC5qcz9jYWI4Il0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcbmNvbnN0IGNvbnRlbnQgPSBgLS1bW1xuICBHZXQgY291bnRzIHBlciBwcm92aWRlZCBzdGF0ZXNcbiAgICBJbnB1dDpcbiAgICAgIEtFWVNbMV0gd2FpdCBrZXlcbiAgICAgIEtFWVNbMl0gcGF1c2VkIGtleVxuICAgICAgS0VZU1szXSBtZXRhLXBhdXNlZCBrZXlcbiAgICAgIEtFWVNbNF0gcHJpb3JpdHkga2V5XG4gICAgICBBUkdWWzEuLi5dIHByaW9yaXRpZXNcbl1dXG5sb2NhbCByY2FsbCA9IHJlZGlzLmNhbGxcbmxvY2FsIHJlc3VsdHMgPSB7fVxubG9jYWwgcHJpb3JpdGl6ZWRLZXkgPSBLRVlTWzRdXG4tLSBJbmNsdWRlc1xuLS1bW1xuICBGdW5jdGlvbiB0byBjaGVjayBmb3IgdGhlIG1ldGEucGF1c2VkIGtleSB0byBkZWNpZGUgaWYgd2UgYXJlIHBhdXNlZCBvciBub3RcbiAgKHNpbmNlIGFuIGVtcHR5IGxpc3QgYW5kICFFWElTVFMgYXJlIG5vdCByZWFsbHkgdGhlIHNhbWUpLlxuXV1cbmxvY2FsIGZ1bmN0aW9uIGdldFRhcmdldFF1ZXVlTGlzdChxdWV1ZU1ldGFLZXksIHdhaXRLZXksIHBhdXNlZEtleSlcbiAgaWYgcmNhbGwoXCJFWElTVFNcIiwgcXVldWVNZXRhS2V5KSB+PSAxIHRoZW5cbiAgICByZXR1cm4gd2FpdEtleSwgZmFsc2VcbiAgZWxzZVxuICAgIHJldHVybiBwYXVzZWRLZXksIHRydWVcbiAgZW5kXG5lbmRcbmZvciBpID0gMSwgI0FSR1YgZG9cbiAgbG9jYWwgcHJpb3JpdHkgPSB0b251bWJlcihBUkdWW2ldKVxuICBpZiBwcmlvcml0eSA9PSAwIHRoZW5cbiAgICBsb2NhbCB0YXJnZXQgPSBnZXRUYXJnZXRRdWV1ZUxpc3QoS0VZU1szXSwgS0VZU1sxXSwgS0VZU1syXSlcbiAgICBsb2NhbCBjb3VudCA9IHJjYWxsKFwiTExFTlwiLCB0YXJnZXQpIC0gcmNhbGwoXCJaQ0FSRFwiLCBwcmlvcml0aXplZEtleSlcbiAgICBpZiBjb3VudCA8IDAgdGhlblxuICAgICAgLS0gY29uc2lkZXJpbmcgd2hlbiBsYXN0IHdhaXRpbmcgam9iIGlzIG1vdmVkIHRvIGFjdGl2ZSBiZWZvcmVcbiAgICAgIC0tIHJlbW92aW5nIHByaW9yaXR5IHJlZmVyZW5jZVxuICAgICAgcmVzdWx0c1sjcmVzdWx0cysxXSA9IDBcbiAgICBlbHNlXG4gICAgICByZXN1bHRzWyNyZXN1bHRzKzFdID0gY291bnRcbiAgICBlbmRcbiAgZWxzZVxuICAgIHJlc3VsdHNbI3Jlc3VsdHMrMV0gPSByY2FsbChcIlpDT1VOVFwiLCBwcmlvcml0aXplZEtleSxcbiAgICAgIHByaW9yaXR5LCBwcmlvcml0eSlcbiAgZW5kXG5lbmRcbnJldHVybiByZXN1bHRzXG5gO1xubW9kdWxlLmV4cG9ydHMgPSB7XG4gIG5hbWU6ICdnZXRDb3VudHNQZXJQcmlvcml0eScsXG4gIGNvbnRlbnQsXG4gIGtleXM6IDQsXG59O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/bull/lib/scripts/getCountsPerPriority-4.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/bull/lib/scripts/index.js":
/*!************************************************!*\
  !*** ./node_modules/bull/lib/scripts/index.js ***!
  \************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nmodule.exports = {\n  [\"addJob-6\"]: __webpack_require__(/*! ./addJob-6 */ \"(rsc)/./node_modules/bull/lib/scripts/addJob-6.js\"),\n  [\"addLog-2\"]: __webpack_require__(/*! ./addLog-2 */ \"(rsc)/./node_modules/bull/lib/scripts/addLog-2.js\"),\n  [\"cleanJobsInSet-3\"]: __webpack_require__(/*! ./cleanJobsInSet-3 */ \"(rsc)/./node_modules/bull/lib/scripts/cleanJobsInSet-3.js\"),\n  [\"extendLock-2\"]: __webpack_require__(/*! ./extendLock-2 */ \"(rsc)/./node_modules/bull/lib/scripts/extendLock-2.js\"),\n  [\"getCountsPerPriority-4\"]: __webpack_require__(/*! ./getCountsPerPriority-4 */ \"(rsc)/./node_modules/bull/lib/scripts/getCountsPerPriority-4.js\"),\n  [\"isFinished-2\"]: __webpack_require__(/*! ./isFinished-2 */ \"(rsc)/./node_modules/bull/lib/scripts/isFinished-2.js\"),\n  [\"isJobInList-1\"]: __webpack_require__(/*! ./isJobInList-1 */ \"(rsc)/./node_modules/bull/lib/scripts/isJobInList-1.js\"),\n  [\"moveStalledJobsToWait-7\"]: __webpack_require__(/*! ./moveStalledJobsToWait-7 */ \"(rsc)/./node_modules/bull/lib/scripts/moveStalledJobsToWait-7.js\"),\n  [\"moveToActive-8\"]: __webpack_require__(/*! ./moveToActive-8 */ \"(rsc)/./node_modules/bull/lib/scripts/moveToActive-8.js\"),\n  [\"moveToDelayed-4\"]: __webpack_require__(/*! ./moveToDelayed-4 */ \"(rsc)/./node_modules/bull/lib/scripts/moveToDelayed-4.js\"),\n  [\"moveToFinished-9\"]: __webpack_require__(/*! ./moveToFinished-9 */ \"(rsc)/./node_modules/bull/lib/scripts/moveToFinished-9.js\"),\n  [\"obliterate-2\"]: __webpack_require__(/*! ./obliterate-2 */ \"(rsc)/./node_modules/bull/lib/scripts/obliterate-2.js\"),\n  [\"pause-5\"]: __webpack_require__(/*! ./pause-5 */ \"(rsc)/./node_modules/bull/lib/scripts/pause-5.js\"),\n  [\"promote-5\"]: __webpack_require__(/*! ./promote-5 */ \"(rsc)/./node_modules/bull/lib/scripts/promote-5.js\"),\n  [\"releaseLock-1\"]: __webpack_require__(/*! ./releaseLock-1 */ \"(rsc)/./node_modules/bull/lib/scripts/releaseLock-1.js\"),\n  [\"removeJob-11\"]: __webpack_require__(/*! ./removeJob-11 */ \"(rsc)/./node_modules/bull/lib/scripts/removeJob-11.js\"),\n  [\"removeJobs-8\"]: __webpack_require__(/*! ./removeJobs-8 */ \"(rsc)/./node_modules/bull/lib/scripts/removeJobs-8.js\"),\n  [\"removeRepeatable-2\"]: __webpack_require__(/*! ./removeRepeatable-2 */ \"(rsc)/./node_modules/bull/lib/scripts/removeRepeatable-2.js\"),\n  [\"reprocessJob-6\"]: __webpack_require__(/*! ./reprocessJob-6 */ \"(rsc)/./node_modules/bull/lib/scripts/reprocessJob-6.js\"),\n  [\"retryJob-7\"]: __webpack_require__(/*! ./retryJob-7 */ \"(rsc)/./node_modules/bull/lib/scripts/retryJob-7.js\"),\n  [\"retryJobs-5\"]: __webpack_require__(/*! ./retryJobs-5 */ \"(rsc)/./node_modules/bull/lib/scripts/retryJobs-5.js\"),\n  [\"saveStacktrace-1\"]: __webpack_require__(/*! ./saveStacktrace-1 */ \"(rsc)/./node_modules/bull/lib/scripts/saveStacktrace-1.js\"),\n  [\"takeLock-1\"]: __webpack_require__(/*! ./takeLock-1 */ \"(rsc)/./node_modules/bull/lib/scripts/takeLock-1.js\"),\n  [\"updateData-1\"]: __webpack_require__(/*! ./updateData-1 */ \"(rsc)/./node_modules/bull/lib/scripts/updateData-1.js\"),\n  [\"updateDelaySet-6\"]: __webpack_require__(/*! ./updateDelaySet-6 */ \"(rsc)/./node_modules/bull/lib/scripts/updateDelaySet-6.js\"),\n  [\"updateProgress-2\"]: __webpack_require__(/*! ./updateProgress-2 */ \"(rsc)/./node_modules/bull/lib/scripts/updateProgress-2.js\"),\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvYnVsbC9saWIvc2NyaXB0cy9pbmRleC5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0EsZ0JBQWdCLG1CQUFPLENBQUMscUVBQVk7QUFDcEMsZ0JBQWdCLG1CQUFPLENBQUMscUVBQVk7QUFDcEMsd0JBQXdCLG1CQUFPLENBQUMscUZBQW9CO0FBQ3BELG9CQUFvQixtQkFBTyxDQUFDLDZFQUFnQjtBQUM1Qyw4QkFBOEIsbUJBQU8sQ0FBQyxpR0FBMEI7QUFDaEUsb0JBQW9CLG1CQUFPLENBQUMsNkVBQWdCO0FBQzVDLHFCQUFxQixtQkFBTyxDQUFDLCtFQUFpQjtBQUM5QywrQkFBK0IsbUJBQU8sQ0FBQyxtR0FBMkI7QUFDbEUsc0JBQXNCLG1CQUFPLENBQUMsaUZBQWtCO0FBQ2hELHVCQUF1QixtQkFBTyxDQUFDLG1GQUFtQjtBQUNsRCx3QkFBd0IsbUJBQU8sQ0FBQyxxRkFBb0I7QUFDcEQsb0JBQW9CLG1CQUFPLENBQUMsNkVBQWdCO0FBQzVDLGVBQWUsbUJBQU8sQ0FBQyxtRUFBVztBQUNsQyxpQkFBaUIsbUJBQU8sQ0FBQyx1RUFBYTtBQUN0QyxxQkFBcUIsbUJBQU8sQ0FBQywrRUFBaUI7QUFDOUMsb0JBQW9CLG1CQUFPLENBQUMsNkVBQWdCO0FBQzVDLG9CQUFvQixtQkFBTyxDQUFDLDZFQUFnQjtBQUM1QywwQkFBMEIsbUJBQU8sQ0FBQyx5RkFBc0I7QUFDeEQsc0JBQXNCLG1CQUFPLENBQUMsaUZBQWtCO0FBQ2hELGtCQUFrQixtQkFBTyxDQUFDLHlFQUFjO0FBQ3hDLG1CQUFtQixtQkFBTyxDQUFDLDJFQUFlO0FBQzFDLHdCQUF3QixtQkFBTyxDQUFDLHFGQUFvQjtBQUNwRCxrQkFBa0IsbUJBQU8sQ0FBQyx5RUFBYztBQUN4QyxvQkFBb0IsbUJBQU8sQ0FBQyw2RUFBZ0I7QUFDNUMsd0JBQXdCLG1CQUFPLENBQUMscUZBQW9CO0FBQ3BELHdCQUF3QixtQkFBTyxDQUFDLHFGQUFvQjtBQUNwRCIsInNvdXJjZXMiOlsid2VicGFjazovL215LWFwcC8uL25vZGVfbW9kdWxlcy9idWxsL2xpYi9zY3JpcHRzL2luZGV4LmpzPzY3N2UiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xubW9kdWxlLmV4cG9ydHMgPSB7XG4gIFtcImFkZEpvYi02XCJdOiByZXF1aXJlKCcuL2FkZEpvYi02JyksXG4gIFtcImFkZExvZy0yXCJdOiByZXF1aXJlKCcuL2FkZExvZy0yJyksXG4gIFtcImNsZWFuSm9ic0luU2V0LTNcIl06IHJlcXVpcmUoJy4vY2xlYW5Kb2JzSW5TZXQtMycpLFxuICBbXCJleHRlbmRMb2NrLTJcIl06IHJlcXVpcmUoJy4vZXh0ZW5kTG9jay0yJyksXG4gIFtcImdldENvdW50c1BlclByaW9yaXR5LTRcIl06IHJlcXVpcmUoJy4vZ2V0Q291bnRzUGVyUHJpb3JpdHktNCcpLFxuICBbXCJpc0ZpbmlzaGVkLTJcIl06IHJlcXVpcmUoJy4vaXNGaW5pc2hlZC0yJyksXG4gIFtcImlzSm9iSW5MaXN0LTFcIl06IHJlcXVpcmUoJy4vaXNKb2JJbkxpc3QtMScpLFxuICBbXCJtb3ZlU3RhbGxlZEpvYnNUb1dhaXQtN1wiXTogcmVxdWlyZSgnLi9tb3ZlU3RhbGxlZEpvYnNUb1dhaXQtNycpLFxuICBbXCJtb3ZlVG9BY3RpdmUtOFwiXTogcmVxdWlyZSgnLi9tb3ZlVG9BY3RpdmUtOCcpLFxuICBbXCJtb3ZlVG9EZWxheWVkLTRcIl06IHJlcXVpcmUoJy4vbW92ZVRvRGVsYXllZC00JyksXG4gIFtcIm1vdmVUb0ZpbmlzaGVkLTlcIl06IHJlcXVpcmUoJy4vbW92ZVRvRmluaXNoZWQtOScpLFxuICBbXCJvYmxpdGVyYXRlLTJcIl06IHJlcXVpcmUoJy4vb2JsaXRlcmF0ZS0yJyksXG4gIFtcInBhdXNlLTVcIl06IHJlcXVpcmUoJy4vcGF1c2UtNScpLFxuICBbXCJwcm9tb3RlLTVcIl06IHJlcXVpcmUoJy4vcHJvbW90ZS01JyksXG4gIFtcInJlbGVhc2VMb2NrLTFcIl06IHJlcXVpcmUoJy4vcmVsZWFzZUxvY2stMScpLFxuICBbXCJyZW1vdmVKb2ItMTFcIl06IHJlcXVpcmUoJy4vcmVtb3ZlSm9iLTExJyksXG4gIFtcInJlbW92ZUpvYnMtOFwiXTogcmVxdWlyZSgnLi9yZW1vdmVKb2JzLTgnKSxcbiAgW1wicmVtb3ZlUmVwZWF0YWJsZS0yXCJdOiByZXF1aXJlKCcuL3JlbW92ZVJlcGVhdGFibGUtMicpLFxuICBbXCJyZXByb2Nlc3NKb2ItNlwiXTogcmVxdWlyZSgnLi9yZXByb2Nlc3NKb2ItNicpLFxuICBbXCJyZXRyeUpvYi03XCJdOiByZXF1aXJlKCcuL3JldHJ5Sm9iLTcnKSxcbiAgW1wicmV0cnlKb2JzLTVcIl06IHJlcXVpcmUoJy4vcmV0cnlKb2JzLTUnKSxcbiAgW1wic2F2ZVN0YWNrdHJhY2UtMVwiXTogcmVxdWlyZSgnLi9zYXZlU3RhY2t0cmFjZS0xJyksXG4gIFtcInRha2VMb2NrLTFcIl06IHJlcXVpcmUoJy4vdGFrZUxvY2stMScpLFxuICBbXCJ1cGRhdGVEYXRhLTFcIl06IHJlcXVpcmUoJy4vdXBkYXRlRGF0YS0xJyksXG4gIFtcInVwZGF0ZURlbGF5U2V0LTZcIl06IHJlcXVpcmUoJy4vdXBkYXRlRGVsYXlTZXQtNicpLFxuICBbXCJ1cGRhdGVQcm9ncmVzcy0yXCJdOiByZXF1aXJlKCcuL3VwZGF0ZVByb2dyZXNzLTInKSxcbn1cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/bull/lib/scripts/index.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/bull/lib/scripts/isFinished-2.js":
/*!*******************************************************!*\
  !*** ./node_modules/bull/lib/scripts/isFinished-2.js ***!
  \*******************************************************/
/***/ ((module) => {

eval("\nconst content = `--[[\n  Checks if a job is finished (.i.e. is in the completed or failed set)\n  Input: \n    KEYS[1] completed key\n    KEYS[2] failed key\n    ARGV[1] job id\n  Output:\n    0 - not finished.\n    1 - completed.\n    2 - failed.\n]]\nif redis.call(\"ZSCORE\", KEYS[1], ARGV[1]) ~= false then\n  return 1\nend\nif redis.call(\"ZSCORE\", KEYS[2], ARGV[1]) ~= false then\n  return 2\nend\nreturn redis.call(\"ZSCORE\", KEYS[2], ARGV[1])\n`;\nmodule.exports = {\n  name: 'isFinished',\n  content,\n  keys: 2,\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvYnVsbC9saWIvc2NyaXB0cy9pc0ZpbmlzaGVkLTIuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9teS1hcHAvLi9ub2RlX21vZHVsZXMvYnVsbC9saWIvc2NyaXB0cy9pc0ZpbmlzaGVkLTIuanM/MGE4ZCJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5jb25zdCBjb250ZW50ID0gYC0tW1tcbiAgQ2hlY2tzIGlmIGEgam9iIGlzIGZpbmlzaGVkICguaS5lLiBpcyBpbiB0aGUgY29tcGxldGVkIG9yIGZhaWxlZCBzZXQpXG4gIElucHV0OiBcbiAgICBLRVlTWzFdIGNvbXBsZXRlZCBrZXlcbiAgICBLRVlTWzJdIGZhaWxlZCBrZXlcbiAgICBBUkdWWzFdIGpvYiBpZFxuICBPdXRwdXQ6XG4gICAgMCAtIG5vdCBmaW5pc2hlZC5cbiAgICAxIC0gY29tcGxldGVkLlxuICAgIDIgLSBmYWlsZWQuXG5dXVxuaWYgcmVkaXMuY2FsbChcIlpTQ09SRVwiLCBLRVlTWzFdLCBBUkdWWzFdKSB+PSBmYWxzZSB0aGVuXG4gIHJldHVybiAxXG5lbmRcbmlmIHJlZGlzLmNhbGwoXCJaU0NPUkVcIiwgS0VZU1syXSwgQVJHVlsxXSkgfj0gZmFsc2UgdGhlblxuICByZXR1cm4gMlxuZW5kXG5yZXR1cm4gcmVkaXMuY2FsbChcIlpTQ09SRVwiLCBLRVlTWzJdLCBBUkdWWzFdKVxuYDtcbm1vZHVsZS5leHBvcnRzID0ge1xuICBuYW1lOiAnaXNGaW5pc2hlZCcsXG4gIGNvbnRlbnQsXG4gIGtleXM6IDIsXG59O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/bull/lib/scripts/isFinished-2.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/bull/lib/scripts/isJobInList-1.js":
/*!********************************************************!*\
  !*** ./node_modules/bull/lib/scripts/isJobInList-1.js ***!
  \********************************************************/
/***/ ((module) => {

eval("\nconst content = `--[[\n      Checks if job is in a given list.\n      Input:\n        KEYS[1]\n        ARGV[1]\n      Output:\n        1 if element found in the list.\n]]\nlocal function item_in_list (list, item)\n  for _, v in pairs(list) do\n    if v == item then\n      return 1\n    end\n  end\n  return nil\nend\nlocal items = redis.call(\"LRANGE\", KEYS[1] , 0, -1)\nreturn item_in_list(items, ARGV[1])\n`;\nmodule.exports = {\n  name: 'isJobInList',\n  content,\n  keys: 1,\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvYnVsbC9saWIvc2NyaXB0cy9pc0pvYkluTGlzdC0xLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbXktYXBwLy4vbm9kZV9tb2R1bGVzL2J1bGwvbGliL3NjcmlwdHMvaXNKb2JJbkxpc3QtMS5qcz81MmZkIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcbmNvbnN0IGNvbnRlbnQgPSBgLS1bW1xuICAgICAgQ2hlY2tzIGlmIGpvYiBpcyBpbiBhIGdpdmVuIGxpc3QuXG4gICAgICBJbnB1dDpcbiAgICAgICAgS0VZU1sxXVxuICAgICAgICBBUkdWWzFdXG4gICAgICBPdXRwdXQ6XG4gICAgICAgIDEgaWYgZWxlbWVudCBmb3VuZCBpbiB0aGUgbGlzdC5cbl1dXG5sb2NhbCBmdW5jdGlvbiBpdGVtX2luX2xpc3QgKGxpc3QsIGl0ZW0pXG4gIGZvciBfLCB2IGluIHBhaXJzKGxpc3QpIGRvXG4gICAgaWYgdiA9PSBpdGVtIHRoZW5cbiAgICAgIHJldHVybiAxXG4gICAgZW5kXG4gIGVuZFxuICByZXR1cm4gbmlsXG5lbmRcbmxvY2FsIGl0ZW1zID0gcmVkaXMuY2FsbChcIkxSQU5HRVwiLCBLRVlTWzFdICwgMCwgLTEpXG5yZXR1cm4gaXRlbV9pbl9saXN0KGl0ZW1zLCBBUkdWWzFdKVxuYDtcbm1vZHVsZS5leHBvcnRzID0ge1xuICBuYW1lOiAnaXNKb2JJbkxpc3QnLFxuICBjb250ZW50LFxuICBrZXlzOiAxLFxufTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/bull/lib/scripts/isJobInList-1.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/bull/lib/scripts/moveStalledJobsToWait-7.js":
/*!******************************************************************!*\
  !*** ./node_modules/bull/lib/scripts/moveStalledJobsToWait-7.js ***!
  \******************************************************************/
/***/ ((module) => {

eval("\nconst content = `--[[\n  Move stalled jobs to wait.\n    Input:\n      KEYS[1] 'stalled' (SET)\n      KEYS[2] 'wait',   (LIST)\n      KEYS[3] 'active', (LIST)\n      KEYS[4] 'failed', (ZSET)\n      KEYS[5] 'stalled-check', (KEY)\n      KEYS[6] 'meta-paused', (KEY)\n      KEYS[7] 'paused', (LIST)\n      ARGV[1]  Max stalled job count\n      ARGV[2]  queue.toKey('')\n      ARGV[3]  timestamp\n      ARGV[4]  max check time\n    Events:\n      'stalled' with stalled job id.\n]]\nlocal rcall = redis.call\n-- Includes\n--[[\n  Function to loop in batches.\n  Just a bit of warning, some commands as ZREM\n  could receive a maximum of 7000 parameters per call.\n]]\nlocal function batches(n, batchSize)\n  local i = 0\n  return function()\n    local from = i * batchSize + 1\n    i = i + 1\n    if (from <= n) then\n      local to = math.min(from + batchSize - 1, n)\n      return from, to\n    end\n  end\nend\n--[[\n  Function to check for the meta.paused key to decide if we are paused or not\n  (since an empty list and !EXISTS are not really the same).\n]]\nlocal function getTargetQueueList(queueMetaKey, waitKey, pausedKey)\n  if rcall(\"EXISTS\", queueMetaKey) ~= 1 then\n    return waitKey, false\n  else\n    return pausedKey, true\n  end\nend\n--[[\n  Function to remove debounce key if needed.\n]]\nlocal function removeDebounceKeyIfNeeded(prefixKey, debounceId)\n  if debounceId then\n    local debounceKey = prefixKey .. \"de:\" .. debounceId\n    local pttl = rcall(\"PTTL\", debounceKey)\n    if pttl == 0 or pttl == -1 then\n      rcall(\"DEL\", debounceKey)\n    end\n  end\nend\nlocal function removeJob(jobId, baseKey)\n  local jobKey = baseKey .. jobId\n  rcall(\"DEL\", jobKey, jobKey .. ':logs')\nend\nlocal function removeJobsByMaxAge(timestamp, maxAge, targetSet, prefix)\n  local start = timestamp - maxAge * 1000\n  local jobIds = rcall(\"ZREVRANGEBYSCORE\", targetSet, start, \"-inf\")\n  for i, jobId in ipairs(jobIds) do\n    removeJob(jobId, prefix)\n  end\n  rcall(\"ZREMRANGEBYSCORE\", targetSet, \"-inf\", start)\nend\nlocal function removeJobsByMaxCount(maxCount, targetSet, prefix)\n  local start = maxCount\n  local jobIds = rcall(\"ZREVRANGE\", targetSet, start, -1)\n  for i, jobId in ipairs(jobIds) do\n    removeJob(jobId, prefix)\n  end\n  rcall(\"ZREMRANGEBYRANK\", targetSet, 0, -(maxCount + 1))\nend\n-- Check if we need to check for stalled jobs now.\nif rcall(\"EXISTS\", KEYS[5]) == 1 then\n  return {{}, {}}\nend\nrcall(\"SET\", KEYS[5], ARGV[3], \"PX\", ARGV[4])\n-- Move all stalled jobs to wait\nlocal stalling = rcall('SMEMBERS', KEYS[1])\nlocal stalled = {}\nlocal failed = {}\nif(#stalling > 0) then\n  rcall('DEL', KEYS[1])\n  local MAX_STALLED_JOB_COUNT = tonumber(ARGV[1])\n  -- Remove from active list\n  for i, jobId in ipairs(stalling) do\n    local jobKey = ARGV[2] .. jobId\n    -- Check that the lock is also missing, then we can handle this job as really stalled.\n    if(rcall(\"EXISTS\", jobKey .. \":lock\") == 0) then\n      --  Remove from the active queue.\n      local removed = rcall(\"LREM\", KEYS[3], 1, jobId)\n      if(removed > 0) then\n        -- If this job has been stalled too many times, such as if it crashes the worker, then fail it.\n        local stalledCount = rcall(\"HINCRBY\", jobKey, \"stalledCounter\", 1)\n        if(stalledCount > MAX_STALLED_JOB_COUNT) then\n          local jobAttributes = rcall(\"HMGET\", jobKey, \"opts\", \"deid\")\n          local opts = cjson.decode(jobAttributes[1])\n          local removeOnFailType = type(opts[\"removeOnFail\"])\n          rcall(\"ZADD\", KEYS[4], ARGV[3], jobId)\n          rcall(\"HMSET\", jobKey, \"failedReason\", \"job stalled more than allowable limit\",\n            \"finishedOn\", ARGV[3])\n          removeDebounceKeyIfNeeded(ARGV[2], jobAttributes[2])\n          rcall(\"PUBLISH\", KEYS[4],  '{\"jobId\":\"' .. jobId .. '\", \"val\": \"job stalled more than maxStalledCount\"}')\n          if removeOnFailType == \"number\" then\n            removeJobsByMaxCount(opts[\"removeOnFail\"],\n                KEYS[4], ARGV[2])\n          elseif removeOnFailType == \"boolean\" then\n            if opts[\"removeOnFail\"] then\n              removeJob(jobId, ARGV[2])\n              rcall(\"ZREM\", KEYS[4], jobId)\n            end\n          elseif removeOnFailType ~= \"nil\" then\n            local maxAge = opts[\"removeOnFail\"][\"age\"]\n            local maxCount = opts[\"removeOnFail\"][\"count\"]\n            if maxAge ~= nil then\n              removeJobsByMaxAge(ARGV[3], maxAge,\n                KEYS[4], ARGV[2])\n            end\n            if maxCount ~= nil and maxCount > 0 then\n              removeJobsByMaxCount(maxCount, KEYS[4],\n                ARGV[2])\n            end\n          end\n          table.insert(failed, jobId)\n        else\n          local target = getTargetQueueList(KEYS[6], KEYS[2], KEYS[7])\n          -- Move the job back to the wait queue, to immediately be picked up by a waiting worker.\n          rcall(\"RPUSH\", target, jobId)\n          rcall('PUBLISH', KEYS[1] .. '@', jobId)\n          table.insert(stalled, jobId)\n        end\n      end\n    end\n  end\nend\n-- Mark potentially stalled jobs\nlocal active = rcall('LRANGE', KEYS[3], 0, -1)\nif (#active > 0) then\n  for from, to in batches(#active, 7000) do\n    rcall('SADD', KEYS[1], unpack(active, from, to))\n  end\nend\nreturn {failed, stalled}\n`;\nmodule.exports = {\n  name: 'moveStalledJobsToWait',\n  content,\n  keys: 7,\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvYnVsbC9saWIvc2NyaXB0cy9tb3ZlU3RhbGxlZEpvYnNUb1dhaXQtNy5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDLDBFQUEwRTtBQUNqSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbXktYXBwLy4vbm9kZV9tb2R1bGVzL2J1bGwvbGliL3NjcmlwdHMvbW92ZVN0YWxsZWRKb2JzVG9XYWl0LTcuanM/Y2QzNyJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5jb25zdCBjb250ZW50ID0gYC0tW1tcbiAgTW92ZSBzdGFsbGVkIGpvYnMgdG8gd2FpdC5cbiAgICBJbnB1dDpcbiAgICAgIEtFWVNbMV0gJ3N0YWxsZWQnIChTRVQpXG4gICAgICBLRVlTWzJdICd3YWl0JywgICAoTElTVClcbiAgICAgIEtFWVNbM10gJ2FjdGl2ZScsIChMSVNUKVxuICAgICAgS0VZU1s0XSAnZmFpbGVkJywgKFpTRVQpXG4gICAgICBLRVlTWzVdICdzdGFsbGVkLWNoZWNrJywgKEtFWSlcbiAgICAgIEtFWVNbNl0gJ21ldGEtcGF1c2VkJywgKEtFWSlcbiAgICAgIEtFWVNbN10gJ3BhdXNlZCcsIChMSVNUKVxuICAgICAgQVJHVlsxXSAgTWF4IHN0YWxsZWQgam9iIGNvdW50XG4gICAgICBBUkdWWzJdICBxdWV1ZS50b0tleSgnJylcbiAgICAgIEFSR1ZbM10gIHRpbWVzdGFtcFxuICAgICAgQVJHVls0XSAgbWF4IGNoZWNrIHRpbWVcbiAgICBFdmVudHM6XG4gICAgICAnc3RhbGxlZCcgd2l0aCBzdGFsbGVkIGpvYiBpZC5cbl1dXG5sb2NhbCByY2FsbCA9IHJlZGlzLmNhbGxcbi0tIEluY2x1ZGVzXG4tLVtbXG4gIEZ1bmN0aW9uIHRvIGxvb3AgaW4gYmF0Y2hlcy5cbiAgSnVzdCBhIGJpdCBvZiB3YXJuaW5nLCBzb21lIGNvbW1hbmRzIGFzIFpSRU1cbiAgY291bGQgcmVjZWl2ZSBhIG1heGltdW0gb2YgNzAwMCBwYXJhbWV0ZXJzIHBlciBjYWxsLlxuXV1cbmxvY2FsIGZ1bmN0aW9uIGJhdGNoZXMobiwgYmF0Y2hTaXplKVxuICBsb2NhbCBpID0gMFxuICByZXR1cm4gZnVuY3Rpb24oKVxuICAgIGxvY2FsIGZyb20gPSBpICogYmF0Y2hTaXplICsgMVxuICAgIGkgPSBpICsgMVxuICAgIGlmIChmcm9tIDw9IG4pIHRoZW5cbiAgICAgIGxvY2FsIHRvID0gbWF0aC5taW4oZnJvbSArIGJhdGNoU2l6ZSAtIDEsIG4pXG4gICAgICByZXR1cm4gZnJvbSwgdG9cbiAgICBlbmRcbiAgZW5kXG5lbmRcbi0tW1tcbiAgRnVuY3Rpb24gdG8gY2hlY2sgZm9yIHRoZSBtZXRhLnBhdXNlZCBrZXkgdG8gZGVjaWRlIGlmIHdlIGFyZSBwYXVzZWQgb3Igbm90XG4gIChzaW5jZSBhbiBlbXB0eSBsaXN0IGFuZCAhRVhJU1RTIGFyZSBub3QgcmVhbGx5IHRoZSBzYW1lKS5cbl1dXG5sb2NhbCBmdW5jdGlvbiBnZXRUYXJnZXRRdWV1ZUxpc3QocXVldWVNZXRhS2V5LCB3YWl0S2V5LCBwYXVzZWRLZXkpXG4gIGlmIHJjYWxsKFwiRVhJU1RTXCIsIHF1ZXVlTWV0YUtleSkgfj0gMSB0aGVuXG4gICAgcmV0dXJuIHdhaXRLZXksIGZhbHNlXG4gIGVsc2VcbiAgICByZXR1cm4gcGF1c2VkS2V5LCB0cnVlXG4gIGVuZFxuZW5kXG4tLVtbXG4gIEZ1bmN0aW9uIHRvIHJlbW92ZSBkZWJvdW5jZSBrZXkgaWYgbmVlZGVkLlxuXV1cbmxvY2FsIGZ1bmN0aW9uIHJlbW92ZURlYm91bmNlS2V5SWZOZWVkZWQocHJlZml4S2V5LCBkZWJvdW5jZUlkKVxuICBpZiBkZWJvdW5jZUlkIHRoZW5cbiAgICBsb2NhbCBkZWJvdW5jZUtleSA9IHByZWZpeEtleSAuLiBcImRlOlwiIC4uIGRlYm91bmNlSWRcbiAgICBsb2NhbCBwdHRsID0gcmNhbGwoXCJQVFRMXCIsIGRlYm91bmNlS2V5KVxuICAgIGlmIHB0dGwgPT0gMCBvciBwdHRsID09IC0xIHRoZW5cbiAgICAgIHJjYWxsKFwiREVMXCIsIGRlYm91bmNlS2V5KVxuICAgIGVuZFxuICBlbmRcbmVuZFxubG9jYWwgZnVuY3Rpb24gcmVtb3ZlSm9iKGpvYklkLCBiYXNlS2V5KVxuICBsb2NhbCBqb2JLZXkgPSBiYXNlS2V5IC4uIGpvYklkXG4gIHJjYWxsKFwiREVMXCIsIGpvYktleSwgam9iS2V5IC4uICc6bG9ncycpXG5lbmRcbmxvY2FsIGZ1bmN0aW9uIHJlbW92ZUpvYnNCeU1heEFnZSh0aW1lc3RhbXAsIG1heEFnZSwgdGFyZ2V0U2V0LCBwcmVmaXgpXG4gIGxvY2FsIHN0YXJ0ID0gdGltZXN0YW1wIC0gbWF4QWdlICogMTAwMFxuICBsb2NhbCBqb2JJZHMgPSByY2FsbChcIlpSRVZSQU5HRUJZU0NPUkVcIiwgdGFyZ2V0U2V0LCBzdGFydCwgXCItaW5mXCIpXG4gIGZvciBpLCBqb2JJZCBpbiBpcGFpcnMoam9iSWRzKSBkb1xuICAgIHJlbW92ZUpvYihqb2JJZCwgcHJlZml4KVxuICBlbmRcbiAgcmNhbGwoXCJaUkVNUkFOR0VCWVNDT1JFXCIsIHRhcmdldFNldCwgXCItaW5mXCIsIHN0YXJ0KVxuZW5kXG5sb2NhbCBmdW5jdGlvbiByZW1vdmVKb2JzQnlNYXhDb3VudChtYXhDb3VudCwgdGFyZ2V0U2V0LCBwcmVmaXgpXG4gIGxvY2FsIHN0YXJ0ID0gbWF4Q291bnRcbiAgbG9jYWwgam9iSWRzID0gcmNhbGwoXCJaUkVWUkFOR0VcIiwgdGFyZ2V0U2V0LCBzdGFydCwgLTEpXG4gIGZvciBpLCBqb2JJZCBpbiBpcGFpcnMoam9iSWRzKSBkb1xuICAgIHJlbW92ZUpvYihqb2JJZCwgcHJlZml4KVxuICBlbmRcbiAgcmNhbGwoXCJaUkVNUkFOR0VCWVJBTktcIiwgdGFyZ2V0U2V0LCAwLCAtKG1heENvdW50ICsgMSkpXG5lbmRcbi0tIENoZWNrIGlmIHdlIG5lZWQgdG8gY2hlY2sgZm9yIHN0YWxsZWQgam9icyBub3cuXG5pZiByY2FsbChcIkVYSVNUU1wiLCBLRVlTWzVdKSA9PSAxIHRoZW5cbiAgcmV0dXJuIHt7fSwge319XG5lbmRcbnJjYWxsKFwiU0VUXCIsIEtFWVNbNV0sIEFSR1ZbM10sIFwiUFhcIiwgQVJHVls0XSlcbi0tIE1vdmUgYWxsIHN0YWxsZWQgam9icyB0byB3YWl0XG5sb2NhbCBzdGFsbGluZyA9IHJjYWxsKCdTTUVNQkVSUycsIEtFWVNbMV0pXG5sb2NhbCBzdGFsbGVkID0ge31cbmxvY2FsIGZhaWxlZCA9IHt9XG5pZigjc3RhbGxpbmcgPiAwKSB0aGVuXG4gIHJjYWxsKCdERUwnLCBLRVlTWzFdKVxuICBsb2NhbCBNQVhfU1RBTExFRF9KT0JfQ09VTlQgPSB0b251bWJlcihBUkdWWzFdKVxuICAtLSBSZW1vdmUgZnJvbSBhY3RpdmUgbGlzdFxuICBmb3IgaSwgam9iSWQgaW4gaXBhaXJzKHN0YWxsaW5nKSBkb1xuICAgIGxvY2FsIGpvYktleSA9IEFSR1ZbMl0gLi4gam9iSWRcbiAgICAtLSBDaGVjayB0aGF0IHRoZSBsb2NrIGlzIGFsc28gbWlzc2luZywgdGhlbiB3ZSBjYW4gaGFuZGxlIHRoaXMgam9iIGFzIHJlYWxseSBzdGFsbGVkLlxuICAgIGlmKHJjYWxsKFwiRVhJU1RTXCIsIGpvYktleSAuLiBcIjpsb2NrXCIpID09IDApIHRoZW5cbiAgICAgIC0tICBSZW1vdmUgZnJvbSB0aGUgYWN0aXZlIHF1ZXVlLlxuICAgICAgbG9jYWwgcmVtb3ZlZCA9IHJjYWxsKFwiTFJFTVwiLCBLRVlTWzNdLCAxLCBqb2JJZClcbiAgICAgIGlmKHJlbW92ZWQgPiAwKSB0aGVuXG4gICAgICAgIC0tIElmIHRoaXMgam9iIGhhcyBiZWVuIHN0YWxsZWQgdG9vIG1hbnkgdGltZXMsIHN1Y2ggYXMgaWYgaXQgY3Jhc2hlcyB0aGUgd29ya2VyLCB0aGVuIGZhaWwgaXQuXG4gICAgICAgIGxvY2FsIHN0YWxsZWRDb3VudCA9IHJjYWxsKFwiSElOQ1JCWVwiLCBqb2JLZXksIFwic3RhbGxlZENvdW50ZXJcIiwgMSlcbiAgICAgICAgaWYoc3RhbGxlZENvdW50ID4gTUFYX1NUQUxMRURfSk9CX0NPVU5UKSB0aGVuXG4gICAgICAgICAgbG9jYWwgam9iQXR0cmlidXRlcyA9IHJjYWxsKFwiSE1HRVRcIiwgam9iS2V5LCBcIm9wdHNcIiwgXCJkZWlkXCIpXG4gICAgICAgICAgbG9jYWwgb3B0cyA9IGNqc29uLmRlY29kZShqb2JBdHRyaWJ1dGVzWzFdKVxuICAgICAgICAgIGxvY2FsIHJlbW92ZU9uRmFpbFR5cGUgPSB0eXBlKG9wdHNbXCJyZW1vdmVPbkZhaWxcIl0pXG4gICAgICAgICAgcmNhbGwoXCJaQUREXCIsIEtFWVNbNF0sIEFSR1ZbM10sIGpvYklkKVxuICAgICAgICAgIHJjYWxsKFwiSE1TRVRcIiwgam9iS2V5LCBcImZhaWxlZFJlYXNvblwiLCBcImpvYiBzdGFsbGVkIG1vcmUgdGhhbiBhbGxvd2FibGUgbGltaXRcIixcbiAgICAgICAgICAgIFwiZmluaXNoZWRPblwiLCBBUkdWWzNdKVxuICAgICAgICAgIHJlbW92ZURlYm91bmNlS2V5SWZOZWVkZWQoQVJHVlsyXSwgam9iQXR0cmlidXRlc1syXSlcbiAgICAgICAgICByY2FsbChcIlBVQkxJU0hcIiwgS0VZU1s0XSwgICd7XCJqb2JJZFwiOlwiJyAuLiBqb2JJZCAuLiAnXCIsIFwidmFsXCI6IFwiam9iIHN0YWxsZWQgbW9yZSB0aGFuIG1heFN0YWxsZWRDb3VudFwifScpXG4gICAgICAgICAgaWYgcmVtb3ZlT25GYWlsVHlwZSA9PSBcIm51bWJlclwiIHRoZW5cbiAgICAgICAgICAgIHJlbW92ZUpvYnNCeU1heENvdW50KG9wdHNbXCJyZW1vdmVPbkZhaWxcIl0sXG4gICAgICAgICAgICAgICAgS0VZU1s0XSwgQVJHVlsyXSlcbiAgICAgICAgICBlbHNlaWYgcmVtb3ZlT25GYWlsVHlwZSA9PSBcImJvb2xlYW5cIiB0aGVuXG4gICAgICAgICAgICBpZiBvcHRzW1wicmVtb3ZlT25GYWlsXCJdIHRoZW5cbiAgICAgICAgICAgICAgcmVtb3ZlSm9iKGpvYklkLCBBUkdWWzJdKVxuICAgICAgICAgICAgICByY2FsbChcIlpSRU1cIiwgS0VZU1s0XSwgam9iSWQpXG4gICAgICAgICAgICBlbmRcbiAgICAgICAgICBlbHNlaWYgcmVtb3ZlT25GYWlsVHlwZSB+PSBcIm5pbFwiIHRoZW5cbiAgICAgICAgICAgIGxvY2FsIG1heEFnZSA9IG9wdHNbXCJyZW1vdmVPbkZhaWxcIl1bXCJhZ2VcIl1cbiAgICAgICAgICAgIGxvY2FsIG1heENvdW50ID0gb3B0c1tcInJlbW92ZU9uRmFpbFwiXVtcImNvdW50XCJdXG4gICAgICAgICAgICBpZiBtYXhBZ2Ugfj0gbmlsIHRoZW5cbiAgICAgICAgICAgICAgcmVtb3ZlSm9ic0J5TWF4QWdlKEFSR1ZbM10sIG1heEFnZSxcbiAgICAgICAgICAgICAgICBLRVlTWzRdLCBBUkdWWzJdKVxuICAgICAgICAgICAgZW5kXG4gICAgICAgICAgICBpZiBtYXhDb3VudCB+PSBuaWwgYW5kIG1heENvdW50ID4gMCB0aGVuXG4gICAgICAgICAgICAgIHJlbW92ZUpvYnNCeU1heENvdW50KG1heENvdW50LCBLRVlTWzRdLFxuICAgICAgICAgICAgICAgIEFSR1ZbMl0pXG4gICAgICAgICAgICBlbmRcbiAgICAgICAgICBlbmRcbiAgICAgICAgICB0YWJsZS5pbnNlcnQoZmFpbGVkLCBqb2JJZClcbiAgICAgICAgZWxzZVxuICAgICAgICAgIGxvY2FsIHRhcmdldCA9IGdldFRhcmdldFF1ZXVlTGlzdChLRVlTWzZdLCBLRVlTWzJdLCBLRVlTWzddKVxuICAgICAgICAgIC0tIE1vdmUgdGhlIGpvYiBiYWNrIHRvIHRoZSB3YWl0IHF1ZXVlLCB0byBpbW1lZGlhdGVseSBiZSBwaWNrZWQgdXAgYnkgYSB3YWl0aW5nIHdvcmtlci5cbiAgICAgICAgICByY2FsbChcIlJQVVNIXCIsIHRhcmdldCwgam9iSWQpXG4gICAgICAgICAgcmNhbGwoJ1BVQkxJU0gnLCBLRVlTWzFdIC4uICdAJywgam9iSWQpXG4gICAgICAgICAgdGFibGUuaW5zZXJ0KHN0YWxsZWQsIGpvYklkKVxuICAgICAgICBlbmRcbiAgICAgIGVuZFxuICAgIGVuZFxuICBlbmRcbmVuZFxuLS0gTWFyayBwb3RlbnRpYWxseSBzdGFsbGVkIGpvYnNcbmxvY2FsIGFjdGl2ZSA9IHJjYWxsKCdMUkFOR0UnLCBLRVlTWzNdLCAwLCAtMSlcbmlmICgjYWN0aXZlID4gMCkgdGhlblxuICBmb3IgZnJvbSwgdG8gaW4gYmF0Y2hlcygjYWN0aXZlLCA3MDAwKSBkb1xuICAgIHJjYWxsKCdTQUREJywgS0VZU1sxXSwgdW5wYWNrKGFjdGl2ZSwgZnJvbSwgdG8pKVxuICBlbmRcbmVuZFxucmV0dXJuIHtmYWlsZWQsIHN0YWxsZWR9XG5gO1xubW9kdWxlLmV4cG9ydHMgPSB7XG4gIG5hbWU6ICdtb3ZlU3RhbGxlZEpvYnNUb1dhaXQnLFxuICBjb250ZW50LFxuICBrZXlzOiA3LFxufTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/bull/lib/scripts/moveStalledJobsToWait-7.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/bull/lib/scripts/moveToActive-8.js":
/*!*********************************************************!*\
  !*** ./node_modules/bull/lib/scripts/moveToActive-8.js ***!
  \*********************************************************/
/***/ ((module) => {

eval("\nconst content = `--[[\n  Move next job to be processed to active, lock it and fetch its data. The job\n  may be delayed, in that case we need to move it to the delayed set instead.\n  This operation guarantees that the worker owns the job during the locks\n  expiration time. The worker is responsible of keeping the lock fresh\n  so that no other worker picks this job again.\n  Input:\n      KEYS[1] wait key\n      KEYS[2] active key\n      KEYS[3] priority key\n      KEYS[4] active event key\n      KEYS[5] stalled key\n      -- Rate limiting\n      KEYS[6] rate limiter key\n      KEYS[7] delayed key\n      --\n      KEYS[8] drained key\n      ARGV[1] key prefix\n      ARGV[2] lock token\n      ARGV[3] lock duration in milliseconds\n      ARGV[4] timestamp\n      ARGV[5] optional jobid\n      ARGV[6] optional jobs per time unit (rate limiter)\n      ARGV[7] optional time unit (rate limiter)\n      ARGV[8] optional do not do anything with job if rate limit hit\n      ARGV[9] optional rate limit by key\n]]\nlocal rcall = redis.call\nlocal rateLimit = function(jobId, maxJobs)\n  local rateLimiterKey = KEYS[6];\n  local limiterIndexTable = rateLimiterKey .. \":index\"\n  -- Rate limit by group?\n  if(ARGV[9]) then\n    local group = string.match(jobId, \"[^:]+$\")\n    if group ~= nil then\n      rateLimiterKey = rateLimiterKey .. \":\" .. group\n    end\n  end\n  -- -- key for storing rate limited jobs\n  -- When a job has been previously rate limited it should be part of this set\n  -- if the job is back here means that the delay time for this job has passed and now we should\n  -- be able to process it again.\n  local limitedSetKey = rateLimiterKey .. \":limited\"\n  local delay = 0\n  -- -- Check if job was already limited\n  local isLimited = rcall(\"SISMEMBER\", limitedSetKey, jobId);\n  if isLimited == 1 then\n     -- Remove from limited zset since we are going to try to process it\n     rcall(\"SREM\", limitedSetKey, jobId)\n     rcall(\"HDEL\", limiterIndexTable, jobId)\n  else\n    -- If not, check if there are any limited jobs\n    -- If the job has not been rate limited, we should check if there are any other rate limited jobs, because if that\n    -- is the case we do not want to process this job, just calculate a delay for it and put it to \"sleep\".\n    local numLimitedJobs = rcall(\"SCARD\", limitedSetKey)\n    if numLimitedJobs > 0 then\n      -- Note, add some slack to compensate for drift.\n      delay = ((numLimitedJobs * ARGV[7] * 1.1) /  maxJobs) + tonumber(rcall(\"PTTL\", rateLimiterKey))\n    end\n  end\n  local jobCounter = tonumber(rcall(\"GET\", rateLimiterKey))\n  if(jobCounter == nil) then\n    jobCounter = 0\n  end\n  -- check if rate limit hit\n  if (delay == 0) and (jobCounter >= maxJobs) then\n    -- Seems like there are no current rated limited jobs, but the jobCounter has exceeded the number of jobs for this unit of time so we need to rate limit this job.\n    local exceedingJobs = jobCounter - maxJobs\n    delay = tonumber(rcall(\"PTTL\", rateLimiterKey)) + ((exceedingJobs) * ARGV[7]) / maxJobs\n  end\n  if delay > 0 then\n    local bounceBack = ARGV[8]\n    if bounceBack == 'false' then\n      local timestamp = delay + tonumber(ARGV[4])\n      -- put job into delayed queue\n      rcall(\"ZADD\", KEYS[7], timestamp * 0x1000 + bit.band(jobCounter, 0xfff), jobId)\n      rcall(\"PUBLISH\", KEYS[7], timestamp)\n      rcall(\"SADD\", limitedSetKey, jobId)\n      -- store index so that we can delete rate limited data\n      rcall(\"HSET\", limiterIndexTable, jobId, limitedSetKey)\n    end\n    -- remove from active queue\n    rcall(\"LREM\", KEYS[2], 1, jobId)\n    return true\n  else\n    -- false indicates not rate limited\n    -- increment jobCounter only when a job is not rate limited\n    if (jobCounter == 0) then\n      rcall(\"PSETEX\", rateLimiterKey, ARGV[7], 1)\n    else\n      rcall(\"INCR\", rateLimiterKey)\n    end\n    return false\n  end\nend\nlocal jobId = ARGV[5]\nif jobId ~= '' then\n  -- clean stalled key\n  rcall(\"SREM\", KEYS[5], jobId)\nelse\n  -- move from wait to active\n  jobId = rcall(\"RPOPLPUSH\", KEYS[1], KEYS[2])\nend\nif jobId then\n  -- Check if we need to perform rate limiting.\n  local maxJobs = tonumber(ARGV[6])\n  if maxJobs then\n    if rateLimit(jobId, maxJobs) then\n       return\n    end\n  end\n  -- get a lock\n  local jobKey = ARGV[1] .. jobId\n  local lockKey = jobKey .. ':lock'\n  rcall(\"SET\", lockKey, ARGV[2], \"PX\", ARGV[3])\n  -- remove from priority\n  rcall(\"ZREM\", KEYS[3], jobId)\n  rcall(\"PUBLISH\", KEYS[4], jobId)\n  rcall(\"HSET\", jobKey, \"processedOn\", ARGV[4])\n  return {rcall(\"HGETALL\", jobKey), jobId} -- get job data\nelse\n  rcall(\"PUBLISH\", KEYS[8], \"\")\nend\n`;\nmodule.exports = {\n  name: 'moveToActive',\n  content,\n  keys: 8,\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvYnVsbC9saWIvc2NyaXB0cy9tb3ZlVG9BY3RpdmUtOC5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLGlDQUFpQztBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9teS1hcHAvLi9ub2RlX21vZHVsZXMvYnVsbC9saWIvc2NyaXB0cy9tb3ZlVG9BY3RpdmUtOC5qcz80M2U1Il0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcbmNvbnN0IGNvbnRlbnQgPSBgLS1bW1xuICBNb3ZlIG5leHQgam9iIHRvIGJlIHByb2Nlc3NlZCB0byBhY3RpdmUsIGxvY2sgaXQgYW5kIGZldGNoIGl0cyBkYXRhLiBUaGUgam9iXG4gIG1heSBiZSBkZWxheWVkLCBpbiB0aGF0IGNhc2Ugd2UgbmVlZCB0byBtb3ZlIGl0IHRvIHRoZSBkZWxheWVkIHNldCBpbnN0ZWFkLlxuICBUaGlzIG9wZXJhdGlvbiBndWFyYW50ZWVzIHRoYXQgdGhlIHdvcmtlciBvd25zIHRoZSBqb2IgZHVyaW5nIHRoZSBsb2Nrc1xuICBleHBpcmF0aW9uIHRpbWUuIFRoZSB3b3JrZXIgaXMgcmVzcG9uc2libGUgb2Yga2VlcGluZyB0aGUgbG9jayBmcmVzaFxuICBzbyB0aGF0IG5vIG90aGVyIHdvcmtlciBwaWNrcyB0aGlzIGpvYiBhZ2Fpbi5cbiAgSW5wdXQ6XG4gICAgICBLRVlTWzFdIHdhaXQga2V5XG4gICAgICBLRVlTWzJdIGFjdGl2ZSBrZXlcbiAgICAgIEtFWVNbM10gcHJpb3JpdHkga2V5XG4gICAgICBLRVlTWzRdIGFjdGl2ZSBldmVudCBrZXlcbiAgICAgIEtFWVNbNV0gc3RhbGxlZCBrZXlcbiAgICAgIC0tIFJhdGUgbGltaXRpbmdcbiAgICAgIEtFWVNbNl0gcmF0ZSBsaW1pdGVyIGtleVxuICAgICAgS0VZU1s3XSBkZWxheWVkIGtleVxuICAgICAgLS1cbiAgICAgIEtFWVNbOF0gZHJhaW5lZCBrZXlcbiAgICAgIEFSR1ZbMV0ga2V5IHByZWZpeFxuICAgICAgQVJHVlsyXSBsb2NrIHRva2VuXG4gICAgICBBUkdWWzNdIGxvY2sgZHVyYXRpb24gaW4gbWlsbGlzZWNvbmRzXG4gICAgICBBUkdWWzRdIHRpbWVzdGFtcFxuICAgICAgQVJHVls1XSBvcHRpb25hbCBqb2JpZFxuICAgICAgQVJHVls2XSBvcHRpb25hbCBqb2JzIHBlciB0aW1lIHVuaXQgKHJhdGUgbGltaXRlcilcbiAgICAgIEFSR1ZbN10gb3B0aW9uYWwgdGltZSB1bml0IChyYXRlIGxpbWl0ZXIpXG4gICAgICBBUkdWWzhdIG9wdGlvbmFsIGRvIG5vdCBkbyBhbnl0aGluZyB3aXRoIGpvYiBpZiByYXRlIGxpbWl0IGhpdFxuICAgICAgQVJHVls5XSBvcHRpb25hbCByYXRlIGxpbWl0IGJ5IGtleVxuXV1cbmxvY2FsIHJjYWxsID0gcmVkaXMuY2FsbFxubG9jYWwgcmF0ZUxpbWl0ID0gZnVuY3Rpb24oam9iSWQsIG1heEpvYnMpXG4gIGxvY2FsIHJhdGVMaW1pdGVyS2V5ID0gS0VZU1s2XTtcbiAgbG9jYWwgbGltaXRlckluZGV4VGFibGUgPSByYXRlTGltaXRlcktleSAuLiBcIjppbmRleFwiXG4gIC0tIFJhdGUgbGltaXQgYnkgZ3JvdXA/XG4gIGlmKEFSR1ZbOV0pIHRoZW5cbiAgICBsb2NhbCBncm91cCA9IHN0cmluZy5tYXRjaChqb2JJZCwgXCJbXjpdKyRcIilcbiAgICBpZiBncm91cCB+PSBuaWwgdGhlblxuICAgICAgcmF0ZUxpbWl0ZXJLZXkgPSByYXRlTGltaXRlcktleSAuLiBcIjpcIiAuLiBncm91cFxuICAgIGVuZFxuICBlbmRcbiAgLS0gLS0ga2V5IGZvciBzdG9yaW5nIHJhdGUgbGltaXRlZCBqb2JzXG4gIC0tIFdoZW4gYSBqb2IgaGFzIGJlZW4gcHJldmlvdXNseSByYXRlIGxpbWl0ZWQgaXQgc2hvdWxkIGJlIHBhcnQgb2YgdGhpcyBzZXRcbiAgLS0gaWYgdGhlIGpvYiBpcyBiYWNrIGhlcmUgbWVhbnMgdGhhdCB0aGUgZGVsYXkgdGltZSBmb3IgdGhpcyBqb2IgaGFzIHBhc3NlZCBhbmQgbm93IHdlIHNob3VsZFxuICAtLSBiZSBhYmxlIHRvIHByb2Nlc3MgaXQgYWdhaW4uXG4gIGxvY2FsIGxpbWl0ZWRTZXRLZXkgPSByYXRlTGltaXRlcktleSAuLiBcIjpsaW1pdGVkXCJcbiAgbG9jYWwgZGVsYXkgPSAwXG4gIC0tIC0tIENoZWNrIGlmIGpvYiB3YXMgYWxyZWFkeSBsaW1pdGVkXG4gIGxvY2FsIGlzTGltaXRlZCA9IHJjYWxsKFwiU0lTTUVNQkVSXCIsIGxpbWl0ZWRTZXRLZXksIGpvYklkKTtcbiAgaWYgaXNMaW1pdGVkID09IDEgdGhlblxuICAgICAtLSBSZW1vdmUgZnJvbSBsaW1pdGVkIHpzZXQgc2luY2Ugd2UgYXJlIGdvaW5nIHRvIHRyeSB0byBwcm9jZXNzIGl0XG4gICAgIHJjYWxsKFwiU1JFTVwiLCBsaW1pdGVkU2V0S2V5LCBqb2JJZClcbiAgICAgcmNhbGwoXCJIREVMXCIsIGxpbWl0ZXJJbmRleFRhYmxlLCBqb2JJZClcbiAgZWxzZVxuICAgIC0tIElmIG5vdCwgY2hlY2sgaWYgdGhlcmUgYXJlIGFueSBsaW1pdGVkIGpvYnNcbiAgICAtLSBJZiB0aGUgam9iIGhhcyBub3QgYmVlbiByYXRlIGxpbWl0ZWQsIHdlIHNob3VsZCBjaGVjayBpZiB0aGVyZSBhcmUgYW55IG90aGVyIHJhdGUgbGltaXRlZCBqb2JzLCBiZWNhdXNlIGlmIHRoYXRcbiAgICAtLSBpcyB0aGUgY2FzZSB3ZSBkbyBub3Qgd2FudCB0byBwcm9jZXNzIHRoaXMgam9iLCBqdXN0IGNhbGN1bGF0ZSBhIGRlbGF5IGZvciBpdCBhbmQgcHV0IGl0IHRvIFwic2xlZXBcIi5cbiAgICBsb2NhbCBudW1MaW1pdGVkSm9icyA9IHJjYWxsKFwiU0NBUkRcIiwgbGltaXRlZFNldEtleSlcbiAgICBpZiBudW1MaW1pdGVkSm9icyA+IDAgdGhlblxuICAgICAgLS0gTm90ZSwgYWRkIHNvbWUgc2xhY2sgdG8gY29tcGVuc2F0ZSBmb3IgZHJpZnQuXG4gICAgICBkZWxheSA9ICgobnVtTGltaXRlZEpvYnMgKiBBUkdWWzddICogMS4xKSAvICBtYXhKb2JzKSArIHRvbnVtYmVyKHJjYWxsKFwiUFRUTFwiLCByYXRlTGltaXRlcktleSkpXG4gICAgZW5kXG4gIGVuZFxuICBsb2NhbCBqb2JDb3VudGVyID0gdG9udW1iZXIocmNhbGwoXCJHRVRcIiwgcmF0ZUxpbWl0ZXJLZXkpKVxuICBpZihqb2JDb3VudGVyID09IG5pbCkgdGhlblxuICAgIGpvYkNvdW50ZXIgPSAwXG4gIGVuZFxuICAtLSBjaGVjayBpZiByYXRlIGxpbWl0IGhpdFxuICBpZiAoZGVsYXkgPT0gMCkgYW5kIChqb2JDb3VudGVyID49IG1heEpvYnMpIHRoZW5cbiAgICAtLSBTZWVtcyBsaWtlIHRoZXJlIGFyZSBubyBjdXJyZW50IHJhdGVkIGxpbWl0ZWQgam9icywgYnV0IHRoZSBqb2JDb3VudGVyIGhhcyBleGNlZWRlZCB0aGUgbnVtYmVyIG9mIGpvYnMgZm9yIHRoaXMgdW5pdCBvZiB0aW1lIHNvIHdlIG5lZWQgdG8gcmF0ZSBsaW1pdCB0aGlzIGpvYi5cbiAgICBsb2NhbCBleGNlZWRpbmdKb2JzID0gam9iQ291bnRlciAtIG1heEpvYnNcbiAgICBkZWxheSA9IHRvbnVtYmVyKHJjYWxsKFwiUFRUTFwiLCByYXRlTGltaXRlcktleSkpICsgKChleGNlZWRpbmdKb2JzKSAqIEFSR1ZbN10pIC8gbWF4Sm9ic1xuICBlbmRcbiAgaWYgZGVsYXkgPiAwIHRoZW5cbiAgICBsb2NhbCBib3VuY2VCYWNrID0gQVJHVls4XVxuICAgIGlmIGJvdW5jZUJhY2sgPT0gJ2ZhbHNlJyB0aGVuXG4gICAgICBsb2NhbCB0aW1lc3RhbXAgPSBkZWxheSArIHRvbnVtYmVyKEFSR1ZbNF0pXG4gICAgICAtLSBwdXQgam9iIGludG8gZGVsYXllZCBxdWV1ZVxuICAgICAgcmNhbGwoXCJaQUREXCIsIEtFWVNbN10sIHRpbWVzdGFtcCAqIDB4MTAwMCArIGJpdC5iYW5kKGpvYkNvdW50ZXIsIDB4ZmZmKSwgam9iSWQpXG4gICAgICByY2FsbChcIlBVQkxJU0hcIiwgS0VZU1s3XSwgdGltZXN0YW1wKVxuICAgICAgcmNhbGwoXCJTQUREXCIsIGxpbWl0ZWRTZXRLZXksIGpvYklkKVxuICAgICAgLS0gc3RvcmUgaW5kZXggc28gdGhhdCB3ZSBjYW4gZGVsZXRlIHJhdGUgbGltaXRlZCBkYXRhXG4gICAgICByY2FsbChcIkhTRVRcIiwgbGltaXRlckluZGV4VGFibGUsIGpvYklkLCBsaW1pdGVkU2V0S2V5KVxuICAgIGVuZFxuICAgIC0tIHJlbW92ZSBmcm9tIGFjdGl2ZSBxdWV1ZVxuICAgIHJjYWxsKFwiTFJFTVwiLCBLRVlTWzJdLCAxLCBqb2JJZClcbiAgICByZXR1cm4gdHJ1ZVxuICBlbHNlXG4gICAgLS0gZmFsc2UgaW5kaWNhdGVzIG5vdCByYXRlIGxpbWl0ZWRcbiAgICAtLSBpbmNyZW1lbnQgam9iQ291bnRlciBvbmx5IHdoZW4gYSBqb2IgaXMgbm90IHJhdGUgbGltaXRlZFxuICAgIGlmIChqb2JDb3VudGVyID09IDApIHRoZW5cbiAgICAgIHJjYWxsKFwiUFNFVEVYXCIsIHJhdGVMaW1pdGVyS2V5LCBBUkdWWzddLCAxKVxuICAgIGVsc2VcbiAgICAgIHJjYWxsKFwiSU5DUlwiLCByYXRlTGltaXRlcktleSlcbiAgICBlbmRcbiAgICByZXR1cm4gZmFsc2VcbiAgZW5kXG5lbmRcbmxvY2FsIGpvYklkID0gQVJHVls1XVxuaWYgam9iSWQgfj0gJycgdGhlblxuICAtLSBjbGVhbiBzdGFsbGVkIGtleVxuICByY2FsbChcIlNSRU1cIiwgS0VZU1s1XSwgam9iSWQpXG5lbHNlXG4gIC0tIG1vdmUgZnJvbSB3YWl0IHRvIGFjdGl2ZVxuICBqb2JJZCA9IHJjYWxsKFwiUlBPUExQVVNIXCIsIEtFWVNbMV0sIEtFWVNbMl0pXG5lbmRcbmlmIGpvYklkIHRoZW5cbiAgLS0gQ2hlY2sgaWYgd2UgbmVlZCB0byBwZXJmb3JtIHJhdGUgbGltaXRpbmcuXG4gIGxvY2FsIG1heEpvYnMgPSB0b251bWJlcihBUkdWWzZdKVxuICBpZiBtYXhKb2JzIHRoZW5cbiAgICBpZiByYXRlTGltaXQoam9iSWQsIG1heEpvYnMpIHRoZW5cbiAgICAgICByZXR1cm5cbiAgICBlbmRcbiAgZW5kXG4gIC0tIGdldCBhIGxvY2tcbiAgbG9jYWwgam9iS2V5ID0gQVJHVlsxXSAuLiBqb2JJZFxuICBsb2NhbCBsb2NrS2V5ID0gam9iS2V5IC4uICc6bG9jaydcbiAgcmNhbGwoXCJTRVRcIiwgbG9ja0tleSwgQVJHVlsyXSwgXCJQWFwiLCBBUkdWWzNdKVxuICAtLSByZW1vdmUgZnJvbSBwcmlvcml0eVxuICByY2FsbChcIlpSRU1cIiwgS0VZU1szXSwgam9iSWQpXG4gIHJjYWxsKFwiUFVCTElTSFwiLCBLRVlTWzRdLCBqb2JJZClcbiAgcmNhbGwoXCJIU0VUXCIsIGpvYktleSwgXCJwcm9jZXNzZWRPblwiLCBBUkdWWzRdKVxuICByZXR1cm4ge3JjYWxsKFwiSEdFVEFMTFwiLCBqb2JLZXkpLCBqb2JJZH0gLS0gZ2V0IGpvYiBkYXRhXG5lbHNlXG4gIHJjYWxsKFwiUFVCTElTSFwiLCBLRVlTWzhdLCBcIlwiKVxuZW5kXG5gO1xubW9kdWxlLmV4cG9ydHMgPSB7XG4gIG5hbWU6ICdtb3ZlVG9BY3RpdmUnLFxuICBjb250ZW50LFxuICBrZXlzOiA4LFxufTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/bull/lib/scripts/moveToActive-8.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/bull/lib/scripts/moveToDelayed-4.js":
/*!**********************************************************!*\
  !*** ./node_modules/bull/lib/scripts/moveToDelayed-4.js ***!
  \**********************************************************/
/***/ ((module) => {

eval("\nconst content = `--[[\n  Moves job from active to delayed set.\n  Input:\n    KEYS[1] active key\n    KEYS[2] delayed key\n    KEYS[3] job key\n    KEYS[4] stalled key\n    ARGV[1] delayedTimestamp\n    ARGV[2] the id of the job\n    ARGV[3] queue token\n  Output:\n    0 - OK\n   -1 - Missing job.\n   -2 - Job is locked.\n  Events:\n    - delayed key.\n]]\nlocal rcall = redis.call\n-- Includes\nlocal function removeLock(jobKey, stalledKey, token, jobId)\n  if token ~= \"0\" then\n    local lockKey = jobKey .. ':lock'\n    local lockToken = rcall(\"GET\", lockKey)\n    if lockToken == token then\n      rcall(\"DEL\", lockKey)\n      rcall(\"SREM\", stalledKey, jobId)\n    else\n      if lockToken then\n        -- Lock exists but token does not match\n        return -6\n      else\n        -- Lock is missing completely\n        return -2\n      end\n    end\n  end\n  return 0\nend\nif rcall(\"EXISTS\", KEYS[3]) == 1 then\n  local errorCode = removeLock(KEYS[3], KEYS[4], ARGV[3], ARGV[2])\n  if errorCode < 0 then\n    return errorCode\n  end\n  local numRemovedElements = rcall(\"LREM\", KEYS[1], -1, ARGV[2])\n  if numRemovedElements < 1 then return -3 end\n  local score = tonumber(ARGV[1])\n  rcall(\"ZADD\", KEYS[2], score, ARGV[2])\n  rcall(\"PUBLISH\", KEYS[2], (score / 0x1000))\n  return 0\nelse\n  return -1\nend\n`;\nmodule.exports = {\n  name: 'moveToDelayed',\n  content,\n  keys: 4,\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvYnVsbC9saWIvc2NyaXB0cy9tb3ZlVG9EZWxheWVkLTQuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL215LWFwcC8uL25vZGVfbW9kdWxlcy9idWxsL2xpYi9zY3JpcHRzL21vdmVUb0RlbGF5ZWQtNC5qcz9hMjYyIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcbmNvbnN0IGNvbnRlbnQgPSBgLS1bW1xuICBNb3ZlcyBqb2IgZnJvbSBhY3RpdmUgdG8gZGVsYXllZCBzZXQuXG4gIElucHV0OlxuICAgIEtFWVNbMV0gYWN0aXZlIGtleVxuICAgIEtFWVNbMl0gZGVsYXllZCBrZXlcbiAgICBLRVlTWzNdIGpvYiBrZXlcbiAgICBLRVlTWzRdIHN0YWxsZWQga2V5XG4gICAgQVJHVlsxXSBkZWxheWVkVGltZXN0YW1wXG4gICAgQVJHVlsyXSB0aGUgaWQgb2YgdGhlIGpvYlxuICAgIEFSR1ZbM10gcXVldWUgdG9rZW5cbiAgT3V0cHV0OlxuICAgIDAgLSBPS1xuICAgLTEgLSBNaXNzaW5nIGpvYi5cbiAgIC0yIC0gSm9iIGlzIGxvY2tlZC5cbiAgRXZlbnRzOlxuICAgIC0gZGVsYXllZCBrZXkuXG5dXVxubG9jYWwgcmNhbGwgPSByZWRpcy5jYWxsXG4tLSBJbmNsdWRlc1xubG9jYWwgZnVuY3Rpb24gcmVtb3ZlTG9jayhqb2JLZXksIHN0YWxsZWRLZXksIHRva2VuLCBqb2JJZClcbiAgaWYgdG9rZW4gfj0gXCIwXCIgdGhlblxuICAgIGxvY2FsIGxvY2tLZXkgPSBqb2JLZXkgLi4gJzpsb2NrJ1xuICAgIGxvY2FsIGxvY2tUb2tlbiA9IHJjYWxsKFwiR0VUXCIsIGxvY2tLZXkpXG4gICAgaWYgbG9ja1Rva2VuID09IHRva2VuIHRoZW5cbiAgICAgIHJjYWxsKFwiREVMXCIsIGxvY2tLZXkpXG4gICAgICByY2FsbChcIlNSRU1cIiwgc3RhbGxlZEtleSwgam9iSWQpXG4gICAgZWxzZVxuICAgICAgaWYgbG9ja1Rva2VuIHRoZW5cbiAgICAgICAgLS0gTG9jayBleGlzdHMgYnV0IHRva2VuIGRvZXMgbm90IG1hdGNoXG4gICAgICAgIHJldHVybiAtNlxuICAgICAgZWxzZVxuICAgICAgICAtLSBMb2NrIGlzIG1pc3NpbmcgY29tcGxldGVseVxuICAgICAgICByZXR1cm4gLTJcbiAgICAgIGVuZFxuICAgIGVuZFxuICBlbmRcbiAgcmV0dXJuIDBcbmVuZFxuaWYgcmNhbGwoXCJFWElTVFNcIiwgS0VZU1szXSkgPT0gMSB0aGVuXG4gIGxvY2FsIGVycm9yQ29kZSA9IHJlbW92ZUxvY2soS0VZU1szXSwgS0VZU1s0XSwgQVJHVlszXSwgQVJHVlsyXSlcbiAgaWYgZXJyb3JDb2RlIDwgMCB0aGVuXG4gICAgcmV0dXJuIGVycm9yQ29kZVxuICBlbmRcbiAgbG9jYWwgbnVtUmVtb3ZlZEVsZW1lbnRzID0gcmNhbGwoXCJMUkVNXCIsIEtFWVNbMV0sIC0xLCBBUkdWWzJdKVxuICBpZiBudW1SZW1vdmVkRWxlbWVudHMgPCAxIHRoZW4gcmV0dXJuIC0zIGVuZFxuICBsb2NhbCBzY29yZSA9IHRvbnVtYmVyKEFSR1ZbMV0pXG4gIHJjYWxsKFwiWkFERFwiLCBLRVlTWzJdLCBzY29yZSwgQVJHVlsyXSlcbiAgcmNhbGwoXCJQVUJMSVNIXCIsIEtFWVNbMl0sIChzY29yZSAvIDB4MTAwMCkpXG4gIHJldHVybiAwXG5lbHNlXG4gIHJldHVybiAtMVxuZW5kXG5gO1xubW9kdWxlLmV4cG9ydHMgPSB7XG4gIG5hbWU6ICdtb3ZlVG9EZWxheWVkJyxcbiAgY29udGVudCxcbiAga2V5czogNCxcbn07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/bull/lib/scripts/moveToDelayed-4.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/bull/lib/scripts/moveToFinished-9.js":
/*!***********************************************************!*\
  !*** ./node_modules/bull/lib/scripts/moveToFinished-9.js ***!
  \***********************************************************/
/***/ ((module) => {

eval("\nconst content = `--[[\n  Move job from active to a finished status (completed or failed)\n  A job can only be moved to completed if it was active.\n  The job must be locked before it can be moved to a finished status,\n  and the lock must be released in this script.\n     Input:\n      KEYS[1] active key\n      KEYS[2] completed/failed key\n      KEYS[3] jobId key\n      KEYS[4] wait key\n      KEYS[5] priority key\n      KEYS[6] active event key\n      KEYS[7] delayed key\n      KEYS[8] stalled key\n      KEYS[9] metrics key\n      ARGV[1]  jobId\n      ARGV[2]  timestamp\n      ARGV[3]  msg property\n      ARGV[4]  return value / failed reason\n      ARGV[5]  token\n      ARGV[6]  shouldRemove\n      ARGV[7]  event data (? maybe just send jobid).\n      ARGV[8]  should fetch next job\n      ARGV[9]  base key\n      ARGV[10] lock token\n      ARGV[11] lock duration in milliseconds\n      ARGV[12] maxMetricsSize\n     Output:\n      0 OK\n      -1 Missing key.\n      -2 Missing lock.\n      -3 - Job not in active set.\n     Events:\n      'completed/failed'\n]]\nlocal rcall = redis.call\n-- Includes\n--[[\n  Functions to collect metrics based on a current and previous count of jobs.\n  Granualarity is fixed at 1 minute.\n]]\n-- Includes\n--[[\n  Function to loop in batches.\n  Just a bit of warning, some commands as ZREM\n  could receive a maximum of 7000 parameters per call.\n]]\nlocal function batches(n, batchSize)\n  local i = 0\n  return function()\n    local from = i * batchSize + 1\n    i = i + 1\n    if (from <= n) then\n      local to = math.min(from + batchSize - 1, n)\n      return from, to\n    end\n  end\nend\nlocal function collectMetrics(metaKey, dataPointsList, maxDataPoints, timestamp)\n    -- Increment current count\n    local count = rcall(\"HINCRBY\", metaKey, \"count\", 1) - 1\n    -- Compute how many data points we need to add to the list, N.\n    local prevTS = rcall(\"HGET\", metaKey, \"prevTS\")\n    if not prevTS then\n        -- If prevTS is nil, set it to the current timestamp\n        rcall(\"HSET\", metaKey, \"prevTS\", timestamp, \"prevCount\", 0)\n        return\n    end\n    local N = math.min(math.floor(timestamp / 60000) - math.floor(prevTS / 60000), tonumber(maxDataPoints))\n    if N > 0 then\n        local delta = count - rcall(\"HGET\", metaKey, \"prevCount\")\n        -- If N > 1, add N-1 zeros to the list\n        if N > 1 then\n            local points = {}\n            points[1] = delta\n            for i = 2, N do points[i] = 0 end\n            for from, to in batches(#points, 7000) do\n                rcall(\"LPUSH\", dataPointsList, unpack(points, from, to))\n            end\n        else\n            -- LPUSH delta to the list\n            rcall(\"LPUSH\", dataPointsList, delta)\n        end\n        -- LTRIM to keep list to its max size\n        rcall(\"LTRIM\", dataPointsList, 0, maxDataPoints - 1)\n        -- update prev count with current count\n        rcall(\"HSET\", metaKey, \"prevCount\", count, \"prevTS\", timestamp)\n    end\nend\nlocal function removeLock(jobKey, stalledKey, token, jobId)\n  if token ~= \"0\" then\n    local lockKey = jobKey .. ':lock'\n    local lockToken = rcall(\"GET\", lockKey)\n    if lockToken == token then\n      rcall(\"DEL\", lockKey)\n      rcall(\"SREM\", stalledKey, jobId)\n    else\n      if lockToken then\n        -- Lock exists but token does not match\n        return -6\n      else\n        -- Lock is missing completely\n        return -2\n      end\n    end\n  end\n  return 0\nend\n--[[\n  Function to remove debounce key if needed.\n]]\nlocal function removeDebounceKeyIfNeeded(prefixKey, debounceId)\n  if debounceId then\n    local debounceKey = prefixKey .. \"de:\" .. debounceId\n    local pttl = rcall(\"PTTL\", debounceKey)\n    if pttl == 0 or pttl == -1 then\n      rcall(\"DEL\", debounceKey)\n    end\n  end\nend\nif rcall(\"EXISTS\", KEYS[3]) == 1 then -- // Make sure job exists\n    local errorCode = removeLock(KEYS[3], KEYS[8], ARGV[5], ARGV[1])\n    if errorCode < 0 then\n        return errorCode\n    end\n    -- Remove from active list (if not active we shall return error)\n    local numRemovedElements = rcall(\"LREM\", KEYS[1], -1, ARGV[1])\n    if numRemovedElements < 1 then return -3 end\n    local debounceId = rcall(\"HGET\", KEYS[3], \"deid\")\n    removeDebounceKeyIfNeeded(ARGV[9], debounceId)\n    -- Remove job?\n    local keepJobs = cmsgpack.unpack(ARGV[6])\n    local maxCount = keepJobs['count']\n    local maxAge = keepJobs['age']\n    local targetSet = KEYS[2]\n    local timestamp = ARGV[2]\n    if maxCount ~= 0 then\n        -- Add to complete/failed set\n        rcall(\"ZADD\", targetSet, timestamp, ARGV[1])\n        rcall(\"HMSET\", KEYS[3], ARGV[3], ARGV[4], \"finishedOn\", timestamp) -- \"returnvalue\" / \"failedReason\" and \"finishedOn\"\n        local function removeJobs(jobIds)\n            for i, jobId in ipairs(jobIds) do\n                local jobKey = ARGV[9] .. jobId\n                local jobLogKey = jobKey .. ':logs'\n                rcall(\"DEL\", jobKey, jobLogKey)\n            end\n        end\n        -- Remove old jobs?\n        if maxAge ~= nil then\n            local start = timestamp - maxAge * 1000\n            local jobIds = rcall(\"ZREVRANGEBYSCORE\", targetSet, start, \"-inf\")\n            removeJobs(jobIds)\n            rcall(\"ZREMRANGEBYSCORE\", targetSet, \"-inf\", start)\n        end\n        if maxCount ~= nil and maxCount > 0 then\n            local start = maxCount\n            local jobIds = rcall(\"ZREVRANGE\", targetSet, start, -1)\n            removeJobs(jobIds)\n            rcall(\"ZREMRANGEBYRANK\", targetSet, 0, -(maxCount + 1));\n        end\n    else\n        local jobLogKey = KEYS[3] .. ':logs'\n        rcall(\"DEL\", KEYS[3], jobLogKey)\n    end\n    -- Collect metrics\n    if ARGV[12] ~= \"\" then\n      collectMetrics(KEYS[9], KEYS[9]..':data', ARGV[12], timestamp)\n    end\n    rcall(\"PUBLISH\", targetSet, ARGV[7])\n    -- Try to get next job to avoid an extra roundtrip if the queue is not closing, \n    -- and not rate limited.\n    if (ARGV[8] == \"1\") then\n        -- move from wait to active \n        local jobId = rcall(\"RPOPLPUSH\", KEYS[4], KEYS[1])\n        if jobId then\n            local jobKey = ARGV[9] .. jobId\n            local lockKey = jobKey .. ':lock'\n            -- get a lock\n            rcall(\"SET\", lockKey, ARGV[11], \"PX\", ARGV[10])\n            rcall(\"ZREM\", KEYS[5], jobId) -- remove from priority\n            rcall(\"PUBLISH\", KEYS[6], jobId)\n            rcall(\"HSET\", jobKey, \"processedOn\", ARGV[2])\n            return {rcall(\"HGETALL\", jobKey), jobId} -- get job data\n        end\n    end\n    return 0\nelse\n    return -1\nend\n`;\nmodule.exports = {\n  name: 'moveToFinished',\n  content,\n  keys: 9,\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvYnVsbC9saWIvc2NyaXB0cy9tb3ZlVG9GaW5pc2hlZC05LmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixpQ0FBaUM7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbXktYXBwLy4vbm9kZV9tb2R1bGVzL2J1bGwvbGliL3NjcmlwdHMvbW92ZVRvRmluaXNoZWQtOS5qcz82NTZiIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcbmNvbnN0IGNvbnRlbnQgPSBgLS1bW1xuICBNb3ZlIGpvYiBmcm9tIGFjdGl2ZSB0byBhIGZpbmlzaGVkIHN0YXR1cyAoY29tcGxldGVkIG9yIGZhaWxlZClcbiAgQSBqb2IgY2FuIG9ubHkgYmUgbW92ZWQgdG8gY29tcGxldGVkIGlmIGl0IHdhcyBhY3RpdmUuXG4gIFRoZSBqb2IgbXVzdCBiZSBsb2NrZWQgYmVmb3JlIGl0IGNhbiBiZSBtb3ZlZCB0byBhIGZpbmlzaGVkIHN0YXR1cyxcbiAgYW5kIHRoZSBsb2NrIG11c3QgYmUgcmVsZWFzZWQgaW4gdGhpcyBzY3JpcHQuXG4gICAgIElucHV0OlxuICAgICAgS0VZU1sxXSBhY3RpdmUga2V5XG4gICAgICBLRVlTWzJdIGNvbXBsZXRlZC9mYWlsZWQga2V5XG4gICAgICBLRVlTWzNdIGpvYklkIGtleVxuICAgICAgS0VZU1s0XSB3YWl0IGtleVxuICAgICAgS0VZU1s1XSBwcmlvcml0eSBrZXlcbiAgICAgIEtFWVNbNl0gYWN0aXZlIGV2ZW50IGtleVxuICAgICAgS0VZU1s3XSBkZWxheWVkIGtleVxuICAgICAgS0VZU1s4XSBzdGFsbGVkIGtleVxuICAgICAgS0VZU1s5XSBtZXRyaWNzIGtleVxuICAgICAgQVJHVlsxXSAgam9iSWRcbiAgICAgIEFSR1ZbMl0gIHRpbWVzdGFtcFxuICAgICAgQVJHVlszXSAgbXNnIHByb3BlcnR5XG4gICAgICBBUkdWWzRdICByZXR1cm4gdmFsdWUgLyBmYWlsZWQgcmVhc29uXG4gICAgICBBUkdWWzVdICB0b2tlblxuICAgICAgQVJHVls2XSAgc2hvdWxkUmVtb3ZlXG4gICAgICBBUkdWWzddICBldmVudCBkYXRhICg/IG1heWJlIGp1c3Qgc2VuZCBqb2JpZCkuXG4gICAgICBBUkdWWzhdICBzaG91bGQgZmV0Y2ggbmV4dCBqb2JcbiAgICAgIEFSR1ZbOV0gIGJhc2Uga2V5XG4gICAgICBBUkdWWzEwXSBsb2NrIHRva2VuXG4gICAgICBBUkdWWzExXSBsb2NrIGR1cmF0aW9uIGluIG1pbGxpc2Vjb25kc1xuICAgICAgQVJHVlsxMl0gbWF4TWV0cmljc1NpemVcbiAgICAgT3V0cHV0OlxuICAgICAgMCBPS1xuICAgICAgLTEgTWlzc2luZyBrZXkuXG4gICAgICAtMiBNaXNzaW5nIGxvY2suXG4gICAgICAtMyAtIEpvYiBub3QgaW4gYWN0aXZlIHNldC5cbiAgICAgRXZlbnRzOlxuICAgICAgJ2NvbXBsZXRlZC9mYWlsZWQnXG5dXVxubG9jYWwgcmNhbGwgPSByZWRpcy5jYWxsXG4tLSBJbmNsdWRlc1xuLS1bW1xuICBGdW5jdGlvbnMgdG8gY29sbGVjdCBtZXRyaWNzIGJhc2VkIG9uIGEgY3VycmVudCBhbmQgcHJldmlvdXMgY291bnQgb2Ygam9icy5cbiAgR3JhbnVhbGFyaXR5IGlzIGZpeGVkIGF0IDEgbWludXRlLlxuXV1cbi0tIEluY2x1ZGVzXG4tLVtbXG4gIEZ1bmN0aW9uIHRvIGxvb3AgaW4gYmF0Y2hlcy5cbiAgSnVzdCBhIGJpdCBvZiB3YXJuaW5nLCBzb21lIGNvbW1hbmRzIGFzIFpSRU1cbiAgY291bGQgcmVjZWl2ZSBhIG1heGltdW0gb2YgNzAwMCBwYXJhbWV0ZXJzIHBlciBjYWxsLlxuXV1cbmxvY2FsIGZ1bmN0aW9uIGJhdGNoZXMobiwgYmF0Y2hTaXplKVxuICBsb2NhbCBpID0gMFxuICByZXR1cm4gZnVuY3Rpb24oKVxuICAgIGxvY2FsIGZyb20gPSBpICogYmF0Y2hTaXplICsgMVxuICAgIGkgPSBpICsgMVxuICAgIGlmIChmcm9tIDw9IG4pIHRoZW5cbiAgICAgIGxvY2FsIHRvID0gbWF0aC5taW4oZnJvbSArIGJhdGNoU2l6ZSAtIDEsIG4pXG4gICAgICByZXR1cm4gZnJvbSwgdG9cbiAgICBlbmRcbiAgZW5kXG5lbmRcbmxvY2FsIGZ1bmN0aW9uIGNvbGxlY3RNZXRyaWNzKG1ldGFLZXksIGRhdGFQb2ludHNMaXN0LCBtYXhEYXRhUG9pbnRzLCB0aW1lc3RhbXApXG4gICAgLS0gSW5jcmVtZW50IGN1cnJlbnQgY291bnRcbiAgICBsb2NhbCBjb3VudCA9IHJjYWxsKFwiSElOQ1JCWVwiLCBtZXRhS2V5LCBcImNvdW50XCIsIDEpIC0gMVxuICAgIC0tIENvbXB1dGUgaG93IG1hbnkgZGF0YSBwb2ludHMgd2UgbmVlZCB0byBhZGQgdG8gdGhlIGxpc3QsIE4uXG4gICAgbG9jYWwgcHJldlRTID0gcmNhbGwoXCJIR0VUXCIsIG1ldGFLZXksIFwicHJldlRTXCIpXG4gICAgaWYgbm90IHByZXZUUyB0aGVuXG4gICAgICAgIC0tIElmIHByZXZUUyBpcyBuaWwsIHNldCBpdCB0byB0aGUgY3VycmVudCB0aW1lc3RhbXBcbiAgICAgICAgcmNhbGwoXCJIU0VUXCIsIG1ldGFLZXksIFwicHJldlRTXCIsIHRpbWVzdGFtcCwgXCJwcmV2Q291bnRcIiwgMClcbiAgICAgICAgcmV0dXJuXG4gICAgZW5kXG4gICAgbG9jYWwgTiA9IG1hdGgubWluKG1hdGguZmxvb3IodGltZXN0YW1wIC8gNjAwMDApIC0gbWF0aC5mbG9vcihwcmV2VFMgLyA2MDAwMCksIHRvbnVtYmVyKG1heERhdGFQb2ludHMpKVxuICAgIGlmIE4gPiAwIHRoZW5cbiAgICAgICAgbG9jYWwgZGVsdGEgPSBjb3VudCAtIHJjYWxsKFwiSEdFVFwiLCBtZXRhS2V5LCBcInByZXZDb3VudFwiKVxuICAgICAgICAtLSBJZiBOID4gMSwgYWRkIE4tMSB6ZXJvcyB0byB0aGUgbGlzdFxuICAgICAgICBpZiBOID4gMSB0aGVuXG4gICAgICAgICAgICBsb2NhbCBwb2ludHMgPSB7fVxuICAgICAgICAgICAgcG9pbnRzWzFdID0gZGVsdGFcbiAgICAgICAgICAgIGZvciBpID0gMiwgTiBkbyBwb2ludHNbaV0gPSAwIGVuZFxuICAgICAgICAgICAgZm9yIGZyb20sIHRvIGluIGJhdGNoZXMoI3BvaW50cywgNzAwMCkgZG9cbiAgICAgICAgICAgICAgICByY2FsbChcIkxQVVNIXCIsIGRhdGFQb2ludHNMaXN0LCB1bnBhY2socG9pbnRzLCBmcm9tLCB0bykpXG4gICAgICAgICAgICBlbmRcbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgLS0gTFBVU0ggZGVsdGEgdG8gdGhlIGxpc3RcbiAgICAgICAgICAgIHJjYWxsKFwiTFBVU0hcIiwgZGF0YVBvaW50c0xpc3QsIGRlbHRhKVxuICAgICAgICBlbmRcbiAgICAgICAgLS0gTFRSSU0gdG8ga2VlcCBsaXN0IHRvIGl0cyBtYXggc2l6ZVxuICAgICAgICByY2FsbChcIkxUUklNXCIsIGRhdGFQb2ludHNMaXN0LCAwLCBtYXhEYXRhUG9pbnRzIC0gMSlcbiAgICAgICAgLS0gdXBkYXRlIHByZXYgY291bnQgd2l0aCBjdXJyZW50IGNvdW50XG4gICAgICAgIHJjYWxsKFwiSFNFVFwiLCBtZXRhS2V5LCBcInByZXZDb3VudFwiLCBjb3VudCwgXCJwcmV2VFNcIiwgdGltZXN0YW1wKVxuICAgIGVuZFxuZW5kXG5sb2NhbCBmdW5jdGlvbiByZW1vdmVMb2NrKGpvYktleSwgc3RhbGxlZEtleSwgdG9rZW4sIGpvYklkKVxuICBpZiB0b2tlbiB+PSBcIjBcIiB0aGVuXG4gICAgbG9jYWwgbG9ja0tleSA9IGpvYktleSAuLiAnOmxvY2snXG4gICAgbG9jYWwgbG9ja1Rva2VuID0gcmNhbGwoXCJHRVRcIiwgbG9ja0tleSlcbiAgICBpZiBsb2NrVG9rZW4gPT0gdG9rZW4gdGhlblxuICAgICAgcmNhbGwoXCJERUxcIiwgbG9ja0tleSlcbiAgICAgIHJjYWxsKFwiU1JFTVwiLCBzdGFsbGVkS2V5LCBqb2JJZClcbiAgICBlbHNlXG4gICAgICBpZiBsb2NrVG9rZW4gdGhlblxuICAgICAgICAtLSBMb2NrIGV4aXN0cyBidXQgdG9rZW4gZG9lcyBub3QgbWF0Y2hcbiAgICAgICAgcmV0dXJuIC02XG4gICAgICBlbHNlXG4gICAgICAgIC0tIExvY2sgaXMgbWlzc2luZyBjb21wbGV0ZWx5XG4gICAgICAgIHJldHVybiAtMlxuICAgICAgZW5kXG4gICAgZW5kXG4gIGVuZFxuICByZXR1cm4gMFxuZW5kXG4tLVtbXG4gIEZ1bmN0aW9uIHRvIHJlbW92ZSBkZWJvdW5jZSBrZXkgaWYgbmVlZGVkLlxuXV1cbmxvY2FsIGZ1bmN0aW9uIHJlbW92ZURlYm91bmNlS2V5SWZOZWVkZWQocHJlZml4S2V5LCBkZWJvdW5jZUlkKVxuICBpZiBkZWJvdW5jZUlkIHRoZW5cbiAgICBsb2NhbCBkZWJvdW5jZUtleSA9IHByZWZpeEtleSAuLiBcImRlOlwiIC4uIGRlYm91bmNlSWRcbiAgICBsb2NhbCBwdHRsID0gcmNhbGwoXCJQVFRMXCIsIGRlYm91bmNlS2V5KVxuICAgIGlmIHB0dGwgPT0gMCBvciBwdHRsID09IC0xIHRoZW5cbiAgICAgIHJjYWxsKFwiREVMXCIsIGRlYm91bmNlS2V5KVxuICAgIGVuZFxuICBlbmRcbmVuZFxuaWYgcmNhbGwoXCJFWElTVFNcIiwgS0VZU1szXSkgPT0gMSB0aGVuIC0tIC8vIE1ha2Ugc3VyZSBqb2IgZXhpc3RzXG4gICAgbG9jYWwgZXJyb3JDb2RlID0gcmVtb3ZlTG9jayhLRVlTWzNdLCBLRVlTWzhdLCBBUkdWWzVdLCBBUkdWWzFdKVxuICAgIGlmIGVycm9yQ29kZSA8IDAgdGhlblxuICAgICAgICByZXR1cm4gZXJyb3JDb2RlXG4gICAgZW5kXG4gICAgLS0gUmVtb3ZlIGZyb20gYWN0aXZlIGxpc3QgKGlmIG5vdCBhY3RpdmUgd2Ugc2hhbGwgcmV0dXJuIGVycm9yKVxuICAgIGxvY2FsIG51bVJlbW92ZWRFbGVtZW50cyA9IHJjYWxsKFwiTFJFTVwiLCBLRVlTWzFdLCAtMSwgQVJHVlsxXSlcbiAgICBpZiBudW1SZW1vdmVkRWxlbWVudHMgPCAxIHRoZW4gcmV0dXJuIC0zIGVuZFxuICAgIGxvY2FsIGRlYm91bmNlSWQgPSByY2FsbChcIkhHRVRcIiwgS0VZU1szXSwgXCJkZWlkXCIpXG4gICAgcmVtb3ZlRGVib3VuY2VLZXlJZk5lZWRlZChBUkdWWzldLCBkZWJvdW5jZUlkKVxuICAgIC0tIFJlbW92ZSBqb2I/XG4gICAgbG9jYWwga2VlcEpvYnMgPSBjbXNncGFjay51bnBhY2soQVJHVls2XSlcbiAgICBsb2NhbCBtYXhDb3VudCA9IGtlZXBKb2JzWydjb3VudCddXG4gICAgbG9jYWwgbWF4QWdlID0ga2VlcEpvYnNbJ2FnZSddXG4gICAgbG9jYWwgdGFyZ2V0U2V0ID0gS0VZU1syXVxuICAgIGxvY2FsIHRpbWVzdGFtcCA9IEFSR1ZbMl1cbiAgICBpZiBtYXhDb3VudCB+PSAwIHRoZW5cbiAgICAgICAgLS0gQWRkIHRvIGNvbXBsZXRlL2ZhaWxlZCBzZXRcbiAgICAgICAgcmNhbGwoXCJaQUREXCIsIHRhcmdldFNldCwgdGltZXN0YW1wLCBBUkdWWzFdKVxuICAgICAgICByY2FsbChcIkhNU0VUXCIsIEtFWVNbM10sIEFSR1ZbM10sIEFSR1ZbNF0sIFwiZmluaXNoZWRPblwiLCB0aW1lc3RhbXApIC0tIFwicmV0dXJudmFsdWVcIiAvIFwiZmFpbGVkUmVhc29uXCIgYW5kIFwiZmluaXNoZWRPblwiXG4gICAgICAgIGxvY2FsIGZ1bmN0aW9uIHJlbW92ZUpvYnMoam9iSWRzKVxuICAgICAgICAgICAgZm9yIGksIGpvYklkIGluIGlwYWlycyhqb2JJZHMpIGRvXG4gICAgICAgICAgICAgICAgbG9jYWwgam9iS2V5ID0gQVJHVls5XSAuLiBqb2JJZFxuICAgICAgICAgICAgICAgIGxvY2FsIGpvYkxvZ0tleSA9IGpvYktleSAuLiAnOmxvZ3MnXG4gICAgICAgICAgICAgICAgcmNhbGwoXCJERUxcIiwgam9iS2V5LCBqb2JMb2dLZXkpXG4gICAgICAgICAgICBlbmRcbiAgICAgICAgZW5kXG4gICAgICAgIC0tIFJlbW92ZSBvbGQgam9icz9cbiAgICAgICAgaWYgbWF4QWdlIH49IG5pbCB0aGVuXG4gICAgICAgICAgICBsb2NhbCBzdGFydCA9IHRpbWVzdGFtcCAtIG1heEFnZSAqIDEwMDBcbiAgICAgICAgICAgIGxvY2FsIGpvYklkcyA9IHJjYWxsKFwiWlJFVlJBTkdFQllTQ09SRVwiLCB0YXJnZXRTZXQsIHN0YXJ0LCBcIi1pbmZcIilcbiAgICAgICAgICAgIHJlbW92ZUpvYnMoam9iSWRzKVxuICAgICAgICAgICAgcmNhbGwoXCJaUkVNUkFOR0VCWVNDT1JFXCIsIHRhcmdldFNldCwgXCItaW5mXCIsIHN0YXJ0KVxuICAgICAgICBlbmRcbiAgICAgICAgaWYgbWF4Q291bnQgfj0gbmlsIGFuZCBtYXhDb3VudCA+IDAgdGhlblxuICAgICAgICAgICAgbG9jYWwgc3RhcnQgPSBtYXhDb3VudFxuICAgICAgICAgICAgbG9jYWwgam9iSWRzID0gcmNhbGwoXCJaUkVWUkFOR0VcIiwgdGFyZ2V0U2V0LCBzdGFydCwgLTEpXG4gICAgICAgICAgICByZW1vdmVKb2JzKGpvYklkcylcbiAgICAgICAgICAgIHJjYWxsKFwiWlJFTVJBTkdFQllSQU5LXCIsIHRhcmdldFNldCwgMCwgLShtYXhDb3VudCArIDEpKTtcbiAgICAgICAgZW5kXG4gICAgZWxzZVxuICAgICAgICBsb2NhbCBqb2JMb2dLZXkgPSBLRVlTWzNdIC4uICc6bG9ncydcbiAgICAgICAgcmNhbGwoXCJERUxcIiwgS0VZU1szXSwgam9iTG9nS2V5KVxuICAgIGVuZFxuICAgIC0tIENvbGxlY3QgbWV0cmljc1xuICAgIGlmIEFSR1ZbMTJdIH49IFwiXCIgdGhlblxuICAgICAgY29sbGVjdE1ldHJpY3MoS0VZU1s5XSwgS0VZU1s5XS4uJzpkYXRhJywgQVJHVlsxMl0sIHRpbWVzdGFtcClcbiAgICBlbmRcbiAgICByY2FsbChcIlBVQkxJU0hcIiwgdGFyZ2V0U2V0LCBBUkdWWzddKVxuICAgIC0tIFRyeSB0byBnZXQgbmV4dCBqb2IgdG8gYXZvaWQgYW4gZXh0cmEgcm91bmR0cmlwIGlmIHRoZSBxdWV1ZSBpcyBub3QgY2xvc2luZywgXG4gICAgLS0gYW5kIG5vdCByYXRlIGxpbWl0ZWQuXG4gICAgaWYgKEFSR1ZbOF0gPT0gXCIxXCIpIHRoZW5cbiAgICAgICAgLS0gbW92ZSBmcm9tIHdhaXQgdG8gYWN0aXZlIFxuICAgICAgICBsb2NhbCBqb2JJZCA9IHJjYWxsKFwiUlBPUExQVVNIXCIsIEtFWVNbNF0sIEtFWVNbMV0pXG4gICAgICAgIGlmIGpvYklkIHRoZW5cbiAgICAgICAgICAgIGxvY2FsIGpvYktleSA9IEFSR1ZbOV0gLi4gam9iSWRcbiAgICAgICAgICAgIGxvY2FsIGxvY2tLZXkgPSBqb2JLZXkgLi4gJzpsb2NrJ1xuICAgICAgICAgICAgLS0gZ2V0IGEgbG9ja1xuICAgICAgICAgICAgcmNhbGwoXCJTRVRcIiwgbG9ja0tleSwgQVJHVlsxMV0sIFwiUFhcIiwgQVJHVlsxMF0pXG4gICAgICAgICAgICByY2FsbChcIlpSRU1cIiwgS0VZU1s1XSwgam9iSWQpIC0tIHJlbW92ZSBmcm9tIHByaW9yaXR5XG4gICAgICAgICAgICByY2FsbChcIlBVQkxJU0hcIiwgS0VZU1s2XSwgam9iSWQpXG4gICAgICAgICAgICByY2FsbChcIkhTRVRcIiwgam9iS2V5LCBcInByb2Nlc3NlZE9uXCIsIEFSR1ZbMl0pXG4gICAgICAgICAgICByZXR1cm4ge3JjYWxsKFwiSEdFVEFMTFwiLCBqb2JLZXkpLCBqb2JJZH0gLS0gZ2V0IGpvYiBkYXRhXG4gICAgICAgIGVuZFxuICAgIGVuZFxuICAgIHJldHVybiAwXG5lbHNlXG4gICAgcmV0dXJuIC0xXG5lbmRcbmA7XG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgbmFtZTogJ21vdmVUb0ZpbmlzaGVkJyxcbiAgY29udGVudCxcbiAga2V5czogOSxcbn07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/bull/lib/scripts/moveToFinished-9.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/bull/lib/scripts/obliterate-2.js":
/*!*******************************************************!*\
  !*** ./node_modules/bull/lib/scripts/obliterate-2.js ***!
  \*******************************************************/
/***/ ((module) => {

eval("\nconst content = `--[[\n    Completely obliterates a queue and all of its contents\n     Input:\n        KEYS[1] meta-paused\n        KEYS[2] base\n        ARGV[1]  count\n        ARGV[2]  force\n]] \n-- This command completely destroys a queue including all of its jobs, current or past \n-- leaving no trace of its existence. Since this script needs to iterate to find all the job\n-- keys, consider that this call may be slow for very large queues.\n-- The queue needs to be \"paused\" or it will return an error\n-- If the queue has currently active jobs then the script by default will return error,\n-- however this behaviour can be overrided using the 'force' option.\nlocal maxCount = tonumber(ARGV[1])\nlocal baseKey = KEYS[2]\nlocal rcall = redis.call\n-- Includes\n--[[\n  Function to remove debounce key.\n]]\nlocal function removeDebounceKey(prefixKey, jobKey)\n  local debounceId = rcall(\"HGET\", jobKey, \"deid\")\n  if debounceId then\n    local debounceKey = prefixKey .. \"de:\" .. debounceId\n    rcall(\"DEL\", debounceKey)\n  end\nend\nlocal function getListItems(keyName, max)\n    return rcall('LRANGE', keyName, 0, max - 1)\nend\nlocal function getZSetItems(keyName, max)\n    return rcall('ZRANGE', keyName, 0, max - 1)\nend\nlocal function removeJobs(baseKey, keys)\n    for i, key in ipairs(keys) do\n        local jobKey = baseKey .. key\n        rcall(\"DEL\", jobKey, jobKey .. ':logs')\n        removeDebounceKey(baseKey, jobKey)\n    end\n    maxCount = maxCount - #keys\nend\nlocal function removeListJobs(keyName, max)\n    local jobs = getListItems(keyName, max)\n    removeJobs(baseKey, jobs)\n    rcall(\"LTRIM\", keyName, #jobs, -1)\nend\nlocal function removeZSetJobs(keyName, max)\n    local jobs = getZSetItems(keyName, max)\n    removeJobs(baseKey, jobs)\n    if (#jobs > 0) then rcall(\"ZREM\", keyName, unpack(jobs)) end\nend\nlocal function removeLockKeys(keys)\n    for i, key in ipairs(keys) do rcall(\"DEL\", baseKey .. key .. ':lock') end\nend\n-- 1) Check if paused, if not return with error.\nif rcall(\"EXISTS\", KEYS[1]) ~= 1 then\n    return -1 -- Error, NotPaused\nend\n-- 2) Check if there are active jobs, if there are and not \"force\" return error.\nlocal activeKey = baseKey .. 'active'\nlocal activeJobs = getListItems(activeKey, maxCount)\nif (#activeJobs > 0) then\n    if (ARGV[2] == \"\") then\n        return -2 -- Error, ExistsActiveJobs\n    end\nend\nremoveLockKeys(activeJobs)\nremoveJobs(baseKey, activeJobs)\nrcall(\"LTRIM\", activeKey, #activeJobs, -1)\nif (maxCount <= 0) then return 1 end\nlocal waitKey = baseKey .. 'paused'\nremoveListJobs(waitKey, maxCount)\nif (maxCount <= 0) then return 1 end\nlocal delayedKey = baseKey .. 'delayed'\nremoveZSetJobs(delayedKey, maxCount)\nif (maxCount <= 0) then return 1 end\nlocal completedKey = baseKey .. 'completed'\nremoveZSetJobs(completedKey, maxCount)\nif (maxCount <= 0) then return 1 end\nlocal failedKey = baseKey .. 'failed'\nremoveZSetJobs(failedKey, maxCount)\nif (maxCount <= 0) then return 1 end\nif (maxCount > 0) then\n    rcall(\"DEL\", baseKey .. 'priority')\n    rcall(\"DEL\", baseKey .. 'stalled-check')\n    rcall(\"DEL\", baseKey .. 'stalled')\n    rcall(\"DEL\", baseKey .. 'meta-paused')\n    rcall(\"DEL\", baseKey .. 'meta')\n    rcall(\"DEL\", baseKey .. 'id')\n    rcall(\"DEL\", baseKey .. 'repeat')\n    rcall(\"DEL\", baseKey .. 'metrics:completed')\n    rcall(\"DEL\", baseKey .. 'metrics:completed:data')\n    rcall(\"DEL\", baseKey .. 'metrics:failed')\n    rcall(\"DEL\", baseKey .. 'metrics:failed:data')\n    return 0\nelse\n    return 1\nend\n`;\nmodule.exports = {\n  name: 'obliterate',\n  content,\n  keys: 2,\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvYnVsbC9saWIvc2NyaXB0cy9vYmxpdGVyYXRlLTIuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9teS1hcHAvLi9ub2RlX21vZHVsZXMvYnVsbC9saWIvc2NyaXB0cy9vYmxpdGVyYXRlLTIuanM/YjU4NSJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5jb25zdCBjb250ZW50ID0gYC0tW1tcbiAgICBDb21wbGV0ZWx5IG9ibGl0ZXJhdGVzIGEgcXVldWUgYW5kIGFsbCBvZiBpdHMgY29udGVudHNcbiAgICAgSW5wdXQ6XG4gICAgICAgIEtFWVNbMV0gbWV0YS1wYXVzZWRcbiAgICAgICAgS0VZU1syXSBiYXNlXG4gICAgICAgIEFSR1ZbMV0gIGNvdW50XG4gICAgICAgIEFSR1ZbMl0gIGZvcmNlXG5dXSBcbi0tIFRoaXMgY29tbWFuZCBjb21wbGV0ZWx5IGRlc3Ryb3lzIGEgcXVldWUgaW5jbHVkaW5nIGFsbCBvZiBpdHMgam9icywgY3VycmVudCBvciBwYXN0IFxuLS0gbGVhdmluZyBubyB0cmFjZSBvZiBpdHMgZXhpc3RlbmNlLiBTaW5jZSB0aGlzIHNjcmlwdCBuZWVkcyB0byBpdGVyYXRlIHRvIGZpbmQgYWxsIHRoZSBqb2Jcbi0tIGtleXMsIGNvbnNpZGVyIHRoYXQgdGhpcyBjYWxsIG1heSBiZSBzbG93IGZvciB2ZXJ5IGxhcmdlIHF1ZXVlcy5cbi0tIFRoZSBxdWV1ZSBuZWVkcyB0byBiZSBcInBhdXNlZFwiIG9yIGl0IHdpbGwgcmV0dXJuIGFuIGVycm9yXG4tLSBJZiB0aGUgcXVldWUgaGFzIGN1cnJlbnRseSBhY3RpdmUgam9icyB0aGVuIHRoZSBzY3JpcHQgYnkgZGVmYXVsdCB3aWxsIHJldHVybiBlcnJvcixcbi0tIGhvd2V2ZXIgdGhpcyBiZWhhdmlvdXIgY2FuIGJlIG92ZXJyaWRlZCB1c2luZyB0aGUgJ2ZvcmNlJyBvcHRpb24uXG5sb2NhbCBtYXhDb3VudCA9IHRvbnVtYmVyKEFSR1ZbMV0pXG5sb2NhbCBiYXNlS2V5ID0gS0VZU1syXVxubG9jYWwgcmNhbGwgPSByZWRpcy5jYWxsXG4tLSBJbmNsdWRlc1xuLS1bW1xuICBGdW5jdGlvbiB0byByZW1vdmUgZGVib3VuY2Uga2V5LlxuXV1cbmxvY2FsIGZ1bmN0aW9uIHJlbW92ZURlYm91bmNlS2V5KHByZWZpeEtleSwgam9iS2V5KVxuICBsb2NhbCBkZWJvdW5jZUlkID0gcmNhbGwoXCJIR0VUXCIsIGpvYktleSwgXCJkZWlkXCIpXG4gIGlmIGRlYm91bmNlSWQgdGhlblxuICAgIGxvY2FsIGRlYm91bmNlS2V5ID0gcHJlZml4S2V5IC4uIFwiZGU6XCIgLi4gZGVib3VuY2VJZFxuICAgIHJjYWxsKFwiREVMXCIsIGRlYm91bmNlS2V5KVxuICBlbmRcbmVuZFxubG9jYWwgZnVuY3Rpb24gZ2V0TGlzdEl0ZW1zKGtleU5hbWUsIG1heClcbiAgICByZXR1cm4gcmNhbGwoJ0xSQU5HRScsIGtleU5hbWUsIDAsIG1heCAtIDEpXG5lbmRcbmxvY2FsIGZ1bmN0aW9uIGdldFpTZXRJdGVtcyhrZXlOYW1lLCBtYXgpXG4gICAgcmV0dXJuIHJjYWxsKCdaUkFOR0UnLCBrZXlOYW1lLCAwLCBtYXggLSAxKVxuZW5kXG5sb2NhbCBmdW5jdGlvbiByZW1vdmVKb2JzKGJhc2VLZXksIGtleXMpXG4gICAgZm9yIGksIGtleSBpbiBpcGFpcnMoa2V5cykgZG9cbiAgICAgICAgbG9jYWwgam9iS2V5ID0gYmFzZUtleSAuLiBrZXlcbiAgICAgICAgcmNhbGwoXCJERUxcIiwgam9iS2V5LCBqb2JLZXkgLi4gJzpsb2dzJylcbiAgICAgICAgcmVtb3ZlRGVib3VuY2VLZXkoYmFzZUtleSwgam9iS2V5KVxuICAgIGVuZFxuICAgIG1heENvdW50ID0gbWF4Q291bnQgLSAja2V5c1xuZW5kXG5sb2NhbCBmdW5jdGlvbiByZW1vdmVMaXN0Sm9icyhrZXlOYW1lLCBtYXgpXG4gICAgbG9jYWwgam9icyA9IGdldExpc3RJdGVtcyhrZXlOYW1lLCBtYXgpXG4gICAgcmVtb3ZlSm9icyhiYXNlS2V5LCBqb2JzKVxuICAgIHJjYWxsKFwiTFRSSU1cIiwga2V5TmFtZSwgI2pvYnMsIC0xKVxuZW5kXG5sb2NhbCBmdW5jdGlvbiByZW1vdmVaU2V0Sm9icyhrZXlOYW1lLCBtYXgpXG4gICAgbG9jYWwgam9icyA9IGdldFpTZXRJdGVtcyhrZXlOYW1lLCBtYXgpXG4gICAgcmVtb3ZlSm9icyhiYXNlS2V5LCBqb2JzKVxuICAgIGlmICgjam9icyA+IDApIHRoZW4gcmNhbGwoXCJaUkVNXCIsIGtleU5hbWUsIHVucGFjayhqb2JzKSkgZW5kXG5lbmRcbmxvY2FsIGZ1bmN0aW9uIHJlbW92ZUxvY2tLZXlzKGtleXMpXG4gICAgZm9yIGksIGtleSBpbiBpcGFpcnMoa2V5cykgZG8gcmNhbGwoXCJERUxcIiwgYmFzZUtleSAuLiBrZXkgLi4gJzpsb2NrJykgZW5kXG5lbmRcbi0tIDEpIENoZWNrIGlmIHBhdXNlZCwgaWYgbm90IHJldHVybiB3aXRoIGVycm9yLlxuaWYgcmNhbGwoXCJFWElTVFNcIiwgS0VZU1sxXSkgfj0gMSB0aGVuXG4gICAgcmV0dXJuIC0xIC0tIEVycm9yLCBOb3RQYXVzZWRcbmVuZFxuLS0gMikgQ2hlY2sgaWYgdGhlcmUgYXJlIGFjdGl2ZSBqb2JzLCBpZiB0aGVyZSBhcmUgYW5kIG5vdCBcImZvcmNlXCIgcmV0dXJuIGVycm9yLlxubG9jYWwgYWN0aXZlS2V5ID0gYmFzZUtleSAuLiAnYWN0aXZlJ1xubG9jYWwgYWN0aXZlSm9icyA9IGdldExpc3RJdGVtcyhhY3RpdmVLZXksIG1heENvdW50KVxuaWYgKCNhY3RpdmVKb2JzID4gMCkgdGhlblxuICAgIGlmIChBUkdWWzJdID09IFwiXCIpIHRoZW5cbiAgICAgICAgcmV0dXJuIC0yIC0tIEVycm9yLCBFeGlzdHNBY3RpdmVKb2JzXG4gICAgZW5kXG5lbmRcbnJlbW92ZUxvY2tLZXlzKGFjdGl2ZUpvYnMpXG5yZW1vdmVKb2JzKGJhc2VLZXksIGFjdGl2ZUpvYnMpXG5yY2FsbChcIkxUUklNXCIsIGFjdGl2ZUtleSwgI2FjdGl2ZUpvYnMsIC0xKVxuaWYgKG1heENvdW50IDw9IDApIHRoZW4gcmV0dXJuIDEgZW5kXG5sb2NhbCB3YWl0S2V5ID0gYmFzZUtleSAuLiAncGF1c2VkJ1xucmVtb3ZlTGlzdEpvYnMod2FpdEtleSwgbWF4Q291bnQpXG5pZiAobWF4Q291bnQgPD0gMCkgdGhlbiByZXR1cm4gMSBlbmRcbmxvY2FsIGRlbGF5ZWRLZXkgPSBiYXNlS2V5IC4uICdkZWxheWVkJ1xucmVtb3ZlWlNldEpvYnMoZGVsYXllZEtleSwgbWF4Q291bnQpXG5pZiAobWF4Q291bnQgPD0gMCkgdGhlbiByZXR1cm4gMSBlbmRcbmxvY2FsIGNvbXBsZXRlZEtleSA9IGJhc2VLZXkgLi4gJ2NvbXBsZXRlZCdcbnJlbW92ZVpTZXRKb2JzKGNvbXBsZXRlZEtleSwgbWF4Q291bnQpXG5pZiAobWF4Q291bnQgPD0gMCkgdGhlbiByZXR1cm4gMSBlbmRcbmxvY2FsIGZhaWxlZEtleSA9IGJhc2VLZXkgLi4gJ2ZhaWxlZCdcbnJlbW92ZVpTZXRKb2JzKGZhaWxlZEtleSwgbWF4Q291bnQpXG5pZiAobWF4Q291bnQgPD0gMCkgdGhlbiByZXR1cm4gMSBlbmRcbmlmIChtYXhDb3VudCA+IDApIHRoZW5cbiAgICByY2FsbChcIkRFTFwiLCBiYXNlS2V5IC4uICdwcmlvcml0eScpXG4gICAgcmNhbGwoXCJERUxcIiwgYmFzZUtleSAuLiAnc3RhbGxlZC1jaGVjaycpXG4gICAgcmNhbGwoXCJERUxcIiwgYmFzZUtleSAuLiAnc3RhbGxlZCcpXG4gICAgcmNhbGwoXCJERUxcIiwgYmFzZUtleSAuLiAnbWV0YS1wYXVzZWQnKVxuICAgIHJjYWxsKFwiREVMXCIsIGJhc2VLZXkgLi4gJ21ldGEnKVxuICAgIHJjYWxsKFwiREVMXCIsIGJhc2VLZXkgLi4gJ2lkJylcbiAgICByY2FsbChcIkRFTFwiLCBiYXNlS2V5IC4uICdyZXBlYXQnKVxuICAgIHJjYWxsKFwiREVMXCIsIGJhc2VLZXkgLi4gJ21ldHJpY3M6Y29tcGxldGVkJylcbiAgICByY2FsbChcIkRFTFwiLCBiYXNlS2V5IC4uICdtZXRyaWNzOmNvbXBsZXRlZDpkYXRhJylcbiAgICByY2FsbChcIkRFTFwiLCBiYXNlS2V5IC4uICdtZXRyaWNzOmZhaWxlZCcpXG4gICAgcmNhbGwoXCJERUxcIiwgYmFzZUtleSAuLiAnbWV0cmljczpmYWlsZWQ6ZGF0YScpXG4gICAgcmV0dXJuIDBcbmVsc2VcbiAgICByZXR1cm4gMVxuZW5kXG5gO1xubW9kdWxlLmV4cG9ydHMgPSB7XG4gIG5hbWU6ICdvYmxpdGVyYXRlJyxcbiAgY29udGVudCxcbiAga2V5czogMixcbn07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/bull/lib/scripts/obliterate-2.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/bull/lib/scripts/pause-5.js":
/*!**************************************************!*\
  !*** ./node_modules/bull/lib/scripts/pause-5.js ***!
  \**************************************************/
/***/ ((module) => {

eval("\nconst content = `--[[\n  Pauses or resumes a queue globably.\n   Input:\n      KEYS[1] 'wait' or 'paused''\n      KEYS[2] 'paused' or 'wait'\n      KEYS[3] 'meta-paused'\n      KEYS[4] 'paused' o 'resumed' event.\n      KEYS[5] 'meta' this key is only used in BullMQ and above.\n      ARGV[1] 'paused' or 'resumed'\n    Event:\n      publish paused or resumed event.\n]]\nlocal rcall = redis.call\nif rcall(\"EXISTS\", KEYS[1]) == 1 then\n  rcall(\"RENAME\", KEYS[1], KEYS[2])\nend\nif ARGV[1] == \"paused\" then\n  rcall(\"SET\", KEYS[3], 1)\n  -- for forwards compatibility\n  rcall(\"HSET\", KEYS[5], \"paused\", 1)\nelse\n  rcall(\"DEL\", KEYS[3])\n  -- for forwards compatibility\n  rcall(\"HDEL\", KEYS[5], \"paused\")\nend\nrcall(\"PUBLISH\", KEYS[4], ARGV[1])\n`;\nmodule.exports = {\n  name: 'pause',\n  content,\n  keys: 5,\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvYnVsbC9saWIvc2NyaXB0cy9wYXVzZS01LmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL215LWFwcC8uL25vZGVfbW9kdWxlcy9idWxsL2xpYi9zY3JpcHRzL3BhdXNlLTUuanM/YWQ2MCJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5jb25zdCBjb250ZW50ID0gYC0tW1tcbiAgUGF1c2VzIG9yIHJlc3VtZXMgYSBxdWV1ZSBnbG9iYWJseS5cbiAgIElucHV0OlxuICAgICAgS0VZU1sxXSAnd2FpdCcgb3IgJ3BhdXNlZCcnXG4gICAgICBLRVlTWzJdICdwYXVzZWQnIG9yICd3YWl0J1xuICAgICAgS0VZU1szXSAnbWV0YS1wYXVzZWQnXG4gICAgICBLRVlTWzRdICdwYXVzZWQnIG8gJ3Jlc3VtZWQnIGV2ZW50LlxuICAgICAgS0VZU1s1XSAnbWV0YScgdGhpcyBrZXkgaXMgb25seSB1c2VkIGluIEJ1bGxNUSBhbmQgYWJvdmUuXG4gICAgICBBUkdWWzFdICdwYXVzZWQnIG9yICdyZXN1bWVkJ1xuICAgIEV2ZW50OlxuICAgICAgcHVibGlzaCBwYXVzZWQgb3IgcmVzdW1lZCBldmVudC5cbl1dXG5sb2NhbCByY2FsbCA9IHJlZGlzLmNhbGxcbmlmIHJjYWxsKFwiRVhJU1RTXCIsIEtFWVNbMV0pID09IDEgdGhlblxuICByY2FsbChcIlJFTkFNRVwiLCBLRVlTWzFdLCBLRVlTWzJdKVxuZW5kXG5pZiBBUkdWWzFdID09IFwicGF1c2VkXCIgdGhlblxuICByY2FsbChcIlNFVFwiLCBLRVlTWzNdLCAxKVxuICAtLSBmb3IgZm9yd2FyZHMgY29tcGF0aWJpbGl0eVxuICByY2FsbChcIkhTRVRcIiwgS0VZU1s1XSwgXCJwYXVzZWRcIiwgMSlcbmVsc2VcbiAgcmNhbGwoXCJERUxcIiwgS0VZU1szXSlcbiAgLS0gZm9yIGZvcndhcmRzIGNvbXBhdGliaWxpdHlcbiAgcmNhbGwoXCJIREVMXCIsIEtFWVNbNV0sIFwicGF1c2VkXCIpXG5lbmRcbnJjYWxsKFwiUFVCTElTSFwiLCBLRVlTWzRdLCBBUkdWWzFdKVxuYDtcbm1vZHVsZS5leHBvcnRzID0ge1xuICBuYW1lOiAncGF1c2UnLFxuICBjb250ZW50LFxuICBrZXlzOiA1LFxufTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/bull/lib/scripts/pause-5.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/bull/lib/scripts/promote-5.js":
/*!****************************************************!*\
  !*** ./node_modules/bull/lib/scripts/promote-5.js ***!
  \****************************************************/
/***/ ((module) => {

eval("\nconst content = `--[[\n  Promotes a job that is currently \"delayed\" to the \"waiting\" state\n     Input:\n      KEYS[1] 'delayed'\n      KEYS[2] 'wait'\n      KEYS[3] 'paused'\n      KEYS[4] 'meta-paused'\n      KEYS[5] 'priority'\n      ARGV[1]  queue.toKey('')\n      ARGV[2]  jobId\n      ARGV[3]  queue token\n     Events:\n      'waiting'\n]]\nlocal rcall = redis.call;\nlocal jobId = ARGV[2]\n-- Includes\n--[[\n  Function to add job considering priority.\n]]\nlocal function addJobWithPriority(priorityKey, priority, jobId, targetKey)\n  rcall(\"ZADD\", priorityKey, priority, jobId)\n  local count = rcall(\"ZCOUNT\", priorityKey, 0, priority)\n  local len = rcall(\"LLEN\", targetKey)\n  local id = rcall(\"LINDEX\", targetKey, len - (count - 1))\n  if id then\n    rcall(\"LINSERT\", targetKey, \"BEFORE\", id, jobId)\n  else\n    rcall(\"RPUSH\", targetKey, jobId)\n  end\nend\n--[[\n  Function to check for the meta.paused key to decide if we are paused or not\n  (since an empty list and !EXISTS are not really the same).\n]]\nlocal function getTargetQueueList(queueMetaKey, waitKey, pausedKey)\n  if rcall(\"EXISTS\", queueMetaKey) ~= 1 then\n    return waitKey, false\n  else\n    return pausedKey, true\n  end\nend\nif rcall(\"ZREM\", KEYS[1], jobId) == 1 then\n  local priority = tonumber(rcall(\"HGET\", ARGV[1] .. jobId, \"priority\")) or 0\n  local target = getTargetQueueList(KEYS[4], KEYS[2], KEYS[3])\n  if priority == 0 then\n    -- LIFO or FIFO\n    rcall(\"LPUSH\", target, jobId)\n  else\n    addJobWithPriority(KEYS[5], priority, jobId, target)\n  end\n  -- Emit waiting event (wait..ing@token)\n  rcall(\"PUBLISH\", KEYS[2] .. \"ing@\" .. ARGV[3], jobId)\n  rcall(\"HSET\", ARGV[1] .. jobId, \"delay\", 0)\n  return 0\nelse\n  return -1\nend\n`;\nmodule.exports = {\n  name: 'promote',\n  content,\n  keys: 5,\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvYnVsbC9saWIvc2NyaXB0cy9wcm9tb3RlLTUuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL215LWFwcC8uL25vZGVfbW9kdWxlcy9idWxsL2xpYi9zY3JpcHRzL3Byb21vdGUtNS5qcz81NzQxIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcbmNvbnN0IGNvbnRlbnQgPSBgLS1bW1xuICBQcm9tb3RlcyBhIGpvYiB0aGF0IGlzIGN1cnJlbnRseSBcImRlbGF5ZWRcIiB0byB0aGUgXCJ3YWl0aW5nXCIgc3RhdGVcbiAgICAgSW5wdXQ6XG4gICAgICBLRVlTWzFdICdkZWxheWVkJ1xuICAgICAgS0VZU1syXSAnd2FpdCdcbiAgICAgIEtFWVNbM10gJ3BhdXNlZCdcbiAgICAgIEtFWVNbNF0gJ21ldGEtcGF1c2VkJ1xuICAgICAgS0VZU1s1XSAncHJpb3JpdHknXG4gICAgICBBUkdWWzFdICBxdWV1ZS50b0tleSgnJylcbiAgICAgIEFSR1ZbMl0gIGpvYklkXG4gICAgICBBUkdWWzNdICBxdWV1ZSB0b2tlblxuICAgICBFdmVudHM6XG4gICAgICAnd2FpdGluZydcbl1dXG5sb2NhbCByY2FsbCA9IHJlZGlzLmNhbGw7XG5sb2NhbCBqb2JJZCA9IEFSR1ZbMl1cbi0tIEluY2x1ZGVzXG4tLVtbXG4gIEZ1bmN0aW9uIHRvIGFkZCBqb2IgY29uc2lkZXJpbmcgcHJpb3JpdHkuXG5dXVxubG9jYWwgZnVuY3Rpb24gYWRkSm9iV2l0aFByaW9yaXR5KHByaW9yaXR5S2V5LCBwcmlvcml0eSwgam9iSWQsIHRhcmdldEtleSlcbiAgcmNhbGwoXCJaQUREXCIsIHByaW9yaXR5S2V5LCBwcmlvcml0eSwgam9iSWQpXG4gIGxvY2FsIGNvdW50ID0gcmNhbGwoXCJaQ09VTlRcIiwgcHJpb3JpdHlLZXksIDAsIHByaW9yaXR5KVxuICBsb2NhbCBsZW4gPSByY2FsbChcIkxMRU5cIiwgdGFyZ2V0S2V5KVxuICBsb2NhbCBpZCA9IHJjYWxsKFwiTElOREVYXCIsIHRhcmdldEtleSwgbGVuIC0gKGNvdW50IC0gMSkpXG4gIGlmIGlkIHRoZW5cbiAgICByY2FsbChcIkxJTlNFUlRcIiwgdGFyZ2V0S2V5LCBcIkJFRk9SRVwiLCBpZCwgam9iSWQpXG4gIGVsc2VcbiAgICByY2FsbChcIlJQVVNIXCIsIHRhcmdldEtleSwgam9iSWQpXG4gIGVuZFxuZW5kXG4tLVtbXG4gIEZ1bmN0aW9uIHRvIGNoZWNrIGZvciB0aGUgbWV0YS5wYXVzZWQga2V5IHRvIGRlY2lkZSBpZiB3ZSBhcmUgcGF1c2VkIG9yIG5vdFxuICAoc2luY2UgYW4gZW1wdHkgbGlzdCBhbmQgIUVYSVNUUyBhcmUgbm90IHJlYWxseSB0aGUgc2FtZSkuXG5dXVxubG9jYWwgZnVuY3Rpb24gZ2V0VGFyZ2V0UXVldWVMaXN0KHF1ZXVlTWV0YUtleSwgd2FpdEtleSwgcGF1c2VkS2V5KVxuICBpZiByY2FsbChcIkVYSVNUU1wiLCBxdWV1ZU1ldGFLZXkpIH49IDEgdGhlblxuICAgIHJldHVybiB3YWl0S2V5LCBmYWxzZVxuICBlbHNlXG4gICAgcmV0dXJuIHBhdXNlZEtleSwgdHJ1ZVxuICBlbmRcbmVuZFxuaWYgcmNhbGwoXCJaUkVNXCIsIEtFWVNbMV0sIGpvYklkKSA9PSAxIHRoZW5cbiAgbG9jYWwgcHJpb3JpdHkgPSB0b251bWJlcihyY2FsbChcIkhHRVRcIiwgQVJHVlsxXSAuLiBqb2JJZCwgXCJwcmlvcml0eVwiKSkgb3IgMFxuICBsb2NhbCB0YXJnZXQgPSBnZXRUYXJnZXRRdWV1ZUxpc3QoS0VZU1s0XSwgS0VZU1syXSwgS0VZU1szXSlcbiAgaWYgcHJpb3JpdHkgPT0gMCB0aGVuXG4gICAgLS0gTElGTyBvciBGSUZPXG4gICAgcmNhbGwoXCJMUFVTSFwiLCB0YXJnZXQsIGpvYklkKVxuICBlbHNlXG4gICAgYWRkSm9iV2l0aFByaW9yaXR5KEtFWVNbNV0sIHByaW9yaXR5LCBqb2JJZCwgdGFyZ2V0KVxuICBlbmRcbiAgLS0gRW1pdCB3YWl0aW5nIGV2ZW50ICh3YWl0Li5pbmdAdG9rZW4pXG4gIHJjYWxsKFwiUFVCTElTSFwiLCBLRVlTWzJdIC4uIFwiaW5nQFwiIC4uIEFSR1ZbM10sIGpvYklkKVxuICByY2FsbChcIkhTRVRcIiwgQVJHVlsxXSAuLiBqb2JJZCwgXCJkZWxheVwiLCAwKVxuICByZXR1cm4gMFxuZWxzZVxuICByZXR1cm4gLTFcbmVuZFxuYDtcbm1vZHVsZS5leHBvcnRzID0ge1xuICBuYW1lOiAncHJvbW90ZScsXG4gIGNvbnRlbnQsXG4gIGtleXM6IDUsXG59O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/bull/lib/scripts/promote-5.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/bull/lib/scripts/releaseLock-1.js":
/*!********************************************************!*\
  !*** ./node_modules/bull/lib/scripts/releaseLock-1.js ***!
  \********************************************************/
/***/ ((module) => {

eval("\nconst content = `--[[\n  Release lock\n     Input:\n        KEYS[1] 'lock',\n        ARGV[1]  token\n        ARGV[2]  lock duration in milliseconds\n      Output:\n        \"OK\" if lock extented succesfully.\n]]\nlocal rcall = redis.call\nif rcall(\"GET\", KEYS[1]) == ARGV[1] then\n  return rcall(\"DEL\", KEYS[1])\nelse\n  return 0\nend\n`;\nmodule.exports = {\n  name: 'releaseLock',\n  content,\n  keys: 1,\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvYnVsbC9saWIvc2NyaXB0cy9yZWxlYXNlTG9jay0xLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbXktYXBwLy4vbm9kZV9tb2R1bGVzL2J1bGwvbGliL3NjcmlwdHMvcmVsZWFzZUxvY2stMS5qcz8xODJhIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcbmNvbnN0IGNvbnRlbnQgPSBgLS1bW1xuICBSZWxlYXNlIGxvY2tcbiAgICAgSW5wdXQ6XG4gICAgICAgIEtFWVNbMV0gJ2xvY2snLFxuICAgICAgICBBUkdWWzFdICB0b2tlblxuICAgICAgICBBUkdWWzJdICBsb2NrIGR1cmF0aW9uIGluIG1pbGxpc2Vjb25kc1xuICAgICAgT3V0cHV0OlxuICAgICAgICBcIk9LXCIgaWYgbG9jayBleHRlbnRlZCBzdWNjZXNmdWxseS5cbl1dXG5sb2NhbCByY2FsbCA9IHJlZGlzLmNhbGxcbmlmIHJjYWxsKFwiR0VUXCIsIEtFWVNbMV0pID09IEFSR1ZbMV0gdGhlblxuICByZXR1cm4gcmNhbGwoXCJERUxcIiwgS0VZU1sxXSlcbmVsc2VcbiAgcmV0dXJuIDBcbmVuZFxuYDtcbm1vZHVsZS5leHBvcnRzID0ge1xuICBuYW1lOiAncmVsZWFzZUxvY2snLFxuICBjb250ZW50LFxuICBrZXlzOiAxLFxufTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/bull/lib/scripts/releaseLock-1.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/bull/lib/scripts/removeJob-11.js":
/*!*******************************************************!*\
  !*** ./node_modules/bull/lib/scripts/removeJob-11.js ***!
  \*******************************************************/
/***/ ((module) => {

eval("\nconst content = `--[[\n    Remove a job from all the queues it may be in as well as all its data.\n    In order to be able to remove a job, it must be unlocked.\n     Input:\n      KEYS[1]  'active',\n      KEYS[2]  'wait',\n      KEYS[3]  'delayed',\n      KEYS[4]  'paused',\n      KEYS[5]  'completed',\n      KEYS[6]  'failed',\n      KEYS[7]  'priority',\n      KEYS[8]  jobId key\n      KEYS[9]  job logs\n      KEYS[10] rate limiter index table\n      KEYS[11] prefix key\n      ARGV[1]  jobId\n      ARGV[2]  lock token\n     Events:\n      'removed'\n]]\n-- TODO PUBLISH global event 'removed'\nlocal rcall = redis.call\n-- Includes\n--[[\n  Function to remove debounce key.\n]]\nlocal function removeDebounceKey(prefixKey, jobKey)\n  local debounceId = rcall(\"HGET\", jobKey, \"deid\")\n  if debounceId then\n    local debounceKey = prefixKey .. \"de:\" .. debounceId\n    rcall(\"DEL\", debounceKey)\n  end\nend\nlocal lockKey = KEYS[8] .. ':lock'\nlocal lock = rcall(\"GET\", lockKey)\nif not lock then             -- or (lock == ARGV[2])) then\n  local jobId = ARGV[1]\n  rcall(\"LREM\", KEYS[1], 0, jobId)\n  rcall(\"LREM\", KEYS[2], 0, jobId)\n  rcall(\"ZREM\", KEYS[3], jobId)\n  rcall(\"LREM\", KEYS[4], 0, jobId)\n  rcall(\"ZREM\", KEYS[5], jobId)\n  rcall(\"ZREM\", KEYS[6], jobId)\n  rcall(\"ZREM\", KEYS[7], jobId)\n  removeDebounceKey(KEYS[11], KEYS[8])\n  rcall(\"DEL\", KEYS[8])\n  rcall(\"DEL\", KEYS[9])\n  -- delete keys related to rate limiter\n  local limiterIndexTable = KEYS[10] .. \":index\"\n  local limitedSetKey = rcall(\"HGET\", limiterIndexTable, jobId)\n  if limitedSetKey then\n    rcall(\"SREM\", limitedSetKey, jobId)\n    rcall(\"HDEL\", limiterIndexTable, jobId)\n  end\n  return 1\nelse\n  return 0\nend\n`;\nmodule.exports = {\n  name: 'removeJob',\n  content,\n  keys: 11,\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvYnVsbC9saWIvc2NyaXB0cy9yZW1vdmVKb2ItMTEuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL215LWFwcC8uL25vZGVfbW9kdWxlcy9idWxsL2xpYi9zY3JpcHRzL3JlbW92ZUpvYi0xMS5qcz9jYzU2Il0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcbmNvbnN0IGNvbnRlbnQgPSBgLS1bW1xuICAgIFJlbW92ZSBhIGpvYiBmcm9tIGFsbCB0aGUgcXVldWVzIGl0IG1heSBiZSBpbiBhcyB3ZWxsIGFzIGFsbCBpdHMgZGF0YS5cbiAgICBJbiBvcmRlciB0byBiZSBhYmxlIHRvIHJlbW92ZSBhIGpvYiwgaXQgbXVzdCBiZSB1bmxvY2tlZC5cbiAgICAgSW5wdXQ6XG4gICAgICBLRVlTWzFdICAnYWN0aXZlJyxcbiAgICAgIEtFWVNbMl0gICd3YWl0JyxcbiAgICAgIEtFWVNbM10gICdkZWxheWVkJyxcbiAgICAgIEtFWVNbNF0gICdwYXVzZWQnLFxuICAgICAgS0VZU1s1XSAgJ2NvbXBsZXRlZCcsXG4gICAgICBLRVlTWzZdICAnZmFpbGVkJyxcbiAgICAgIEtFWVNbN10gICdwcmlvcml0eScsXG4gICAgICBLRVlTWzhdICBqb2JJZCBrZXlcbiAgICAgIEtFWVNbOV0gIGpvYiBsb2dzXG4gICAgICBLRVlTWzEwXSByYXRlIGxpbWl0ZXIgaW5kZXggdGFibGVcbiAgICAgIEtFWVNbMTFdIHByZWZpeCBrZXlcbiAgICAgIEFSR1ZbMV0gIGpvYklkXG4gICAgICBBUkdWWzJdICBsb2NrIHRva2VuXG4gICAgIEV2ZW50czpcbiAgICAgICdyZW1vdmVkJ1xuXV1cbi0tIFRPRE8gUFVCTElTSCBnbG9iYWwgZXZlbnQgJ3JlbW92ZWQnXG5sb2NhbCByY2FsbCA9IHJlZGlzLmNhbGxcbi0tIEluY2x1ZGVzXG4tLVtbXG4gIEZ1bmN0aW9uIHRvIHJlbW92ZSBkZWJvdW5jZSBrZXkuXG5dXVxubG9jYWwgZnVuY3Rpb24gcmVtb3ZlRGVib3VuY2VLZXkocHJlZml4S2V5LCBqb2JLZXkpXG4gIGxvY2FsIGRlYm91bmNlSWQgPSByY2FsbChcIkhHRVRcIiwgam9iS2V5LCBcImRlaWRcIilcbiAgaWYgZGVib3VuY2VJZCB0aGVuXG4gICAgbG9jYWwgZGVib3VuY2VLZXkgPSBwcmVmaXhLZXkgLi4gXCJkZTpcIiAuLiBkZWJvdW5jZUlkXG4gICAgcmNhbGwoXCJERUxcIiwgZGVib3VuY2VLZXkpXG4gIGVuZFxuZW5kXG5sb2NhbCBsb2NrS2V5ID0gS0VZU1s4XSAuLiAnOmxvY2snXG5sb2NhbCBsb2NrID0gcmNhbGwoXCJHRVRcIiwgbG9ja0tleSlcbmlmIG5vdCBsb2NrIHRoZW4gICAgICAgICAgICAgLS0gb3IgKGxvY2sgPT0gQVJHVlsyXSkpIHRoZW5cbiAgbG9jYWwgam9iSWQgPSBBUkdWWzFdXG4gIHJjYWxsKFwiTFJFTVwiLCBLRVlTWzFdLCAwLCBqb2JJZClcbiAgcmNhbGwoXCJMUkVNXCIsIEtFWVNbMl0sIDAsIGpvYklkKVxuICByY2FsbChcIlpSRU1cIiwgS0VZU1szXSwgam9iSWQpXG4gIHJjYWxsKFwiTFJFTVwiLCBLRVlTWzRdLCAwLCBqb2JJZClcbiAgcmNhbGwoXCJaUkVNXCIsIEtFWVNbNV0sIGpvYklkKVxuICByY2FsbChcIlpSRU1cIiwgS0VZU1s2XSwgam9iSWQpXG4gIHJjYWxsKFwiWlJFTVwiLCBLRVlTWzddLCBqb2JJZClcbiAgcmVtb3ZlRGVib3VuY2VLZXkoS0VZU1sxMV0sIEtFWVNbOF0pXG4gIHJjYWxsKFwiREVMXCIsIEtFWVNbOF0pXG4gIHJjYWxsKFwiREVMXCIsIEtFWVNbOV0pXG4gIC0tIGRlbGV0ZSBrZXlzIHJlbGF0ZWQgdG8gcmF0ZSBsaW1pdGVyXG4gIGxvY2FsIGxpbWl0ZXJJbmRleFRhYmxlID0gS0VZU1sxMF0gLi4gXCI6aW5kZXhcIlxuICBsb2NhbCBsaW1pdGVkU2V0S2V5ID0gcmNhbGwoXCJIR0VUXCIsIGxpbWl0ZXJJbmRleFRhYmxlLCBqb2JJZClcbiAgaWYgbGltaXRlZFNldEtleSB0aGVuXG4gICAgcmNhbGwoXCJTUkVNXCIsIGxpbWl0ZWRTZXRLZXksIGpvYklkKVxuICAgIHJjYWxsKFwiSERFTFwiLCBsaW1pdGVySW5kZXhUYWJsZSwgam9iSWQpXG4gIGVuZFxuICByZXR1cm4gMVxuZWxzZVxuICByZXR1cm4gMFxuZW5kXG5gO1xubW9kdWxlLmV4cG9ydHMgPSB7XG4gIG5hbWU6ICdyZW1vdmVKb2InLFxuICBjb250ZW50LFxuICBrZXlzOiAxMSxcbn07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/bull/lib/scripts/removeJob-11.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/bull/lib/scripts/removeJobs-8.js":
/*!*******************************************************!*\
  !*** ./node_modules/bull/lib/scripts/removeJobs-8.js ***!
  \*******************************************************/
/***/ ((module) => {

eval("\nconst content = `--[[\n    Remove all jobs matching a given pattern from all the queues they may be in as well as all its data.\n    In order to be able to remove any job, they must be unlocked.\n     Input:\n      KEYS[1] 'active',\n      KEYS[2] 'wait',\n      KEYS[3] 'delayed',\n      KEYS[4] 'paused',\n      KEYS[5] 'completed',\n      KEYS[6] 'failed',\n      KEYS[7] 'priority',\n      KEYS[8] 'rate-limiter'\n      ARGV[1]  prefix\n      ARGV[2]  pattern\n      ARGV[3]  cursor\n     Events:\n      'removed'\n]]\n-- TODO PUBLISH global events 'removed'\nlocal rcall = redis.call\nlocal result = rcall(\"SCAN\", ARGV[3], \"MATCH\", ARGV[1] .. ARGV[2])\nlocal cursor = result[1];\nlocal jobKeys = result[2];\nlocal removed = {}\nlocal prefixLen = string.len(ARGV[1]) + 1\nfor i, jobKey in ipairs(jobKeys) do\n    local keyTypeResp = rcall(\"TYPE\", jobKey)\n    if keyTypeResp[\"ok\"] == \"hash\" then\n        local jobId = string.sub(jobKey, prefixLen)\n        local lockKey = jobKey .. ':lock'\n        local lock = redis.call(\"GET\", lockKey)\n        if not lock then\n            rcall(\"LREM\", KEYS[1], 0, jobId)\n            rcall(\"LREM\", KEYS[2], 0, jobId)\n            rcall(\"ZREM\", KEYS[3], jobId)\n            rcall(\"LREM\", KEYS[4], 0, jobId)\n            rcall(\"ZREM\", KEYS[5], jobId)\n            rcall(\"ZREM\", KEYS[6], jobId)\n            rcall(\"ZREM\", KEYS[7], jobId)\n            rcall(\"DEL\", jobKey)\n            rcall(\"DEL\", jobKey .. ':logs')\n            -- delete keys related to rate limiter\n            local limiterIndexTable = KEYS[8] .. \":index\"\n            local limitedSetKey = rcall(\"HGET\", limiterIndexTable, jobId)\n            if limitedSetKey then\n                rcall(\"SREM\", limitedSetKey, jobId)\n                rcall(\"HDEL\", limiterIndexTable, jobId)\n            end\n            table.insert(removed, jobId)\n        end\n    end\nend\nreturn {cursor, removed}\n`;\nmodule.exports = {\n  name: 'removeJobs',\n  content,\n  keys: 8,\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvYnVsbC9saWIvc2NyaXB0cy9yZW1vdmVKb2JzLTguanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9teS1hcHAvLi9ub2RlX21vZHVsZXMvYnVsbC9saWIvc2NyaXB0cy9yZW1vdmVKb2JzLTguanM/YjM5OSJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5jb25zdCBjb250ZW50ID0gYC0tW1tcbiAgICBSZW1vdmUgYWxsIGpvYnMgbWF0Y2hpbmcgYSBnaXZlbiBwYXR0ZXJuIGZyb20gYWxsIHRoZSBxdWV1ZXMgdGhleSBtYXkgYmUgaW4gYXMgd2VsbCBhcyBhbGwgaXRzIGRhdGEuXG4gICAgSW4gb3JkZXIgdG8gYmUgYWJsZSB0byByZW1vdmUgYW55IGpvYiwgdGhleSBtdXN0IGJlIHVubG9ja2VkLlxuICAgICBJbnB1dDpcbiAgICAgIEtFWVNbMV0gJ2FjdGl2ZScsXG4gICAgICBLRVlTWzJdICd3YWl0JyxcbiAgICAgIEtFWVNbM10gJ2RlbGF5ZWQnLFxuICAgICAgS0VZU1s0XSAncGF1c2VkJyxcbiAgICAgIEtFWVNbNV0gJ2NvbXBsZXRlZCcsXG4gICAgICBLRVlTWzZdICdmYWlsZWQnLFxuICAgICAgS0VZU1s3XSAncHJpb3JpdHknLFxuICAgICAgS0VZU1s4XSAncmF0ZS1saW1pdGVyJ1xuICAgICAgQVJHVlsxXSAgcHJlZml4XG4gICAgICBBUkdWWzJdICBwYXR0ZXJuXG4gICAgICBBUkdWWzNdICBjdXJzb3JcbiAgICAgRXZlbnRzOlxuICAgICAgJ3JlbW92ZWQnXG5dXVxuLS0gVE9ETyBQVUJMSVNIIGdsb2JhbCBldmVudHMgJ3JlbW92ZWQnXG5sb2NhbCByY2FsbCA9IHJlZGlzLmNhbGxcbmxvY2FsIHJlc3VsdCA9IHJjYWxsKFwiU0NBTlwiLCBBUkdWWzNdLCBcIk1BVENIXCIsIEFSR1ZbMV0gLi4gQVJHVlsyXSlcbmxvY2FsIGN1cnNvciA9IHJlc3VsdFsxXTtcbmxvY2FsIGpvYktleXMgPSByZXN1bHRbMl07XG5sb2NhbCByZW1vdmVkID0ge31cbmxvY2FsIHByZWZpeExlbiA9IHN0cmluZy5sZW4oQVJHVlsxXSkgKyAxXG5mb3IgaSwgam9iS2V5IGluIGlwYWlycyhqb2JLZXlzKSBkb1xuICAgIGxvY2FsIGtleVR5cGVSZXNwID0gcmNhbGwoXCJUWVBFXCIsIGpvYktleSlcbiAgICBpZiBrZXlUeXBlUmVzcFtcIm9rXCJdID09IFwiaGFzaFwiIHRoZW5cbiAgICAgICAgbG9jYWwgam9iSWQgPSBzdHJpbmcuc3ViKGpvYktleSwgcHJlZml4TGVuKVxuICAgICAgICBsb2NhbCBsb2NrS2V5ID0gam9iS2V5IC4uICc6bG9jaydcbiAgICAgICAgbG9jYWwgbG9jayA9IHJlZGlzLmNhbGwoXCJHRVRcIiwgbG9ja0tleSlcbiAgICAgICAgaWYgbm90IGxvY2sgdGhlblxuICAgICAgICAgICAgcmNhbGwoXCJMUkVNXCIsIEtFWVNbMV0sIDAsIGpvYklkKVxuICAgICAgICAgICAgcmNhbGwoXCJMUkVNXCIsIEtFWVNbMl0sIDAsIGpvYklkKVxuICAgICAgICAgICAgcmNhbGwoXCJaUkVNXCIsIEtFWVNbM10sIGpvYklkKVxuICAgICAgICAgICAgcmNhbGwoXCJMUkVNXCIsIEtFWVNbNF0sIDAsIGpvYklkKVxuICAgICAgICAgICAgcmNhbGwoXCJaUkVNXCIsIEtFWVNbNV0sIGpvYklkKVxuICAgICAgICAgICAgcmNhbGwoXCJaUkVNXCIsIEtFWVNbNl0sIGpvYklkKVxuICAgICAgICAgICAgcmNhbGwoXCJaUkVNXCIsIEtFWVNbN10sIGpvYklkKVxuICAgICAgICAgICAgcmNhbGwoXCJERUxcIiwgam9iS2V5KVxuICAgICAgICAgICAgcmNhbGwoXCJERUxcIiwgam9iS2V5IC4uICc6bG9ncycpXG4gICAgICAgICAgICAtLSBkZWxldGUga2V5cyByZWxhdGVkIHRvIHJhdGUgbGltaXRlclxuICAgICAgICAgICAgbG9jYWwgbGltaXRlckluZGV4VGFibGUgPSBLRVlTWzhdIC4uIFwiOmluZGV4XCJcbiAgICAgICAgICAgIGxvY2FsIGxpbWl0ZWRTZXRLZXkgPSByY2FsbChcIkhHRVRcIiwgbGltaXRlckluZGV4VGFibGUsIGpvYklkKVxuICAgICAgICAgICAgaWYgbGltaXRlZFNldEtleSB0aGVuXG4gICAgICAgICAgICAgICAgcmNhbGwoXCJTUkVNXCIsIGxpbWl0ZWRTZXRLZXksIGpvYklkKVxuICAgICAgICAgICAgICAgIHJjYWxsKFwiSERFTFwiLCBsaW1pdGVySW5kZXhUYWJsZSwgam9iSWQpXG4gICAgICAgICAgICBlbmRcbiAgICAgICAgICAgIHRhYmxlLmluc2VydChyZW1vdmVkLCBqb2JJZClcbiAgICAgICAgZW5kXG4gICAgZW5kXG5lbmRcbnJldHVybiB7Y3Vyc29yLCByZW1vdmVkfVxuYDtcbm1vZHVsZS5leHBvcnRzID0ge1xuICBuYW1lOiAncmVtb3ZlSm9icycsXG4gIGNvbnRlbnQsXG4gIGtleXM6IDgsXG59O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/bull/lib/scripts/removeJobs-8.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/bull/lib/scripts/removeRepeatable-2.js":
/*!*************************************************************!*\
  !*** ./node_modules/bull/lib/scripts/removeRepeatable-2.js ***!
  \*************************************************************/
/***/ ((module) => {

eval("\nconst content = `--[[\n  Removes a repeatable job\n  Input:\n    KEYS[1] repeat jobs key\n    KEYS[2] delayed jobs key\n    ARGV[1] repeat job id\n    ARGV[2] repeat job key\n    ARGV[3] queue key\n]]\nlocal millis = redis.call(\"ZSCORE\", KEYS[1], ARGV[2])\nif(millis) then\n  -- Delete next programmed job.\n  local repeatJobId = ARGV[1] .. millis\n  if(redis.call(\"ZREM\", KEYS[2], repeatJobId) == 1) then\n    redis.call(\"DEL\", ARGV[3] .. repeatJobId)\n  end\nend\nredis.call(\"ZREM\", KEYS[1], ARGV[2]);\n`;\nmodule.exports = {\n  name: 'removeRepeatable',\n  content,\n  keys: 2,\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvYnVsbC9saWIvc2NyaXB0cy9yZW1vdmVSZXBlYXRhYmxlLTIuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9teS1hcHAvLi9ub2RlX21vZHVsZXMvYnVsbC9saWIvc2NyaXB0cy9yZW1vdmVSZXBlYXRhYmxlLTIuanM/ZjBiZCJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5jb25zdCBjb250ZW50ID0gYC0tW1tcbiAgUmVtb3ZlcyBhIHJlcGVhdGFibGUgam9iXG4gIElucHV0OlxuICAgIEtFWVNbMV0gcmVwZWF0IGpvYnMga2V5XG4gICAgS0VZU1syXSBkZWxheWVkIGpvYnMga2V5XG4gICAgQVJHVlsxXSByZXBlYXQgam9iIGlkXG4gICAgQVJHVlsyXSByZXBlYXQgam9iIGtleVxuICAgIEFSR1ZbM10gcXVldWUga2V5XG5dXVxubG9jYWwgbWlsbGlzID0gcmVkaXMuY2FsbChcIlpTQ09SRVwiLCBLRVlTWzFdLCBBUkdWWzJdKVxuaWYobWlsbGlzKSB0aGVuXG4gIC0tIERlbGV0ZSBuZXh0IHByb2dyYW1tZWQgam9iLlxuICBsb2NhbCByZXBlYXRKb2JJZCA9IEFSR1ZbMV0gLi4gbWlsbGlzXG4gIGlmKHJlZGlzLmNhbGwoXCJaUkVNXCIsIEtFWVNbMl0sIHJlcGVhdEpvYklkKSA9PSAxKSB0aGVuXG4gICAgcmVkaXMuY2FsbChcIkRFTFwiLCBBUkdWWzNdIC4uIHJlcGVhdEpvYklkKVxuICBlbmRcbmVuZFxucmVkaXMuY2FsbChcIlpSRU1cIiwgS0VZU1sxXSwgQVJHVlsyXSk7XG5gO1xubW9kdWxlLmV4cG9ydHMgPSB7XG4gIG5hbWU6ICdyZW1vdmVSZXBlYXRhYmxlJyxcbiAgY29udGVudCxcbiAga2V5czogMixcbn07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/bull/lib/scripts/removeRepeatable-2.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/bull/lib/scripts/reprocessJob-6.js":
/*!*********************************************************!*\
  !*** ./node_modules/bull/lib/scripts/reprocessJob-6.js ***!
  \*********************************************************/
/***/ ((module) => {

eval("\nconst content = `--[[\n  Attempts to reprocess a job\n  Input:\n    KEYS[1] job key\n    KEYS[2] job lock key\n    KEYS[3] job state\n    KEYS[4] wait key\n    KEYS[5] meta-pause\n    KEYS[6] paused key\n    ARGV[1] job.id,\n    ARGV[2] (job.opts.lifo ? 'R' : 'L') + 'PUSH'\n    ARGV[3] token\n    ARGV[4] timestamp\n  Output:\n    1 means the operation was a success\n    0 means the job does not exist\n    -1 means the job is currently locked and can't be retried.\n    -2 means the job was not found in the expected set.\n]]\nlocal rcall = redis.call;\nif (rcall(\"EXISTS\", KEYS[1]) == 1) then\n    if (rcall(\"EXISTS\", KEYS[2]) == 0) then\n        rcall(\"HDEL\", KEYS[1], \"finishedOn\", \"processedOn\", \"failedReason\")\n        rcall(\"HSET\", KEYS[1], \"retriedOn\", ARGV[4])\n        if (rcall(\"ZREM\", KEYS[3], ARGV[1]) == 1) then\n            local target\n            if rcall(\"EXISTS\", KEYS[5]) ~= 1 then\n                target = KEYS[4]\n            else\n                target = KEYS[6]\n            end\n            rcall(ARGV[2], target, ARGV[1])\n            -- Emit waiting event (wait..ing@token)\n            rcall(\"PUBLISH\", KEYS[4] .. \"ing@\" .. ARGV[3], ARGV[1])\n            return 1\n        else\n            return -2\n        end\n    else\n        return -1\n    end\nelse\n    return 0\nend\n`;\nmodule.exports = {\n  name: 'reprocessJob',\n  content,\n  keys: 6,\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvYnVsbC9saWIvc2NyaXB0cy9yZXByb2Nlc3NKb2ItNi5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9teS1hcHAvLi9ub2RlX21vZHVsZXMvYnVsbC9saWIvc2NyaXB0cy9yZXByb2Nlc3NKb2ItNi5qcz8xODdkIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcbmNvbnN0IGNvbnRlbnQgPSBgLS1bW1xuICBBdHRlbXB0cyB0byByZXByb2Nlc3MgYSBqb2JcbiAgSW5wdXQ6XG4gICAgS0VZU1sxXSBqb2Iga2V5XG4gICAgS0VZU1syXSBqb2IgbG9jayBrZXlcbiAgICBLRVlTWzNdIGpvYiBzdGF0ZVxuICAgIEtFWVNbNF0gd2FpdCBrZXlcbiAgICBLRVlTWzVdIG1ldGEtcGF1c2VcbiAgICBLRVlTWzZdIHBhdXNlZCBrZXlcbiAgICBBUkdWWzFdIGpvYi5pZCxcbiAgICBBUkdWWzJdIChqb2Iub3B0cy5saWZvID8gJ1InIDogJ0wnKSArICdQVVNIJ1xuICAgIEFSR1ZbM10gdG9rZW5cbiAgICBBUkdWWzRdIHRpbWVzdGFtcFxuICBPdXRwdXQ6XG4gICAgMSBtZWFucyB0aGUgb3BlcmF0aW9uIHdhcyBhIHN1Y2Nlc3NcbiAgICAwIG1lYW5zIHRoZSBqb2IgZG9lcyBub3QgZXhpc3RcbiAgICAtMSBtZWFucyB0aGUgam9iIGlzIGN1cnJlbnRseSBsb2NrZWQgYW5kIGNhbid0IGJlIHJldHJpZWQuXG4gICAgLTIgbWVhbnMgdGhlIGpvYiB3YXMgbm90IGZvdW5kIGluIHRoZSBleHBlY3RlZCBzZXQuXG5dXVxubG9jYWwgcmNhbGwgPSByZWRpcy5jYWxsO1xuaWYgKHJjYWxsKFwiRVhJU1RTXCIsIEtFWVNbMV0pID09IDEpIHRoZW5cbiAgICBpZiAocmNhbGwoXCJFWElTVFNcIiwgS0VZU1syXSkgPT0gMCkgdGhlblxuICAgICAgICByY2FsbChcIkhERUxcIiwgS0VZU1sxXSwgXCJmaW5pc2hlZE9uXCIsIFwicHJvY2Vzc2VkT25cIiwgXCJmYWlsZWRSZWFzb25cIilcbiAgICAgICAgcmNhbGwoXCJIU0VUXCIsIEtFWVNbMV0sIFwicmV0cmllZE9uXCIsIEFSR1ZbNF0pXG4gICAgICAgIGlmIChyY2FsbChcIlpSRU1cIiwgS0VZU1szXSwgQVJHVlsxXSkgPT0gMSkgdGhlblxuICAgICAgICAgICAgbG9jYWwgdGFyZ2V0XG4gICAgICAgICAgICBpZiByY2FsbChcIkVYSVNUU1wiLCBLRVlTWzVdKSB+PSAxIHRoZW5cbiAgICAgICAgICAgICAgICB0YXJnZXQgPSBLRVlTWzRdXG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgdGFyZ2V0ID0gS0VZU1s2XVxuICAgICAgICAgICAgZW5kXG4gICAgICAgICAgICByY2FsbChBUkdWWzJdLCB0YXJnZXQsIEFSR1ZbMV0pXG4gICAgICAgICAgICAtLSBFbWl0IHdhaXRpbmcgZXZlbnQgKHdhaXQuLmluZ0B0b2tlbilcbiAgICAgICAgICAgIHJjYWxsKFwiUFVCTElTSFwiLCBLRVlTWzRdIC4uIFwiaW5nQFwiIC4uIEFSR1ZbM10sIEFSR1ZbMV0pXG4gICAgICAgICAgICByZXR1cm4gMVxuICAgICAgICBlbHNlXG4gICAgICAgICAgICByZXR1cm4gLTJcbiAgICAgICAgZW5kXG4gICAgZWxzZVxuICAgICAgICByZXR1cm4gLTFcbiAgICBlbmRcbmVsc2VcbiAgICByZXR1cm4gMFxuZW5kXG5gO1xubW9kdWxlLmV4cG9ydHMgPSB7XG4gIG5hbWU6ICdyZXByb2Nlc3NKb2InLFxuICBjb250ZW50LFxuICBrZXlzOiA2LFxufTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/bull/lib/scripts/reprocessJob-6.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/bull/lib/scripts/retryJob-7.js":
/*!*****************************************************!*\
  !*** ./node_modules/bull/lib/scripts/retryJob-7.js ***!
  \*****************************************************/
/***/ ((module) => {

eval("\nconst content = `--[[\n  Retries a failed job by moving it back to the wait queue.\n    Input:\n      KEYS[1] 'active',\n      KEYS[2] 'wait'\n      KEYS[3] jobId key\n      KEYS[4] 'meta-paused'\n      KEYS[5] 'paused'\n      KEYS[6] stalled key\n      KEYS[7] 'priority'\n      ARGV[1]  pushCmd\n      ARGV[2]  jobId\n      ARGV[3]  token\n    Events:\n      'prefix:added'\n    Output:\n     0  - OK\n     -1 - Missing key\n     -2 - Job Not locked\n     -3 - Job not in active set\n]]\nlocal rcall = redis.call\n-- Includes\n--[[\n  Function to add job considering priority.\n]]\nlocal function addJobWithPriority(priorityKey, priority, jobId, targetKey)\n  rcall(\"ZADD\", priorityKey, priority, jobId)\n  local count = rcall(\"ZCOUNT\", priorityKey, 0, priority)\n  local len = rcall(\"LLEN\", targetKey)\n  local id = rcall(\"LINDEX\", targetKey, len - (count - 1))\n  if id then\n    rcall(\"LINSERT\", targetKey, \"BEFORE\", id, jobId)\n  else\n    rcall(\"RPUSH\", targetKey, jobId)\n  end\nend\n--[[\n  Function to check for the meta.paused key to decide if we are paused or not\n  (since an empty list and !EXISTS are not really the same).\n]]\nlocal function getTargetQueueList(queueMetaKey, waitKey, pausedKey)\n  if rcall(\"EXISTS\", queueMetaKey) ~= 1 then\n    return waitKey, false\n  else\n    return pausedKey, true\n  end\nend\nlocal function removeLock(jobKey, stalledKey, token, jobId)\n  if token ~= \"0\" then\n    local lockKey = jobKey .. ':lock'\n    local lockToken = rcall(\"GET\", lockKey)\n    if lockToken == token then\n      rcall(\"DEL\", lockKey)\n      rcall(\"SREM\", stalledKey, jobId)\n    else\n      if lockToken then\n        -- Lock exists but token does not match\n        return -6\n      else\n        -- Lock is missing completely\n        return -2\n      end\n    end\n  end\n  return 0\nend\nif rcall(\"EXISTS\", KEYS[3]) == 1 then\n  local errorCode = removeLock(KEYS[3], KEYS[6], ARGV[3], ARGV[2])\n  if errorCode < 0 then\n    return errorCode\n  end\n  local numRemovedElements = rcall(\"LREM\", KEYS[1], -1, ARGV[2])\n  if numRemovedElements < 1 then return -3 end\n  local target = getTargetQueueList(KEYS[4], KEYS[2], KEYS[5])\n  local priority = tonumber(rcall(\"HGET\", KEYS[3], \"priority\")) or 0\n  if priority == 0 then\n    -- LIFO or FIFO\n    rcall(ARGV[1], target, ARGV[2])\n  else\n    addJobWithPriority(KEYS[7], priority, ARGV[2], target)\n  end\n  return 0\nelse\n  return -1\nend\n`;\nmodule.exports = {\n  name: 'retryJob',\n  content,\n  keys: 7,\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvYnVsbC9saWIvc2NyaXB0cy9yZXRyeUpvYi03LmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL215LWFwcC8uL25vZGVfbW9kdWxlcy9idWxsL2xpYi9zY3JpcHRzL3JldHJ5Sm9iLTcuanM/NmQ3MyJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5jb25zdCBjb250ZW50ID0gYC0tW1tcbiAgUmV0cmllcyBhIGZhaWxlZCBqb2IgYnkgbW92aW5nIGl0IGJhY2sgdG8gdGhlIHdhaXQgcXVldWUuXG4gICAgSW5wdXQ6XG4gICAgICBLRVlTWzFdICdhY3RpdmUnLFxuICAgICAgS0VZU1syXSAnd2FpdCdcbiAgICAgIEtFWVNbM10gam9iSWQga2V5XG4gICAgICBLRVlTWzRdICdtZXRhLXBhdXNlZCdcbiAgICAgIEtFWVNbNV0gJ3BhdXNlZCdcbiAgICAgIEtFWVNbNl0gc3RhbGxlZCBrZXlcbiAgICAgIEtFWVNbN10gJ3ByaW9yaXR5J1xuICAgICAgQVJHVlsxXSAgcHVzaENtZFxuICAgICAgQVJHVlsyXSAgam9iSWRcbiAgICAgIEFSR1ZbM10gIHRva2VuXG4gICAgRXZlbnRzOlxuICAgICAgJ3ByZWZpeDphZGRlZCdcbiAgICBPdXRwdXQ6XG4gICAgIDAgIC0gT0tcbiAgICAgLTEgLSBNaXNzaW5nIGtleVxuICAgICAtMiAtIEpvYiBOb3QgbG9ja2VkXG4gICAgIC0zIC0gSm9iIG5vdCBpbiBhY3RpdmUgc2V0XG5dXVxubG9jYWwgcmNhbGwgPSByZWRpcy5jYWxsXG4tLSBJbmNsdWRlc1xuLS1bW1xuICBGdW5jdGlvbiB0byBhZGQgam9iIGNvbnNpZGVyaW5nIHByaW9yaXR5LlxuXV1cbmxvY2FsIGZ1bmN0aW9uIGFkZEpvYldpdGhQcmlvcml0eShwcmlvcml0eUtleSwgcHJpb3JpdHksIGpvYklkLCB0YXJnZXRLZXkpXG4gIHJjYWxsKFwiWkFERFwiLCBwcmlvcml0eUtleSwgcHJpb3JpdHksIGpvYklkKVxuICBsb2NhbCBjb3VudCA9IHJjYWxsKFwiWkNPVU5UXCIsIHByaW9yaXR5S2V5LCAwLCBwcmlvcml0eSlcbiAgbG9jYWwgbGVuID0gcmNhbGwoXCJMTEVOXCIsIHRhcmdldEtleSlcbiAgbG9jYWwgaWQgPSByY2FsbChcIkxJTkRFWFwiLCB0YXJnZXRLZXksIGxlbiAtIChjb3VudCAtIDEpKVxuICBpZiBpZCB0aGVuXG4gICAgcmNhbGwoXCJMSU5TRVJUXCIsIHRhcmdldEtleSwgXCJCRUZPUkVcIiwgaWQsIGpvYklkKVxuICBlbHNlXG4gICAgcmNhbGwoXCJSUFVTSFwiLCB0YXJnZXRLZXksIGpvYklkKVxuICBlbmRcbmVuZFxuLS1bW1xuICBGdW5jdGlvbiB0byBjaGVjayBmb3IgdGhlIG1ldGEucGF1c2VkIGtleSB0byBkZWNpZGUgaWYgd2UgYXJlIHBhdXNlZCBvciBub3RcbiAgKHNpbmNlIGFuIGVtcHR5IGxpc3QgYW5kICFFWElTVFMgYXJlIG5vdCByZWFsbHkgdGhlIHNhbWUpLlxuXV1cbmxvY2FsIGZ1bmN0aW9uIGdldFRhcmdldFF1ZXVlTGlzdChxdWV1ZU1ldGFLZXksIHdhaXRLZXksIHBhdXNlZEtleSlcbiAgaWYgcmNhbGwoXCJFWElTVFNcIiwgcXVldWVNZXRhS2V5KSB+PSAxIHRoZW5cbiAgICByZXR1cm4gd2FpdEtleSwgZmFsc2VcbiAgZWxzZVxuICAgIHJldHVybiBwYXVzZWRLZXksIHRydWVcbiAgZW5kXG5lbmRcbmxvY2FsIGZ1bmN0aW9uIHJlbW92ZUxvY2soam9iS2V5LCBzdGFsbGVkS2V5LCB0b2tlbiwgam9iSWQpXG4gIGlmIHRva2VuIH49IFwiMFwiIHRoZW5cbiAgICBsb2NhbCBsb2NrS2V5ID0gam9iS2V5IC4uICc6bG9jaydcbiAgICBsb2NhbCBsb2NrVG9rZW4gPSByY2FsbChcIkdFVFwiLCBsb2NrS2V5KVxuICAgIGlmIGxvY2tUb2tlbiA9PSB0b2tlbiB0aGVuXG4gICAgICByY2FsbChcIkRFTFwiLCBsb2NrS2V5KVxuICAgICAgcmNhbGwoXCJTUkVNXCIsIHN0YWxsZWRLZXksIGpvYklkKVxuICAgIGVsc2VcbiAgICAgIGlmIGxvY2tUb2tlbiB0aGVuXG4gICAgICAgIC0tIExvY2sgZXhpc3RzIGJ1dCB0b2tlbiBkb2VzIG5vdCBtYXRjaFxuICAgICAgICByZXR1cm4gLTZcbiAgICAgIGVsc2VcbiAgICAgICAgLS0gTG9jayBpcyBtaXNzaW5nIGNvbXBsZXRlbHlcbiAgICAgICAgcmV0dXJuIC0yXG4gICAgICBlbmRcbiAgICBlbmRcbiAgZW5kXG4gIHJldHVybiAwXG5lbmRcbmlmIHJjYWxsKFwiRVhJU1RTXCIsIEtFWVNbM10pID09IDEgdGhlblxuICBsb2NhbCBlcnJvckNvZGUgPSByZW1vdmVMb2NrKEtFWVNbM10sIEtFWVNbNl0sIEFSR1ZbM10sIEFSR1ZbMl0pXG4gIGlmIGVycm9yQ29kZSA8IDAgdGhlblxuICAgIHJldHVybiBlcnJvckNvZGVcbiAgZW5kXG4gIGxvY2FsIG51bVJlbW92ZWRFbGVtZW50cyA9IHJjYWxsKFwiTFJFTVwiLCBLRVlTWzFdLCAtMSwgQVJHVlsyXSlcbiAgaWYgbnVtUmVtb3ZlZEVsZW1lbnRzIDwgMSB0aGVuIHJldHVybiAtMyBlbmRcbiAgbG9jYWwgdGFyZ2V0ID0gZ2V0VGFyZ2V0UXVldWVMaXN0KEtFWVNbNF0sIEtFWVNbMl0sIEtFWVNbNV0pXG4gIGxvY2FsIHByaW9yaXR5ID0gdG9udW1iZXIocmNhbGwoXCJIR0VUXCIsIEtFWVNbM10sIFwicHJpb3JpdHlcIikpIG9yIDBcbiAgaWYgcHJpb3JpdHkgPT0gMCB0aGVuXG4gICAgLS0gTElGTyBvciBGSUZPXG4gICAgcmNhbGwoQVJHVlsxXSwgdGFyZ2V0LCBBUkdWWzJdKVxuICBlbHNlXG4gICAgYWRkSm9iV2l0aFByaW9yaXR5KEtFWVNbN10sIHByaW9yaXR5LCBBUkdWWzJdLCB0YXJnZXQpXG4gIGVuZFxuICByZXR1cm4gMFxuZWxzZVxuICByZXR1cm4gLTFcbmVuZFxuYDtcbm1vZHVsZS5leHBvcnRzID0ge1xuICBuYW1lOiAncmV0cnlKb2InLFxuICBjb250ZW50LFxuICBrZXlzOiA3LFxufTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/bull/lib/scripts/retryJob-7.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/bull/lib/scripts/retryJobs-5.js":
/*!******************************************************!*\
  !*** ./node_modules/bull/lib/scripts/retryJobs-5.js ***!
  \******************************************************/
/***/ ((module) => {

eval("\nconst content = `--[[\n  Attempts to retry all failed jobs\n  Input:\n    KEYS[1] base key\n    KEYS[2] failed state key\n    KEYS[3] wait state key\n    KEYS[4] 'meta-paused'\n    KEYS[5] 'paused'\n    ARGV[1]  count\n  Output:\n    1  means the operation is not completed\n    0  means the operation is completed\n]]\nlocal baseKey = KEYS[1]\nlocal maxCount = tonumber(ARGV[1])\nlocal rcall = redis.call;\n-- Includes\n--[[\n  Function to loop in batches.\n  Just a bit of warning, some commands as ZREM\n  could receive a maximum of 7000 parameters per call.\n]]\nlocal function batches(n, batchSize)\n  local i = 0\n  return function()\n    local from = i * batchSize + 1\n    i = i + 1\n    if (from <= n) then\n      local to = math.min(from + batchSize - 1, n)\n      return from, to\n    end\n  end\nend\nlocal function getZSetItems(keyName, max)\n    return rcall('ZRANGE', keyName, 0, max - 1)\nend\nlocal jobs = getZSetItems(KEYS[2], maxCount)\nif (#jobs > 0) then\n    for i, key in ipairs(jobs) do\n        local jobKey = baseKey .. key\n        rcall(\"HDEL\", jobKey, \"finishedOn\", \"processedOn\", \"failedReason\")\n    end\n    local target\n    if rcall(\"EXISTS\", KEYS[4]) ~= 1 then\n        target = KEYS[3]\n    else\n        target = KEYS[5]\n    end\n    for from, to in batches(#jobs, 7000) do\n        rcall(\"ZREM\", KEYS[2], unpack(jobs, from, to))\n        rcall(\"LPUSH\", target, unpack(jobs, from, to))\n    end\nend\nmaxCount = maxCount - #jobs\nif (maxCount <= 0) then return 1 end\nreturn 0\n`;\nmodule.exports = {\n  name: 'retryJobs',\n  content,\n  keys: 5,\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvYnVsbC9saWIvc2NyaXB0cy9yZXRyeUpvYnMtNS5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9teS1hcHAvLi9ub2RlX21vZHVsZXMvYnVsbC9saWIvc2NyaXB0cy9yZXRyeUpvYnMtNS5qcz8wMWQ3Il0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcbmNvbnN0IGNvbnRlbnQgPSBgLS1bW1xuICBBdHRlbXB0cyB0byByZXRyeSBhbGwgZmFpbGVkIGpvYnNcbiAgSW5wdXQ6XG4gICAgS0VZU1sxXSBiYXNlIGtleVxuICAgIEtFWVNbMl0gZmFpbGVkIHN0YXRlIGtleVxuICAgIEtFWVNbM10gd2FpdCBzdGF0ZSBrZXlcbiAgICBLRVlTWzRdICdtZXRhLXBhdXNlZCdcbiAgICBLRVlTWzVdICdwYXVzZWQnXG4gICAgQVJHVlsxXSAgY291bnRcbiAgT3V0cHV0OlxuICAgIDEgIG1lYW5zIHRoZSBvcGVyYXRpb24gaXMgbm90IGNvbXBsZXRlZFxuICAgIDAgIG1lYW5zIHRoZSBvcGVyYXRpb24gaXMgY29tcGxldGVkXG5dXVxubG9jYWwgYmFzZUtleSA9IEtFWVNbMV1cbmxvY2FsIG1heENvdW50ID0gdG9udW1iZXIoQVJHVlsxXSlcbmxvY2FsIHJjYWxsID0gcmVkaXMuY2FsbDtcbi0tIEluY2x1ZGVzXG4tLVtbXG4gIEZ1bmN0aW9uIHRvIGxvb3AgaW4gYmF0Y2hlcy5cbiAgSnVzdCBhIGJpdCBvZiB3YXJuaW5nLCBzb21lIGNvbW1hbmRzIGFzIFpSRU1cbiAgY291bGQgcmVjZWl2ZSBhIG1heGltdW0gb2YgNzAwMCBwYXJhbWV0ZXJzIHBlciBjYWxsLlxuXV1cbmxvY2FsIGZ1bmN0aW9uIGJhdGNoZXMobiwgYmF0Y2hTaXplKVxuICBsb2NhbCBpID0gMFxuICByZXR1cm4gZnVuY3Rpb24oKVxuICAgIGxvY2FsIGZyb20gPSBpICogYmF0Y2hTaXplICsgMVxuICAgIGkgPSBpICsgMVxuICAgIGlmIChmcm9tIDw9IG4pIHRoZW5cbiAgICAgIGxvY2FsIHRvID0gbWF0aC5taW4oZnJvbSArIGJhdGNoU2l6ZSAtIDEsIG4pXG4gICAgICByZXR1cm4gZnJvbSwgdG9cbiAgICBlbmRcbiAgZW5kXG5lbmRcbmxvY2FsIGZ1bmN0aW9uIGdldFpTZXRJdGVtcyhrZXlOYW1lLCBtYXgpXG4gICAgcmV0dXJuIHJjYWxsKCdaUkFOR0UnLCBrZXlOYW1lLCAwLCBtYXggLSAxKVxuZW5kXG5sb2NhbCBqb2JzID0gZ2V0WlNldEl0ZW1zKEtFWVNbMl0sIG1heENvdW50KVxuaWYgKCNqb2JzID4gMCkgdGhlblxuICAgIGZvciBpLCBrZXkgaW4gaXBhaXJzKGpvYnMpIGRvXG4gICAgICAgIGxvY2FsIGpvYktleSA9IGJhc2VLZXkgLi4ga2V5XG4gICAgICAgIHJjYWxsKFwiSERFTFwiLCBqb2JLZXksIFwiZmluaXNoZWRPblwiLCBcInByb2Nlc3NlZE9uXCIsIFwiZmFpbGVkUmVhc29uXCIpXG4gICAgZW5kXG4gICAgbG9jYWwgdGFyZ2V0XG4gICAgaWYgcmNhbGwoXCJFWElTVFNcIiwgS0VZU1s0XSkgfj0gMSB0aGVuXG4gICAgICAgIHRhcmdldCA9IEtFWVNbM11cbiAgICBlbHNlXG4gICAgICAgIHRhcmdldCA9IEtFWVNbNV1cbiAgICBlbmRcbiAgICBmb3IgZnJvbSwgdG8gaW4gYmF0Y2hlcygjam9icywgNzAwMCkgZG9cbiAgICAgICAgcmNhbGwoXCJaUkVNXCIsIEtFWVNbMl0sIHVucGFjayhqb2JzLCBmcm9tLCB0bykpXG4gICAgICAgIHJjYWxsKFwiTFBVU0hcIiwgdGFyZ2V0LCB1bnBhY2soam9icywgZnJvbSwgdG8pKVxuICAgIGVuZFxuZW5kXG5tYXhDb3VudCA9IG1heENvdW50IC0gI2pvYnNcbmlmIChtYXhDb3VudCA8PSAwKSB0aGVuIHJldHVybiAxIGVuZFxucmV0dXJuIDBcbmA7XG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgbmFtZTogJ3JldHJ5Sm9icycsXG4gIGNvbnRlbnQsXG4gIGtleXM6IDUsXG59O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/bull/lib/scripts/retryJobs-5.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/bull/lib/scripts/saveStacktrace-1.js":
/*!***********************************************************!*\
  !*** ./node_modules/bull/lib/scripts/saveStacktrace-1.js ***!
  \***********************************************************/
/***/ ((module) => {

eval("\nconst content = `--[[\n  Save stacktrace and failedReason.\n  Input:\n    KEYS[1] job key\n    ARGV[1]  stacktrace\n    ARGV[2]  failedReason\n    ARGV[3]  attemptsMade\n  Output:\n     0 - OK\n    -1 - Missing key\n]]\nlocal rcall = redis.call\nif rcall(\"EXISTS\", KEYS[1]) == 1 then\n  rcall(\"HMSET\", KEYS[1], \"stacktrace\", ARGV[1], \"failedReason\", ARGV[2],\n    \"attemptsMade\", ARGV[3])\n  return 0\nelse\n  return -1\nend\n`;\nmodule.exports = {\n  name: 'saveStacktrace',\n  content,\n  keys: 1,\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvYnVsbC9saWIvc2NyaXB0cy9zYXZlU3RhY2t0cmFjZS0xLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9teS1hcHAvLi9ub2RlX21vZHVsZXMvYnVsbC9saWIvc2NyaXB0cy9zYXZlU3RhY2t0cmFjZS0xLmpzPzdhOWIiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuY29uc3QgY29udGVudCA9IGAtLVtbXG4gIFNhdmUgc3RhY2t0cmFjZSBhbmQgZmFpbGVkUmVhc29uLlxuICBJbnB1dDpcbiAgICBLRVlTWzFdIGpvYiBrZXlcbiAgICBBUkdWWzFdICBzdGFja3RyYWNlXG4gICAgQVJHVlsyXSAgZmFpbGVkUmVhc29uXG4gICAgQVJHVlszXSAgYXR0ZW1wdHNNYWRlXG4gIE91dHB1dDpcbiAgICAgMCAtIE9LXG4gICAgLTEgLSBNaXNzaW5nIGtleVxuXV1cbmxvY2FsIHJjYWxsID0gcmVkaXMuY2FsbFxuaWYgcmNhbGwoXCJFWElTVFNcIiwgS0VZU1sxXSkgPT0gMSB0aGVuXG4gIHJjYWxsKFwiSE1TRVRcIiwgS0VZU1sxXSwgXCJzdGFja3RyYWNlXCIsIEFSR1ZbMV0sIFwiZmFpbGVkUmVhc29uXCIsIEFSR1ZbMl0sXG4gICAgXCJhdHRlbXB0c01hZGVcIiwgQVJHVlszXSlcbiAgcmV0dXJuIDBcbmVsc2VcbiAgcmV0dXJuIC0xXG5lbmRcbmA7XG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgbmFtZTogJ3NhdmVTdGFja3RyYWNlJyxcbiAgY29udGVudCxcbiAga2V5czogMSxcbn07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/bull/lib/scripts/saveStacktrace-1.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/bull/lib/scripts/takeLock-1.js":
/*!*****************************************************!*\
  !*** ./node_modules/bull/lib/scripts/takeLock-1.js ***!
  \*****************************************************/
/***/ ((module) => {

eval("\nconst content = `--[[\n  Takes a lock\n     Input:\n        KEYS[1] 'lock',\n        ARGV[1]  token\n        ARGV[2]  lock duration in milliseconds\n      Output:\n        \"OK\" if lock taken successfully.\n]]\nif redis.call(\"SET\", KEYS[1], ARGV[1], \"NX\", \"PX\", ARGV[2]) then\n  return 1\nelse\n  return 0\nend\n`;\nmodule.exports = {\n  name: 'takeLock',\n  content,\n  keys: 1,\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvYnVsbC9saWIvc2NyaXB0cy90YWtlTG9jay0xLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL215LWFwcC8uL25vZGVfbW9kdWxlcy9idWxsL2xpYi9zY3JpcHRzL3Rha2VMb2NrLTEuanM/ODgwMiJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5jb25zdCBjb250ZW50ID0gYC0tW1tcbiAgVGFrZXMgYSBsb2NrXG4gICAgIElucHV0OlxuICAgICAgICBLRVlTWzFdICdsb2NrJyxcbiAgICAgICAgQVJHVlsxXSAgdG9rZW5cbiAgICAgICAgQVJHVlsyXSAgbG9jayBkdXJhdGlvbiBpbiBtaWxsaXNlY29uZHNcbiAgICAgIE91dHB1dDpcbiAgICAgICAgXCJPS1wiIGlmIGxvY2sgdGFrZW4gc3VjY2Vzc2Z1bGx5LlxuXV1cbmlmIHJlZGlzLmNhbGwoXCJTRVRcIiwgS0VZU1sxXSwgQVJHVlsxXSwgXCJOWFwiLCBcIlBYXCIsIEFSR1ZbMl0pIHRoZW5cbiAgcmV0dXJuIDFcbmVsc2VcbiAgcmV0dXJuIDBcbmVuZFxuYDtcbm1vZHVsZS5leHBvcnRzID0ge1xuICBuYW1lOiAndGFrZUxvY2snLFxuICBjb250ZW50LFxuICBrZXlzOiAxLFxufTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/bull/lib/scripts/takeLock-1.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/bull/lib/scripts/updateData-1.js":
/*!*******************************************************!*\
  !*** ./node_modules/bull/lib/scripts/updateData-1.js ***!
  \*******************************************************/
/***/ ((module) => {

eval("\nconst content = `--[[\n  Update job data\n  Input:\n    KEYS[1] Job id key\n    ARGV[1] data\n  Output:\n    0 - OK\n   -1 - Missing job.\n]]\nlocal rcall = redis.call\nif rcall(\"EXISTS\",KEYS[1]) == 1 then -- // Make sure job exists\n  rcall(\"HSET\", KEYS[1], \"data\", ARGV[1])\n  return 0\nelse\n  return -1\nend\n`;\nmodule.exports = {\n  name: 'updateData',\n  content,\n  keys: 1,\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvYnVsbC9saWIvc2NyaXB0cy91cGRhdGVEYXRhLTEuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL215LWFwcC8uL25vZGVfbW9kdWxlcy9idWxsL2xpYi9zY3JpcHRzL3VwZGF0ZURhdGEtMS5qcz9iZDhhIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcbmNvbnN0IGNvbnRlbnQgPSBgLS1bW1xuICBVcGRhdGUgam9iIGRhdGFcbiAgSW5wdXQ6XG4gICAgS0VZU1sxXSBKb2IgaWQga2V5XG4gICAgQVJHVlsxXSBkYXRhXG4gIE91dHB1dDpcbiAgICAwIC0gT0tcbiAgIC0xIC0gTWlzc2luZyBqb2IuXG5dXVxubG9jYWwgcmNhbGwgPSByZWRpcy5jYWxsXG5pZiByY2FsbChcIkVYSVNUU1wiLEtFWVNbMV0pID09IDEgdGhlbiAtLSAvLyBNYWtlIHN1cmUgam9iIGV4aXN0c1xuICByY2FsbChcIkhTRVRcIiwgS0VZU1sxXSwgXCJkYXRhXCIsIEFSR1ZbMV0pXG4gIHJldHVybiAwXG5lbHNlXG4gIHJldHVybiAtMVxuZW5kXG5gO1xubW9kdWxlLmV4cG9ydHMgPSB7XG4gIG5hbWU6ICd1cGRhdGVEYXRhJyxcbiAgY29udGVudCxcbiAga2V5czogMSxcbn07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/bull/lib/scripts/updateData-1.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/bull/lib/scripts/updateDelaySet-6.js":
/*!***********************************************************!*\
  !*** ./node_modules/bull/lib/scripts/updateDelaySet-6.js ***!
  \***********************************************************/
/***/ ((module) => {

eval("\nconst content = `--[[\n  Updates the delay set, by picking a delayed job that should\n  be processed now.\n     Input:\n      KEYS[1] 'delayed'\n      KEYS[2] 'active'\n      KEYS[3] 'wait'\n      KEYS[4] 'priority'\n      KEYS[5] 'paused'\n      KEYS[6] 'meta-paused'\n      ARGV[1]  queue.toKey('')\n      ARGV[2]  delayed timestamp\n      ARGV[3]  queue token\n     Events:\n      'removed'\n]]\nlocal rcall = redis.call;\n-- Includes\n--[[\n  Function to add job considering priority.\n]]\nlocal function addJobWithPriority(priorityKey, priority, jobId, targetKey)\n  rcall(\"ZADD\", priorityKey, priority, jobId)\n  local count = rcall(\"ZCOUNT\", priorityKey, 0, priority)\n  local len = rcall(\"LLEN\", targetKey)\n  local id = rcall(\"LINDEX\", targetKey, len - (count - 1))\n  if id then\n    rcall(\"LINSERT\", targetKey, \"BEFORE\", id, jobId)\n  else\n    rcall(\"RPUSH\", targetKey, jobId)\n  end\nend\n--[[\n  Function to check for the meta.paused key to decide if we are paused or not\n  (since an empty list and !EXISTS are not really the same).\n]]\nlocal function getTargetQueueList(queueMetaKey, waitKey, pausedKey)\n  if rcall(\"EXISTS\", queueMetaKey) ~= 1 then\n    return waitKey, false\n  else\n    return pausedKey, true\n  end\nend\n-- Try to get as much as 1000 jobs at once\nlocal jobs = rcall(\"ZRANGEBYSCORE\", KEYS[1], 0, tonumber(ARGV[2]) * 0x1000, \"LIMIT\", 0, 1000)\nif(#jobs > 0) then\n  rcall(\"ZREM\", KEYS[1], unpack(jobs))\n  -- check if we need to use push in paused instead of waiting\n  local target = getTargetQueueList(KEYS[6], KEYS[3], KEYS[5])\n  for _, jobId in ipairs(jobs) do\n    -- Is this really needed?\n    rcall(\"LREM\", KEYS[2], 0, jobId)\n    local priority = tonumber(rcall(\"HGET\", ARGV[1] .. jobId, \"priority\")) or 0\n    if priority == 0 then\n      -- LIFO or FIFO\n      rcall(\"LPUSH\", target, jobId)\n    else\n      addJobWithPriority(KEYS[4], priority, jobId, target)\n    end\n    -- Emit waiting event (wait..ing@token)\n    rcall(\"PUBLISH\", KEYS[3] .. \"ing@\" .. ARGV[3], jobId)\n    rcall(\"HSET\", ARGV[1] .. jobId, \"delay\", 0)\n  end\nend\nlocal nextTimestamp = rcall(\"ZRANGE\", KEYS[1], 0, 0, \"WITHSCORES\")[2]\nif(nextTimestamp ~= nil) then\n  rcall(\"PUBLISH\", KEYS[1], nextTimestamp / 0x1000)\nend\nreturn nextTimestamp\n`;\nmodule.exports = {\n  name: 'updateDelaySet',\n  content,\n  keys: 6,\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvYnVsbC9saWIvc2NyaXB0cy91cGRhdGVEZWxheVNldC02LmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbXktYXBwLy4vbm9kZV9tb2R1bGVzL2J1bGwvbGliL3NjcmlwdHMvdXBkYXRlRGVsYXlTZXQtNi5qcz8zNjZlIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcbmNvbnN0IGNvbnRlbnQgPSBgLS1bW1xuICBVcGRhdGVzIHRoZSBkZWxheSBzZXQsIGJ5IHBpY2tpbmcgYSBkZWxheWVkIGpvYiB0aGF0IHNob3VsZFxuICBiZSBwcm9jZXNzZWQgbm93LlxuICAgICBJbnB1dDpcbiAgICAgIEtFWVNbMV0gJ2RlbGF5ZWQnXG4gICAgICBLRVlTWzJdICdhY3RpdmUnXG4gICAgICBLRVlTWzNdICd3YWl0J1xuICAgICAgS0VZU1s0XSAncHJpb3JpdHknXG4gICAgICBLRVlTWzVdICdwYXVzZWQnXG4gICAgICBLRVlTWzZdICdtZXRhLXBhdXNlZCdcbiAgICAgIEFSR1ZbMV0gIHF1ZXVlLnRvS2V5KCcnKVxuICAgICAgQVJHVlsyXSAgZGVsYXllZCB0aW1lc3RhbXBcbiAgICAgIEFSR1ZbM10gIHF1ZXVlIHRva2VuXG4gICAgIEV2ZW50czpcbiAgICAgICdyZW1vdmVkJ1xuXV1cbmxvY2FsIHJjYWxsID0gcmVkaXMuY2FsbDtcbi0tIEluY2x1ZGVzXG4tLVtbXG4gIEZ1bmN0aW9uIHRvIGFkZCBqb2IgY29uc2lkZXJpbmcgcHJpb3JpdHkuXG5dXVxubG9jYWwgZnVuY3Rpb24gYWRkSm9iV2l0aFByaW9yaXR5KHByaW9yaXR5S2V5LCBwcmlvcml0eSwgam9iSWQsIHRhcmdldEtleSlcbiAgcmNhbGwoXCJaQUREXCIsIHByaW9yaXR5S2V5LCBwcmlvcml0eSwgam9iSWQpXG4gIGxvY2FsIGNvdW50ID0gcmNhbGwoXCJaQ09VTlRcIiwgcHJpb3JpdHlLZXksIDAsIHByaW9yaXR5KVxuICBsb2NhbCBsZW4gPSByY2FsbChcIkxMRU5cIiwgdGFyZ2V0S2V5KVxuICBsb2NhbCBpZCA9IHJjYWxsKFwiTElOREVYXCIsIHRhcmdldEtleSwgbGVuIC0gKGNvdW50IC0gMSkpXG4gIGlmIGlkIHRoZW5cbiAgICByY2FsbChcIkxJTlNFUlRcIiwgdGFyZ2V0S2V5LCBcIkJFRk9SRVwiLCBpZCwgam9iSWQpXG4gIGVsc2VcbiAgICByY2FsbChcIlJQVVNIXCIsIHRhcmdldEtleSwgam9iSWQpXG4gIGVuZFxuZW5kXG4tLVtbXG4gIEZ1bmN0aW9uIHRvIGNoZWNrIGZvciB0aGUgbWV0YS5wYXVzZWQga2V5IHRvIGRlY2lkZSBpZiB3ZSBhcmUgcGF1c2VkIG9yIG5vdFxuICAoc2luY2UgYW4gZW1wdHkgbGlzdCBhbmQgIUVYSVNUUyBhcmUgbm90IHJlYWxseSB0aGUgc2FtZSkuXG5dXVxubG9jYWwgZnVuY3Rpb24gZ2V0VGFyZ2V0UXVldWVMaXN0KHF1ZXVlTWV0YUtleSwgd2FpdEtleSwgcGF1c2VkS2V5KVxuICBpZiByY2FsbChcIkVYSVNUU1wiLCBxdWV1ZU1ldGFLZXkpIH49IDEgdGhlblxuICAgIHJldHVybiB3YWl0S2V5LCBmYWxzZVxuICBlbHNlXG4gICAgcmV0dXJuIHBhdXNlZEtleSwgdHJ1ZVxuICBlbmRcbmVuZFxuLS0gVHJ5IHRvIGdldCBhcyBtdWNoIGFzIDEwMDAgam9icyBhdCBvbmNlXG5sb2NhbCBqb2JzID0gcmNhbGwoXCJaUkFOR0VCWVNDT1JFXCIsIEtFWVNbMV0sIDAsIHRvbnVtYmVyKEFSR1ZbMl0pICogMHgxMDAwLCBcIkxJTUlUXCIsIDAsIDEwMDApXG5pZigjam9icyA+IDApIHRoZW5cbiAgcmNhbGwoXCJaUkVNXCIsIEtFWVNbMV0sIHVucGFjayhqb2JzKSlcbiAgLS0gY2hlY2sgaWYgd2UgbmVlZCB0byB1c2UgcHVzaCBpbiBwYXVzZWQgaW5zdGVhZCBvZiB3YWl0aW5nXG4gIGxvY2FsIHRhcmdldCA9IGdldFRhcmdldFF1ZXVlTGlzdChLRVlTWzZdLCBLRVlTWzNdLCBLRVlTWzVdKVxuICBmb3IgXywgam9iSWQgaW4gaXBhaXJzKGpvYnMpIGRvXG4gICAgLS0gSXMgdGhpcyByZWFsbHkgbmVlZGVkP1xuICAgIHJjYWxsKFwiTFJFTVwiLCBLRVlTWzJdLCAwLCBqb2JJZClcbiAgICBsb2NhbCBwcmlvcml0eSA9IHRvbnVtYmVyKHJjYWxsKFwiSEdFVFwiLCBBUkdWWzFdIC4uIGpvYklkLCBcInByaW9yaXR5XCIpKSBvciAwXG4gICAgaWYgcHJpb3JpdHkgPT0gMCB0aGVuXG4gICAgICAtLSBMSUZPIG9yIEZJRk9cbiAgICAgIHJjYWxsKFwiTFBVU0hcIiwgdGFyZ2V0LCBqb2JJZClcbiAgICBlbHNlXG4gICAgICBhZGRKb2JXaXRoUHJpb3JpdHkoS0VZU1s0XSwgcHJpb3JpdHksIGpvYklkLCB0YXJnZXQpXG4gICAgZW5kXG4gICAgLS0gRW1pdCB3YWl0aW5nIGV2ZW50ICh3YWl0Li5pbmdAdG9rZW4pXG4gICAgcmNhbGwoXCJQVUJMSVNIXCIsIEtFWVNbM10gLi4gXCJpbmdAXCIgLi4gQVJHVlszXSwgam9iSWQpXG4gICAgcmNhbGwoXCJIU0VUXCIsIEFSR1ZbMV0gLi4gam9iSWQsIFwiZGVsYXlcIiwgMClcbiAgZW5kXG5lbmRcbmxvY2FsIG5leHRUaW1lc3RhbXAgPSByY2FsbChcIlpSQU5HRVwiLCBLRVlTWzFdLCAwLCAwLCBcIldJVEhTQ09SRVNcIilbMl1cbmlmKG5leHRUaW1lc3RhbXAgfj0gbmlsKSB0aGVuXG4gIHJjYWxsKFwiUFVCTElTSFwiLCBLRVlTWzFdLCBuZXh0VGltZXN0YW1wIC8gMHgxMDAwKVxuZW5kXG5yZXR1cm4gbmV4dFRpbWVzdGFtcFxuYDtcbm1vZHVsZS5leHBvcnRzID0ge1xuICBuYW1lOiAndXBkYXRlRGVsYXlTZXQnLFxuICBjb250ZW50LFxuICBrZXlzOiA2LFxufTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/bull/lib/scripts/updateDelaySet-6.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/bull/lib/scripts/updateProgress-2.js":
/*!***********************************************************!*\
  !*** ./node_modules/bull/lib/scripts/updateProgress-2.js ***!
  \***********************************************************/
/***/ ((module) => {

eval("\nconst content = `--[[\n  Update job progress\n     Input:\n        KEYS[1] Job id key\n        KEYS[2] progress event key\n        ARGV[1] progress\n        ARGV[2] event data\n      Event:\n        progress(jobId, progress)\n]]\nlocal rcall = redis.call\nif rcall(\"EXISTS\", KEYS[1]) == 1 then -- // Make sure job exists\n  rcall(\"HSET\", KEYS[1], \"progress\", ARGV[1])\n  rcall(\"PUBLISH\", KEYS[2], ARGV[2])\n  return 0\nelse\n  return -1\nend\n`;\nmodule.exports = {\n  name: 'updateProgress',\n  content,\n  keys: 2,\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvYnVsbC9saWIvc2NyaXB0cy91cGRhdGVQcm9ncmVzcy0yLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbXktYXBwLy4vbm9kZV9tb2R1bGVzL2J1bGwvbGliL3NjcmlwdHMvdXBkYXRlUHJvZ3Jlc3MtMi5qcz84M2QxIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcbmNvbnN0IGNvbnRlbnQgPSBgLS1bW1xuICBVcGRhdGUgam9iIHByb2dyZXNzXG4gICAgIElucHV0OlxuICAgICAgICBLRVlTWzFdIEpvYiBpZCBrZXlcbiAgICAgICAgS0VZU1syXSBwcm9ncmVzcyBldmVudCBrZXlcbiAgICAgICAgQVJHVlsxXSBwcm9ncmVzc1xuICAgICAgICBBUkdWWzJdIGV2ZW50IGRhdGFcbiAgICAgIEV2ZW50OlxuICAgICAgICBwcm9ncmVzcyhqb2JJZCwgcHJvZ3Jlc3MpXG5dXVxubG9jYWwgcmNhbGwgPSByZWRpcy5jYWxsXG5pZiByY2FsbChcIkVYSVNUU1wiLCBLRVlTWzFdKSA9PSAxIHRoZW4gLS0gLy8gTWFrZSBzdXJlIGpvYiBleGlzdHNcbiAgcmNhbGwoXCJIU0VUXCIsIEtFWVNbMV0sIFwicHJvZ3Jlc3NcIiwgQVJHVlsxXSlcbiAgcmNhbGwoXCJQVUJMSVNIXCIsIEtFWVNbMl0sIEFSR1ZbMl0pXG4gIHJldHVybiAwXG5lbHNlXG4gIHJldHVybiAtMVxuZW5kXG5gO1xubW9kdWxlLmV4cG9ydHMgPSB7XG4gIG5hbWU6ICd1cGRhdGVQcm9ncmVzcycsXG4gIGNvbnRlbnQsXG4gIGtleXM6IDIsXG59O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/bull/lib/scripts/updateProgress-2.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/bull/lib/timer-manager.js":
/*!************************************************!*\
  !*** ./node_modules/bull/lib/timer-manager.js ***!
  \************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\n\nconst _ = __webpack_require__(/*! lodash */ \"(rsc)/./node_modules/lodash/lodash.js\");\nconst uuid = __webpack_require__(/*! uuid */ \"(rsc)/./node_modules/bull/node_modules/uuid/dist/esm-node/index.js\");\n\n/**\n  Timer Manager\n\n  Keep track of timers to ensure that disconnect() is\n  only called (via close()) at a time when it's safe\n  to do so.\n\n  Queues currently use two timers:\n\n    - The first one is used for delayed jobs and is\n    preemptible i.e. it is possible to close a queue\n    while delayed jobs are still pending (they will\n    be processed when the queue is resumed). This timer\n    is cleared by close() and is not managed here.\n\n    - The second one is used to lock Redis while\n    processing jobs. These timers are short-lived,\n    and there can be more than one active at a\n    time.\n\n  The lock timer executes Redis commands, which\n  means we can't close queues while it's active i.e.\n  this won't work:\n\n    queue.process(function (job, jobDone) {\n      handle(job);\n      queue.disconnect().then(jobDone);\n    })\n\n  The disconnect() call closes the Redis connections; then, when\n  a queue tries to perform the scheduled Redis commands,\n  they block until a Redis connection becomes available...\n\n  The solution is to close the Redis connections when there are no\n  active timers i.e. when the queue is idle. This helper class keeps\n  track of the active timers and executes any queued listeners\n  whenever that count goes to zero.\n\n  Since disconnect() simply can't work if there are active handles,\n  its close() wrapper postpones closing the Redis connections\n  until the next idle state. This means that close() can safely\n  be called from anywhere at any time, even from within a job\n  handler:\n\n    queue.process(function (job, jobDone) {\n      handle(job);\n      queue.close();\n      jobDone();\n    })\n*/\n\nfunction TimerManager() {\n  this.idle = true;\n  this.listeners = [];\n  this.timers = {};\n}\n\n/**\n  Create a new timer (setTimeout).\n\n  Expired timers are automatically cleared\n\n  @param {String} name - Name of a timer key. Used only for debugging.\n  @param {Number} delay - delay of timeout\n  @param {Function} fn - Function to execute after delay\n  @returns {Number} id - The timer id. Used to clear the timer\n*/\nTimerManager.prototype.set = function(name, delay, fn) {\n  const id = uuid.v4();\n  const timer = setTimeout(\n    (timerInstance, timeoutId) => {\n      timerInstance.clear(timeoutId);\n      try {\n        fn();\n      } catch (err) {\n        console.error(err);\n      }\n    },\n    delay,\n    this,\n    id\n  );\n\n  // XXX only the timer is used, but the\n  // other fields are useful for\n  // troubleshooting/debugging\n  this.timers[id] = {\n    name,\n    timer\n  };\n\n  this.idle = false;\n  return id;\n};\n\n/**\n  Clear a timer (clearTimeout).\n\n  Queued listeners are executed if there are no\n  remaining timers\n*/\nTimerManager.prototype.clear = function(id) {\n  const timers = this.timers;\n  const timer = timers[id];\n  if (!timer) {\n    return;\n  }\n  clearTimeout(timer.timer);\n  delete timers[id];\n  if (!this.idle && _.size(timers) === 0) {\n    while (this.listeners.length) {\n      this.listeners.pop()();\n    }\n    this.idle = true;\n  }\n};\n\nTimerManager.prototype.clearAll = function() {\n  _.each(this.timers, (timer, id) => {\n    this.clear(id);\n  });\n};\n\n/**\n * Returns a promise that resolves when there are no active timers.\n */\nTimerManager.prototype.whenIdle = function() {\n  return new Promise(resolve => {\n    if (this.idle) {\n      resolve();\n    } else {\n      this.listeners.unshift(resolve);\n    }\n  });\n};\n\nmodule.exports = TimerManager;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvYnVsbC9saWIvdGltZXItbWFuYWdlci5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYixVQUFVLG1CQUFPLENBQUMscURBQVE7QUFDMUIsYUFBYSxtQkFBTyxDQUFDLGdGQUFNOztBQUUzQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMLHNEQUFzRDtBQUN0RDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBLFVBQVUsUUFBUTtBQUNsQixVQUFVLFFBQVE7QUFDbEIsVUFBVSxVQUFVO0FBQ3BCLFlBQVksUUFBUTtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbXktYXBwLy4vbm9kZV9tb2R1bGVzL2J1bGwvbGliL3RpbWVyLW1hbmFnZXIuanM/YjdiYiJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbmNvbnN0IF8gPSByZXF1aXJlKCdsb2Rhc2gnKTtcbmNvbnN0IHV1aWQgPSByZXF1aXJlKCd1dWlkJyk7XG5cbi8qKlxuICBUaW1lciBNYW5hZ2VyXG5cbiAgS2VlcCB0cmFjayBvZiB0aW1lcnMgdG8gZW5zdXJlIHRoYXQgZGlzY29ubmVjdCgpIGlzXG4gIG9ubHkgY2FsbGVkICh2aWEgY2xvc2UoKSkgYXQgYSB0aW1lIHdoZW4gaXQncyBzYWZlXG4gIHRvIGRvIHNvLlxuXG4gIFF1ZXVlcyBjdXJyZW50bHkgdXNlIHR3byB0aW1lcnM6XG5cbiAgICAtIFRoZSBmaXJzdCBvbmUgaXMgdXNlZCBmb3IgZGVsYXllZCBqb2JzIGFuZCBpc1xuICAgIHByZWVtcHRpYmxlIGkuZS4gaXQgaXMgcG9zc2libGUgdG8gY2xvc2UgYSBxdWV1ZVxuICAgIHdoaWxlIGRlbGF5ZWQgam9icyBhcmUgc3RpbGwgcGVuZGluZyAodGhleSB3aWxsXG4gICAgYmUgcHJvY2Vzc2VkIHdoZW4gdGhlIHF1ZXVlIGlzIHJlc3VtZWQpLiBUaGlzIHRpbWVyXG4gICAgaXMgY2xlYXJlZCBieSBjbG9zZSgpIGFuZCBpcyBub3QgbWFuYWdlZCBoZXJlLlxuXG4gICAgLSBUaGUgc2Vjb25kIG9uZSBpcyB1c2VkIHRvIGxvY2sgUmVkaXMgd2hpbGVcbiAgICBwcm9jZXNzaW5nIGpvYnMuIFRoZXNlIHRpbWVycyBhcmUgc2hvcnQtbGl2ZWQsXG4gICAgYW5kIHRoZXJlIGNhbiBiZSBtb3JlIHRoYW4gb25lIGFjdGl2ZSBhdCBhXG4gICAgdGltZS5cblxuICBUaGUgbG9jayB0aW1lciBleGVjdXRlcyBSZWRpcyBjb21tYW5kcywgd2hpY2hcbiAgbWVhbnMgd2UgY2FuJ3QgY2xvc2UgcXVldWVzIHdoaWxlIGl0J3MgYWN0aXZlIGkuZS5cbiAgdGhpcyB3b24ndCB3b3JrOlxuXG4gICAgcXVldWUucHJvY2VzcyhmdW5jdGlvbiAoam9iLCBqb2JEb25lKSB7XG4gICAgICBoYW5kbGUoam9iKTtcbiAgICAgIHF1ZXVlLmRpc2Nvbm5lY3QoKS50aGVuKGpvYkRvbmUpO1xuICAgIH0pXG5cbiAgVGhlIGRpc2Nvbm5lY3QoKSBjYWxsIGNsb3NlcyB0aGUgUmVkaXMgY29ubmVjdGlvbnM7IHRoZW4sIHdoZW5cbiAgYSBxdWV1ZSB0cmllcyB0byBwZXJmb3JtIHRoZSBzY2hlZHVsZWQgUmVkaXMgY29tbWFuZHMsXG4gIHRoZXkgYmxvY2sgdW50aWwgYSBSZWRpcyBjb25uZWN0aW9uIGJlY29tZXMgYXZhaWxhYmxlLi4uXG5cbiAgVGhlIHNvbHV0aW9uIGlzIHRvIGNsb3NlIHRoZSBSZWRpcyBjb25uZWN0aW9ucyB3aGVuIHRoZXJlIGFyZSBub1xuICBhY3RpdmUgdGltZXJzIGkuZS4gd2hlbiB0aGUgcXVldWUgaXMgaWRsZS4gVGhpcyBoZWxwZXIgY2xhc3Mga2VlcHNcbiAgdHJhY2sgb2YgdGhlIGFjdGl2ZSB0aW1lcnMgYW5kIGV4ZWN1dGVzIGFueSBxdWV1ZWQgbGlzdGVuZXJzXG4gIHdoZW5ldmVyIHRoYXQgY291bnQgZ29lcyB0byB6ZXJvLlxuXG4gIFNpbmNlIGRpc2Nvbm5lY3QoKSBzaW1wbHkgY2FuJ3Qgd29yayBpZiB0aGVyZSBhcmUgYWN0aXZlIGhhbmRsZXMsXG4gIGl0cyBjbG9zZSgpIHdyYXBwZXIgcG9zdHBvbmVzIGNsb3NpbmcgdGhlIFJlZGlzIGNvbm5lY3Rpb25zXG4gIHVudGlsIHRoZSBuZXh0IGlkbGUgc3RhdGUuIFRoaXMgbWVhbnMgdGhhdCBjbG9zZSgpIGNhbiBzYWZlbHlcbiAgYmUgY2FsbGVkIGZyb20gYW55d2hlcmUgYXQgYW55IHRpbWUsIGV2ZW4gZnJvbSB3aXRoaW4gYSBqb2JcbiAgaGFuZGxlcjpcblxuICAgIHF1ZXVlLnByb2Nlc3MoZnVuY3Rpb24gKGpvYiwgam9iRG9uZSkge1xuICAgICAgaGFuZGxlKGpvYik7XG4gICAgICBxdWV1ZS5jbG9zZSgpO1xuICAgICAgam9iRG9uZSgpO1xuICAgIH0pXG4qL1xuXG5mdW5jdGlvbiBUaW1lck1hbmFnZXIoKSB7XG4gIHRoaXMuaWRsZSA9IHRydWU7XG4gIHRoaXMubGlzdGVuZXJzID0gW107XG4gIHRoaXMudGltZXJzID0ge307XG59XG5cbi8qKlxuICBDcmVhdGUgYSBuZXcgdGltZXIgKHNldFRpbWVvdXQpLlxuXG4gIEV4cGlyZWQgdGltZXJzIGFyZSBhdXRvbWF0aWNhbGx5IGNsZWFyZWRcblxuICBAcGFyYW0ge1N0cmluZ30gbmFtZSAtIE5hbWUgb2YgYSB0aW1lciBrZXkuIFVzZWQgb25seSBmb3IgZGVidWdnaW5nLlxuICBAcGFyYW0ge051bWJlcn0gZGVsYXkgLSBkZWxheSBvZiB0aW1lb3V0XG4gIEBwYXJhbSB7RnVuY3Rpb259IGZuIC0gRnVuY3Rpb24gdG8gZXhlY3V0ZSBhZnRlciBkZWxheVxuICBAcmV0dXJucyB7TnVtYmVyfSBpZCAtIFRoZSB0aW1lciBpZC4gVXNlZCB0byBjbGVhciB0aGUgdGltZXJcbiovXG5UaW1lck1hbmFnZXIucHJvdG90eXBlLnNldCA9IGZ1bmN0aW9uKG5hbWUsIGRlbGF5LCBmbikge1xuICBjb25zdCBpZCA9IHV1aWQudjQoKTtcbiAgY29uc3QgdGltZXIgPSBzZXRUaW1lb3V0KFxuICAgICh0aW1lckluc3RhbmNlLCB0aW1lb3V0SWQpID0+IHtcbiAgICAgIHRpbWVySW5zdGFuY2UuY2xlYXIodGltZW91dElkKTtcbiAgICAgIHRyeSB7XG4gICAgICAgIGZuKCk7XG4gICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcihlcnIpO1xuICAgICAgfVxuICAgIH0sXG4gICAgZGVsYXksXG4gICAgdGhpcyxcbiAgICBpZFxuICApO1xuXG4gIC8vIFhYWCBvbmx5IHRoZSB0aW1lciBpcyB1c2VkLCBidXQgdGhlXG4gIC8vIG90aGVyIGZpZWxkcyBhcmUgdXNlZnVsIGZvclxuICAvLyB0cm91Ymxlc2hvb3RpbmcvZGVidWdnaW5nXG4gIHRoaXMudGltZXJzW2lkXSA9IHtcbiAgICBuYW1lLFxuICAgIHRpbWVyXG4gIH07XG5cbiAgdGhpcy5pZGxlID0gZmFsc2U7XG4gIHJldHVybiBpZDtcbn07XG5cbi8qKlxuICBDbGVhciBhIHRpbWVyIChjbGVhclRpbWVvdXQpLlxuXG4gIFF1ZXVlZCBsaXN0ZW5lcnMgYXJlIGV4ZWN1dGVkIGlmIHRoZXJlIGFyZSBub1xuICByZW1haW5pbmcgdGltZXJzXG4qL1xuVGltZXJNYW5hZ2VyLnByb3RvdHlwZS5jbGVhciA9IGZ1bmN0aW9uKGlkKSB7XG4gIGNvbnN0IHRpbWVycyA9IHRoaXMudGltZXJzO1xuICBjb25zdCB0aW1lciA9IHRpbWVyc1tpZF07XG4gIGlmICghdGltZXIpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgY2xlYXJUaW1lb3V0KHRpbWVyLnRpbWVyKTtcbiAgZGVsZXRlIHRpbWVyc1tpZF07XG4gIGlmICghdGhpcy5pZGxlICYmIF8uc2l6ZSh0aW1lcnMpID09PSAwKSB7XG4gICAgd2hpbGUgKHRoaXMubGlzdGVuZXJzLmxlbmd0aCkge1xuICAgICAgdGhpcy5saXN0ZW5lcnMucG9wKCkoKTtcbiAgICB9XG4gICAgdGhpcy5pZGxlID0gdHJ1ZTtcbiAgfVxufTtcblxuVGltZXJNYW5hZ2VyLnByb3RvdHlwZS5jbGVhckFsbCA9IGZ1bmN0aW9uKCkge1xuICBfLmVhY2godGhpcy50aW1lcnMsICh0aW1lciwgaWQpID0+IHtcbiAgICB0aGlzLmNsZWFyKGlkKTtcbiAgfSk7XG59O1xuXG4vKipcbiAqIFJldHVybnMgYSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgd2hlbiB0aGVyZSBhcmUgbm8gYWN0aXZlIHRpbWVycy5cbiAqL1xuVGltZXJNYW5hZ2VyLnByb3RvdHlwZS53aGVuSWRsZSA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gbmV3IFByb21pc2UocmVzb2x2ZSA9PiB7XG4gICAgaWYgKHRoaXMuaWRsZSkge1xuICAgICAgcmVzb2x2ZSgpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmxpc3RlbmVycy51bnNoaWZ0KHJlc29sdmUpO1xuICAgIH1cbiAgfSk7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFRpbWVyTWFuYWdlcjtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/bull/lib/timer-manager.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/bull/lib/utils.js":
/*!****************************************!*\
  !*** ./node_modules/bull/lib/utils.js ***!
  \****************************************/
/***/ ((module) => {

eval("\nconst errorObject = { value: null };\nfunction tryCatch(fn, ctx, args) {\n  try {\n    return fn.apply(ctx, args);\n  } catch (e) {\n    errorObject.value = e;\n    return errorObject;\n  }\n}\n\n/**\n * Waits for a redis client to be ready.\n * @param {Redis} redis client\n */\nfunction isRedisReady(client) {\n  return new Promise((resolve, reject) => {\n    if (client.status === 'ready') {\n      resolve();\n    } else {\n      function handleReady() {\n        client.removeListener('end', handleEnd);\n        client.removeListener('error', handleError);\n        resolve();\n      }\n\n      let lastError;\n      function handleError(err) {\n        lastError = err;\n      }\n\n      function handleEnd() {\n        client.removeListener('ready', handleReady);\n        client.removeListener('error', handleError);\n        reject(lastError);\n      }\n\n      client.once('ready', handleReady);\n      client.on('error', handleError);\n      client.once('end', handleEnd);\n    }\n  });\n}\n\nmodule.exports.errorObject = errorObject;\nmodule.exports.tryCatch = tryCatch;\nmodule.exports.isRedisReady = isRedisReady;\nmodule.exports.emitSafe = function(emitter, event, ...args) {\n  try {\n    return emitter.emit(event, ...args);\n  } catch (err) {\n    try {\n      return emitter.emit('error', err);\n    } catch (err) {\n      // We give up if the error event also throws an exception.\n      console.error(err);\n    }\n  }\n};\n\nmodule.exports.MetricsTime = {\n  ONE_MINUTE: 1,\n  FIVE_MINUTES: 5,\n  FIFTEEN_MINUTES: 15,\n  THIRTY_MINUTES: 30,\n  ONE_HOUR: 60,\n  ONE_WEEK: 60 * 24 * 7,\n  TWO_WEEKS: 60 * 24 * 7 * 2,\n  ONE_MONTH: 60 * 24 * 7 * 2 * 4\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvYnVsbC9saWIvdXRpbHMuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYixzQkFBc0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUEsMEJBQTBCO0FBQzFCLHVCQUF1QjtBQUN2QiwyQkFBMkI7QUFDM0IsdUJBQXVCO0FBQ3ZCO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDBCQUEwQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9teS1hcHAvLi9ub2RlX21vZHVsZXMvYnVsbC9saWIvdXRpbHMuanM/ODFjYSJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5jb25zdCBlcnJvck9iamVjdCA9IHsgdmFsdWU6IG51bGwgfTtcbmZ1bmN0aW9uIHRyeUNhdGNoKGZuLCBjdHgsIGFyZ3MpIHtcbiAgdHJ5IHtcbiAgICByZXR1cm4gZm4uYXBwbHkoY3R4LCBhcmdzKTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIGVycm9yT2JqZWN0LnZhbHVlID0gZTtcbiAgICByZXR1cm4gZXJyb3JPYmplY3Q7XG4gIH1cbn1cblxuLyoqXG4gKiBXYWl0cyBmb3IgYSByZWRpcyBjbGllbnQgdG8gYmUgcmVhZHkuXG4gKiBAcGFyYW0ge1JlZGlzfSByZWRpcyBjbGllbnRcbiAqL1xuZnVuY3Rpb24gaXNSZWRpc1JlYWR5KGNsaWVudCkge1xuICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgIGlmIChjbGllbnQuc3RhdHVzID09PSAncmVhZHknKSB7XG4gICAgICByZXNvbHZlKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGZ1bmN0aW9uIGhhbmRsZVJlYWR5KCkge1xuICAgICAgICBjbGllbnQucmVtb3ZlTGlzdGVuZXIoJ2VuZCcsIGhhbmRsZUVuZCk7XG4gICAgICAgIGNsaWVudC5yZW1vdmVMaXN0ZW5lcignZXJyb3InLCBoYW5kbGVFcnJvcik7XG4gICAgICAgIHJlc29sdmUoKTtcbiAgICAgIH1cblxuICAgICAgbGV0IGxhc3RFcnJvcjtcbiAgICAgIGZ1bmN0aW9uIGhhbmRsZUVycm9yKGVycikge1xuICAgICAgICBsYXN0RXJyb3IgPSBlcnI7XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIGhhbmRsZUVuZCgpIHtcbiAgICAgICAgY2xpZW50LnJlbW92ZUxpc3RlbmVyKCdyZWFkeScsIGhhbmRsZVJlYWR5KTtcbiAgICAgICAgY2xpZW50LnJlbW92ZUxpc3RlbmVyKCdlcnJvcicsIGhhbmRsZUVycm9yKTtcbiAgICAgICAgcmVqZWN0KGxhc3RFcnJvcik7XG4gICAgICB9XG5cbiAgICAgIGNsaWVudC5vbmNlKCdyZWFkeScsIGhhbmRsZVJlYWR5KTtcbiAgICAgIGNsaWVudC5vbignZXJyb3InLCBoYW5kbGVFcnJvcik7XG4gICAgICBjbGllbnQub25jZSgnZW5kJywgaGFuZGxlRW5kKTtcbiAgICB9XG4gIH0pO1xufVxuXG5tb2R1bGUuZXhwb3J0cy5lcnJvck9iamVjdCA9IGVycm9yT2JqZWN0O1xubW9kdWxlLmV4cG9ydHMudHJ5Q2F0Y2ggPSB0cnlDYXRjaDtcbm1vZHVsZS5leHBvcnRzLmlzUmVkaXNSZWFkeSA9IGlzUmVkaXNSZWFkeTtcbm1vZHVsZS5leHBvcnRzLmVtaXRTYWZlID0gZnVuY3Rpb24oZW1pdHRlciwgZXZlbnQsIC4uLmFyZ3MpIHtcbiAgdHJ5IHtcbiAgICByZXR1cm4gZW1pdHRlci5lbWl0KGV2ZW50LCAuLi5hcmdzKTtcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiBlbWl0dGVyLmVtaXQoJ2Vycm9yJywgZXJyKTtcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIC8vIFdlIGdpdmUgdXAgaWYgdGhlIGVycm9yIGV2ZW50IGFsc28gdGhyb3dzIGFuIGV4Y2VwdGlvbi5cbiAgICAgIGNvbnNvbGUuZXJyb3IoZXJyKTtcbiAgICB9XG4gIH1cbn07XG5cbm1vZHVsZS5leHBvcnRzLk1ldHJpY3NUaW1lID0ge1xuICBPTkVfTUlOVVRFOiAxLFxuICBGSVZFX01JTlVURVM6IDUsXG4gIEZJRlRFRU5fTUlOVVRFUzogMTUsXG4gIFRISVJUWV9NSU5VVEVTOiAzMCxcbiAgT05FX0hPVVI6IDYwLFxuICBPTkVfV0VFSzogNjAgKiAyNCAqIDcsXG4gIFRXT19XRUVLUzogNjAgKiAyNCAqIDcgKiAyLFxuICBPTkVfTU9OVEg6IDYwICogMjQgKiA3ICogMiAqIDRcbn07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/bull/lib/utils.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/bull/lib/worker.js":
/*!*****************************************!*\
  !*** ./node_modules/bull/lib/worker.js ***!
  \*****************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\n\nconst utils = __webpack_require__(/*! ./utils */ \"(rsc)/./node_modules/bull/lib/utils.js\");\nconst clientCommandMessageReg = /ERR unknown command ['`]\\s*client\\s*['`]/;\n\nmodule.exports = function(Queue) {\n  // IDEA, How to store metadata associated to a worker.\n  // create a key from the worker ID associated to the given name.\n  // We keep a hash table bull:myqueue:workers where every worker is a hash key workername:workerId with json holding\n  // metadata of the worker. The worker key gets expired every 30 seconds or so, we renew the worker metadata.\n  //\n  Queue.prototype.setWorkerName = function() {\n    return utils\n      .isRedisReady(this.client)\n      .then(() => {\n        const connectionName = this.clientName();\n        this.bclient.options.connectionName = connectionName;\n        return this.bclient.client('setname', connectionName);\n      })\n      .catch(err => {\n        if (!clientCommandMessageReg.test(err.message)) throw err;\n      });\n  };\n\n  Queue.prototype.getWorkers = function() {\n    return utils\n      .isRedisReady(this.client)\n      .then(() => {\n        return this.client.client('list');\n      })\n      .then(clients => {\n        return this.parseClientList(clients);\n      })\n      .catch(err => {\n        if (!clientCommandMessageReg.test(err.message)) throw err;\n      });\n  };\n\n  Queue.prototype.base64Name = function() {\n    return Buffer.from(this.name).toString('base64');\n  };\n\n  Queue.prototype.clientName = function() {\n    return this.keyPrefix + ':' + this.base64Name();\n  };\n\n  Queue.prototype.parseClientList = function(list) {\n    const lines = list.split('\\n');\n    const clients = [];\n\n    lines.forEach(line => {\n      const client = {};\n      const keyValues = line.split(' ');\n      keyValues.forEach(keyValue => {\n        const index = keyValue.indexOf('=');\n        const key = keyValue.substring(0, index);\n        const value = keyValue.substring(index + 1);\n        client[key] = value;\n      });\n      const name = client['name'];\n      if (name && name.startsWith(this.clientName())) {\n        client['name'] = this.name;\n        clients.push(client);\n      }\n    });\n    return clients;\n  };\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvYnVsbC9saWIvd29ya2VyLmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViLGNBQWMsbUJBQU8sQ0FBQyx1REFBUztBQUMvQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9teS1hcHAvLi9ub2RlX21vZHVsZXMvYnVsbC9saWIvd29ya2VyLmpzPzQzNGUiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCB1dGlscyA9IHJlcXVpcmUoJy4vdXRpbHMnKTtcbmNvbnN0IGNsaWVudENvbW1hbmRNZXNzYWdlUmVnID0gL0VSUiB1bmtub3duIGNvbW1hbmQgWydgXVxccypjbGllbnRcXHMqWydgXS87XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oUXVldWUpIHtcbiAgLy8gSURFQSwgSG93IHRvIHN0b3JlIG1ldGFkYXRhIGFzc29jaWF0ZWQgdG8gYSB3b3JrZXIuXG4gIC8vIGNyZWF0ZSBhIGtleSBmcm9tIHRoZSB3b3JrZXIgSUQgYXNzb2NpYXRlZCB0byB0aGUgZ2l2ZW4gbmFtZS5cbiAgLy8gV2Uga2VlcCBhIGhhc2ggdGFibGUgYnVsbDpteXF1ZXVlOndvcmtlcnMgd2hlcmUgZXZlcnkgd29ya2VyIGlzIGEgaGFzaCBrZXkgd29ya2VybmFtZTp3b3JrZXJJZCB3aXRoIGpzb24gaG9sZGluZ1xuICAvLyBtZXRhZGF0YSBvZiB0aGUgd29ya2VyLiBUaGUgd29ya2VyIGtleSBnZXRzIGV4cGlyZWQgZXZlcnkgMzAgc2Vjb25kcyBvciBzbywgd2UgcmVuZXcgdGhlIHdvcmtlciBtZXRhZGF0YS5cbiAgLy9cbiAgUXVldWUucHJvdG90eXBlLnNldFdvcmtlck5hbWUgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdXRpbHNcbiAgICAgIC5pc1JlZGlzUmVhZHkodGhpcy5jbGllbnQpXG4gICAgICAudGhlbigoKSA9PiB7XG4gICAgICAgIGNvbnN0IGNvbm5lY3Rpb25OYW1lID0gdGhpcy5jbGllbnROYW1lKCk7XG4gICAgICAgIHRoaXMuYmNsaWVudC5vcHRpb25zLmNvbm5lY3Rpb25OYW1lID0gY29ubmVjdGlvbk5hbWU7XG4gICAgICAgIHJldHVybiB0aGlzLmJjbGllbnQuY2xpZW50KCdzZXRuYW1lJywgY29ubmVjdGlvbk5hbWUpO1xuICAgICAgfSlcbiAgICAgIC5jYXRjaChlcnIgPT4ge1xuICAgICAgICBpZiAoIWNsaWVudENvbW1hbmRNZXNzYWdlUmVnLnRlc3QoZXJyLm1lc3NhZ2UpKSB0aHJvdyBlcnI7XG4gICAgICB9KTtcbiAgfTtcblxuICBRdWV1ZS5wcm90b3R5cGUuZ2V0V29ya2VycyA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB1dGlsc1xuICAgICAgLmlzUmVkaXNSZWFkeSh0aGlzLmNsaWVudClcbiAgICAgIC50aGVuKCgpID0+IHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2xpZW50LmNsaWVudCgnbGlzdCcpO1xuICAgICAgfSlcbiAgICAgIC50aGVuKGNsaWVudHMgPT4ge1xuICAgICAgICByZXR1cm4gdGhpcy5wYXJzZUNsaWVudExpc3QoY2xpZW50cyk7XG4gICAgICB9KVxuICAgICAgLmNhdGNoKGVyciA9PiB7XG4gICAgICAgIGlmICghY2xpZW50Q29tbWFuZE1lc3NhZ2VSZWcudGVzdChlcnIubWVzc2FnZSkpIHRocm93IGVycjtcbiAgICAgIH0pO1xuICB9O1xuXG4gIFF1ZXVlLnByb3RvdHlwZS5iYXNlNjROYW1lID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIEJ1ZmZlci5mcm9tKHRoaXMubmFtZSkudG9TdHJpbmcoJ2Jhc2U2NCcpO1xuICB9O1xuXG4gIFF1ZXVlLnByb3RvdHlwZS5jbGllbnROYW1lID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMua2V5UHJlZml4ICsgJzonICsgdGhpcy5iYXNlNjROYW1lKCk7XG4gIH07XG5cbiAgUXVldWUucHJvdG90eXBlLnBhcnNlQ2xpZW50TGlzdCA9IGZ1bmN0aW9uKGxpc3QpIHtcbiAgICBjb25zdCBsaW5lcyA9IGxpc3Quc3BsaXQoJ1xcbicpO1xuICAgIGNvbnN0IGNsaWVudHMgPSBbXTtcblxuICAgIGxpbmVzLmZvckVhY2gobGluZSA9PiB7XG4gICAgICBjb25zdCBjbGllbnQgPSB7fTtcbiAgICAgIGNvbnN0IGtleVZhbHVlcyA9IGxpbmUuc3BsaXQoJyAnKTtcbiAgICAgIGtleVZhbHVlcy5mb3JFYWNoKGtleVZhbHVlID0+IHtcbiAgICAgICAgY29uc3QgaW5kZXggPSBrZXlWYWx1ZS5pbmRleE9mKCc9Jyk7XG4gICAgICAgIGNvbnN0IGtleSA9IGtleVZhbHVlLnN1YnN0cmluZygwLCBpbmRleCk7XG4gICAgICAgIGNvbnN0IHZhbHVlID0ga2V5VmFsdWUuc3Vic3RyaW5nKGluZGV4ICsgMSk7XG4gICAgICAgIGNsaWVudFtrZXldID0gdmFsdWU7XG4gICAgICB9KTtcbiAgICAgIGNvbnN0IG5hbWUgPSBjbGllbnRbJ25hbWUnXTtcbiAgICAgIGlmIChuYW1lICYmIG5hbWUuc3RhcnRzV2l0aCh0aGlzLmNsaWVudE5hbWUoKSkpIHtcbiAgICAgICAgY2xpZW50WyduYW1lJ10gPSB0aGlzLm5hbWU7XG4gICAgICAgIGNsaWVudHMucHVzaChjbGllbnQpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiBjbGllbnRzO1xuICB9O1xufTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/bull/lib/worker.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/bull/node_modules/uuid/dist/esm-node/index.js":
/*!********************************************************************!*\
  !*** ./node_modules/bull/node_modules/uuid/dist/esm-node/index.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   NIL: () => (/* reexport safe */ _nil_js__WEBPACK_IMPORTED_MODULE_4__[\"default\"]),\n/* harmony export */   parse: () => (/* reexport safe */ _parse_js__WEBPACK_IMPORTED_MODULE_8__[\"default\"]),\n/* harmony export */   stringify: () => (/* reexport safe */ _stringify_js__WEBPACK_IMPORTED_MODULE_7__[\"default\"]),\n/* harmony export */   v1: () => (/* reexport safe */ _v1_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"]),\n/* harmony export */   v3: () => (/* reexport safe */ _v3_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"]),\n/* harmony export */   v4: () => (/* reexport safe */ _v4_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"]),\n/* harmony export */   v5: () => (/* reexport safe */ _v5_js__WEBPACK_IMPORTED_MODULE_3__[\"default\"]),\n/* harmony export */   validate: () => (/* reexport safe */ _validate_js__WEBPACK_IMPORTED_MODULE_6__[\"default\"]),\n/* harmony export */   version: () => (/* reexport safe */ _version_js__WEBPACK_IMPORTED_MODULE_5__[\"default\"])\n/* harmony export */ });\n/* harmony import */ var _v1_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./v1.js */ \"(rsc)/./node_modules/bull/node_modules/uuid/dist/esm-node/v1.js\");\n/* harmony import */ var _v3_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./v3.js */ \"(rsc)/./node_modules/bull/node_modules/uuid/dist/esm-node/v3.js\");\n/* harmony import */ var _v4_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./v4.js */ \"(rsc)/./node_modules/bull/node_modules/uuid/dist/esm-node/v4.js\");\n/* harmony import */ var _v5_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./v5.js */ \"(rsc)/./node_modules/bull/node_modules/uuid/dist/esm-node/v5.js\");\n/* harmony import */ var _nil_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./nil.js */ \"(rsc)/./node_modules/bull/node_modules/uuid/dist/esm-node/nil.js\");\n/* harmony import */ var _version_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./version.js */ \"(rsc)/./node_modules/bull/node_modules/uuid/dist/esm-node/version.js\");\n/* harmony import */ var _validate_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./validate.js */ \"(rsc)/./node_modules/bull/node_modules/uuid/dist/esm-node/validate.js\");\n/* harmony import */ var _stringify_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./stringify.js */ \"(rsc)/./node_modules/bull/node_modules/uuid/dist/esm-node/stringify.js\");\n/* harmony import */ var _parse_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./parse.js */ \"(rsc)/./node_modules/bull/node_modules/uuid/dist/esm-node/parse.js\");\n\n\n\n\n\n\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvYnVsbC9ub2RlX21vZHVsZXMvdXVpZC9kaXN0L2VzbS1ub2RlL2luZGV4LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUF3QztBQUNBO0FBQ0E7QUFDQTtBQUNFO0FBQ1E7QUFDRTtBQUNFIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbXktYXBwLy4vbm9kZV9tb2R1bGVzL2J1bGwvbm9kZV9tb2R1bGVzL3V1aWQvZGlzdC9lc20tbm9kZS9pbmRleC5qcz84NDAzIl0sInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCB7IGRlZmF1bHQgYXMgdjEgfSBmcm9tICcuL3YxLmpzJztcbmV4cG9ydCB7IGRlZmF1bHQgYXMgdjMgfSBmcm9tICcuL3YzLmpzJztcbmV4cG9ydCB7IGRlZmF1bHQgYXMgdjQgfSBmcm9tICcuL3Y0LmpzJztcbmV4cG9ydCB7IGRlZmF1bHQgYXMgdjUgfSBmcm9tICcuL3Y1LmpzJztcbmV4cG9ydCB7IGRlZmF1bHQgYXMgTklMIH0gZnJvbSAnLi9uaWwuanMnO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyB2ZXJzaW9uIH0gZnJvbSAnLi92ZXJzaW9uLmpzJztcbmV4cG9ydCB7IGRlZmF1bHQgYXMgdmFsaWRhdGUgfSBmcm9tICcuL3ZhbGlkYXRlLmpzJztcbmV4cG9ydCB7IGRlZmF1bHQgYXMgc3RyaW5naWZ5IH0gZnJvbSAnLi9zdHJpbmdpZnkuanMnO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBwYXJzZSB9IGZyb20gJy4vcGFyc2UuanMnOyJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/bull/node_modules/uuid/dist/esm-node/index.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/bull/node_modules/uuid/dist/esm-node/md5.js":
/*!******************************************************************!*\
  !*** ./node_modules/bull/node_modules/uuid/dist/esm-node/md5.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var crypto__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! crypto */ \"crypto\");\n/* harmony import */ var crypto__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(crypto__WEBPACK_IMPORTED_MODULE_0__);\n\n\nfunction md5(bytes) {\n  if (Array.isArray(bytes)) {\n    bytes = Buffer.from(bytes);\n  } else if (typeof bytes === 'string') {\n    bytes = Buffer.from(bytes, 'utf8');\n  }\n\n  return crypto__WEBPACK_IMPORTED_MODULE_0___default().createHash('md5').update(bytes).digest();\n}\n\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (md5);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvYnVsbC9ub2RlX21vZHVsZXMvdXVpZC9kaXN0L2VzbS1ub2RlL21kNS5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7QUFBNEI7O0FBRTVCO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBOztBQUVBLFNBQVMsd0RBQWlCO0FBQzFCOztBQUVBLGlFQUFlLEdBQUciLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9teS1hcHAvLi9ub2RlX21vZHVsZXMvYnVsbC9ub2RlX21vZHVsZXMvdXVpZC9kaXN0L2VzbS1ub2RlL21kNS5qcz9mZDE1Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBjcnlwdG8gZnJvbSAnY3J5cHRvJztcblxuZnVuY3Rpb24gbWQ1KGJ5dGVzKSB7XG4gIGlmIChBcnJheS5pc0FycmF5KGJ5dGVzKSkge1xuICAgIGJ5dGVzID0gQnVmZmVyLmZyb20oYnl0ZXMpO1xuICB9IGVsc2UgaWYgKHR5cGVvZiBieXRlcyA9PT0gJ3N0cmluZycpIHtcbiAgICBieXRlcyA9IEJ1ZmZlci5mcm9tKGJ5dGVzLCAndXRmOCcpO1xuICB9XG5cbiAgcmV0dXJuIGNyeXB0by5jcmVhdGVIYXNoKCdtZDUnKS51cGRhdGUoYnl0ZXMpLmRpZ2VzdCgpO1xufVxuXG5leHBvcnQgZGVmYXVsdCBtZDU7Il0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/bull/node_modules/uuid/dist/esm-node/md5.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/bull/node_modules/uuid/dist/esm-node/nil.js":
/*!******************************************************************!*\
  !*** ./node_modules/bull/node_modules/uuid/dist/esm-node/nil.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ('00000000-0000-0000-0000-000000000000');//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvYnVsbC9ub2RlX21vZHVsZXMvdXVpZC9kaXN0L2VzbS1ub2RlL25pbC5qcyIsIm1hcHBpbmdzIjoiOzs7O0FBQUEsaUVBQWUsc0NBQXNDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbXktYXBwLy4vbm9kZV9tb2R1bGVzL2J1bGwvbm9kZV9tb2R1bGVzL3V1aWQvZGlzdC9lc20tbm9kZS9uaWwuanM/YWZhYiJdLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnQgZGVmYXVsdCAnMDAwMDAwMDAtMDAwMC0wMDAwLTAwMDAtMDAwMDAwMDAwMDAwJzsiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/bull/node_modules/uuid/dist/esm-node/nil.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/bull/node_modules/uuid/dist/esm-node/parse.js":
/*!********************************************************************!*\
  !*** ./node_modules/bull/node_modules/uuid/dist/esm-node/parse.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _validate_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./validate.js */ \"(rsc)/./node_modules/bull/node_modules/uuid/dist/esm-node/validate.js\");\n\n\nfunction parse(uuid) {\n  if (!(0,_validate_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(uuid)) {\n    throw TypeError('Invalid UUID');\n  }\n\n  let v;\n  const arr = new Uint8Array(16); // Parse ########-....-....-....-............\n\n  arr[0] = (v = parseInt(uuid.slice(0, 8), 16)) >>> 24;\n  arr[1] = v >>> 16 & 0xff;\n  arr[2] = v >>> 8 & 0xff;\n  arr[3] = v & 0xff; // Parse ........-####-....-....-............\n\n  arr[4] = (v = parseInt(uuid.slice(9, 13), 16)) >>> 8;\n  arr[5] = v & 0xff; // Parse ........-....-####-....-............\n\n  arr[6] = (v = parseInt(uuid.slice(14, 18), 16)) >>> 8;\n  arr[7] = v & 0xff; // Parse ........-....-....-####-............\n\n  arr[8] = (v = parseInt(uuid.slice(19, 23), 16)) >>> 8;\n  arr[9] = v & 0xff; // Parse ........-....-....-....-############\n  // (Use \"/\" to avoid 32-bit truncation when bit-shifting high-order bytes)\n\n  arr[10] = (v = parseInt(uuid.slice(24, 36), 16)) / 0x10000000000 & 0xff;\n  arr[11] = v / 0x100000000 & 0xff;\n  arr[12] = v >>> 24 & 0xff;\n  arr[13] = v >>> 16 & 0xff;\n  arr[14] = v >>> 8 & 0xff;\n  arr[15] = v & 0xff;\n  return arr;\n}\n\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (parse);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvYnVsbC9ub2RlX21vZHVsZXMvdXVpZC9kaXN0L2VzbS1ub2RlL3BhcnNlLmpzIiwibWFwcGluZ3MiOiI7Ozs7O0FBQXFDOztBQUVyQztBQUNBLE9BQU8sd0RBQVE7QUFDZjtBQUNBOztBQUVBO0FBQ0Esa0NBQWtDOztBQUVsQztBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7O0FBRXJCO0FBQ0EscUJBQXFCOztBQUVyQjtBQUNBLHFCQUFxQjs7QUFFckI7QUFDQSxxQkFBcUI7QUFDckI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxpRUFBZSxLQUFLIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbXktYXBwLy4vbm9kZV9tb2R1bGVzL2J1bGwvbm9kZV9tb2R1bGVzL3V1aWQvZGlzdC9lc20tbm9kZS9wYXJzZS5qcz83NWZmIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB2YWxpZGF0ZSBmcm9tICcuL3ZhbGlkYXRlLmpzJztcblxuZnVuY3Rpb24gcGFyc2UodXVpZCkge1xuICBpZiAoIXZhbGlkYXRlKHV1aWQpKSB7XG4gICAgdGhyb3cgVHlwZUVycm9yKCdJbnZhbGlkIFVVSUQnKTtcbiAgfVxuXG4gIGxldCB2O1xuICBjb25zdCBhcnIgPSBuZXcgVWludDhBcnJheSgxNik7IC8vIFBhcnNlICMjIyMjIyMjLS4uLi4tLi4uLi0uLi4uLS4uLi4uLi4uLi4uLlxuXG4gIGFyclswXSA9ICh2ID0gcGFyc2VJbnQodXVpZC5zbGljZSgwLCA4KSwgMTYpKSA+Pj4gMjQ7XG4gIGFyclsxXSA9IHYgPj4+IDE2ICYgMHhmZjtcbiAgYXJyWzJdID0gdiA+Pj4gOCAmIDB4ZmY7XG4gIGFyclszXSA9IHYgJiAweGZmOyAvLyBQYXJzZSAuLi4uLi4uLi0jIyMjLS4uLi4tLi4uLi0uLi4uLi4uLi4uLi5cblxuICBhcnJbNF0gPSAodiA9IHBhcnNlSW50KHV1aWQuc2xpY2UoOSwgMTMpLCAxNikpID4+PiA4O1xuICBhcnJbNV0gPSB2ICYgMHhmZjsgLy8gUGFyc2UgLi4uLi4uLi4tLi4uLi0jIyMjLS4uLi4tLi4uLi4uLi4uLi4uXG5cbiAgYXJyWzZdID0gKHYgPSBwYXJzZUludCh1dWlkLnNsaWNlKDE0LCAxOCksIDE2KSkgPj4+IDg7XG4gIGFycls3XSA9IHYgJiAweGZmOyAvLyBQYXJzZSAuLi4uLi4uLi0uLi4uLS4uLi4tIyMjIy0uLi4uLi4uLi4uLi5cblxuICBhcnJbOF0gPSAodiA9IHBhcnNlSW50KHV1aWQuc2xpY2UoMTksIDIzKSwgMTYpKSA+Pj4gODtcbiAgYXJyWzldID0gdiAmIDB4ZmY7IC8vIFBhcnNlIC4uLi4uLi4uLS4uLi4tLi4uLi0uLi4uLSMjIyMjIyMjIyMjI1xuICAvLyAoVXNlIFwiL1wiIHRvIGF2b2lkIDMyLWJpdCB0cnVuY2F0aW9uIHdoZW4gYml0LXNoaWZ0aW5nIGhpZ2gtb3JkZXIgYnl0ZXMpXG5cbiAgYXJyWzEwXSA9ICh2ID0gcGFyc2VJbnQodXVpZC5zbGljZSgyNCwgMzYpLCAxNikpIC8gMHgxMDAwMDAwMDAwMCAmIDB4ZmY7XG4gIGFyclsxMV0gPSB2IC8gMHgxMDAwMDAwMDAgJiAweGZmO1xuICBhcnJbMTJdID0gdiA+Pj4gMjQgJiAweGZmO1xuICBhcnJbMTNdID0gdiA+Pj4gMTYgJiAweGZmO1xuICBhcnJbMTRdID0gdiA+Pj4gOCAmIDB4ZmY7XG4gIGFyclsxNV0gPSB2ICYgMHhmZjtcbiAgcmV0dXJuIGFycjtcbn1cblxuZXhwb3J0IGRlZmF1bHQgcGFyc2U7Il0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/bull/node_modules/uuid/dist/esm-node/parse.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/bull/node_modules/uuid/dist/esm-node/regex.js":
/*!********************************************************************!*\
  !*** ./node_modules/bull/node_modules/uuid/dist/esm-node/regex.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (/^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000)$/i);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvYnVsbC9ub2RlX21vZHVsZXMvdXVpZC9kaXN0L2VzbS1ub2RlL3JlZ2V4LmpzIiwibWFwcGluZ3MiOiI7Ozs7QUFBQSxpRUFBZSxjQUFjLEVBQUUsVUFBVSxFQUFFLGVBQWUsRUFBRSxnQkFBZ0IsRUFBRSxVQUFVLEdBQUcseUNBQXlDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbXktYXBwLy4vbm9kZV9tb2R1bGVzL2J1bGwvbm9kZV9tb2R1bGVzL3V1aWQvZGlzdC9lc20tbm9kZS9yZWdleC5qcz80NDgxIl0sInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCBkZWZhdWx0IC9eKD86WzAtOWEtZl17OH0tWzAtOWEtZl17NH0tWzEtNV1bMC05YS1mXXszfS1bODlhYl1bMC05YS1mXXszfS1bMC05YS1mXXsxMn18MDAwMDAwMDAtMDAwMC0wMDAwLTAwMDAtMDAwMDAwMDAwMDAwKSQvaTsiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/bull/node_modules/uuid/dist/esm-node/regex.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/bull/node_modules/uuid/dist/esm-node/rng.js":
/*!******************************************************************!*\
  !*** ./node_modules/bull/node_modules/uuid/dist/esm-node/rng.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ rng)\n/* harmony export */ });\n/* harmony import */ var crypto__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! crypto */ \"crypto\");\n/* harmony import */ var crypto__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(crypto__WEBPACK_IMPORTED_MODULE_0__);\n\nconst rnds8Pool = new Uint8Array(256); // # of random values to pre-allocate\n\nlet poolPtr = rnds8Pool.length;\nfunction rng() {\n  if (poolPtr > rnds8Pool.length - 16) {\n    crypto__WEBPACK_IMPORTED_MODULE_0___default().randomFillSync(rnds8Pool);\n    poolPtr = 0;\n  }\n\n  return rnds8Pool.slice(poolPtr, poolPtr += 16);\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvYnVsbC9ub2RlX21vZHVsZXMvdXVpZC9kaXN0L2VzbS1ub2RlL3JuZy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7QUFBNEI7QUFDNUIsdUNBQXVDOztBQUV2QztBQUNlO0FBQ2Y7QUFDQSxJQUFJLDREQUFxQjtBQUN6QjtBQUNBOztBQUVBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9teS1hcHAvLi9ub2RlX21vZHVsZXMvYnVsbC9ub2RlX21vZHVsZXMvdXVpZC9kaXN0L2VzbS1ub2RlL3JuZy5qcz9hYjYxIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBjcnlwdG8gZnJvbSAnY3J5cHRvJztcbmNvbnN0IHJuZHM4UG9vbCA9IG5ldyBVaW50OEFycmF5KDI1Nik7IC8vICMgb2YgcmFuZG9tIHZhbHVlcyB0byBwcmUtYWxsb2NhdGVcblxubGV0IHBvb2xQdHIgPSBybmRzOFBvb2wubGVuZ3RoO1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gcm5nKCkge1xuICBpZiAocG9vbFB0ciA+IHJuZHM4UG9vbC5sZW5ndGggLSAxNikge1xuICAgIGNyeXB0by5yYW5kb21GaWxsU3luYyhybmRzOFBvb2wpO1xuICAgIHBvb2xQdHIgPSAwO1xuICB9XG5cbiAgcmV0dXJuIHJuZHM4UG9vbC5zbGljZShwb29sUHRyLCBwb29sUHRyICs9IDE2KTtcbn0iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/bull/node_modules/uuid/dist/esm-node/rng.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/bull/node_modules/uuid/dist/esm-node/sha1.js":
/*!*******************************************************************!*\
  !*** ./node_modules/bull/node_modules/uuid/dist/esm-node/sha1.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var crypto__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! crypto */ \"crypto\");\n/* harmony import */ var crypto__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(crypto__WEBPACK_IMPORTED_MODULE_0__);\n\n\nfunction sha1(bytes) {\n  if (Array.isArray(bytes)) {\n    bytes = Buffer.from(bytes);\n  } else if (typeof bytes === 'string') {\n    bytes = Buffer.from(bytes, 'utf8');\n  }\n\n  return crypto__WEBPACK_IMPORTED_MODULE_0___default().createHash('sha1').update(bytes).digest();\n}\n\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (sha1);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvYnVsbC9ub2RlX21vZHVsZXMvdXVpZC9kaXN0L2VzbS1ub2RlL3NoYTEuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQTRCOztBQUU1QjtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTs7QUFFQSxTQUFTLHdEQUFpQjtBQUMxQjs7QUFFQSxpRUFBZSxJQUFJIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbXktYXBwLy4vbm9kZV9tb2R1bGVzL2J1bGwvbm9kZV9tb2R1bGVzL3V1aWQvZGlzdC9lc20tbm9kZS9zaGExLmpzP2VjZmUiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IGNyeXB0byBmcm9tICdjcnlwdG8nO1xuXG5mdW5jdGlvbiBzaGExKGJ5dGVzKSB7XG4gIGlmIChBcnJheS5pc0FycmF5KGJ5dGVzKSkge1xuICAgIGJ5dGVzID0gQnVmZmVyLmZyb20oYnl0ZXMpO1xuICB9IGVsc2UgaWYgKHR5cGVvZiBieXRlcyA9PT0gJ3N0cmluZycpIHtcbiAgICBieXRlcyA9IEJ1ZmZlci5mcm9tKGJ5dGVzLCAndXRmOCcpO1xuICB9XG5cbiAgcmV0dXJuIGNyeXB0by5jcmVhdGVIYXNoKCdzaGExJykudXBkYXRlKGJ5dGVzKS5kaWdlc3QoKTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgc2hhMTsiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/bull/node_modules/uuid/dist/esm-node/sha1.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/bull/node_modules/uuid/dist/esm-node/stringify.js":
/*!************************************************************************!*\
  !*** ./node_modules/bull/node_modules/uuid/dist/esm-node/stringify.js ***!
  \************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _validate_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./validate.js */ \"(rsc)/./node_modules/bull/node_modules/uuid/dist/esm-node/validate.js\");\n\n/**\n * Convert array of 16 byte values to UUID string format of the form:\n * XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX\n */\n\nconst byteToHex = [];\n\nfor (let i = 0; i < 256; ++i) {\n  byteToHex.push((i + 0x100).toString(16).substr(1));\n}\n\nfunction stringify(arr, offset = 0) {\n  // Note: Be careful editing this code!  It's been tuned for performance\n  // and works in ways you may not expect. See https://github.com/uuidjs/uuid/pull/434\n  const uuid = (byteToHex[arr[offset + 0]] + byteToHex[arr[offset + 1]] + byteToHex[arr[offset + 2]] + byteToHex[arr[offset + 3]] + '-' + byteToHex[arr[offset + 4]] + byteToHex[arr[offset + 5]] + '-' + byteToHex[arr[offset + 6]] + byteToHex[arr[offset + 7]] + '-' + byteToHex[arr[offset + 8]] + byteToHex[arr[offset + 9]] + '-' + byteToHex[arr[offset + 10]] + byteToHex[arr[offset + 11]] + byteToHex[arr[offset + 12]] + byteToHex[arr[offset + 13]] + byteToHex[arr[offset + 14]] + byteToHex[arr[offset + 15]]).toLowerCase(); // Consistency check for valid UUID.  If this throws, it's likely due to one\n  // of the following:\n  // - One or more input array values don't map to a hex octet (leading to\n  // \"undefined\" in the uuid)\n  // - Invalid input values for the RFC `version` or `variant` fields\n\n  if (!(0,_validate_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(uuid)) {\n    throw TypeError('Stringified UUID is invalid');\n  }\n\n  return uuid;\n}\n\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (stringify);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvYnVsbC9ub2RlX21vZHVsZXMvdXVpZC9kaXN0L2VzbS1ub2RlL3N0cmluZ2lmeS5qcyIsIm1hcHBpbmdzIjoiOzs7OztBQUFxQztBQUNyQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxnQkFBZ0IsU0FBUztBQUN6QjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLDRnQkFBNGdCO0FBQzVnQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxPQUFPLHdEQUFRO0FBQ2Y7QUFDQTs7QUFFQTtBQUNBOztBQUVBLGlFQUFlLFNBQVMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9teS1hcHAvLi9ub2RlX21vZHVsZXMvYnVsbC9ub2RlX21vZHVsZXMvdXVpZC9kaXN0L2VzbS1ub2RlL3N0cmluZ2lmeS5qcz83ZDYwIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB2YWxpZGF0ZSBmcm9tICcuL3ZhbGlkYXRlLmpzJztcbi8qKlxuICogQ29udmVydCBhcnJheSBvZiAxNiBieXRlIHZhbHVlcyB0byBVVUlEIHN0cmluZyBmb3JtYXQgb2YgdGhlIGZvcm06XG4gKiBYWFhYWFhYWC1YWFhYLVhYWFgtWFhYWC1YWFhYWFhYWFhYWFhcbiAqL1xuXG5jb25zdCBieXRlVG9IZXggPSBbXTtcblxuZm9yIChsZXQgaSA9IDA7IGkgPCAyNTY7ICsraSkge1xuICBieXRlVG9IZXgucHVzaCgoaSArIDB4MTAwKS50b1N0cmluZygxNikuc3Vic3RyKDEpKTtcbn1cblxuZnVuY3Rpb24gc3RyaW5naWZ5KGFyciwgb2Zmc2V0ID0gMCkge1xuICAvLyBOb3RlOiBCZSBjYXJlZnVsIGVkaXRpbmcgdGhpcyBjb2RlISAgSXQncyBiZWVuIHR1bmVkIGZvciBwZXJmb3JtYW5jZVxuICAvLyBhbmQgd29ya3MgaW4gd2F5cyB5b3UgbWF5IG5vdCBleHBlY3QuIFNlZSBodHRwczovL2dpdGh1Yi5jb20vdXVpZGpzL3V1aWQvcHVsbC80MzRcbiAgY29uc3QgdXVpZCA9IChieXRlVG9IZXhbYXJyW29mZnNldCArIDBdXSArIGJ5dGVUb0hleFthcnJbb2Zmc2V0ICsgMV1dICsgYnl0ZVRvSGV4W2FycltvZmZzZXQgKyAyXV0gKyBieXRlVG9IZXhbYXJyW29mZnNldCArIDNdXSArICctJyArIGJ5dGVUb0hleFthcnJbb2Zmc2V0ICsgNF1dICsgYnl0ZVRvSGV4W2FycltvZmZzZXQgKyA1XV0gKyAnLScgKyBieXRlVG9IZXhbYXJyW29mZnNldCArIDZdXSArIGJ5dGVUb0hleFthcnJbb2Zmc2V0ICsgN11dICsgJy0nICsgYnl0ZVRvSGV4W2FycltvZmZzZXQgKyA4XV0gKyBieXRlVG9IZXhbYXJyW29mZnNldCArIDldXSArICctJyArIGJ5dGVUb0hleFthcnJbb2Zmc2V0ICsgMTBdXSArIGJ5dGVUb0hleFthcnJbb2Zmc2V0ICsgMTFdXSArIGJ5dGVUb0hleFthcnJbb2Zmc2V0ICsgMTJdXSArIGJ5dGVUb0hleFthcnJbb2Zmc2V0ICsgMTNdXSArIGJ5dGVUb0hleFthcnJbb2Zmc2V0ICsgMTRdXSArIGJ5dGVUb0hleFthcnJbb2Zmc2V0ICsgMTVdXSkudG9Mb3dlckNhc2UoKTsgLy8gQ29uc2lzdGVuY3kgY2hlY2sgZm9yIHZhbGlkIFVVSUQuICBJZiB0aGlzIHRocm93cywgaXQncyBsaWtlbHkgZHVlIHRvIG9uZVxuICAvLyBvZiB0aGUgZm9sbG93aW5nOlxuICAvLyAtIE9uZSBvciBtb3JlIGlucHV0IGFycmF5IHZhbHVlcyBkb24ndCBtYXAgdG8gYSBoZXggb2N0ZXQgKGxlYWRpbmcgdG9cbiAgLy8gXCJ1bmRlZmluZWRcIiBpbiB0aGUgdXVpZClcbiAgLy8gLSBJbnZhbGlkIGlucHV0IHZhbHVlcyBmb3IgdGhlIFJGQyBgdmVyc2lvbmAgb3IgYHZhcmlhbnRgIGZpZWxkc1xuXG4gIGlmICghdmFsaWRhdGUodXVpZCkpIHtcbiAgICB0aHJvdyBUeXBlRXJyb3IoJ1N0cmluZ2lmaWVkIFVVSUQgaXMgaW52YWxpZCcpO1xuICB9XG5cbiAgcmV0dXJuIHV1aWQ7XG59XG5cbmV4cG9ydCBkZWZhdWx0IHN0cmluZ2lmeTsiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/bull/node_modules/uuid/dist/esm-node/stringify.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/bull/node_modules/uuid/dist/esm-node/v1.js":
/*!*****************************************************************!*\
  !*** ./node_modules/bull/node_modules/uuid/dist/esm-node/v1.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _rng_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./rng.js */ \"(rsc)/./node_modules/bull/node_modules/uuid/dist/esm-node/rng.js\");\n/* harmony import */ var _stringify_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./stringify.js */ \"(rsc)/./node_modules/bull/node_modules/uuid/dist/esm-node/stringify.js\");\n\n // **`v1()` - Generate time-based UUID**\n//\n// Inspired by https://github.com/LiosK/UUID.js\n// and http://docs.python.org/library/uuid.html\n\nlet _nodeId;\n\nlet _clockseq; // Previous uuid creation time\n\n\nlet _lastMSecs = 0;\nlet _lastNSecs = 0; // See https://github.com/uuidjs/uuid for API details\n\nfunction v1(options, buf, offset) {\n  let i = buf && offset || 0;\n  const b = buf || new Array(16);\n  options = options || {};\n  let node = options.node || _nodeId;\n  let clockseq = options.clockseq !== undefined ? options.clockseq : _clockseq; // node and clockseq need to be initialized to random values if they're not\n  // specified.  We do this lazily to minimize issues related to insufficient\n  // system entropy.  See #189\n\n  if (node == null || clockseq == null) {\n    const seedBytes = options.random || (options.rng || _rng_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"])();\n\n    if (node == null) {\n      // Per 4.5, create and 48-bit node id, (47 random bits + multicast bit = 1)\n      node = _nodeId = [seedBytes[0] | 0x01, seedBytes[1], seedBytes[2], seedBytes[3], seedBytes[4], seedBytes[5]];\n    }\n\n    if (clockseq == null) {\n      // Per 4.2.2, randomize (14 bit) clockseq\n      clockseq = _clockseq = (seedBytes[6] << 8 | seedBytes[7]) & 0x3fff;\n    }\n  } // UUID timestamps are 100 nano-second units since the Gregorian epoch,\n  // (1582-10-15 00:00).  JSNumbers aren't precise enough for this, so\n  // time is handled internally as 'msecs' (integer milliseconds) and 'nsecs'\n  // (100-nanoseconds offset from msecs) since unix epoch, 1970-01-01 00:00.\n\n\n  let msecs = options.msecs !== undefined ? options.msecs : Date.now(); // Per 4.2.1.2, use count of uuid's generated during the current clock\n  // cycle to simulate higher resolution clock\n\n  let nsecs = options.nsecs !== undefined ? options.nsecs : _lastNSecs + 1; // Time since last uuid creation (in msecs)\n\n  const dt = msecs - _lastMSecs + (nsecs - _lastNSecs) / 10000; // Per 4.2.1.2, Bump clockseq on clock regression\n\n  if (dt < 0 && options.clockseq === undefined) {\n    clockseq = clockseq + 1 & 0x3fff;\n  } // Reset nsecs if clock regresses (new clockseq) or we've moved onto a new\n  // time interval\n\n\n  if ((dt < 0 || msecs > _lastMSecs) && options.nsecs === undefined) {\n    nsecs = 0;\n  } // Per 4.2.1.2 Throw error if too many uuids are requested\n\n\n  if (nsecs >= 10000) {\n    throw new Error(\"uuid.v1(): Can't create more than 10M uuids/sec\");\n  }\n\n  _lastMSecs = msecs;\n  _lastNSecs = nsecs;\n  _clockseq = clockseq; // Per 4.1.4 - Convert from unix epoch to Gregorian epoch\n\n  msecs += 12219292800000; // `time_low`\n\n  const tl = ((msecs & 0xfffffff) * 10000 + nsecs) % 0x100000000;\n  b[i++] = tl >>> 24 & 0xff;\n  b[i++] = tl >>> 16 & 0xff;\n  b[i++] = tl >>> 8 & 0xff;\n  b[i++] = tl & 0xff; // `time_mid`\n\n  const tmh = msecs / 0x100000000 * 10000 & 0xfffffff;\n  b[i++] = tmh >>> 8 & 0xff;\n  b[i++] = tmh & 0xff; // `time_high_and_version`\n\n  b[i++] = tmh >>> 24 & 0xf | 0x10; // include version\n\n  b[i++] = tmh >>> 16 & 0xff; // `clock_seq_hi_and_reserved` (Per 4.2.2 - include variant)\n\n  b[i++] = clockseq >>> 8 | 0x80; // `clock_seq_low`\n\n  b[i++] = clockseq & 0xff; // `node`\n\n  for (let n = 0; n < 6; ++n) {\n    b[i + n] = node[n];\n  }\n\n  return buf || (0,_stringify_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(b);\n}\n\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (v1);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvYnVsbC9ub2RlX21vZHVsZXMvdXVpZC9kaXN0L2VzbS1ub2RlL3YxLmpzIiwibWFwcGluZ3MiOiI7Ozs7OztBQUEyQjtBQUNZLENBQUM7QUFDeEM7QUFDQTtBQUNBOztBQUVBOztBQUVBLGVBQWU7OztBQUdmO0FBQ0Esb0JBQW9COztBQUVwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0ZBQWdGO0FBQ2hGO0FBQ0E7O0FBRUE7QUFDQSx3REFBd0QsK0NBQUc7O0FBRTNEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7O0FBR0Esd0VBQXdFO0FBQ3hFOztBQUVBLDRFQUE0RTs7QUFFNUUsZ0VBQWdFOztBQUVoRTtBQUNBO0FBQ0EsSUFBSTtBQUNKOzs7QUFHQTtBQUNBO0FBQ0EsSUFBSTs7O0FBR0o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSx3QkFBd0I7O0FBRXhCLDJCQUEyQjs7QUFFM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7O0FBRXRCO0FBQ0E7QUFDQSx1QkFBdUI7O0FBRXZCLG9DQUFvQzs7QUFFcEMsOEJBQThCOztBQUU5QixrQ0FBa0M7O0FBRWxDLDRCQUE0Qjs7QUFFNUIsa0JBQWtCLE9BQU87QUFDekI7QUFDQTs7QUFFQSxnQkFBZ0IseURBQVM7QUFDekI7O0FBRUEsaUVBQWUsRUFBRSIsInNvdXJjZXMiOlsid2VicGFjazovL215LWFwcC8uL25vZGVfbW9kdWxlcy9idWxsL25vZGVfbW9kdWxlcy91dWlkL2Rpc3QvZXNtLW5vZGUvdjEuanM/ZDFmNiJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgcm5nIGZyb20gJy4vcm5nLmpzJztcbmltcG9ydCBzdHJpbmdpZnkgZnJvbSAnLi9zdHJpbmdpZnkuanMnOyAvLyAqKmB2MSgpYCAtIEdlbmVyYXRlIHRpbWUtYmFzZWQgVVVJRCoqXG4vL1xuLy8gSW5zcGlyZWQgYnkgaHR0cHM6Ly9naXRodWIuY29tL0xpb3NLL1VVSUQuanNcbi8vIGFuZCBodHRwOi8vZG9jcy5weXRob24ub3JnL2xpYnJhcnkvdXVpZC5odG1sXG5cbmxldCBfbm9kZUlkO1xuXG5sZXQgX2Nsb2Nrc2VxOyAvLyBQcmV2aW91cyB1dWlkIGNyZWF0aW9uIHRpbWVcblxuXG5sZXQgX2xhc3RNU2VjcyA9IDA7XG5sZXQgX2xhc3ROU2VjcyA9IDA7IC8vIFNlZSBodHRwczovL2dpdGh1Yi5jb20vdXVpZGpzL3V1aWQgZm9yIEFQSSBkZXRhaWxzXG5cbmZ1bmN0aW9uIHYxKG9wdGlvbnMsIGJ1Ziwgb2Zmc2V0KSB7XG4gIGxldCBpID0gYnVmICYmIG9mZnNldCB8fCAwO1xuICBjb25zdCBiID0gYnVmIHx8IG5ldyBBcnJheSgxNik7XG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICBsZXQgbm9kZSA9IG9wdGlvbnMubm9kZSB8fCBfbm9kZUlkO1xuICBsZXQgY2xvY2tzZXEgPSBvcHRpb25zLmNsb2Nrc2VxICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLmNsb2Nrc2VxIDogX2Nsb2Nrc2VxOyAvLyBub2RlIGFuZCBjbG9ja3NlcSBuZWVkIHRvIGJlIGluaXRpYWxpemVkIHRvIHJhbmRvbSB2YWx1ZXMgaWYgdGhleSdyZSBub3RcbiAgLy8gc3BlY2lmaWVkLiAgV2UgZG8gdGhpcyBsYXppbHkgdG8gbWluaW1pemUgaXNzdWVzIHJlbGF0ZWQgdG8gaW5zdWZmaWNpZW50XG4gIC8vIHN5c3RlbSBlbnRyb3B5LiAgU2VlICMxODlcblxuICBpZiAobm9kZSA9PSBudWxsIHx8IGNsb2Nrc2VxID09IG51bGwpIHtcbiAgICBjb25zdCBzZWVkQnl0ZXMgPSBvcHRpb25zLnJhbmRvbSB8fCAob3B0aW9ucy5ybmcgfHwgcm5nKSgpO1xuXG4gICAgaWYgKG5vZGUgPT0gbnVsbCkge1xuICAgICAgLy8gUGVyIDQuNSwgY3JlYXRlIGFuZCA0OC1iaXQgbm9kZSBpZCwgKDQ3IHJhbmRvbSBiaXRzICsgbXVsdGljYXN0IGJpdCA9IDEpXG4gICAgICBub2RlID0gX25vZGVJZCA9IFtzZWVkQnl0ZXNbMF0gfCAweDAxLCBzZWVkQnl0ZXNbMV0sIHNlZWRCeXRlc1syXSwgc2VlZEJ5dGVzWzNdLCBzZWVkQnl0ZXNbNF0sIHNlZWRCeXRlc1s1XV07XG4gICAgfVxuXG4gICAgaWYgKGNsb2Nrc2VxID09IG51bGwpIHtcbiAgICAgIC8vIFBlciA0LjIuMiwgcmFuZG9taXplICgxNCBiaXQpIGNsb2Nrc2VxXG4gICAgICBjbG9ja3NlcSA9IF9jbG9ja3NlcSA9IChzZWVkQnl0ZXNbNl0gPDwgOCB8IHNlZWRCeXRlc1s3XSkgJiAweDNmZmY7XG4gICAgfVxuICB9IC8vIFVVSUQgdGltZXN0YW1wcyBhcmUgMTAwIG5hbm8tc2Vjb25kIHVuaXRzIHNpbmNlIHRoZSBHcmVnb3JpYW4gZXBvY2gsXG4gIC8vICgxNTgyLTEwLTE1IDAwOjAwKS4gIEpTTnVtYmVycyBhcmVuJ3QgcHJlY2lzZSBlbm91Z2ggZm9yIHRoaXMsIHNvXG4gIC8vIHRpbWUgaXMgaGFuZGxlZCBpbnRlcm5hbGx5IGFzICdtc2VjcycgKGludGVnZXIgbWlsbGlzZWNvbmRzKSBhbmQgJ25zZWNzJ1xuICAvLyAoMTAwLW5hbm9zZWNvbmRzIG9mZnNldCBmcm9tIG1zZWNzKSBzaW5jZSB1bml4IGVwb2NoLCAxOTcwLTAxLTAxIDAwOjAwLlxuXG5cbiAgbGV0IG1zZWNzID0gb3B0aW9ucy5tc2VjcyAhPT0gdW5kZWZpbmVkID8gb3B0aW9ucy5tc2VjcyA6IERhdGUubm93KCk7IC8vIFBlciA0LjIuMS4yLCB1c2UgY291bnQgb2YgdXVpZCdzIGdlbmVyYXRlZCBkdXJpbmcgdGhlIGN1cnJlbnQgY2xvY2tcbiAgLy8gY3ljbGUgdG8gc2ltdWxhdGUgaGlnaGVyIHJlc29sdXRpb24gY2xvY2tcblxuICBsZXQgbnNlY3MgPSBvcHRpb25zLm5zZWNzICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLm5zZWNzIDogX2xhc3ROU2VjcyArIDE7IC8vIFRpbWUgc2luY2UgbGFzdCB1dWlkIGNyZWF0aW9uIChpbiBtc2VjcylcblxuICBjb25zdCBkdCA9IG1zZWNzIC0gX2xhc3RNU2VjcyArIChuc2VjcyAtIF9sYXN0TlNlY3MpIC8gMTAwMDA7IC8vIFBlciA0LjIuMS4yLCBCdW1wIGNsb2Nrc2VxIG9uIGNsb2NrIHJlZ3Jlc3Npb25cblxuICBpZiAoZHQgPCAwICYmIG9wdGlvbnMuY2xvY2tzZXEgPT09IHVuZGVmaW5lZCkge1xuICAgIGNsb2Nrc2VxID0gY2xvY2tzZXEgKyAxICYgMHgzZmZmO1xuICB9IC8vIFJlc2V0IG5zZWNzIGlmIGNsb2NrIHJlZ3Jlc3NlcyAobmV3IGNsb2Nrc2VxKSBvciB3ZSd2ZSBtb3ZlZCBvbnRvIGEgbmV3XG4gIC8vIHRpbWUgaW50ZXJ2YWxcblxuXG4gIGlmICgoZHQgPCAwIHx8IG1zZWNzID4gX2xhc3RNU2VjcykgJiYgb3B0aW9ucy5uc2VjcyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgbnNlY3MgPSAwO1xuICB9IC8vIFBlciA0LjIuMS4yIFRocm93IGVycm9yIGlmIHRvbyBtYW55IHV1aWRzIGFyZSByZXF1ZXN0ZWRcblxuXG4gIGlmIChuc2VjcyA+PSAxMDAwMCkge1xuICAgIHRocm93IG5ldyBFcnJvcihcInV1aWQudjEoKTogQ2FuJ3QgY3JlYXRlIG1vcmUgdGhhbiAxME0gdXVpZHMvc2VjXCIpO1xuICB9XG5cbiAgX2xhc3RNU2VjcyA9IG1zZWNzO1xuICBfbGFzdE5TZWNzID0gbnNlY3M7XG4gIF9jbG9ja3NlcSA9IGNsb2Nrc2VxOyAvLyBQZXIgNC4xLjQgLSBDb252ZXJ0IGZyb20gdW5peCBlcG9jaCB0byBHcmVnb3JpYW4gZXBvY2hcblxuICBtc2VjcyArPSAxMjIxOTI5MjgwMDAwMDsgLy8gYHRpbWVfbG93YFxuXG4gIGNvbnN0IHRsID0gKChtc2VjcyAmIDB4ZmZmZmZmZikgKiAxMDAwMCArIG5zZWNzKSAlIDB4MTAwMDAwMDAwO1xuICBiW2krK10gPSB0bCA+Pj4gMjQgJiAweGZmO1xuICBiW2krK10gPSB0bCA+Pj4gMTYgJiAweGZmO1xuICBiW2krK10gPSB0bCA+Pj4gOCAmIDB4ZmY7XG4gIGJbaSsrXSA9IHRsICYgMHhmZjsgLy8gYHRpbWVfbWlkYFxuXG4gIGNvbnN0IHRtaCA9IG1zZWNzIC8gMHgxMDAwMDAwMDAgKiAxMDAwMCAmIDB4ZmZmZmZmZjtcbiAgYltpKytdID0gdG1oID4+PiA4ICYgMHhmZjtcbiAgYltpKytdID0gdG1oICYgMHhmZjsgLy8gYHRpbWVfaGlnaF9hbmRfdmVyc2lvbmBcblxuICBiW2krK10gPSB0bWggPj4+IDI0ICYgMHhmIHwgMHgxMDsgLy8gaW5jbHVkZSB2ZXJzaW9uXG5cbiAgYltpKytdID0gdG1oID4+PiAxNiAmIDB4ZmY7IC8vIGBjbG9ja19zZXFfaGlfYW5kX3Jlc2VydmVkYCAoUGVyIDQuMi4yIC0gaW5jbHVkZSB2YXJpYW50KVxuXG4gIGJbaSsrXSA9IGNsb2Nrc2VxID4+PiA4IHwgMHg4MDsgLy8gYGNsb2NrX3NlcV9sb3dgXG5cbiAgYltpKytdID0gY2xvY2tzZXEgJiAweGZmOyAvLyBgbm9kZWBcblxuICBmb3IgKGxldCBuID0gMDsgbiA8IDY7ICsrbikge1xuICAgIGJbaSArIG5dID0gbm9kZVtuXTtcbiAgfVxuXG4gIHJldHVybiBidWYgfHwgc3RyaW5naWZ5KGIpO1xufVxuXG5leHBvcnQgZGVmYXVsdCB2MTsiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/bull/node_modules/uuid/dist/esm-node/v1.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/bull/node_modules/uuid/dist/esm-node/v3.js":
/*!*****************************************************************!*\
  !*** ./node_modules/bull/node_modules/uuid/dist/esm-node/v3.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _v35_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./v35.js */ \"(rsc)/./node_modules/bull/node_modules/uuid/dist/esm-node/v35.js\");\n/* harmony import */ var _md5_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./md5.js */ \"(rsc)/./node_modules/bull/node_modules/uuid/dist/esm-node/md5.js\");\n\n\nconst v3 = (0,_v35_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"])('v3', 0x30, _md5_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"]);\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (v3);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvYnVsbC9ub2RlX21vZHVsZXMvdXVpZC9kaXN0L2VzbS1ub2RlL3YzLmpzIiwibWFwcGluZ3MiOiI7Ozs7OztBQUEyQjtBQUNBO0FBQzNCLFdBQVcsbURBQUcsYUFBYSwrQ0FBRztBQUM5QixpRUFBZSxFQUFFIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbXktYXBwLy4vbm9kZV9tb2R1bGVzL2J1bGwvbm9kZV9tb2R1bGVzL3V1aWQvZGlzdC9lc20tbm9kZS92My5qcz81ZDlhIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB2MzUgZnJvbSAnLi92MzUuanMnO1xuaW1wb3J0IG1kNSBmcm9tICcuL21kNS5qcyc7XG5jb25zdCB2MyA9IHYzNSgndjMnLCAweDMwLCBtZDUpO1xuZXhwb3J0IGRlZmF1bHQgdjM7Il0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/bull/node_modules/uuid/dist/esm-node/v3.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/bull/node_modules/uuid/dist/esm-node/v35.js":
/*!******************************************************************!*\
  !*** ./node_modules/bull/node_modules/uuid/dist/esm-node/v35.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   DNS: () => (/* binding */ DNS),\n/* harmony export */   URL: () => (/* binding */ URL),\n/* harmony export */   \"default\": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _stringify_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./stringify.js */ \"(rsc)/./node_modules/bull/node_modules/uuid/dist/esm-node/stringify.js\");\n/* harmony import */ var _parse_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./parse.js */ \"(rsc)/./node_modules/bull/node_modules/uuid/dist/esm-node/parse.js\");\n\n\n\nfunction stringToBytes(str) {\n  str = unescape(encodeURIComponent(str)); // UTF8 escape\n\n  const bytes = [];\n\n  for (let i = 0; i < str.length; ++i) {\n    bytes.push(str.charCodeAt(i));\n  }\n\n  return bytes;\n}\n\nconst DNS = '6ba7b810-9dad-11d1-80b4-00c04fd430c8';\nconst URL = '6ba7b811-9dad-11d1-80b4-00c04fd430c8';\n/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(name, version, hashfunc) {\n  function generateUUID(value, namespace, buf, offset) {\n    if (typeof value === 'string') {\n      value = stringToBytes(value);\n    }\n\n    if (typeof namespace === 'string') {\n      namespace = (0,_parse_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(namespace);\n    }\n\n    if (namespace.length !== 16) {\n      throw TypeError('Namespace must be array-like (16 iterable integer values, 0-255)');\n    } // Compute hash of namespace and value, Per 4.3\n    // Future: Use spread syntax when supported on all platforms, e.g. `bytes =\n    // hashfunc([...namespace, ... value])`\n\n\n    let bytes = new Uint8Array(16 + value.length);\n    bytes.set(namespace);\n    bytes.set(value, namespace.length);\n    bytes = hashfunc(bytes);\n    bytes[6] = bytes[6] & 0x0f | version;\n    bytes[8] = bytes[8] & 0x3f | 0x80;\n\n    if (buf) {\n      offset = offset || 0;\n\n      for (let i = 0; i < 16; ++i) {\n        buf[offset + i] = bytes[i];\n      }\n\n      return buf;\n    }\n\n    return (0,_stringify_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(bytes);\n  } // Function#name is not settable on some platforms (#270)\n\n\n  try {\n    generateUUID.name = name; // eslint-disable-next-line no-empty\n  } catch (err) {} // For CommonJS default export support\n\n\n  generateUUID.DNS = DNS;\n  generateUUID.URL = URL;\n  return generateUUID;\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvYnVsbC9ub2RlX21vZHVsZXMvdXVpZC9kaXN0L2VzbS1ub2RlL3YzNS5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7OztBQUF1QztBQUNSOztBQUUvQjtBQUNBLDJDQUEyQzs7QUFFM0M7O0FBRUEsa0JBQWtCLGdCQUFnQjtBQUNsQztBQUNBOztBQUVBO0FBQ0E7O0FBRU87QUFDQTtBQUNQLDZCQUFlLG9DQUFVO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esa0JBQWtCLHFEQUFLO0FBQ3ZCOztBQUVBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsc0JBQXNCLFFBQVE7QUFDOUI7QUFDQTs7QUFFQTtBQUNBOztBQUVBLFdBQVcseURBQVM7QUFDcEIsSUFBSTs7O0FBR0o7QUFDQSw4QkFBOEI7QUFDOUIsSUFBSSxlQUFlOzs7QUFHbkI7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9teS1hcHAvLi9ub2RlX21vZHVsZXMvYnVsbC9ub2RlX21vZHVsZXMvdXVpZC9kaXN0L2VzbS1ub2RlL3YzNS5qcz8zNGJmIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBzdHJpbmdpZnkgZnJvbSAnLi9zdHJpbmdpZnkuanMnO1xuaW1wb3J0IHBhcnNlIGZyb20gJy4vcGFyc2UuanMnO1xuXG5mdW5jdGlvbiBzdHJpbmdUb0J5dGVzKHN0cikge1xuICBzdHIgPSB1bmVzY2FwZShlbmNvZGVVUklDb21wb25lbnQoc3RyKSk7IC8vIFVURjggZXNjYXBlXG5cbiAgY29uc3QgYnl0ZXMgPSBbXTtcblxuICBmb3IgKGxldCBpID0gMDsgaSA8IHN0ci5sZW5ndGg7ICsraSkge1xuICAgIGJ5dGVzLnB1c2goc3RyLmNoYXJDb2RlQXQoaSkpO1xuICB9XG5cbiAgcmV0dXJuIGJ5dGVzO1xufVxuXG5leHBvcnQgY29uc3QgRE5TID0gJzZiYTdiODEwLTlkYWQtMTFkMS04MGI0LTAwYzA0ZmQ0MzBjOCc7XG5leHBvcnQgY29uc3QgVVJMID0gJzZiYTdiODExLTlkYWQtMTFkMS04MGI0LTAwYzA0ZmQ0MzBjOCc7XG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiAobmFtZSwgdmVyc2lvbiwgaGFzaGZ1bmMpIHtcbiAgZnVuY3Rpb24gZ2VuZXJhdGVVVUlEKHZhbHVlLCBuYW1lc3BhY2UsIGJ1Ziwgb2Zmc2V0KSB7XG4gICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgIHZhbHVlID0gc3RyaW5nVG9CeXRlcyh2YWx1ZSk7XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBuYW1lc3BhY2UgPT09ICdzdHJpbmcnKSB7XG4gICAgICBuYW1lc3BhY2UgPSBwYXJzZShuYW1lc3BhY2UpO1xuICAgIH1cblxuICAgIGlmIChuYW1lc3BhY2UubGVuZ3RoICE9PSAxNikge1xuICAgICAgdGhyb3cgVHlwZUVycm9yKCdOYW1lc3BhY2UgbXVzdCBiZSBhcnJheS1saWtlICgxNiBpdGVyYWJsZSBpbnRlZ2VyIHZhbHVlcywgMC0yNTUpJyk7XG4gICAgfSAvLyBDb21wdXRlIGhhc2ggb2YgbmFtZXNwYWNlIGFuZCB2YWx1ZSwgUGVyIDQuM1xuICAgIC8vIEZ1dHVyZTogVXNlIHNwcmVhZCBzeW50YXggd2hlbiBzdXBwb3J0ZWQgb24gYWxsIHBsYXRmb3JtcywgZS5nLiBgYnl0ZXMgPVxuICAgIC8vIGhhc2hmdW5jKFsuLi5uYW1lc3BhY2UsIC4uLiB2YWx1ZV0pYFxuXG5cbiAgICBsZXQgYnl0ZXMgPSBuZXcgVWludDhBcnJheSgxNiArIHZhbHVlLmxlbmd0aCk7XG4gICAgYnl0ZXMuc2V0KG5hbWVzcGFjZSk7XG4gICAgYnl0ZXMuc2V0KHZhbHVlLCBuYW1lc3BhY2UubGVuZ3RoKTtcbiAgICBieXRlcyA9IGhhc2hmdW5jKGJ5dGVzKTtcbiAgICBieXRlc1s2XSA9IGJ5dGVzWzZdICYgMHgwZiB8IHZlcnNpb247XG4gICAgYnl0ZXNbOF0gPSBieXRlc1s4XSAmIDB4M2YgfCAweDgwO1xuXG4gICAgaWYgKGJ1Zikge1xuICAgICAgb2Zmc2V0ID0gb2Zmc2V0IHx8IDA7XG5cbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgMTY7ICsraSkge1xuICAgICAgICBidWZbb2Zmc2V0ICsgaV0gPSBieXRlc1tpXTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGJ1ZjtcbiAgICB9XG5cbiAgICByZXR1cm4gc3RyaW5naWZ5KGJ5dGVzKTtcbiAgfSAvLyBGdW5jdGlvbiNuYW1lIGlzIG5vdCBzZXR0YWJsZSBvbiBzb21lIHBsYXRmb3JtcyAoIzI3MClcblxuXG4gIHRyeSB7XG4gICAgZ2VuZXJhdGVVVUlELm5hbWUgPSBuYW1lOyAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tZW1wdHlcbiAgfSBjYXRjaCAoZXJyKSB7fSAvLyBGb3IgQ29tbW9uSlMgZGVmYXVsdCBleHBvcnQgc3VwcG9ydFxuXG5cbiAgZ2VuZXJhdGVVVUlELkROUyA9IEROUztcbiAgZ2VuZXJhdGVVVUlELlVSTCA9IFVSTDtcbiAgcmV0dXJuIGdlbmVyYXRlVVVJRDtcbn0iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/bull/node_modules/uuid/dist/esm-node/v35.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/bull/node_modules/uuid/dist/esm-node/v4.js":
/*!*****************************************************************!*\
  !*** ./node_modules/bull/node_modules/uuid/dist/esm-node/v4.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _rng_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./rng.js */ \"(rsc)/./node_modules/bull/node_modules/uuid/dist/esm-node/rng.js\");\n/* harmony import */ var _stringify_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./stringify.js */ \"(rsc)/./node_modules/bull/node_modules/uuid/dist/esm-node/stringify.js\");\n\n\n\nfunction v4(options, buf, offset) {\n  options = options || {};\n  const rnds = options.random || (options.rng || _rng_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(); // Per 4.4, set bits for version and `clock_seq_hi_and_reserved`\n\n  rnds[6] = rnds[6] & 0x0f | 0x40;\n  rnds[8] = rnds[8] & 0x3f | 0x80; // Copy bytes to buffer, if provided\n\n  if (buf) {\n    offset = offset || 0;\n\n    for (let i = 0; i < 16; ++i) {\n      buf[offset + i] = rnds[i];\n    }\n\n    return buf;\n  }\n\n  return (0,_stringify_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(rnds);\n}\n\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (v4);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvYnVsbC9ub2RlX21vZHVsZXMvdXVpZC9kaXN0L2VzbS1ub2RlL3Y0LmpzIiwibWFwcGluZ3MiOiI7Ozs7OztBQUEyQjtBQUNZOztBQUV2QztBQUNBO0FBQ0EsaURBQWlELCtDQUFHLEtBQUs7O0FBRXpEO0FBQ0EsbUNBQW1DOztBQUVuQztBQUNBOztBQUVBLG9CQUFvQixRQUFRO0FBQzVCO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxTQUFTLHlEQUFTO0FBQ2xCOztBQUVBLGlFQUFlLEVBQUUiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9teS1hcHAvLi9ub2RlX21vZHVsZXMvYnVsbC9ub2RlX21vZHVsZXMvdXVpZC9kaXN0L2VzbS1ub2RlL3Y0LmpzP2FiYzciXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHJuZyBmcm9tICcuL3JuZy5qcyc7XG5pbXBvcnQgc3RyaW5naWZ5IGZyb20gJy4vc3RyaW5naWZ5LmpzJztcblxuZnVuY3Rpb24gdjQob3B0aW9ucywgYnVmLCBvZmZzZXQpIHtcbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gIGNvbnN0IHJuZHMgPSBvcHRpb25zLnJhbmRvbSB8fCAob3B0aW9ucy5ybmcgfHwgcm5nKSgpOyAvLyBQZXIgNC40LCBzZXQgYml0cyBmb3IgdmVyc2lvbiBhbmQgYGNsb2NrX3NlcV9oaV9hbmRfcmVzZXJ2ZWRgXG5cbiAgcm5kc1s2XSA9IHJuZHNbNl0gJiAweDBmIHwgMHg0MDtcbiAgcm5kc1s4XSA9IHJuZHNbOF0gJiAweDNmIHwgMHg4MDsgLy8gQ29weSBieXRlcyB0byBidWZmZXIsIGlmIHByb3ZpZGVkXG5cbiAgaWYgKGJ1Zikge1xuICAgIG9mZnNldCA9IG9mZnNldCB8fCAwO1xuXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCAxNjsgKytpKSB7XG4gICAgICBidWZbb2Zmc2V0ICsgaV0gPSBybmRzW2ldO1xuICAgIH1cblxuICAgIHJldHVybiBidWY7XG4gIH1cblxuICByZXR1cm4gc3RyaW5naWZ5KHJuZHMpO1xufVxuXG5leHBvcnQgZGVmYXVsdCB2NDsiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/bull/node_modules/uuid/dist/esm-node/v4.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/bull/node_modules/uuid/dist/esm-node/v5.js":
/*!*****************************************************************!*\
  !*** ./node_modules/bull/node_modules/uuid/dist/esm-node/v5.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _v35_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./v35.js */ \"(rsc)/./node_modules/bull/node_modules/uuid/dist/esm-node/v35.js\");\n/* harmony import */ var _sha1_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./sha1.js */ \"(rsc)/./node_modules/bull/node_modules/uuid/dist/esm-node/sha1.js\");\n\n\nconst v5 = (0,_v35_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"])('v5', 0x50, _sha1_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"]);\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (v5);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvYnVsbC9ub2RlX21vZHVsZXMvdXVpZC9kaXN0L2VzbS1ub2RlL3Y1LmpzIiwibWFwcGluZ3MiOiI7Ozs7OztBQUEyQjtBQUNFO0FBQzdCLFdBQVcsbURBQUcsYUFBYSxnREFBSTtBQUMvQixpRUFBZSxFQUFFIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbXktYXBwLy4vbm9kZV9tb2R1bGVzL2J1bGwvbm9kZV9tb2R1bGVzL3V1aWQvZGlzdC9lc20tbm9kZS92NS5qcz82MGJmIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB2MzUgZnJvbSAnLi92MzUuanMnO1xuaW1wb3J0IHNoYTEgZnJvbSAnLi9zaGExLmpzJztcbmNvbnN0IHY1ID0gdjM1KCd2NScsIDB4NTAsIHNoYTEpO1xuZXhwb3J0IGRlZmF1bHQgdjU7Il0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/bull/node_modules/uuid/dist/esm-node/v5.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/bull/node_modules/uuid/dist/esm-node/validate.js":
/*!***********************************************************************!*\
  !*** ./node_modules/bull/node_modules/uuid/dist/esm-node/validate.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _regex_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./regex.js */ \"(rsc)/./node_modules/bull/node_modules/uuid/dist/esm-node/regex.js\");\n\n\nfunction validate(uuid) {\n  return typeof uuid === 'string' && _regex_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].test(uuid);\n}\n\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (validate);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvYnVsbC9ub2RlX21vZHVsZXMvdXVpZC9kaXN0L2VzbS1ub2RlL3ZhbGlkYXRlLmpzIiwibWFwcGluZ3MiOiI7Ozs7O0FBQStCOztBQUUvQjtBQUNBLHFDQUFxQyxpREFBSztBQUMxQzs7QUFFQSxpRUFBZSxRQUFRIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbXktYXBwLy4vbm9kZV9tb2R1bGVzL2J1bGwvbm9kZV9tb2R1bGVzL3V1aWQvZGlzdC9lc20tbm9kZS92YWxpZGF0ZS5qcz8zMGY0Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBSRUdFWCBmcm9tICcuL3JlZ2V4LmpzJztcblxuZnVuY3Rpb24gdmFsaWRhdGUodXVpZCkge1xuICByZXR1cm4gdHlwZW9mIHV1aWQgPT09ICdzdHJpbmcnICYmIFJFR0VYLnRlc3QodXVpZCk7XG59XG5cbmV4cG9ydCBkZWZhdWx0IHZhbGlkYXRlOyJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/bull/node_modules/uuid/dist/esm-node/validate.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/bull/node_modules/uuid/dist/esm-node/version.js":
/*!**********************************************************************!*\
  !*** ./node_modules/bull/node_modules/uuid/dist/esm-node/version.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _validate_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./validate.js */ \"(rsc)/./node_modules/bull/node_modules/uuid/dist/esm-node/validate.js\");\n\n\nfunction version(uuid) {\n  if (!(0,_validate_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(uuid)) {\n    throw TypeError('Invalid UUID');\n  }\n\n  return parseInt(uuid.substr(14, 1), 16);\n}\n\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (version);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvYnVsbC9ub2RlX21vZHVsZXMvdXVpZC9kaXN0L2VzbS1ub2RlL3ZlcnNpb24uanMiLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBcUM7O0FBRXJDO0FBQ0EsT0FBTyx3REFBUTtBQUNmO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxpRUFBZSxPQUFPIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbXktYXBwLy4vbm9kZV9tb2R1bGVzL2J1bGwvbm9kZV9tb2R1bGVzL3V1aWQvZGlzdC9lc20tbm9kZS92ZXJzaW9uLmpzPzNmMzEiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHZhbGlkYXRlIGZyb20gJy4vdmFsaWRhdGUuanMnO1xuXG5mdW5jdGlvbiB2ZXJzaW9uKHV1aWQpIHtcbiAgaWYgKCF2YWxpZGF0ZSh1dWlkKSkge1xuICAgIHRocm93IFR5cGVFcnJvcignSW52YWxpZCBVVUlEJyk7XG4gIH1cblxuICByZXR1cm4gcGFyc2VJbnQodXVpZC5zdWJzdHIoMTQsIDEpLCAxNik7XG59XG5cbmV4cG9ydCBkZWZhdWx0IHZlcnNpb247Il0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/bull/node_modules/uuid/dist/esm-node/version.js\n");

/***/ })

};
;