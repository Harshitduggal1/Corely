"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/msgpackr";
exports.ids = ["vendor-chunks/msgpackr"];
exports.modules = {

/***/ "(rsc)/./node_modules/msgpackr/dist/node.cjs":
/*!*********************************************!*\
  !*** ./node_modules/msgpackr/dist/node.cjs ***!
  \*********************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n\nvar stream = __webpack_require__(/*! stream */ \"stream\");\nvar module$1 = __webpack_require__(/*! module */ \"module\");\n\nvar decoder;\ntry {\n\tdecoder = new TextDecoder();\n} catch(error) {}\nvar src;\nvar srcEnd;\nvar position$1 = 0;\nconst EMPTY_ARRAY = [];\nvar strings = EMPTY_ARRAY;\nvar stringPosition = 0;\nvar currentUnpackr = {};\nvar currentStructures;\nvar srcString;\nvar srcStringStart = 0;\nvar srcStringEnd = 0;\nvar bundledStrings$1;\nvar referenceMap;\nvar currentExtensions = [];\nvar dataView;\nvar defaultOptions = {\n\tuseRecords: false,\n\tmapsAsObjects: true\n};\nclass C1Type {}\nconst C1 = new C1Type();\nC1.name = 'MessagePack 0xC1';\nvar sequentialMode = false;\nvar inlineObjectReadThreshold = 2;\nvar readStruct$1, onLoadedStructures$1, onSaveState;\n// no-eval build\ntry {\n\tnew Function('');\n} catch(error) {\n\t// if eval variants are not supported, do not create inline object readers ever\n\tinlineObjectReadThreshold = Infinity;\n}\n\nclass Unpackr {\n\tconstructor(options) {\n\t\tif (options) {\n\t\t\tif (options.useRecords === false && options.mapsAsObjects === undefined)\n\t\t\t\toptions.mapsAsObjects = true;\n\t\t\tif (options.sequential && options.trusted !== false) {\n\t\t\t\toptions.trusted = true;\n\t\t\t\tif (!options.structures && options.useRecords != false) {\n\t\t\t\t\toptions.structures = [];\n\t\t\t\t\tif (!options.maxSharedStructures)\n\t\t\t\t\t\toptions.maxSharedStructures = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (options.structures)\n\t\t\t\toptions.structures.sharedLength = options.structures.length;\n\t\t\telse if (options.getStructures) {\n\t\t\t\t(options.structures = []).uninitialized = true; // this is what we use to denote an uninitialized structures\n\t\t\t\toptions.structures.sharedLength = 0;\n\t\t\t}\n\t\t\tif (options.int64AsNumber) {\n\t\t\t\toptions.int64AsType = 'number';\n\t\t\t}\n\t\t}\n\t\tObject.assign(this, options);\n\t}\n\tunpack(source, options) {\n\t\tif (src) {\n\t\t\t// re-entrant execution, save the state and restore it after we do this unpack\n\t\t\treturn saveState$1(() => {\n\t\t\t\tclearSource();\n\t\t\t\treturn this ? this.unpack(source, options) : Unpackr.prototype.unpack.call(defaultOptions, source, options)\n\t\t\t})\n\t\t}\n\t\tif (!source.buffer && source.constructor === ArrayBuffer)\n\t\t\tsource = typeof Buffer !== 'undefined' ? Buffer.from(source) : new Uint8Array(source);\n\t\tif (typeof options === 'object') {\n\t\t\tsrcEnd = options.end || source.length;\n\t\t\tposition$1 = options.start || 0;\n\t\t} else {\n\t\t\tposition$1 = 0;\n\t\t\tsrcEnd = options > -1 ? options : source.length;\n\t\t}\n\t\tstringPosition = 0;\n\t\tsrcStringEnd = 0;\n\t\tsrcString = null;\n\t\tstrings = EMPTY_ARRAY;\n\t\tbundledStrings$1 = null;\n\t\tsrc = source;\n\t\t// this provides cached access to the data view for a buffer if it is getting reused, which is a recommend\n\t\t// technique for getting data from a database where it can be copied into an existing buffer instead of creating\n\t\t// new ones\n\t\ttry {\n\t\t\tdataView = source.dataView || (source.dataView = new DataView(source.buffer, source.byteOffset, source.byteLength));\n\t\t} catch(error) {\n\t\t\t// if it doesn't have a buffer, maybe it is the wrong type of object\n\t\t\tsrc = null;\n\t\t\tif (source instanceof Uint8Array)\n\t\t\t\tthrow error\n\t\t\tthrow new Error('Source must be a Uint8Array or Buffer but was a ' + ((source && typeof source == 'object') ? source.constructor.name : typeof source))\n\t\t}\n\t\tif (this instanceof Unpackr) {\n\t\t\tcurrentUnpackr = this;\n\t\t\tif (this.structures) {\n\t\t\t\tcurrentStructures = this.structures;\n\t\t\t\treturn checkedRead(options)\n\t\t\t} else if (!currentStructures || currentStructures.length > 0) {\n\t\t\t\tcurrentStructures = [];\n\t\t\t}\n\t\t} else {\n\t\t\tcurrentUnpackr = defaultOptions;\n\t\t\tif (!currentStructures || currentStructures.length > 0)\n\t\t\t\tcurrentStructures = [];\n\t\t}\n\t\treturn checkedRead(options)\n\t}\n\tunpackMultiple(source, forEach) {\n\t\tlet values, lastPosition = 0;\n\t\ttry {\n\t\t\tsequentialMode = true;\n\t\t\tlet size = source.length;\n\t\t\tlet value = this ? this.unpack(source, size) : defaultUnpackr.unpack(source, size);\n\t\t\tif (forEach) {\n\t\t\t\tif (forEach(value, lastPosition, position$1) === false) return;\n\t\t\t\twhile(position$1 < size) {\n\t\t\t\t\tlastPosition = position$1;\n\t\t\t\t\tif (forEach(checkedRead(), lastPosition, position$1) === false) {\n\t\t\t\t\t\treturn\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tvalues = [ value ];\n\t\t\t\twhile(position$1 < size) {\n\t\t\t\t\tlastPosition = position$1;\n\t\t\t\t\tvalues.push(checkedRead());\n\t\t\t\t}\n\t\t\t\treturn values\n\t\t\t}\n\t\t} catch(error) {\n\t\t\terror.lastPosition = lastPosition;\n\t\t\terror.values = values;\n\t\t\tthrow error\n\t\t} finally {\n\t\t\tsequentialMode = false;\n\t\t\tclearSource();\n\t\t}\n\t}\n\t_mergeStructures(loadedStructures, existingStructures) {\n\t\tif (onLoadedStructures$1)\n\t\t\tloadedStructures = onLoadedStructures$1.call(this, loadedStructures);\n\t\tloadedStructures = loadedStructures || [];\n\t\tif (Object.isFrozen(loadedStructures))\n\t\t\tloadedStructures = loadedStructures.map(structure => structure.slice(0));\n\t\tfor (let i = 0, l = loadedStructures.length; i < l; i++) {\n\t\t\tlet structure = loadedStructures[i];\n\t\t\tif (structure) {\n\t\t\t\tstructure.isShared = true;\n\t\t\t\tif (i >= 32)\n\t\t\t\t\tstructure.highByte = (i - 32) >> 5;\n\t\t\t}\n\t\t}\n\t\tloadedStructures.sharedLength = loadedStructures.length;\n\t\tfor (let id in existingStructures || []) {\n\t\t\tif (id >= 0) {\n\t\t\t\tlet structure = loadedStructures[id];\n\t\t\t\tlet existing = existingStructures[id];\n\t\t\t\tif (existing) {\n\t\t\t\t\tif (structure)\n\t\t\t\t\t\t(loadedStructures.restoreStructures || (loadedStructures.restoreStructures = []))[id] = structure;\n\t\t\t\t\tloadedStructures[id] = existing;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn this.structures = loadedStructures\n\t}\n\tdecode(source, options) {\n\t\treturn this.unpack(source, options)\n\t}\n}\nfunction checkedRead(options) {\n\ttry {\n\t\tif (!currentUnpackr.trusted && !sequentialMode) {\n\t\t\tlet sharedLength = currentStructures.sharedLength || 0;\n\t\t\tif (sharedLength < currentStructures.length)\n\t\t\t\tcurrentStructures.length = sharedLength;\n\t\t}\n\t\tlet result;\n\t\tif (currentUnpackr.randomAccessStructure && src[position$1] < 0x40 && src[position$1] >= 0x20 && readStruct$1) {\n\t\t\tresult = readStruct$1(src, position$1, srcEnd, currentUnpackr);\n\t\t\tsrc = null; // dispose of this so that recursive unpack calls don't save state\n\t\t\tif (!(options && options.lazy) && result)\n\t\t\t\tresult = result.toJSON();\n\t\t\tposition$1 = srcEnd;\n\t\t} else\n\t\t\tresult = read();\n\t\tif (bundledStrings$1) { // bundled strings to skip past\n\t\t\tposition$1 = bundledStrings$1.postBundlePosition;\n\t\t\tbundledStrings$1 = null;\n\t\t}\n\t\tif (sequentialMode)\n\t\t\t// we only need to restore the structures if there was an error, but if we completed a read,\n\t\t\t// we can clear this out and keep the structures we read\n\t\t\tcurrentStructures.restoreStructures = null;\n\n\t\tif (position$1 == srcEnd) {\n\t\t\t// finished reading this source, cleanup references\n\t\t\tif (currentStructures && currentStructures.restoreStructures)\n\t\t\t\trestoreStructures();\n\t\t\tcurrentStructures = null;\n\t\t\tsrc = null;\n\t\t\tif (referenceMap)\n\t\t\t\treferenceMap = null;\n\t\t} else if (position$1 > srcEnd) {\n\t\t\t// over read\n\t\t\tthrow new Error('Unexpected end of MessagePack data')\n\t\t} else if (!sequentialMode) {\n\t\t\tlet jsonView;\n\t\t\ttry {\n\t\t\t\tjsonView = JSON.stringify(result, (_, value) => typeof value === \"bigint\" ? `${value}n` : value).slice(0, 100);\n\t\t\t} catch(error) {\n\t\t\t\tjsonView = '(JSON view not available ' + error + ')';\n\t\t\t}\n\t\t\tthrow new Error('Data read, but end of buffer not reached ' + jsonView)\n\t\t}\n\t\t// else more to read, but we are reading sequentially, so don't clear source yet\n\t\treturn result\n\t} catch(error) {\n\t\tif (currentStructures && currentStructures.restoreStructures)\n\t\t\trestoreStructures();\n\t\tclearSource();\n\t\tif (error instanceof RangeError || error.message.startsWith('Unexpected end of buffer') || position$1 > srcEnd) {\n\t\t\terror.incomplete = true;\n\t\t}\n\t\tthrow error\n\t}\n}\n\nfunction restoreStructures() {\n\tfor (let id in currentStructures.restoreStructures) {\n\t\tcurrentStructures[id] = currentStructures.restoreStructures[id];\n\t}\n\tcurrentStructures.restoreStructures = null;\n}\n\nfunction read() {\n\tlet token = src[position$1++];\n\tif (token < 0xa0) {\n\t\tif (token < 0x80) {\n\t\t\tif (token < 0x40)\n\t\t\t\treturn token\n\t\t\telse {\n\t\t\t\tlet structure = currentStructures[token & 0x3f] ||\n\t\t\t\t\tcurrentUnpackr.getStructures && loadStructures()[token & 0x3f];\n\t\t\t\tif (structure) {\n\t\t\t\t\tif (!structure.read) {\n\t\t\t\t\t\tstructure.read = createStructureReader(structure, token & 0x3f);\n\t\t\t\t\t}\n\t\t\t\t\treturn structure.read()\n\t\t\t\t} else\n\t\t\t\t\treturn token\n\t\t\t}\n\t\t} else if (token < 0x90) {\n\t\t\t// map\n\t\t\ttoken -= 0x80;\n\t\t\tif (currentUnpackr.mapsAsObjects) {\n\t\t\t\tlet object = {};\n\t\t\t\tfor (let i = 0; i < token; i++) {\n\t\t\t\t\tlet key = readKey();\n\t\t\t\t\tif (key === '__proto__')\n\t\t\t\t\t\tkey = '__proto_';\n\t\t\t\t\tobject[key] = read();\n\t\t\t\t}\n\t\t\t\treturn object\n\t\t\t} else {\n\t\t\t\tlet map = new Map();\n\t\t\t\tfor (let i = 0; i < token; i++) {\n\t\t\t\t\tmap.set(read(), read());\n\t\t\t\t}\n\t\t\t\treturn map\n\t\t\t}\n\t\t} else {\n\t\t\ttoken -= 0x90;\n\t\t\tlet array = new Array(token);\n\t\t\tfor (let i = 0; i < token; i++) {\n\t\t\t\tarray[i] = read();\n\t\t\t}\n\t\t\tif (currentUnpackr.freezeData)\n\t\t\t\treturn Object.freeze(array)\n\t\t\treturn array\n\t\t}\n\t} else if (token < 0xc0) {\n\t\t// fixstr\n\t\tlet length = token - 0xa0;\n\t\tif (srcStringEnd >= position$1) {\n\t\t\treturn srcString.slice(position$1 - srcStringStart, (position$1 += length) - srcStringStart)\n\t\t}\n\t\tif (srcStringEnd == 0 && srcEnd < 140) {\n\t\t\t// for small blocks, avoiding the overhead of the extract call is helpful\n\t\t\tlet string = length < 16 ? shortStringInJS(length) : longStringInJS(length);\n\t\t\tif (string != null)\n\t\t\t\treturn string\n\t\t}\n\t\treturn readFixedString(length)\n\t} else {\n\t\tlet value;\n\t\tswitch (token) {\n\t\t\tcase 0xc0: return null\n\t\t\tcase 0xc1:\n\t\t\t\tif (bundledStrings$1) {\n\t\t\t\t\tvalue = read(); // followed by the length of the string in characters (not bytes!)\n\t\t\t\t\tif (value > 0)\n\t\t\t\t\t\treturn bundledStrings$1[1].slice(bundledStrings$1.position1, bundledStrings$1.position1 += value)\n\t\t\t\t\telse\n\t\t\t\t\t\treturn bundledStrings$1[0].slice(bundledStrings$1.position0, bundledStrings$1.position0 -= value)\n\t\t\t\t}\n\t\t\t\treturn C1; // \"never-used\", return special object to denote that\n\t\t\tcase 0xc2: return false\n\t\t\tcase 0xc3: return true\n\t\t\tcase 0xc4:\n\t\t\t\t// bin 8\n\t\t\t\tvalue = src[position$1++];\n\t\t\t\tif (value === undefined)\n\t\t\t\t\tthrow new Error('Unexpected end of buffer')\n\t\t\t\treturn readBin(value)\n\t\t\tcase 0xc5:\n\t\t\t\t// bin 16\n\t\t\t\tvalue = dataView.getUint16(position$1);\n\t\t\t\tposition$1 += 2;\n\t\t\t\treturn readBin(value)\n\t\t\tcase 0xc6:\n\t\t\t\t// bin 32\n\t\t\t\tvalue = dataView.getUint32(position$1);\n\t\t\t\tposition$1 += 4;\n\t\t\t\treturn readBin(value)\n\t\t\tcase 0xc7:\n\t\t\t\t// ext 8\n\t\t\t\treturn readExt(src[position$1++])\n\t\t\tcase 0xc8:\n\t\t\t\t// ext 16\n\t\t\t\tvalue = dataView.getUint16(position$1);\n\t\t\t\tposition$1 += 2;\n\t\t\t\treturn readExt(value)\n\t\t\tcase 0xc9:\n\t\t\t\t// ext 32\n\t\t\t\tvalue = dataView.getUint32(position$1);\n\t\t\t\tposition$1 += 4;\n\t\t\t\treturn readExt(value)\n\t\t\tcase 0xca:\n\t\t\t\tvalue = dataView.getFloat32(position$1);\n\t\t\t\tif (currentUnpackr.useFloat32 > 2) {\n\t\t\t\t\t// this does rounding of numbers that were encoded in 32-bit float to nearest significant decimal digit that could be preserved\n\t\t\t\t\tlet multiplier = mult10[((src[position$1] & 0x7f) << 1) | (src[position$1 + 1] >> 7)];\n\t\t\t\t\tposition$1 += 4;\n\t\t\t\t\treturn ((multiplier * value + (value > 0 ? 0.5 : -0.5)) >> 0) / multiplier\n\t\t\t\t}\n\t\t\t\tposition$1 += 4;\n\t\t\t\treturn value\n\t\t\tcase 0xcb:\n\t\t\t\tvalue = dataView.getFloat64(position$1);\n\t\t\t\tposition$1 += 8;\n\t\t\t\treturn value\n\t\t\t// uint handlers\n\t\t\tcase 0xcc:\n\t\t\t\treturn src[position$1++]\n\t\t\tcase 0xcd:\n\t\t\t\tvalue = dataView.getUint16(position$1);\n\t\t\t\tposition$1 += 2;\n\t\t\t\treturn value\n\t\t\tcase 0xce:\n\t\t\t\tvalue = dataView.getUint32(position$1);\n\t\t\t\tposition$1 += 4;\n\t\t\t\treturn value\n\t\t\tcase 0xcf:\n\t\t\t\tif (currentUnpackr.int64AsType === 'number') {\n\t\t\t\t\tvalue = dataView.getUint32(position$1) * 0x100000000;\n\t\t\t\t\tvalue += dataView.getUint32(position$1 + 4);\n\t\t\t\t} else if (currentUnpackr.int64AsType === 'string') {\n\t\t\t\t\tvalue = dataView.getBigUint64(position$1).toString();\n\t\t\t\t} else if (currentUnpackr.int64AsType === 'auto') {\n\t\t\t\t\tvalue = dataView.getBigUint64(position$1);\n\t\t\t\t\tif (value<=BigInt(2)<<BigInt(52)) value=Number(value);\n\t\t\t\t} else\n\t\t\t\t\tvalue = dataView.getBigUint64(position$1);\n\t\t\t\tposition$1 += 8;\n\t\t\t\treturn value\n\n\t\t\t// int handlers\n\t\t\tcase 0xd0:\n\t\t\t\treturn dataView.getInt8(position$1++)\n\t\t\tcase 0xd1:\n\t\t\t\tvalue = dataView.getInt16(position$1);\n\t\t\t\tposition$1 += 2;\n\t\t\t\treturn value\n\t\t\tcase 0xd2:\n\t\t\t\tvalue = dataView.getInt32(position$1);\n\t\t\t\tposition$1 += 4;\n\t\t\t\treturn value\n\t\t\tcase 0xd3:\n\t\t\t\tif (currentUnpackr.int64AsType === 'number') {\n\t\t\t\t\tvalue = dataView.getInt32(position$1) * 0x100000000;\n\t\t\t\t\tvalue += dataView.getUint32(position$1 + 4);\n\t\t\t\t} else if (currentUnpackr.int64AsType === 'string') {\n\t\t\t\t\tvalue = dataView.getBigInt64(position$1).toString();\n\t\t\t\t} else if (currentUnpackr.int64AsType === 'auto') {\n\t\t\t\t\tvalue = dataView.getBigInt64(position$1);\n\t\t\t\t\tif (value>=BigInt(-2)<<BigInt(52)&&value<=BigInt(2)<<BigInt(52)) value=Number(value);\n\t\t\t\t} else\n\t\t\t\t\tvalue = dataView.getBigInt64(position$1);\n\t\t\t\tposition$1 += 8;\n\t\t\t\treturn value\n\n\t\t\tcase 0xd4:\n\t\t\t\t// fixext 1\n\t\t\t\tvalue = src[position$1++];\n\t\t\t\tif (value == 0x72) {\n\t\t\t\t\treturn recordDefinition(src[position$1++] & 0x3f)\n\t\t\t\t} else {\n\t\t\t\t\tlet extension = currentExtensions[value];\n\t\t\t\t\tif (extension) {\n\t\t\t\t\t\tif (extension.read) {\n\t\t\t\t\t\t\tposition$1++; // skip filler byte\n\t\t\t\t\t\t\treturn extension.read(read())\n\t\t\t\t\t\t} else if (extension.noBuffer) {\n\t\t\t\t\t\t\tposition$1++; // skip filler byte\n\t\t\t\t\t\t\treturn extension()\n\t\t\t\t\t\t} else\n\t\t\t\t\t\t\treturn extension(src.subarray(position$1, ++position$1))\n\t\t\t\t\t} else\n\t\t\t\t\t\tthrow new Error('Unknown extension ' + value)\n\t\t\t\t}\n\t\t\tcase 0xd5:\n\t\t\t\t// fixext 2\n\t\t\t\tvalue = src[position$1];\n\t\t\t\tif (value == 0x72) {\n\t\t\t\t\tposition$1++;\n\t\t\t\t\treturn recordDefinition(src[position$1++] & 0x3f, src[position$1++])\n\t\t\t\t} else\n\t\t\t\t\treturn readExt(2)\n\t\t\tcase 0xd6:\n\t\t\t\t// fixext 4\n\t\t\t\treturn readExt(4)\n\t\t\tcase 0xd7:\n\t\t\t\t// fixext 8\n\t\t\t\treturn readExt(8)\n\t\t\tcase 0xd8:\n\t\t\t\t// fixext 16\n\t\t\t\treturn readExt(16)\n\t\t\tcase 0xd9:\n\t\t\t// str 8\n\t\t\t\tvalue = src[position$1++];\n\t\t\t\tif (srcStringEnd >= position$1) {\n\t\t\t\t\treturn srcString.slice(position$1 - srcStringStart, (position$1 += value) - srcStringStart)\n\t\t\t\t}\n\t\t\t\treturn readString8(value)\n\t\t\tcase 0xda:\n\t\t\t// str 16\n\t\t\t\tvalue = dataView.getUint16(position$1);\n\t\t\t\tposition$1 += 2;\n\t\t\t\tif (srcStringEnd >= position$1) {\n\t\t\t\t\treturn srcString.slice(position$1 - srcStringStart, (position$1 += value) - srcStringStart)\n\t\t\t\t}\n\t\t\t\treturn readString16(value)\n\t\t\tcase 0xdb:\n\t\t\t// str 32\n\t\t\t\tvalue = dataView.getUint32(position$1);\n\t\t\t\tposition$1 += 4;\n\t\t\t\tif (srcStringEnd >= position$1) {\n\t\t\t\t\treturn srcString.slice(position$1 - srcStringStart, (position$1 += value) - srcStringStart)\n\t\t\t\t}\n\t\t\t\treturn readString32(value)\n\t\t\tcase 0xdc:\n\t\t\t// array 16\n\t\t\t\tvalue = dataView.getUint16(position$1);\n\t\t\t\tposition$1 += 2;\n\t\t\t\treturn readArray(value)\n\t\t\tcase 0xdd:\n\t\t\t// array 32\n\t\t\t\tvalue = dataView.getUint32(position$1);\n\t\t\t\tposition$1 += 4;\n\t\t\t\treturn readArray(value)\n\t\t\tcase 0xde:\n\t\t\t// map 16\n\t\t\t\tvalue = dataView.getUint16(position$1);\n\t\t\t\tposition$1 += 2;\n\t\t\t\treturn readMap(value)\n\t\t\tcase 0xdf:\n\t\t\t// map 32\n\t\t\t\tvalue = dataView.getUint32(position$1);\n\t\t\t\tposition$1 += 4;\n\t\t\t\treturn readMap(value)\n\t\t\tdefault: // negative int\n\t\t\t\tif (token >= 0xe0)\n\t\t\t\t\treturn token - 0x100\n\t\t\t\tif (token === undefined) {\n\t\t\t\t\tlet error = new Error('Unexpected end of MessagePack data');\n\t\t\t\t\terror.incomplete = true;\n\t\t\t\t\tthrow error\n\t\t\t\t}\n\t\t\t\tthrow new Error('Unknown MessagePack token ' + token)\n\n\t\t}\n\t}\n}\nconst validName = /^[a-zA-Z_$][a-zA-Z\\d_$]*$/;\nfunction createStructureReader(structure, firstId) {\n\tfunction readObject() {\n\t\t// This initial function is quick to instantiate, but runs slower. After several iterations pay the cost to build the faster function\n\t\tif (readObject.count++ > inlineObjectReadThreshold) {\n\t\t\tlet readObject = structure.read = (new Function('r', 'return function(){return ' + (currentUnpackr.freezeData ? 'Object.freeze' : '') +\n\t\t\t\t'({' + structure.map(key => key === '__proto__' ? '__proto_:r()' : validName.test(key) ? key + ':r()' : ('[' + JSON.stringify(key) + ']:r()')).join(',') + '})}'))(read);\n\t\t\tif (structure.highByte === 0)\n\t\t\t\tstructure.read = createSecondByteReader(firstId, structure.read);\n\t\t\treturn readObject() // second byte is already read, if there is one so immediately read object\n\t\t}\n\t\tlet object = {};\n\t\tfor (let i = 0, l = structure.length; i < l; i++) {\n\t\t\tlet key = structure[i];\n\t\t\tif (key === '__proto__')\n\t\t\t\tkey = '__proto_';\n\t\t\tobject[key] = read();\n\t\t}\n\t\tif (currentUnpackr.freezeData)\n\t\t\treturn Object.freeze(object);\n\t\treturn object\n\t}\n\treadObject.count = 0;\n\tif (structure.highByte === 0) {\n\t\treturn createSecondByteReader(firstId, readObject)\n\t}\n\treturn readObject\n}\n\nconst createSecondByteReader = (firstId, read0) => {\n\treturn function() {\n\t\tlet highByte = src[position$1++];\n\t\tif (highByte === 0)\n\t\t\treturn read0()\n\t\tlet id = firstId < 32 ? -(firstId + (highByte << 5)) : firstId + (highByte << 5);\n\t\tlet structure = currentStructures[id] || loadStructures()[id];\n\t\tif (!structure) {\n\t\t\tthrow new Error('Record id is not defined for ' + id)\n\t\t}\n\t\tif (!structure.read)\n\t\t\tstructure.read = createStructureReader(structure, firstId);\n\t\treturn structure.read()\n\t}\n};\n\nfunction loadStructures() {\n\tlet loadedStructures = saveState$1(() => {\n\t\t// save the state in case getStructures modifies our buffer\n\t\tsrc = null;\n\t\treturn currentUnpackr.getStructures()\n\t});\n\treturn currentStructures = currentUnpackr._mergeStructures(loadedStructures, currentStructures)\n}\n\nvar readFixedString = readStringJS;\nvar readString8 = readStringJS;\nvar readString16 = readStringJS;\nvar readString32 = readStringJS;\nexports.isNativeAccelerationEnabled = false;\n\nfunction setExtractor(extractStrings) {\n\texports.isNativeAccelerationEnabled = true;\n\treadFixedString = readString(1);\n\treadString8 = readString(2);\n\treadString16 = readString(3);\n\treadString32 = readString(5);\n\tfunction readString(headerLength) {\n\t\treturn function readString(length) {\n\t\t\tlet string = strings[stringPosition++];\n\t\t\tif (string == null) {\n\t\t\t\tif (bundledStrings$1)\n\t\t\t\t\treturn readStringJS(length)\n\t\t\t\tlet byteOffset = src.byteOffset;\n\t\t\t\tlet extraction = extractStrings(position$1 - headerLength + byteOffset, srcEnd + byteOffset, src.buffer);\n\t\t\t\tif (typeof extraction == 'string') {\n\t\t\t\t\tstring = extraction;\n\t\t\t\t\tstrings = EMPTY_ARRAY;\n\t\t\t\t} else {\n\t\t\t\t\tstrings = extraction;\n\t\t\t\t\tstringPosition = 1;\n\t\t\t\t\tsrcStringEnd = 1; // even if a utf-8 string was decoded, must indicate we are in the midst of extracted strings and can't skip strings\n\t\t\t\t\tstring = strings[0];\n\t\t\t\t\tif (string === undefined)\n\t\t\t\t\t\tthrow new Error('Unexpected end of buffer')\n\t\t\t\t}\n\t\t\t}\n\t\t\tlet srcStringLength = string.length;\n\t\t\tif (srcStringLength <= length) {\n\t\t\t\tposition$1 += length;\n\t\t\t\treturn string\n\t\t\t}\n\t\t\tsrcString = string;\n\t\t\tsrcStringStart = position$1;\n\t\t\tsrcStringEnd = position$1 + srcStringLength;\n\t\t\tposition$1 += length;\n\t\t\treturn string.slice(0, length) // we know we just want the beginning\n\t\t}\n\t}\n}\nfunction readStringJS(length) {\n\tlet result;\n\tif (length < 16) {\n\t\tif (result = shortStringInJS(length))\n\t\t\treturn result\n\t}\n\tif (length > 64 && decoder)\n\t\treturn decoder.decode(src.subarray(position$1, position$1 += length))\n\tconst end = position$1 + length;\n\tconst units = [];\n\tresult = '';\n\twhile (position$1 < end) {\n\t\tconst byte1 = src[position$1++];\n\t\tif ((byte1 & 0x80) === 0) {\n\t\t\t// 1 byte\n\t\t\tunits.push(byte1);\n\t\t} else if ((byte1 & 0xe0) === 0xc0) {\n\t\t\t// 2 bytes\n\t\t\tconst byte2 = src[position$1++] & 0x3f;\n\t\t\tunits.push(((byte1 & 0x1f) << 6) | byte2);\n\t\t} else if ((byte1 & 0xf0) === 0xe0) {\n\t\t\t// 3 bytes\n\t\t\tconst byte2 = src[position$1++] & 0x3f;\n\t\t\tconst byte3 = src[position$1++] & 0x3f;\n\t\t\tunits.push(((byte1 & 0x1f) << 12) | (byte2 << 6) | byte3);\n\t\t} else if ((byte1 & 0xf8) === 0xf0) {\n\t\t\t// 4 bytes\n\t\t\tconst byte2 = src[position$1++] & 0x3f;\n\t\t\tconst byte3 = src[position$1++] & 0x3f;\n\t\t\tconst byte4 = src[position$1++] & 0x3f;\n\t\t\tlet unit = ((byte1 & 0x07) << 0x12) | (byte2 << 0x0c) | (byte3 << 0x06) | byte4;\n\t\t\tif (unit > 0xffff) {\n\t\t\t\tunit -= 0x10000;\n\t\t\t\tunits.push(((unit >>> 10) & 0x3ff) | 0xd800);\n\t\t\t\tunit = 0xdc00 | (unit & 0x3ff);\n\t\t\t}\n\t\t\tunits.push(unit);\n\t\t} else {\n\t\t\tunits.push(byte1);\n\t\t}\n\n\t\tif (units.length >= 0x1000) {\n\t\t\tresult += fromCharCode.apply(String, units);\n\t\t\tunits.length = 0;\n\t\t}\n\t}\n\n\tif (units.length > 0) {\n\t\tresult += fromCharCode.apply(String, units);\n\t}\n\n\treturn result\n}\nfunction readString(source, start, length) {\n\tlet existingSrc = src;\n\tsrc = source;\n\tposition$1 = start;\n\ttry {\n\t\treturn readStringJS(length);\n\t} finally {\n\t\tsrc = existingSrc;\n\t}\n}\n\nfunction readArray(length) {\n\tlet array = new Array(length);\n\tfor (let i = 0; i < length; i++) {\n\t\tarray[i] = read();\n\t}\n\tif (currentUnpackr.freezeData)\n\t\treturn Object.freeze(array)\n\treturn array\n}\n\nfunction readMap(length) {\n\tif (currentUnpackr.mapsAsObjects) {\n\t\tlet object = {};\n\t\tfor (let i = 0; i < length; i++) {\n\t\t\tlet key = readKey();\n\t\t\tif (key === '__proto__')\n\t\t\t\tkey = '__proto_';\n\t\t\tobject[key] = read();\n\t\t}\n\t\treturn object\n\t} else {\n\t\tlet map = new Map();\n\t\tfor (let i = 0; i < length; i++) {\n\t\t\tmap.set(read(), read());\n\t\t}\n\t\treturn map\n\t}\n}\n\nvar fromCharCode = String.fromCharCode;\nfunction longStringInJS(length) {\n\tlet start = position$1;\n\tlet bytes = new Array(length);\n\tfor (let i = 0; i < length; i++) {\n\t\tconst byte = src[position$1++];\n\t\tif ((byte & 0x80) > 0) {\n\t\t\t\tposition$1 = start;\n\t\t\t\treturn\n\t\t\t}\n\t\t\tbytes[i] = byte;\n\t\t}\n\t\treturn fromCharCode.apply(String, bytes)\n}\nfunction shortStringInJS(length) {\n\tif (length < 4) {\n\t\tif (length < 2) {\n\t\t\tif (length === 0)\n\t\t\t\treturn ''\n\t\t\telse {\n\t\t\t\tlet a = src[position$1++];\n\t\t\t\tif ((a & 0x80) > 1) {\n\t\t\t\t\tposition$1 -= 1;\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t\treturn fromCharCode(a)\n\t\t\t}\n\t\t} else {\n\t\t\tlet a = src[position$1++];\n\t\t\tlet b = src[position$1++];\n\t\t\tif ((a & 0x80) > 0 || (b & 0x80) > 0) {\n\t\t\t\tposition$1 -= 2;\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif (length < 3)\n\t\t\t\treturn fromCharCode(a, b)\n\t\t\tlet c = src[position$1++];\n\t\t\tif ((c & 0x80) > 0) {\n\t\t\t\tposition$1 -= 3;\n\t\t\t\treturn\n\t\t\t}\n\t\t\treturn fromCharCode(a, b, c)\n\t\t}\n\t} else {\n\t\tlet a = src[position$1++];\n\t\tlet b = src[position$1++];\n\t\tlet c = src[position$1++];\n\t\tlet d = src[position$1++];\n\t\tif ((a & 0x80) > 0 || (b & 0x80) > 0 || (c & 0x80) > 0 || (d & 0x80) > 0) {\n\t\t\tposition$1 -= 4;\n\t\t\treturn\n\t\t}\n\t\tif (length < 6) {\n\t\t\tif (length === 4)\n\t\t\t\treturn fromCharCode(a, b, c, d)\n\t\t\telse {\n\t\t\t\tlet e = src[position$1++];\n\t\t\t\tif ((e & 0x80) > 0) {\n\t\t\t\t\tposition$1 -= 5;\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t\treturn fromCharCode(a, b, c, d, e)\n\t\t\t}\n\t\t} else if (length < 8) {\n\t\t\tlet e = src[position$1++];\n\t\t\tlet f = src[position$1++];\n\t\t\tif ((e & 0x80) > 0 || (f & 0x80) > 0) {\n\t\t\t\tposition$1 -= 6;\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif (length < 7)\n\t\t\t\treturn fromCharCode(a, b, c, d, e, f)\n\t\t\tlet g = src[position$1++];\n\t\t\tif ((g & 0x80) > 0) {\n\t\t\t\tposition$1 -= 7;\n\t\t\t\treturn\n\t\t\t}\n\t\t\treturn fromCharCode(a, b, c, d, e, f, g)\n\t\t} else {\n\t\t\tlet e = src[position$1++];\n\t\t\tlet f = src[position$1++];\n\t\t\tlet g = src[position$1++];\n\t\t\tlet h = src[position$1++];\n\t\t\tif ((e & 0x80) > 0 || (f & 0x80) > 0 || (g & 0x80) > 0 || (h & 0x80) > 0) {\n\t\t\t\tposition$1 -= 8;\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif (length < 10) {\n\t\t\t\tif (length === 8)\n\t\t\t\t\treturn fromCharCode(a, b, c, d, e, f, g, h)\n\t\t\t\telse {\n\t\t\t\t\tlet i = src[position$1++];\n\t\t\t\t\tif ((i & 0x80) > 0) {\n\t\t\t\t\t\tposition$1 -= 9;\n\t\t\t\t\t\treturn\n\t\t\t\t\t}\n\t\t\t\t\treturn fromCharCode(a, b, c, d, e, f, g, h, i)\n\t\t\t\t}\n\t\t\t} else if (length < 12) {\n\t\t\t\tlet i = src[position$1++];\n\t\t\t\tlet j = src[position$1++];\n\t\t\t\tif ((i & 0x80) > 0 || (j & 0x80) > 0) {\n\t\t\t\t\tposition$1 -= 10;\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t\tif (length < 11)\n\t\t\t\t\treturn fromCharCode(a, b, c, d, e, f, g, h, i, j)\n\t\t\t\tlet k = src[position$1++];\n\t\t\t\tif ((k & 0x80) > 0) {\n\t\t\t\t\tposition$1 -= 11;\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t\treturn fromCharCode(a, b, c, d, e, f, g, h, i, j, k)\n\t\t\t} else {\n\t\t\t\tlet i = src[position$1++];\n\t\t\t\tlet j = src[position$1++];\n\t\t\t\tlet k = src[position$1++];\n\t\t\t\tlet l = src[position$1++];\n\t\t\t\tif ((i & 0x80) > 0 || (j & 0x80) > 0 || (k & 0x80) > 0 || (l & 0x80) > 0) {\n\t\t\t\t\tposition$1 -= 12;\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t\tif (length < 14) {\n\t\t\t\t\tif (length === 12)\n\t\t\t\t\t\treturn fromCharCode(a, b, c, d, e, f, g, h, i, j, k, l)\n\t\t\t\t\telse {\n\t\t\t\t\t\tlet m = src[position$1++];\n\t\t\t\t\t\tif ((m & 0x80) > 0) {\n\t\t\t\t\t\t\tposition$1 -= 13;\n\t\t\t\t\t\t\treturn\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn fromCharCode(a, b, c, d, e, f, g, h, i, j, k, l, m)\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tlet m = src[position$1++];\n\t\t\t\t\tlet n = src[position$1++];\n\t\t\t\t\tif ((m & 0x80) > 0 || (n & 0x80) > 0) {\n\t\t\t\t\t\tposition$1 -= 14;\n\t\t\t\t\t\treturn\n\t\t\t\t\t}\n\t\t\t\t\tif (length < 15)\n\t\t\t\t\t\treturn fromCharCode(a, b, c, d, e, f, g, h, i, j, k, l, m, n)\n\t\t\t\t\tlet o = src[position$1++];\n\t\t\t\t\tif ((o & 0x80) > 0) {\n\t\t\t\t\t\tposition$1 -= 15;\n\t\t\t\t\t\treturn\n\t\t\t\t\t}\n\t\t\t\t\treturn fromCharCode(a, b, c, d, e, f, g, h, i, j, k, l, m, n, o)\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunction readOnlyJSString() {\n\tlet token = src[position$1++];\n\tlet length;\n\tif (token < 0xc0) {\n\t\t// fixstr\n\t\tlength = token - 0xa0;\n\t} else {\n\t\tswitch(token) {\n\t\t\tcase 0xd9:\n\t\t\t// str 8\n\t\t\t\tlength = src[position$1++];\n\t\t\t\tbreak\n\t\t\tcase 0xda:\n\t\t\t// str 16\n\t\t\t\tlength = dataView.getUint16(position$1);\n\t\t\t\tposition$1 += 2;\n\t\t\t\tbreak\n\t\t\tcase 0xdb:\n\t\t\t// str 32\n\t\t\t\tlength = dataView.getUint32(position$1);\n\t\t\t\tposition$1 += 4;\n\t\t\t\tbreak\n\t\t\tdefault:\n\t\t\t\tthrow new Error('Expected string')\n\t\t}\n\t}\n\treturn readStringJS(length)\n}\n\n\nfunction readBin(length) {\n\treturn currentUnpackr.copyBuffers ?\n\t\t// specifically use the copying slice (not the node one)\n\t\tUint8Array.prototype.slice.call(src, position$1, position$1 += length) :\n\t\tsrc.subarray(position$1, position$1 += length)\n}\nfunction readExt(length) {\n\tlet type = src[position$1++];\n\tif (currentExtensions[type]) {\n\t\tlet end;\n\t\treturn currentExtensions[type](src.subarray(position$1, end = (position$1 += length)), (readPosition) => {\n\t\t\tposition$1 = readPosition;\n\t\t\ttry {\n\t\t\t\treturn read();\n\t\t\t} finally {\n\t\t\t\tposition$1 = end;\n\t\t\t}\n\t\t})\n\t}\n\telse\n\t\tthrow new Error('Unknown extension type ' + type)\n}\n\nvar keyCache = new Array(4096);\nfunction readKey() {\n\tlet length = src[position$1++];\n\tif (length >= 0xa0 && length < 0xc0) {\n\t\t// fixstr, potentially use key cache\n\t\tlength = length - 0xa0;\n\t\tif (srcStringEnd >= position$1) // if it has been extracted, must use it (and faster anyway)\n\t\t\treturn srcString.slice(position$1 - srcStringStart, (position$1 += length) - srcStringStart)\n\t\telse if (!(srcStringEnd == 0 && srcEnd < 180))\n\t\t\treturn readFixedString(length)\n\t} else { // not cacheable, go back and do a standard read\n\t\tposition$1--;\n\t\treturn asSafeString(read())\n\t}\n\tlet key = ((length << 5) ^ (length > 1 ? dataView.getUint16(position$1) : length > 0 ? src[position$1] : 0)) & 0xfff;\n\tlet entry = keyCache[key];\n\tlet checkPosition = position$1;\n\tlet end = position$1 + length - 3;\n\tlet chunk;\n\tlet i = 0;\n\tif (entry && entry.bytes == length) {\n\t\twhile (checkPosition < end) {\n\t\t\tchunk = dataView.getUint32(checkPosition);\n\t\t\tif (chunk != entry[i++]) {\n\t\t\t\tcheckPosition = 0x70000000;\n\t\t\t\tbreak\n\t\t\t}\n\t\t\tcheckPosition += 4;\n\t\t}\n\t\tend += 3;\n\t\twhile (checkPosition < end) {\n\t\t\tchunk = src[checkPosition++];\n\t\t\tif (chunk != entry[i++]) {\n\t\t\t\tcheckPosition = 0x70000000;\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t\tif (checkPosition === end) {\n\t\t\tposition$1 = checkPosition;\n\t\t\treturn entry.string\n\t\t}\n\t\tend -= 3;\n\t\tcheckPosition = position$1;\n\t}\n\tentry = [];\n\tkeyCache[key] = entry;\n\tentry.bytes = length;\n\twhile (checkPosition < end) {\n\t\tchunk = dataView.getUint32(checkPosition);\n\t\tentry.push(chunk);\n\t\tcheckPosition += 4;\n\t}\n\tend += 3;\n\twhile (checkPosition < end) {\n\t\tchunk = src[checkPosition++];\n\t\tentry.push(chunk);\n\t}\n\t// for small blocks, avoiding the overhead of the extract call is helpful\n\tlet string = length < 16 ? shortStringInJS(length) : longStringInJS(length);\n\tif (string != null)\n\t\treturn entry.string = string\n\treturn entry.string = readFixedString(length)\n}\n\nfunction asSafeString(property) {\n\t// protect against expensive (DoS) string conversions\n\tif (typeof property === 'string') return property;\n\tif (typeof property === 'number' || typeof property === 'boolean' || typeof property === 'bigint') return property.toString();\n\tif (property == null) return property + '';\n\tthrow new Error('Invalid property type for record', typeof property);\n}\n// the registration of the record definition extension (as \"r\")\nconst recordDefinition = (id, highByte) => {\n\tlet structure = read().map(asSafeString); // ensure that all keys are strings and\n\t// that the array is mutable\n\tlet firstByte = id;\n\tif (highByte !== undefined) {\n\t\tid = id < 32 ? -((highByte << 5) + id) : ((highByte << 5) + id);\n\t\tstructure.highByte = highByte;\n\t}\n\tlet existingStructure = currentStructures[id];\n\t// If it is a shared structure, we need to restore any changes after reading.\n\t// Also in sequential mode, we may get incomplete reads and thus errors, and we need to restore\n\t// to the state prior to an incomplete read in order to properly resume.\n\tif (existingStructure && (existingStructure.isShared || sequentialMode)) {\n\t\t(currentStructures.restoreStructures || (currentStructures.restoreStructures = []))[id] = existingStructure;\n\t}\n\tcurrentStructures[id] = structure;\n\tstructure.read = createStructureReader(structure, firstByte);\n\treturn structure.read()\n};\ncurrentExtensions[0] = () => {}; // notepack defines extension 0 to mean undefined, so use that as the default here\ncurrentExtensions[0].noBuffer = true;\n\ncurrentExtensions[0x42] = (data) => {\n\t// decode bigint\n\tlet length = data.length;\n\tlet value = BigInt(data[0] & 0x80 ? data[0] - 0x100 : data[0]);\n\tfor (let i = 1; i < length; i++) {\n\t\tvalue <<= 8n;\n\t\tvalue += BigInt(data[i]);\n\t}\n\treturn value;\n};\n\nlet errors = { Error, TypeError, ReferenceError };\ncurrentExtensions[0x65] = () => {\n\tlet data = read();\n\treturn (errors[data[0]] || Error)(data[1], { cause: data[2] })\n};\n\ncurrentExtensions[0x69] = (data) => {\n\t// id extension (for structured clones)\n\tif (currentUnpackr.structuredClone === false) throw new Error('Structured clone extension is disabled')\n\tlet id = dataView.getUint32(position$1 - 4);\n\tif (!referenceMap)\n\t\treferenceMap = new Map();\n\tlet token = src[position$1];\n\tlet target;\n\t// TODO: handle Maps, Sets, and other types that can cycle; this is complicated, because you potentially need to read\n\t// ahead past references to record structure definitions\n\tif (token >= 0x90 && token < 0xa0 || token == 0xdc || token == 0xdd)\n\t\ttarget = [];\n\telse\n\t\ttarget = {};\n\n\tlet refEntry = { target }; // a placeholder object\n\treferenceMap.set(id, refEntry);\n\tlet targetProperties = read(); // read the next value as the target object to id\n\tif (refEntry.used) // there is a cycle, so we have to assign properties to original target\n\t\treturn Object.assign(target, targetProperties)\n\trefEntry.target = targetProperties; // the placeholder wasn't used, replace with the deserialized one\n\treturn targetProperties // no cycle, can just use the returned read object\n};\n\ncurrentExtensions[0x70] = (data) => {\n\t// pointer extension (for structured clones)\n\tif (currentUnpackr.structuredClone === false) throw new Error('Structured clone extension is disabled')\n\tlet id = dataView.getUint32(position$1 - 4);\n\tlet refEntry = referenceMap.get(id);\n\trefEntry.used = true;\n\treturn refEntry.target\n};\n\ncurrentExtensions[0x73] = () => new Set(read());\n\nconst typedArrays = ['Int8','Uint8','Uint8Clamped','Int16','Uint16','Int32','Uint32','Float32','Float64','BigInt64','BigUint64'].map(type => type + 'Array');\n\nlet glbl = typeof globalThis === 'object' ? globalThis : window;\ncurrentExtensions[0x74] = (data) => {\n\tlet typeCode = data[0];\n\tlet typedArrayName = typedArrays[typeCode];\n\tif (!typedArrayName) {\n\t\tif (typeCode === 16) {\n\t\t\tlet ab = new ArrayBuffer(data.length - 1);\n\t\t\tlet u8 = new Uint8Array(ab);\n\t\t\tu8.set(data.subarray(1));\n\t\t\treturn ab;\n\t\t}\n\t\tthrow new Error('Could not find typed array for code ' + typeCode)\n\t}\n\t// we have to always slice/copy here to get a new ArrayBuffer that is word/byte aligned\n\treturn new glbl[typedArrayName](Uint8Array.prototype.slice.call(data, 1).buffer)\n};\ncurrentExtensions[0x78] = () => {\n\tlet data = read();\n\treturn new RegExp(data[0], data[1])\n};\nconst TEMP_BUNDLE = [];\ncurrentExtensions[0x62] = (data) => {\n\tlet dataSize = (data[0] << 24) + (data[1] << 16) + (data[2] << 8) + data[3];\n\tlet dataPosition = position$1;\n\tposition$1 += dataSize - data.length;\n\tbundledStrings$1 = TEMP_BUNDLE;\n\tbundledStrings$1 = [readOnlyJSString(), readOnlyJSString()];\n\tbundledStrings$1.position0 = 0;\n\tbundledStrings$1.position1 = 0;\n\tbundledStrings$1.postBundlePosition = position$1;\n\tposition$1 = dataPosition;\n\treturn read()\n};\n\ncurrentExtensions[0xff] = (data) => {\n\t// 32-bit date extension\n\tif (data.length == 4)\n\t\treturn new Date((data[0] * 0x1000000 + (data[1] << 16) + (data[2] << 8) + data[3]) * 1000)\n\telse if (data.length == 8)\n\t\treturn new Date(\n\t\t\t((data[0] << 22) + (data[1] << 14) + (data[2] << 6) + (data[3] >> 2)) / 1000000 +\n\t\t\t((data[3] & 0x3) * 0x100000000 + data[4] * 0x1000000 + (data[5] << 16) + (data[6] << 8) + data[7]) * 1000)\n\telse if (data.length == 12)// TODO: Implement support for negative\n\t\treturn new Date(\n\t\t\t((data[0] << 24) + (data[1] << 16) + (data[2] << 8) + data[3]) / 1000000 +\n\t\t\t(((data[4] & 0x80) ? -0x1000000000000 : 0) + data[6] * 0x10000000000 + data[7] * 0x100000000 + data[8] * 0x1000000 + (data[9] << 16) + (data[10] << 8) + data[11]) * 1000)\n\telse\n\t\treturn new Date('invalid')\n}; // notepack defines extension 0 to mean undefined, so use that as the default here\n// registration of bulk record definition?\n// currentExtensions[0x52] = () =>\n\nfunction saveState$1(callback) {\n\tif (onSaveState)\n\t\tonSaveState();\n\tlet savedSrcEnd = srcEnd;\n\tlet savedPosition = position$1;\n\tlet savedStringPosition = stringPosition;\n\tlet savedSrcStringStart = srcStringStart;\n\tlet savedSrcStringEnd = srcStringEnd;\n\tlet savedSrcString = srcString;\n\tlet savedStrings = strings;\n\tlet savedReferenceMap = referenceMap;\n\tlet savedBundledStrings = bundledStrings$1;\n\n\t// TODO: We may need to revisit this if we do more external calls to user code (since it could be slow)\n\tlet savedSrc = new Uint8Array(src.slice(0, srcEnd)); // we copy the data in case it changes while external data is processed\n\tlet savedStructures = currentStructures;\n\tlet savedStructuresContents = currentStructures.slice(0, currentStructures.length);\n\tlet savedPackr = currentUnpackr;\n\tlet savedSequentialMode = sequentialMode;\n\tlet value = callback();\n\tsrcEnd = savedSrcEnd;\n\tposition$1 = savedPosition;\n\tstringPosition = savedStringPosition;\n\tsrcStringStart = savedSrcStringStart;\n\tsrcStringEnd = savedSrcStringEnd;\n\tsrcString = savedSrcString;\n\tstrings = savedStrings;\n\treferenceMap = savedReferenceMap;\n\tbundledStrings$1 = savedBundledStrings;\n\tsrc = savedSrc;\n\tsequentialMode = savedSequentialMode;\n\tcurrentStructures = savedStructures;\n\tcurrentStructures.splice(0, currentStructures.length, ...savedStructuresContents);\n\tcurrentUnpackr = savedPackr;\n\tdataView = new DataView(src.buffer, src.byteOffset, src.byteLength);\n\treturn value\n}\nfunction clearSource() {\n\tsrc = null;\n\treferenceMap = null;\n\tcurrentStructures = null;\n}\n\nfunction addExtension$1(extension) {\n\tif (extension.unpack)\n\t\tcurrentExtensions[extension.type] = extension.unpack;\n\telse\n\t\tcurrentExtensions[extension.type] = extension;\n}\n\nconst mult10 = new Array(147); // this is a table matching binary exponents to the multiplier to determine significant digit rounding\nfor (let i = 0; i < 256; i++) {\n\tmult10[i] = +('1e' + Math.floor(45.15 - i * 0.30103));\n}\nconst Decoder = Unpackr;\nvar defaultUnpackr = new Unpackr({ useRecords: false });\nconst unpack = defaultUnpackr.unpack;\nconst unpackMultiple = defaultUnpackr.unpackMultiple;\nconst decode = defaultUnpackr.unpack;\nconst FLOAT32_OPTIONS = {\n\tNEVER: 0,\n\tALWAYS: 1,\n\tDECIMAL_ROUND: 3,\n\tDECIMAL_FIT: 4\n};\nlet f32Array = new Float32Array(1);\nlet u8Array = new Uint8Array(f32Array.buffer, 0, 4);\nfunction roundFloat32(float32Number) {\n\tf32Array[0] = float32Number;\n\tlet multiplier = mult10[((u8Array[3] & 0x7f) << 1) | (u8Array[2] >> 7)];\n\treturn ((multiplier * float32Number + (float32Number > 0 ? 0.5 : -0.5)) >> 0) / multiplier\n}\nfunction setReadStruct(updatedReadStruct, loadedStructs, saveState) {\n\treadStruct$1 = updatedReadStruct;\n\tonLoadedStructures$1 = loadedStructs;\n\tonSaveState = saveState;\n}\n\nlet textEncoder$1;\ntry {\n\ttextEncoder$1 = new TextEncoder();\n} catch (error) {}\nlet extensions, extensionClasses;\nconst hasNodeBuffer$1 = typeof Buffer !== 'undefined';\nconst ByteArrayAllocate = hasNodeBuffer$1 ?\n\tfunction(length) { return Buffer.allocUnsafeSlow(length) } : Uint8Array;\nconst ByteArray = hasNodeBuffer$1 ? Buffer : Uint8Array;\nconst MAX_BUFFER_SIZE = hasNodeBuffer$1 ? 0x100000000 : 0x7fd00000;\nlet target, keysTarget;\nlet targetView;\nlet position = 0;\nlet safeEnd;\nlet bundledStrings = null;\nlet writeStructSlots;\nconst MAX_BUNDLE_SIZE = 0x5500; // maximum characters such that the encoded bytes fits in 16 bits.\nconst hasNonLatin = /[\\u0080-\\uFFFF]/;\nconst RECORD_SYMBOL = Symbol('record-id');\nclass Packr extends Unpackr {\n\tconstructor(options) {\n\t\tsuper(options);\n\t\tthis.offset = 0;\n\t\tlet start;\n\t\tlet hasSharedUpdate;\n\t\tlet structures;\n\t\tlet referenceMap;\n\t\tlet encodeUtf8 = ByteArray.prototype.utf8Write ? function(string, position) {\n\t\t\treturn target.utf8Write(string, position, 0xffffffff)\n\t\t} : (textEncoder$1 && textEncoder$1.encodeInto) ?\n\t\t\tfunction(string, position) {\n\t\t\t\treturn textEncoder$1.encodeInto(string, target.subarray(position)).written\n\t\t\t} : false;\n\n\t\tlet packr = this;\n\t\tif (!options)\n\t\t\toptions = {};\n\t\tlet isSequential = options && options.sequential;\n\t\tlet hasSharedStructures = options.structures || options.saveStructures;\n\t\tlet maxSharedStructures = options.maxSharedStructures;\n\t\tif (maxSharedStructures == null)\n\t\t\tmaxSharedStructures = hasSharedStructures ? 32 : 0;\n\t\tif (maxSharedStructures > 8160)\n\t\t\tthrow new Error('Maximum maxSharedStructure is 8160')\n\t\tif (options.structuredClone && options.moreTypes == undefined) {\n\t\t\tthis.moreTypes = true;\n\t\t}\n\t\tlet maxOwnStructures = options.maxOwnStructures;\n\t\tif (maxOwnStructures == null)\n\t\t\tmaxOwnStructures = hasSharedStructures ? 32 : 64;\n\t\tif (!this.structures && options.useRecords != false)\n\t\t\tthis.structures = [];\n\t\t// two byte record ids for shared structures\n\t\tlet useTwoByteRecords = maxSharedStructures > 32 || (maxOwnStructures + maxSharedStructures > 64);\n\t\tlet sharedLimitId = maxSharedStructures + 0x40;\n\t\tlet maxStructureId = maxSharedStructures + maxOwnStructures + 0x40;\n\t\tif (maxStructureId > 8256) {\n\t\t\tthrow new Error('Maximum maxSharedStructure + maxOwnStructure is 8192')\n\t\t}\n\t\tlet recordIdsToRemove = [];\n\t\tlet transitionsCount = 0;\n\t\tlet serializationsSinceTransitionRebuild = 0;\n\n\t\tthis.pack = this.encode = function(value, encodeOptions) {\n\t\t\tif (!target) {\n\t\t\t\ttarget = new ByteArrayAllocate(8192);\n\t\t\t\ttargetView = target.dataView || (target.dataView = new DataView(target.buffer, 0, 8192));\n\t\t\t\tposition = 0;\n\t\t\t}\n\t\t\tsafeEnd = target.length - 10;\n\t\t\tif (safeEnd - position < 0x800) {\n\t\t\t\t// don't start too close to the end,\n\t\t\t\ttarget = new ByteArrayAllocate(target.length);\n\t\t\t\ttargetView = target.dataView || (target.dataView = new DataView(target.buffer, 0, target.length));\n\t\t\t\tsafeEnd = target.length - 10;\n\t\t\t\tposition = 0;\n\t\t\t} else\n\t\t\t\tposition = (position + 7) & 0x7ffffff8; // Word align to make any future copying of this buffer faster\n\t\t\tstart = position;\n\t\t\tif (encodeOptions & RESERVE_START_SPACE) position += (encodeOptions & 0xff);\n\t\t\treferenceMap = packr.structuredClone ? new Map() : null;\n\t\t\tif (packr.bundleStrings && typeof value !== 'string') {\n\t\t\t\tbundledStrings = [];\n\t\t\t\tbundledStrings.size = Infinity; // force a new bundle start on first string\n\t\t\t} else\n\t\t\t\tbundledStrings = null;\n\t\t\tstructures = packr.structures;\n\t\t\tif (structures) {\n\t\t\t\tif (structures.uninitialized)\n\t\t\t\t\tstructures = packr._mergeStructures(packr.getStructures());\n\t\t\t\tlet sharedLength = structures.sharedLength || 0;\n\t\t\t\tif (sharedLength > maxSharedStructures) {\n\t\t\t\t\t//if (maxSharedStructures <= 32 && structures.sharedLength > 32) // TODO: could support this, but would need to update the limit ids\n\t\t\t\t\tthrow new Error('Shared structures is larger than maximum shared structures, try increasing maxSharedStructures to ' + structures.sharedLength)\n\t\t\t\t}\n\t\t\t\tif (!structures.transitions) {\n\t\t\t\t\t// rebuild our structure transitions\n\t\t\t\t\tstructures.transitions = Object.create(null);\n\t\t\t\t\tfor (let i = 0; i < sharedLength; i++) {\n\t\t\t\t\t\tlet keys = structures[i];\n\t\t\t\t\t\tif (!keys)\n\t\t\t\t\t\t\tcontinue\n\t\t\t\t\t\tlet nextTransition, transition = structures.transitions;\n\t\t\t\t\t\tfor (let j = 0, l = keys.length; j < l; j++) {\n\t\t\t\t\t\t\tlet key = keys[j];\n\t\t\t\t\t\t\tnextTransition = transition[key];\n\t\t\t\t\t\t\tif (!nextTransition) {\n\t\t\t\t\t\t\t\tnextTransition = transition[key] = Object.create(null);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\ttransition = nextTransition;\n\t\t\t\t\t\t}\n\t\t\t\t\t\ttransition[RECORD_SYMBOL] = i + 0x40;\n\t\t\t\t\t}\n\t\t\t\t\tthis.lastNamedStructuresLength = sharedLength;\n\t\t\t\t}\n\t\t\t\tif (!isSequential) {\n\t\t\t\t\tstructures.nextId = sharedLength + 0x40;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (hasSharedUpdate)\n\t\t\t\thasSharedUpdate = false;\n\t\t\tlet encodingError;\n\t\t\ttry {\n\t\t\t\tif (packr.randomAccessStructure && value && value.constructor && value.constructor === Object)\n\t\t\t\t\twriteStruct(value);\n\t\t\t\telse\n\t\t\t\t\tpack(value);\n\t\t\t\tlet lastBundle = bundledStrings;\n\t\t\t\tif (bundledStrings)\n\t\t\t\t\twriteBundles(start, pack, 0);\n\t\t\t\tif (referenceMap && referenceMap.idsToInsert) {\n\t\t\t\t\tlet idsToInsert = referenceMap.idsToInsert.sort((a, b) => a.offset > b.offset ? 1 : -1);\n\t\t\t\t\tlet i = idsToInsert.length;\n\t\t\t\t\tlet incrementPosition = -1;\n\t\t\t\t\twhile (lastBundle && i > 0) {\n\t\t\t\t\t\tlet insertionPoint = idsToInsert[--i].offset + start;\n\t\t\t\t\t\tif (insertionPoint < (lastBundle.stringsPosition + start) && incrementPosition === -1)\n\t\t\t\t\t\t\tincrementPosition = 0;\n\t\t\t\t\t\tif (insertionPoint > (lastBundle.position + start)) {\n\t\t\t\t\t\t\tif (incrementPosition >= 0)\n\t\t\t\t\t\t\t\tincrementPosition += 6;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tif (incrementPosition >= 0) {\n\t\t\t\t\t\t\t\t// update the bundle reference now\n\t\t\t\t\t\t\t\ttargetView.setUint32(lastBundle.position + start,\n\t\t\t\t\t\t\t\t\ttargetView.getUint32(lastBundle.position + start) + incrementPosition);\n\t\t\t\t\t\t\t\tincrementPosition = -1; // reset\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tlastBundle = lastBundle.previous;\n\t\t\t\t\t\t\ti++;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (incrementPosition >= 0 && lastBundle) {\n\t\t\t\t\t\t// update the bundle reference now\n\t\t\t\t\t\ttargetView.setUint32(lastBundle.position + start,\n\t\t\t\t\t\t\ttargetView.getUint32(lastBundle.position + start) + incrementPosition);\n\t\t\t\t\t}\n\t\t\t\t\tposition += idsToInsert.length * 6;\n\t\t\t\t\tif (position > safeEnd)\n\t\t\t\t\t\tmakeRoom(position);\n\t\t\t\t\tpackr.offset = position;\n\t\t\t\t\tlet serialized = insertIds(target.subarray(start, position), idsToInsert);\n\t\t\t\t\treferenceMap = null;\n\t\t\t\t\treturn serialized\n\t\t\t\t}\n\t\t\t\tpackr.offset = position; // update the offset so next serialization doesn't write over our buffer, but can continue writing to same buffer sequentially\n\t\t\t\tif (encodeOptions & REUSE_BUFFER_MODE) {\n\t\t\t\t\ttarget.start = start;\n\t\t\t\t\ttarget.end = position;\n\t\t\t\t\treturn target\n\t\t\t\t}\n\t\t\t\treturn target.subarray(start, position) // position can change if we call pack again in saveStructures, so we get the buffer now\n\t\t\t} catch(error) {\n\t\t\t\tencodingError = error;\n\t\t\t\tthrow error;\n\t\t\t} finally {\n\t\t\t\tif (structures) {\n\t\t\t\t\tresetStructures();\n\t\t\t\t\tif (hasSharedUpdate && packr.saveStructures) {\n\t\t\t\t\t\tlet sharedLength = structures.sharedLength || 0;\n\t\t\t\t\t\t// we can't rely on start/end with REUSE_BUFFER_MODE since they will (probably) change when we save\n\t\t\t\t\t\tlet returnBuffer = target.subarray(start, position);\n\t\t\t\t\t\tlet newSharedData = prepareStructures$1(structures, packr);\n\t\t\t\t\t\tif (!encodingError) { // TODO: If there is an encoding error, should make the structures as uninitialized so they get rebuilt next time\n\t\t\t\t\t\t\tif (packr.saveStructures(newSharedData, newSharedData.isCompatible) === false) {\n\t\t\t\t\t\t\t\t// get updated structures and try again if the update failed\n\t\t\t\t\t\t\t\treturn packr.pack(value, encodeOptions)\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tpackr.lastNamedStructuresLength = sharedLength;\n\t\t\t\t\t\t\t// don't keep large buffers around\n\t\t\t\t\t\t\tif (target.length > 0x40000000) target = null;\n\t\t\t\t\t\t\treturn returnBuffer\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t// don't keep large buffers around, they take too much memory and cause problems (limit at 1GB)\n\t\t\t\tif (target.length > 0x40000000) target = null;\n\t\t\t\tif (encodeOptions & RESET_BUFFER_MODE)\n\t\t\t\t\tposition = start;\n\t\t\t}\n\t\t};\n\t\tconst resetStructures = () => {\n\t\t\tif (serializationsSinceTransitionRebuild < 10)\n\t\t\t\tserializationsSinceTransitionRebuild++;\n\t\t\tlet sharedLength = structures.sharedLength || 0;\n\t\t\tif (structures.length > sharedLength && !isSequential)\n\t\t\t\tstructures.length = sharedLength;\n\t\t\tif (transitionsCount > 10000) {\n\t\t\t\t// force a rebuild occasionally after a lot of transitions so it can get cleaned up\n\t\t\t\tstructures.transitions = null;\n\t\t\t\tserializationsSinceTransitionRebuild = 0;\n\t\t\t\ttransitionsCount = 0;\n\t\t\t\tif (recordIdsToRemove.length > 0)\n\t\t\t\t\trecordIdsToRemove = [];\n\t\t\t} else if (recordIdsToRemove.length > 0 && !isSequential) {\n\t\t\t\tfor (let i = 0, l = recordIdsToRemove.length; i < l; i++) {\n\t\t\t\t\trecordIdsToRemove[i][RECORD_SYMBOL] = 0;\n\t\t\t\t}\n\t\t\t\trecordIdsToRemove = [];\n\t\t\t}\n\t\t};\n\t\tconst packArray = (value) => {\n\t\t\tvar length = value.length;\n\t\t\tif (length < 0x10) {\n\t\t\t\ttarget[position++] = 0x90 | length;\n\t\t\t} else if (length < 0x10000) {\n\t\t\t\ttarget[position++] = 0xdc;\n\t\t\t\ttarget[position++] = length >> 8;\n\t\t\t\ttarget[position++] = length & 0xff;\n\t\t\t} else {\n\t\t\t\ttarget[position++] = 0xdd;\n\t\t\t\ttargetView.setUint32(position, length);\n\t\t\t\tposition += 4;\n\t\t\t}\n\t\t\tfor (let i = 0; i < length; i++) {\n\t\t\t\tpack(value[i]);\n\t\t\t}\n\t\t};\n\t\tconst pack = (value) => {\n\t\t\tif (position > safeEnd)\n\t\t\t\ttarget = makeRoom(position);\n\n\t\t\tvar type = typeof value;\n\t\t\tvar length;\n\t\t\tif (type === 'string') {\n\t\t\t\tlet strLength = value.length;\n\t\t\t\tif (bundledStrings && strLength >= 4 && strLength < 0x1000) {\n\t\t\t\t\tif ((bundledStrings.size += strLength) > MAX_BUNDLE_SIZE) {\n\t\t\t\t\t\tlet extStart;\n\t\t\t\t\t\tlet maxBytes = (bundledStrings[0] ? bundledStrings[0].length * 3 + bundledStrings[1].length : 0) + 10;\n\t\t\t\t\t\tif (position + maxBytes > safeEnd)\n\t\t\t\t\t\t\ttarget = makeRoom(position + maxBytes);\n\t\t\t\t\t\tlet lastBundle;\n\t\t\t\t\t\tif (bundledStrings.position) { // here we use the 0x62 extension to write the last bundle and reserve space for the reference pointer to the next/current bundle\n\t\t\t\t\t\t\tlastBundle = bundledStrings;\n\t\t\t\t\t\t\ttarget[position] = 0xc8; // ext 16\n\t\t\t\t\t\t\tposition += 3; // reserve for the writing bundle size\n\t\t\t\t\t\t\ttarget[position++] = 0x62; // 'b'\n\t\t\t\t\t\t\textStart = position - start;\n\t\t\t\t\t\t\tposition += 4; // reserve for writing bundle reference\n\t\t\t\t\t\t\twriteBundles(start, pack, 0); // write the last bundles\n\t\t\t\t\t\t\ttargetView.setUint16(extStart + start - 3, position - start - extStart);\n\t\t\t\t\t\t} else { // here we use the 0x62 extension just to reserve the space for the reference pointer to the bundle (will be updated once the bundle is written)\n\t\t\t\t\t\t\ttarget[position++] = 0xd6; // fixext 4\n\t\t\t\t\t\t\ttarget[position++] = 0x62; // 'b'\n\t\t\t\t\t\t\textStart = position - start;\n\t\t\t\t\t\t\tposition += 4; // reserve for writing bundle reference\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbundledStrings = ['', '']; // create new ones\n\t\t\t\t\t\tbundledStrings.previous = lastBundle;\n\t\t\t\t\t\tbundledStrings.size = 0;\n\t\t\t\t\t\tbundledStrings.position = extStart;\n\t\t\t\t\t}\n\t\t\t\t\tlet twoByte = hasNonLatin.test(value);\n\t\t\t\t\tbundledStrings[twoByte ? 0 : 1] += value;\n\t\t\t\t\ttarget[position++] = 0xc1;\n\t\t\t\t\tpack(twoByte ? -strLength : strLength);\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t\tlet headerSize;\n\t\t\t\t// first we estimate the header size, so we can write to the correct location\n\t\t\t\tif (strLength < 0x20) {\n\t\t\t\t\theaderSize = 1;\n\t\t\t\t} else if (strLength < 0x100) {\n\t\t\t\t\theaderSize = 2;\n\t\t\t\t} else if (strLength < 0x10000) {\n\t\t\t\t\theaderSize = 3;\n\t\t\t\t} else {\n\t\t\t\t\theaderSize = 5;\n\t\t\t\t}\n\t\t\t\tlet maxBytes = strLength * 3;\n\t\t\t\tif (position + maxBytes > safeEnd)\n\t\t\t\t\ttarget = makeRoom(position + maxBytes);\n\n\t\t\t\tif (strLength < 0x40 || !encodeUtf8) {\n\t\t\t\t\tlet i, c1, c2, strPosition = position + headerSize;\n\t\t\t\t\tfor (i = 0; i < strLength; i++) {\n\t\t\t\t\t\tc1 = value.charCodeAt(i);\n\t\t\t\t\t\tif (c1 < 0x80) {\n\t\t\t\t\t\t\ttarget[strPosition++] = c1;\n\t\t\t\t\t\t} else if (c1 < 0x800) {\n\t\t\t\t\t\t\ttarget[strPosition++] = c1 >> 6 | 0xc0;\n\t\t\t\t\t\t\ttarget[strPosition++] = c1 & 0x3f | 0x80;\n\t\t\t\t\t\t} else if (\n\t\t\t\t\t\t\t(c1 & 0xfc00) === 0xd800 &&\n\t\t\t\t\t\t\t((c2 = value.charCodeAt(i + 1)) & 0xfc00) === 0xdc00\n\t\t\t\t\t\t) {\n\t\t\t\t\t\t\tc1 = 0x10000 + ((c1 & 0x03ff) << 10) + (c2 & 0x03ff);\n\t\t\t\t\t\t\ti++;\n\t\t\t\t\t\t\ttarget[strPosition++] = c1 >> 18 | 0xf0;\n\t\t\t\t\t\t\ttarget[strPosition++] = c1 >> 12 & 0x3f | 0x80;\n\t\t\t\t\t\t\ttarget[strPosition++] = c1 >> 6 & 0x3f | 0x80;\n\t\t\t\t\t\t\ttarget[strPosition++] = c1 & 0x3f | 0x80;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\ttarget[strPosition++] = c1 >> 12 | 0xe0;\n\t\t\t\t\t\t\ttarget[strPosition++] = c1 >> 6 & 0x3f | 0x80;\n\t\t\t\t\t\t\ttarget[strPosition++] = c1 & 0x3f | 0x80;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tlength = strPosition - position - headerSize;\n\t\t\t\t} else {\n\t\t\t\t\tlength = encodeUtf8(value, position + headerSize);\n\t\t\t\t}\n\n\t\t\t\tif (length < 0x20) {\n\t\t\t\t\ttarget[position++] = 0xa0 | length;\n\t\t\t\t} else if (length < 0x100) {\n\t\t\t\t\tif (headerSize < 2) {\n\t\t\t\t\t\ttarget.copyWithin(position + 2, position + 1, position + 1 + length);\n\t\t\t\t\t}\n\t\t\t\t\ttarget[position++] = 0xd9;\n\t\t\t\t\ttarget[position++] = length;\n\t\t\t\t} else if (length < 0x10000) {\n\t\t\t\t\tif (headerSize < 3) {\n\t\t\t\t\t\ttarget.copyWithin(position + 3, position + 2, position + 2 + length);\n\t\t\t\t\t}\n\t\t\t\t\ttarget[position++] = 0xda;\n\t\t\t\t\ttarget[position++] = length >> 8;\n\t\t\t\t\ttarget[position++] = length & 0xff;\n\t\t\t\t} else {\n\t\t\t\t\tif (headerSize < 5) {\n\t\t\t\t\t\ttarget.copyWithin(position + 5, position + 3, position + 3 + length);\n\t\t\t\t\t}\n\t\t\t\t\ttarget[position++] = 0xdb;\n\t\t\t\t\ttargetView.setUint32(position, length);\n\t\t\t\t\tposition += 4;\n\t\t\t\t}\n\t\t\t\tposition += length;\n\t\t\t} else if (type === 'number') {\n\t\t\t\tif (value >>> 0 === value) {// positive integer, 32-bit or less\n\t\t\t\t\t// positive uint\n\t\t\t\t\tif (value < 0x20 || (value < 0x80 && this.useRecords === false) || (value < 0x40 && !this.randomAccessStructure)) {\n\t\t\t\t\t\ttarget[position++] = value;\n\t\t\t\t\t} else if (value < 0x100) {\n\t\t\t\t\t\ttarget[position++] = 0xcc;\n\t\t\t\t\t\ttarget[position++] = value;\n\t\t\t\t\t} else if (value < 0x10000) {\n\t\t\t\t\t\ttarget[position++] = 0xcd;\n\t\t\t\t\t\ttarget[position++] = value >> 8;\n\t\t\t\t\t\ttarget[position++] = value & 0xff;\n\t\t\t\t\t} else {\n\t\t\t\t\t\ttarget[position++] = 0xce;\n\t\t\t\t\t\ttargetView.setUint32(position, value);\n\t\t\t\t\t\tposition += 4;\n\t\t\t\t\t}\n\t\t\t\t} else if (value >> 0 === value) { // negative integer\n\t\t\t\t\tif (value >= -0x20) {\n\t\t\t\t\t\ttarget[position++] = 0x100 + value;\n\t\t\t\t\t} else if (value >= -0x80) {\n\t\t\t\t\t\ttarget[position++] = 0xd0;\n\t\t\t\t\t\ttarget[position++] = value + 0x100;\n\t\t\t\t\t} else if (value >= -0x8000) {\n\t\t\t\t\t\ttarget[position++] = 0xd1;\n\t\t\t\t\t\ttargetView.setInt16(position, value);\n\t\t\t\t\t\tposition += 2;\n\t\t\t\t\t} else {\n\t\t\t\t\t\ttarget[position++] = 0xd2;\n\t\t\t\t\t\ttargetView.setInt32(position, value);\n\t\t\t\t\t\tposition += 4;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tlet useFloat32;\n\t\t\t\t\tif ((useFloat32 = this.useFloat32) > 0 && value < 0x100000000 && value >= -0x80000000) {\n\t\t\t\t\t\ttarget[position++] = 0xca;\n\t\t\t\t\t\ttargetView.setFloat32(position, value);\n\t\t\t\t\t\tlet xShifted;\n\t\t\t\t\t\tif (useFloat32 < 4 ||\n\t\t\t\t\t\t\t\t// this checks for rounding of numbers that were encoded in 32-bit float to nearest significant decimal digit that could be preserved\n\t\t\t\t\t\t\t\t((xShifted = value * mult10[((target[position] & 0x7f) << 1) | (target[position + 1] >> 7)]) >> 0) === xShifted) {\n\t\t\t\t\t\t\tposition += 4;\n\t\t\t\t\t\t\treturn\n\t\t\t\t\t\t} else\n\t\t\t\t\t\t\tposition--; // move back into position for writing a double\n\t\t\t\t\t}\n\t\t\t\t\ttarget[position++] = 0xcb;\n\t\t\t\t\ttargetView.setFloat64(position, value);\n\t\t\t\t\tposition += 8;\n\t\t\t\t}\n\t\t\t} else if (type === 'object' || type === 'function') {\n\t\t\t\tif (!value)\n\t\t\t\t\ttarget[position++] = 0xc0;\n\t\t\t\telse {\n\t\t\t\t\tif (referenceMap) {\n\t\t\t\t\t\tlet referee = referenceMap.get(value);\n\t\t\t\t\t\tif (referee) {\n\t\t\t\t\t\t\tif (!referee.id) {\n\t\t\t\t\t\t\t\tlet idsToInsert = referenceMap.idsToInsert || (referenceMap.idsToInsert = []);\n\t\t\t\t\t\t\t\treferee.id = idsToInsert.push(referee);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\ttarget[position++] = 0xd6; // fixext 4\n\t\t\t\t\t\t\ttarget[position++] = 0x70; // \"p\" for pointer\n\t\t\t\t\t\t\ttargetView.setUint32(position, referee.id);\n\t\t\t\t\t\t\tposition += 4;\n\t\t\t\t\t\t\treturn\n\t\t\t\t\t\t} else\n\t\t\t\t\t\t\treferenceMap.set(value, { offset: position - start });\n\t\t\t\t\t}\n\t\t\t\t\tlet constructor = value.constructor;\n\t\t\t\t\tif (constructor === Object) {\n\t\t\t\t\t\twriteObject(value);\n\t\t\t\t\t} else if (constructor === Array) {\n\t\t\t\t\t\tpackArray(value);\n\t\t\t\t\t} else if (constructor === Map) {\n\t\t\t\t\t\tif (this.mapAsEmptyObject) target[position++] = 0x80;\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tlength = value.size;\n\t\t\t\t\t\t\tif (length < 0x10) {\n\t\t\t\t\t\t\t\ttarget[position++] = 0x80 | length;\n\t\t\t\t\t\t\t} else if (length < 0x10000) {\n\t\t\t\t\t\t\t\ttarget[position++] = 0xde;\n\t\t\t\t\t\t\t\ttarget[position++] = length >> 8;\n\t\t\t\t\t\t\t\ttarget[position++] = length & 0xff;\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\ttarget[position++] = 0xdf;\n\t\t\t\t\t\t\t\ttargetView.setUint32(position, length);\n\t\t\t\t\t\t\t\tposition += 4;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tfor (let [key, entryValue] of value) {\n\t\t\t\t\t\t\t\tpack(key);\n\t\t\t\t\t\t\t\tpack(entryValue);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tfor (let i = 0, l = extensions.length; i < l; i++) {\n\t\t\t\t\t\t\tlet extensionClass = extensionClasses[i];\n\t\t\t\t\t\t\tif (value instanceof extensionClass) {\n\t\t\t\t\t\t\t\tlet extension = extensions[i];\n\t\t\t\t\t\t\t\tif (extension.write) {\n\t\t\t\t\t\t\t\t\tif (extension.type) {\n\t\t\t\t\t\t\t\t\t\ttarget[position++] = 0xd4; // one byte \"tag\" extension\n\t\t\t\t\t\t\t\t\t\ttarget[position++] = extension.type;\n\t\t\t\t\t\t\t\t\t\ttarget[position++] = 0;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tlet writeResult = extension.write.call(this, value);\n\t\t\t\t\t\t\t\t\tif (writeResult === value) { // avoid infinite recursion\n\t\t\t\t\t\t\t\t\t\tif (Array.isArray(value)) {\n\t\t\t\t\t\t\t\t\t\t\tpackArray(value);\n\t\t\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t\t\twriteObject(value);\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t\tpack(writeResult);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\treturn\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tlet currentTarget = target;\n\t\t\t\t\t\t\t\tlet currentTargetView = targetView;\n\t\t\t\t\t\t\t\tlet currentPosition = position;\n\t\t\t\t\t\t\t\ttarget = null;\n\t\t\t\t\t\t\t\tlet result;\n\t\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\t\tresult = extension.pack.call(this, value, (size) => {\n\t\t\t\t\t\t\t\t\t\t// restore target and use it\n\t\t\t\t\t\t\t\t\t\ttarget = currentTarget;\n\t\t\t\t\t\t\t\t\t\tcurrentTarget = null;\n\t\t\t\t\t\t\t\t\t\tposition += size;\n\t\t\t\t\t\t\t\t\t\tif (position > safeEnd)\n\t\t\t\t\t\t\t\t\t\t\tmakeRoom(position);\n\t\t\t\t\t\t\t\t\t\treturn {\n\t\t\t\t\t\t\t\t\t\t\ttarget, targetView, position: position - size\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}, pack);\n\t\t\t\t\t\t\t\t} finally {\n\t\t\t\t\t\t\t\t\t// restore current target information (unless already restored)\n\t\t\t\t\t\t\t\t\tif (currentTarget) {\n\t\t\t\t\t\t\t\t\t\ttarget = currentTarget;\n\t\t\t\t\t\t\t\t\t\ttargetView = currentTargetView;\n\t\t\t\t\t\t\t\t\t\tposition = currentPosition;\n\t\t\t\t\t\t\t\t\t\tsafeEnd = target.length - 10;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tif (result) {\n\t\t\t\t\t\t\t\t\tif (result.length + position > safeEnd)\n\t\t\t\t\t\t\t\t\t\tmakeRoom(result.length + position);\n\t\t\t\t\t\t\t\t\tposition = writeExtensionData(result, target, position, extension.type);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\treturn\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\t// check isArray after extensions, because extensions can extend Array\n\t\t\t\t\t\tif (Array.isArray(value)) {\n\t\t\t\t\t\t\tpackArray(value);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t// use this as an alternate mechanism for expressing how to serialize\n\t\t\t\t\t\t\tif (value.toJSON) {\n\t\t\t\t\t\t\t\tconst json = value.toJSON();\n\t\t\t\t\t\t\t\t// if for some reason value.toJSON returns itself it'll loop forever\n\t\t\t\t\t\t\t\tif (json !== value)\n\t\t\t\t\t\t\t\t\treturn pack(json)\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t// if there is a writeFunction, use it, otherwise just encode as undefined\n\t\t\t\t\t\t\tif (type === 'function')\n\t\t\t\t\t\t\t\treturn pack(this.writeFunction && this.writeFunction(value));\n\n\t\t\t\t\t\t\t// no extension found, write as plain object\n\t\t\t\t\t\t\twriteObject(value);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else if (type === 'boolean') {\n\t\t\t\ttarget[position++] = value ? 0xc3 : 0xc2;\n\t\t\t} else if (type === 'bigint') {\n\t\t\t\tif (value < (BigInt(1)<<BigInt(63)) && value >= -(BigInt(1)<<BigInt(63))) {\n\t\t\t\t\t// use a signed int as long as it fits\n\t\t\t\t\ttarget[position++] = 0xd3;\n\t\t\t\t\ttargetView.setBigInt64(position, value);\n\t\t\t\t} else if (value < (BigInt(1)<<BigInt(64)) && value > 0) {\n\t\t\t\t\t// if we can fit an unsigned int, use that\n\t\t\t\t\ttarget[position++] = 0xcf;\n\t\t\t\t\ttargetView.setBigUint64(position, value);\n\t\t\t\t} else {\n\t\t\t\t\t// overflow\n\t\t\t\t\tif (this.largeBigIntToFloat) {\n\t\t\t\t\t\ttarget[position++] = 0xcb;\n\t\t\t\t\t\ttargetView.setFloat64(position, Number(value));\n\t\t\t\t\t} else if (this.useBigIntExtension && value < 2n**(1023n) && value > -(2n**(1023n))) {\n\t\t\t\t\t\ttarget[position++] = 0xc7;\n\t\t\t\t\t\tposition++;\n\t\t\t\t\t\ttarget[position++] = 0x42; // \"B\" for BigInt\n\t\t\t\t\t\tlet bytes = [];\n\t\t\t\t\t\tlet alignedSign;\n\t\t\t\t\t\tdo {\n\t\t\t\t\t\t\tlet byte = value & 0xffn;\n\t\t\t\t\t\t\talignedSign = (byte & 0x80n) === (value < 0n ? 0x80n : 0n);\n\t\t\t\t\t\t\tbytes.push(byte);\n\t\t\t\t\t\t\tvalue >>= 8n;\n\t\t\t\t\t\t} while (!((value === 0n || value === -1n) && alignedSign));\n\t\t\t\t\t\ttarget[position-2] = bytes.length;\n\t\t\t\t\t\tfor (let i = bytes.length; i > 0;) {\n\t\t\t\t\t\t\ttarget[position++] = Number(bytes[--i]);\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn\n\t\t\t\t\t} else {\n\t\t\t\t\t\tthrow new RangeError(value + ' was too large to fit in MessagePack 64-bit integer format, use' +\n\t\t\t\t\t\t\t' useBigIntExtension or set largeBigIntToFloat to convert to float-64')\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tposition += 8;\n\t\t\t} else if (type === 'undefined') {\n\t\t\t\tif (this.encodeUndefinedAsNil)\n\t\t\t\t\ttarget[position++] = 0xc0;\n\t\t\t\telse {\n\t\t\t\t\ttarget[position++] = 0xd4; // a number of implementations use fixext1 with type 0, data 0 to denote undefined, so we follow suite\n\t\t\t\t\ttarget[position++] = 0;\n\t\t\t\t\ttarget[position++] = 0;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tthrow new Error('Unknown type: ' + type)\n\t\t\t}\n\t\t};\n\n\t\tconst writePlainObject = (this.variableMapSize || this.coercibleKeyAsNumber || this.skipValues) ? (object) => {\n\t\t\t// this method is slightly slower, but generates \"preferred serialization\" (optimally small for smaller objects)\n\t\t\tlet keys;\n\t\t\tif (this.skipValues) {\n\t\t\t\tkeys = [];\n\t\t\t\tfor (let key in object) {\n\t\t\t\t\tif ((typeof object.hasOwnProperty !== 'function' || object.hasOwnProperty(key)) &&\n\t\t\t\t\t\t!this.skipValues.includes(object[key]))\n\t\t\t\t\t\tkeys.push(key);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tkeys = Object.keys(object);\n\t\t\t}\n\t\t\tlet length = keys.length;\n\t\t\tif (length < 0x10) {\n\t\t\t\ttarget[position++] = 0x80 | length;\n\t\t\t} else if (length < 0x10000) {\n\t\t\t\ttarget[position++] = 0xde;\n\t\t\t\ttarget[position++] = length >> 8;\n\t\t\t\ttarget[position++] = length & 0xff;\n\t\t\t} else {\n\t\t\t\ttarget[position++] = 0xdf;\n\t\t\t\ttargetView.setUint32(position, length);\n\t\t\t\tposition += 4;\n\t\t\t}\n\t\t\tlet key;\n\t\t\tif (this.coercibleKeyAsNumber) {\n\t\t\t\tfor (let i = 0; i < length; i++) {\n\t\t\t\t\tkey = keys[i];\n\t\t\t\t\tlet num = Number(key);\n\t\t\t\t\tpack(isNaN(num) ? key : num);\n\t\t\t\t\tpack(object[key]);\n\t\t\t\t}\n\n\t\t\t} else {\n\t\t\t\tfor (let i = 0; i < length; i++) {\n\t\t\t\t\tpack(key = keys[i]);\n\t\t\t\t\tpack(object[key]);\n\t\t\t\t}\n\t\t\t}\n\t\t} :\n\t\t(object) => {\n\t\t\ttarget[position++] = 0xde; // always using map 16, so we can preallocate and set the length afterwards\n\t\t\tlet objectOffset = position - start;\n\t\t\tposition += 2;\n\t\t\tlet size = 0;\n\t\t\tfor (let key in object) {\n\t\t\t\tif (typeof object.hasOwnProperty !== 'function' || object.hasOwnProperty(key)) {\n\t\t\t\t\tpack(key);\n\t\t\t\t\tpack(object[key]);\n\t\t\t\t\tsize++;\n\t\t\t\t}\n\t\t\t}\n\t\t\ttarget[objectOffset++ + start] = size >> 8;\n\t\t\ttarget[objectOffset + start] = size & 0xff;\n\t\t};\n\n\t\tconst writeRecord = this.useRecords === false ? writePlainObject :\n\t\t(options.progressiveRecords && !useTwoByteRecords) ?  // this is about 2% faster for highly stable structures, since it only requires one for-in loop (but much more expensive when new structure needs to be written)\n\t\t(object) => {\n\t\t\tlet nextTransition, transition = structures.transitions || (structures.transitions = Object.create(null));\n\t\t\tlet objectOffset = position++ - start;\n\t\t\tlet wroteKeys;\n\t\t\tfor (let key in object) {\n\t\t\t\tif (typeof object.hasOwnProperty !== 'function' || object.hasOwnProperty(key)) {\n\t\t\t\t\tnextTransition = transition[key];\n\t\t\t\t\tif (nextTransition)\n\t\t\t\t\t\ttransition = nextTransition;\n\t\t\t\t\telse {\n\t\t\t\t\t\t// record doesn't exist, create full new record and insert it\n\t\t\t\t\t\tlet keys = Object.keys(object);\n\t\t\t\t\t\tlet lastTransition = transition;\n\t\t\t\t\t\ttransition = structures.transitions;\n\t\t\t\t\t\tlet newTransitions = 0;\n\t\t\t\t\t\tfor (let i = 0, l = keys.length; i < l; i++) {\n\t\t\t\t\t\t\tlet key = keys[i];\n\t\t\t\t\t\t\tnextTransition = transition[key];\n\t\t\t\t\t\t\tif (!nextTransition) {\n\t\t\t\t\t\t\t\tnextTransition = transition[key] = Object.create(null);\n\t\t\t\t\t\t\t\tnewTransitions++;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\ttransition = nextTransition;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (objectOffset + start + 1 == position) {\n\t\t\t\t\t\t\t// first key, so we don't need to insert, we can just write record directly\n\t\t\t\t\t\t\tposition--;\n\t\t\t\t\t\t\tnewRecord(transition, keys, newTransitions);\n\t\t\t\t\t\t} else // otherwise we need to insert the record, moving existing data after the record\n\t\t\t\t\t\t\tinsertNewRecord(transition, keys, objectOffset, newTransitions);\n\t\t\t\t\t\twroteKeys = true;\n\t\t\t\t\t\ttransition = lastTransition[key];\n\t\t\t\t\t}\n\t\t\t\t\tpack(object[key]);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!wroteKeys) {\n\t\t\t\tlet recordId = transition[RECORD_SYMBOL];\n\t\t\t\tif (recordId)\n\t\t\t\t\ttarget[objectOffset + start] = recordId;\n\t\t\t\telse\n\t\t\t\t\tinsertNewRecord(transition, Object.keys(object), objectOffset, 0);\n\t\t\t}\n\t\t} :\n\t\t(object) => {\n\t\t\tlet nextTransition, transition = structures.transitions || (structures.transitions = Object.create(null));\n\t\t\tlet newTransitions = 0;\n\t\t\tfor (let key in object) if (typeof object.hasOwnProperty !== 'function' || object.hasOwnProperty(key)) {\n\t\t\t\tnextTransition = transition[key];\n\t\t\t\tif (!nextTransition) {\n\t\t\t\t\tnextTransition = transition[key] = Object.create(null);\n\t\t\t\t\tnewTransitions++;\n\t\t\t\t}\n\t\t\t\ttransition = nextTransition;\n\t\t\t}\n\t\t\tlet recordId = transition[RECORD_SYMBOL];\n\t\t\tif (recordId) {\n\t\t\t\tif (recordId >= 0x60 && useTwoByteRecords) {\n\t\t\t\t\ttarget[position++] = ((recordId -= 0x60) & 0x1f) + 0x60;\n\t\t\t\t\ttarget[position++] = recordId >> 5;\n\t\t\t\t} else\n\t\t\t\t\ttarget[position++] = recordId;\n\t\t\t} else {\n\t\t\t\tnewRecord(transition, transition.__keys__ || Object.keys(object), newTransitions);\n\t\t\t}\n\t\t\t// now write the values\n\t\t\tfor (let key in object)\n\t\t\t\tif (typeof object.hasOwnProperty !== 'function' || object.hasOwnProperty(key)) {\n\t\t\t\t\tpack(object[key]);\n\t\t\t\t}\n\t\t};\n\n\t\t// create reference to useRecords if useRecords is a function\n\t\tconst checkUseRecords = typeof this.useRecords == 'function' && this.useRecords;\n\n\t\tconst writeObject = checkUseRecords ? (object) => {\n\t\t\tcheckUseRecords(object) ? writeRecord(object) : writePlainObject(object);\n\t\t} : writeRecord;\n\n\t\tconst makeRoom = (end) => {\n\t\t\tlet newSize;\n\t\t\tif (end > 0x1000000) {\n\t\t\t\t// special handling for really large buffers\n\t\t\t\tif ((end - start) > MAX_BUFFER_SIZE)\n\t\t\t\t\tthrow new Error('Packed buffer would be larger than maximum buffer size')\n\t\t\t\tnewSize = Math.min(MAX_BUFFER_SIZE,\n\t\t\t\t\tMath.round(Math.max((end - start) * (end > 0x4000000 ? 1.25 : 2), 0x400000) / 0x1000) * 0x1000);\n\t\t\t} else // faster handling for smaller buffers\n\t\t\t\tnewSize = ((Math.max((end - start) << 2, target.length - 1) >> 12) + 1) << 12;\n\t\t\tlet newBuffer = new ByteArrayAllocate(newSize);\n\t\t\ttargetView = newBuffer.dataView || (newBuffer.dataView = new DataView(newBuffer.buffer, 0, newSize));\n\t\t\tend = Math.min(end, target.length);\n\t\t\tif (target.copy)\n\t\t\t\ttarget.copy(newBuffer, 0, start, end);\n\t\t\telse\n\t\t\t\tnewBuffer.set(target.slice(start, end));\n\t\t\tposition -= start;\n\t\t\tstart = 0;\n\t\t\tsafeEnd = newBuffer.length - 10;\n\t\t\treturn target = newBuffer\n\t\t};\n\t\tconst newRecord = (transition, keys, newTransitions) => {\n\t\t\tlet recordId = structures.nextId;\n\t\t\tif (!recordId)\n\t\t\t\trecordId = 0x40;\n\t\t\tif (recordId < sharedLimitId && this.shouldShareStructure && !this.shouldShareStructure(keys)) {\n\t\t\t\trecordId = structures.nextOwnId;\n\t\t\t\tif (!(recordId < maxStructureId))\n\t\t\t\t\trecordId = sharedLimitId;\n\t\t\t\tstructures.nextOwnId = recordId + 1;\n\t\t\t} else {\n\t\t\t\tif (recordId >= maxStructureId)// cycle back around\n\t\t\t\t\trecordId = sharedLimitId;\n\t\t\t\tstructures.nextId = recordId + 1;\n\t\t\t}\n\t\t\tlet highByte = keys.highByte = recordId >= 0x60 && useTwoByteRecords ? (recordId - 0x60) >> 5 : -1;\n\t\t\ttransition[RECORD_SYMBOL] = recordId;\n\t\t\ttransition.__keys__ = keys;\n\t\t\tstructures[recordId - 0x40] = keys;\n\n\t\t\tif (recordId < sharedLimitId) {\n\t\t\t\tkeys.isShared = true;\n\t\t\t\tstructures.sharedLength = recordId - 0x3f;\n\t\t\t\thasSharedUpdate = true;\n\t\t\t\tif (highByte >= 0) {\n\t\t\t\t\ttarget[position++] = (recordId & 0x1f) + 0x60;\n\t\t\t\t\ttarget[position++] = highByte;\n\t\t\t\t} else {\n\t\t\t\t\ttarget[position++] = recordId;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (highByte >= 0) {\n\t\t\t\t\ttarget[position++] = 0xd5; // fixext 2\n\t\t\t\t\ttarget[position++] = 0x72; // \"r\" record defintion extension type\n\t\t\t\t\ttarget[position++] = (recordId & 0x1f) + 0x60;\n\t\t\t\t\ttarget[position++] = highByte;\n\t\t\t\t} else {\n\t\t\t\t\ttarget[position++] = 0xd4; // fixext 1\n\t\t\t\t\ttarget[position++] = 0x72; // \"r\" record defintion extension type\n\t\t\t\t\ttarget[position++] = recordId;\n\t\t\t\t}\n\n\t\t\t\tif (newTransitions)\n\t\t\t\t\ttransitionsCount += serializationsSinceTransitionRebuild * newTransitions;\n\t\t\t\t// record the removal of the id, we can maintain our shared structure\n\t\t\t\tif (recordIdsToRemove.length >= maxOwnStructures)\n\t\t\t\t\trecordIdsToRemove.shift()[RECORD_SYMBOL] = 0; // we are cycling back through, and have to remove old ones\n\t\t\t\trecordIdsToRemove.push(transition);\n\t\t\t\tpack(keys);\n\t\t\t}\n\t\t};\n\t\tconst insertNewRecord = (transition, keys, insertionOffset, newTransitions) => {\n\t\t\tlet mainTarget = target;\n\t\t\tlet mainPosition = position;\n\t\t\tlet mainSafeEnd = safeEnd;\n\t\t\tlet mainStart = start;\n\t\t\ttarget = keysTarget;\n\t\t\tposition = 0;\n\t\t\tstart = 0;\n\t\t\tif (!target)\n\t\t\t\tkeysTarget = target = new ByteArrayAllocate(8192);\n\t\t\tsafeEnd = target.length - 10;\n\t\t\tnewRecord(transition, keys, newTransitions);\n\t\t\tkeysTarget = target;\n\t\t\tlet keysPosition = position;\n\t\t\ttarget = mainTarget;\n\t\t\tposition = mainPosition;\n\t\t\tsafeEnd = mainSafeEnd;\n\t\t\tstart = mainStart;\n\t\t\tif (keysPosition > 1) {\n\t\t\t\tlet newEnd = position + keysPosition - 1;\n\t\t\t\tif (newEnd > safeEnd)\n\t\t\t\t\tmakeRoom(newEnd);\n\t\t\t\tlet insertionPosition = insertionOffset + start;\n\t\t\t\ttarget.copyWithin(insertionPosition + keysPosition, insertionPosition + 1, position);\n\t\t\t\ttarget.set(keysTarget.slice(0, keysPosition), insertionPosition);\n\t\t\t\tposition = newEnd;\n\t\t\t} else {\n\t\t\t\ttarget[insertionOffset + start] = keysTarget[0];\n\t\t\t}\n\t\t};\n\t\tconst writeStruct = (object) => {\n\t\t\tlet newPosition = writeStructSlots(object, target, start, position, structures, makeRoom, (value, newPosition, notifySharedUpdate) => {\n\t\t\t\tif (notifySharedUpdate)\n\t\t\t\t\treturn hasSharedUpdate = true;\n\t\t\t\tposition = newPosition;\n\t\t\t\tlet startTarget = target;\n\t\t\t\tpack(value);\n\t\t\t\tresetStructures();\n\t\t\t\tif (startTarget !== target) {\n\t\t\t\t\treturn { position, targetView, target }; // indicate the buffer was re-allocated\n\t\t\t\t}\n\t\t\t\treturn position;\n\t\t\t}, this);\n\t\t\tif (newPosition === 0) // bail and go to a msgpack object\n\t\t\t\treturn writeObject(object);\n\t\t\tposition = newPosition;\n\t\t};\n\t}\n\tuseBuffer(buffer) {\n\t\t// this means we are finished using our own buffer and we can write over it safely\n\t\ttarget = buffer;\n\t\ttarget.dataView || (target.dataView = new DataView(target.buffer, target.byteOffset, target.byteLength));\n\t\tposition = 0;\n\t}\n\tset position (value) {\n\t\tposition = value;\n\t}\n\tget position() {\n\t\treturn position;\n\t}\n\tclearSharedData() {\n\t\tif (this.structures)\n\t\t\tthis.structures = [];\n\t\tif (this.typedStructs)\n\t\t\tthis.typedStructs = [];\n\t}\n}\n\nextensionClasses = [ Date, Set, Error, RegExp, ArrayBuffer, Object.getPrototypeOf(Uint8Array.prototype).constructor /*TypedArray*/, C1Type ];\nextensions = [{\n\tpack(date, allocateForWrite, pack) {\n\t\tlet seconds = date.getTime() / 1000;\n\t\tif ((this.useTimestamp32 || date.getMilliseconds() === 0) && seconds >= 0 && seconds < 0x100000000) {\n\t\t\t// Timestamp 32\n\t\t\tlet { target, targetView, position} = allocateForWrite(6);\n\t\t\ttarget[position++] = 0xd6;\n\t\t\ttarget[position++] = 0xff;\n\t\t\ttargetView.setUint32(position, seconds);\n\t\t} else if (seconds > 0 && seconds < 0x100000000) {\n\t\t\t// Timestamp 64\n\t\t\tlet { target, targetView, position} = allocateForWrite(10);\n\t\t\ttarget[position++] = 0xd7;\n\t\t\ttarget[position++] = 0xff;\n\t\t\ttargetView.setUint32(position, date.getMilliseconds() * 4000000 + ((seconds / 1000 / 0x100000000) >> 0));\n\t\t\ttargetView.setUint32(position + 4, seconds);\n\t\t} else if (isNaN(seconds)) {\n\t\t\tif (this.onInvalidDate) {\n\t\t\t\tallocateForWrite(0);\n\t\t\t\treturn pack(this.onInvalidDate())\n\t\t\t}\n\t\t\t// Intentionally invalid timestamp\n\t\t\tlet { target, targetView, position} = allocateForWrite(3);\n\t\t\ttarget[position++] = 0xd4;\n\t\t\ttarget[position++] = 0xff;\n\t\t\ttarget[position++] = 0xff;\n\t\t} else {\n\t\t\t// Timestamp 96\n\t\t\tlet { target, targetView, position} = allocateForWrite(15);\n\t\t\ttarget[position++] = 0xc7;\n\t\t\ttarget[position++] = 12;\n\t\t\ttarget[position++] = 0xff;\n\t\t\ttargetView.setUint32(position, date.getMilliseconds() * 1000000);\n\t\t\ttargetView.setBigInt64(position + 4, BigInt(Math.floor(seconds)));\n\t\t}\n\t}\n}, {\n\tpack(set, allocateForWrite, pack) {\n\t\tif (this.setAsEmptyObject) {\n\t\t\tallocateForWrite(0);\n\t\t\treturn pack({})\n\t\t}\n\t\tlet array = Array.from(set);\n\t\tlet { target, position} = allocateForWrite(this.moreTypes ? 3 : 0);\n\t\tif (this.moreTypes) {\n\t\t\ttarget[position++] = 0xd4;\n\t\t\ttarget[position++] = 0x73; // 's' for Set\n\t\t\ttarget[position++] = 0;\n\t\t}\n\t\tpack(array);\n\t}\n}, {\n\tpack(error, allocateForWrite, pack) {\n\t\tlet { target, position} = allocateForWrite(this.moreTypes ? 3 : 0);\n\t\tif (this.moreTypes) {\n\t\t\ttarget[position++] = 0xd4;\n\t\t\ttarget[position++] = 0x65; // 'e' for error\n\t\t\ttarget[position++] = 0;\n\t\t}\n\t\tpack([ error.name, error.message, error.cause ]);\n\t}\n}, {\n\tpack(regex, allocateForWrite, pack) {\n\t\tlet { target, position} = allocateForWrite(this.moreTypes ? 3 : 0);\n\t\tif (this.moreTypes) {\n\t\t\ttarget[position++] = 0xd4;\n\t\t\ttarget[position++] = 0x78; // 'x' for regeXp\n\t\t\ttarget[position++] = 0;\n\t\t}\n\t\tpack([ regex.source, regex.flags ]);\n\t}\n}, {\n\tpack(arrayBuffer, allocateForWrite) {\n\t\tif (this.moreTypes)\n\t\t\twriteExtBuffer(arrayBuffer, 0x10, allocateForWrite);\n\t\telse\n\t\t\twriteBuffer(hasNodeBuffer$1 ? Buffer.from(arrayBuffer) : new Uint8Array(arrayBuffer), allocateForWrite);\n\t}\n}, {\n\tpack(typedArray, allocateForWrite) {\n\t\tlet constructor = typedArray.constructor;\n\t\tif (constructor !== ByteArray && this.moreTypes)\n\t\t\twriteExtBuffer(typedArray, typedArrays.indexOf(constructor.name), allocateForWrite);\n\t\telse\n\t\t\twriteBuffer(typedArray, allocateForWrite);\n\t}\n}, {\n\tpack(c1, allocateForWrite) { // specific 0xC1 object\n\t\tlet { target, position} = allocateForWrite(1);\n\t\ttarget[position] = 0xc1;\n\t}\n}];\n\nfunction writeExtBuffer(typedArray, type, allocateForWrite, encode) {\n\tlet length = typedArray.byteLength;\n\tif (length + 1 < 0x100) {\n\t\tvar { target, position } = allocateForWrite(4 + length);\n\t\ttarget[position++] = 0xc7;\n\t\ttarget[position++] = length + 1;\n\t} else if (length + 1 < 0x10000) {\n\t\tvar { target, position } = allocateForWrite(5 + length);\n\t\ttarget[position++] = 0xc8;\n\t\ttarget[position++] = (length + 1) >> 8;\n\t\ttarget[position++] = (length + 1) & 0xff;\n\t} else {\n\t\tvar { target, position, targetView } = allocateForWrite(7 + length);\n\t\ttarget[position++] = 0xc9;\n\t\ttargetView.setUint32(position, length + 1); // plus one for the type byte\n\t\tposition += 4;\n\t}\n\ttarget[position++] = 0x74; // \"t\" for typed array\n\ttarget[position++] = type;\n\tif (!typedArray.buffer) typedArray = new Uint8Array(typedArray);\n\ttarget.set(new Uint8Array(typedArray.buffer, typedArray.byteOffset, typedArray.byteLength), position);\n}\nfunction writeBuffer(buffer, allocateForWrite) {\n\tlet length = buffer.byteLength;\n\tvar target, position;\n\tif (length < 0x100) {\n\t\tvar { target, position } = allocateForWrite(length + 2);\n\t\ttarget[position++] = 0xc4;\n\t\ttarget[position++] = length;\n\t} else if (length < 0x10000) {\n\t\tvar { target, position } = allocateForWrite(length + 3);\n\t\ttarget[position++] = 0xc5;\n\t\ttarget[position++] = length >> 8;\n\t\ttarget[position++] = length & 0xff;\n\t} else {\n\t\tvar { target, position, targetView } = allocateForWrite(length + 5);\n\t\ttarget[position++] = 0xc6;\n\t\ttargetView.setUint32(position, length);\n\t\tposition += 4;\n\t}\n\ttarget.set(buffer, position);\n}\n\nfunction writeExtensionData(result, target, position, type) {\n\tlet length = result.length;\n\tswitch (length) {\n\t\tcase 1:\n\t\t\ttarget[position++] = 0xd4;\n\t\t\tbreak\n\t\tcase 2:\n\t\t\ttarget[position++] = 0xd5;\n\t\t\tbreak\n\t\tcase 4:\n\t\t\ttarget[position++] = 0xd6;\n\t\t\tbreak\n\t\tcase 8:\n\t\t\ttarget[position++] = 0xd7;\n\t\t\tbreak\n\t\tcase 16:\n\t\t\ttarget[position++] = 0xd8;\n\t\t\tbreak\n\t\tdefault:\n\t\t\tif (length < 0x100) {\n\t\t\t\ttarget[position++] = 0xc7;\n\t\t\t\ttarget[position++] = length;\n\t\t\t} else if (length < 0x10000) {\n\t\t\t\ttarget[position++] = 0xc8;\n\t\t\t\ttarget[position++] = length >> 8;\n\t\t\t\ttarget[position++] = length & 0xff;\n\t\t\t} else {\n\t\t\t\ttarget[position++] = 0xc9;\n\t\t\t\ttarget[position++] = length >> 24;\n\t\t\t\ttarget[position++] = (length >> 16) & 0xff;\n\t\t\t\ttarget[position++] = (length >> 8) & 0xff;\n\t\t\t\ttarget[position++] = length & 0xff;\n\t\t\t}\n\t}\n\ttarget[position++] = type;\n\ttarget.set(result, position);\n\tposition += length;\n\treturn position\n}\n\nfunction insertIds(serialized, idsToInsert) {\n\t// insert the ids that need to be referenced for structured clones\n\tlet nextId;\n\tlet distanceToMove = idsToInsert.length * 6;\n\tlet lastEnd = serialized.length - distanceToMove;\n\twhile (nextId = idsToInsert.pop()) {\n\t\tlet offset = nextId.offset;\n\t\tlet id = nextId.id;\n\t\tserialized.copyWithin(offset + distanceToMove, offset, lastEnd);\n\t\tdistanceToMove -= 6;\n\t\tlet position = offset + distanceToMove;\n\t\tserialized[position++] = 0xd6;\n\t\tserialized[position++] = 0x69; // 'i'\n\t\tserialized[position++] = id >> 24;\n\t\tserialized[position++] = (id >> 16) & 0xff;\n\t\tserialized[position++] = (id >> 8) & 0xff;\n\t\tserialized[position++] = id & 0xff;\n\t\tlastEnd = offset;\n\t}\n\treturn serialized\n}\n\nfunction writeBundles(start, pack, incrementPosition) {\n\tif (bundledStrings.length > 0) {\n\t\ttargetView.setUint32(bundledStrings.position + start, position + incrementPosition - bundledStrings.position - start);\n\t\tbundledStrings.stringsPosition = position - start;\n\t\tlet writeStrings = bundledStrings;\n\t\tbundledStrings = null;\n\t\tpack(writeStrings[0]);\n\t\tpack(writeStrings[1]);\n\t}\n}\n\nfunction addExtension(extension) {\n\tif (extension.Class) {\n\t\tif (!extension.pack && !extension.write)\n\t\t\tthrow new Error('Extension has no pack or write function')\n\t\tif (extension.pack && !extension.type)\n\t\t\tthrow new Error('Extension has no type (numeric code to identify the extension)')\n\t\textensionClasses.unshift(extension.Class);\n\t\textensions.unshift(extension);\n\t}\n\taddExtension$1(extension);\n}\nfunction prepareStructures$1(structures, packr) {\n\tstructures.isCompatible = (existingStructures) => {\n\t\tlet compatible = !existingStructures || ((packr.lastNamedStructuresLength || 0) === existingStructures.length);\n\t\tif (!compatible) // we want to merge these existing structures immediately since we already have it and we are in the right transaction\n\t\t\tpackr._mergeStructures(existingStructures);\n\t\treturn compatible;\n\t};\n\treturn structures\n}\nfunction setWriteStructSlots(writeSlots, makeStructures) {\n\twriteStructSlots = writeSlots;\n\tprepareStructures$1 = makeStructures;\n}\n\nlet defaultPackr = new Packr({ useRecords: false });\nconst pack = defaultPackr.pack;\nconst encode = defaultPackr.pack;\nconst Encoder = Packr;\nconst { NEVER, ALWAYS, DECIMAL_ROUND, DECIMAL_FIT } = FLOAT32_OPTIONS;\nconst REUSE_BUFFER_MODE = 512;\nconst RESET_BUFFER_MODE = 1024;\nconst RESERVE_START_SPACE = 2048;\n\nconst ASCII = 3; // the MIBenum from https://www.iana.org/assignments/character-sets/character-sets.xhtml (and other character encodings could be referenced by MIBenum)\nconst NUMBER = 0;\nconst UTF8 = 2;\nconst OBJECT_DATA = 1;\nconst DATE = 16;\nconst TYPE_NAMES = ['num', 'object', 'string', 'ascii'];\nTYPE_NAMES[DATE] = 'date';\nconst float32Headers = [false, true, true, false, false, true, true, false];\nlet evalSupported;\ntry {\n\tnew Function('');\n\tevalSupported = true;\n} catch(error) {\n\t// if eval variants are not supported, do not create inline object readers ever\n}\n\nlet updatedPosition;\nconst hasNodeBuffer = typeof Buffer !== 'undefined';\nlet textEncoder, currentSource;\ntry {\n\ttextEncoder = new TextEncoder();\n} catch (error) {}\nconst encodeUtf8 = hasNodeBuffer ? function(target, string, position) {\n\treturn target.utf8Write(string, position, 0xffffffff)\n} : (textEncoder && textEncoder.encodeInto) ?\n\tfunction(target, string, position) {\n\t\treturn textEncoder.encodeInto(string, target.subarray(position)).written\n\t} : false;\nsetWriteStructSlots(writeStruct, prepareStructures);\nfunction writeStruct(object, target, encodingStart, position, structures, makeRoom, pack, packr) {\n\tlet typedStructs = packr.typedStructs || (packr.typedStructs = []);\n\t// note that we rely on pack.js to load stored structures before we get to this point\n\tlet targetView = target.dataView;\n\tlet refsStartPosition = (typedStructs.lastStringStart || 100) + position;\n\tlet safeEnd = target.length - 10;\n\tlet start = position;\n\tif (position > safeEnd) {\n\t\ttarget = makeRoom(position);\n\t\ttargetView = target.dataView;\n\t\tposition -= encodingStart;\n\t\tstart -= encodingStart;\n\t\trefsStartPosition -= encodingStart;\n\t\tencodingStart = 0;\n\t\tsafeEnd = target.length - 10;\n\t}\n\n\tlet refOffset, refPosition = refsStartPosition;\n\n\tlet transition = typedStructs.transitions || (typedStructs.transitions = Object.create(null));\n\tlet nextId = typedStructs.nextId || typedStructs.length;\n\tlet headerSize =\n\t\tnextId < 0xf ? 1 :\n\t\t\tnextId < 0xf0 ? 2 :\n\t\t\t\tnextId < 0xf000 ? 3 :\n\t\t\t\t\tnextId < 0xf00000 ? 4 : 0;\n\tif (headerSize === 0)\n\t\treturn 0;\n\tposition += headerSize;\n\tlet queuedReferences = [];\n\tlet usedAscii0;\n\tlet keyIndex = 0;\n\tfor (let key in object) {\n\t\tlet value = object[key];\n\t\tlet nextTransition = transition[key];\n\t\tif (!nextTransition) {\n\t\t\ttransition[key] = nextTransition = {\n\t\t\t\tkey,\n\t\t\t\tparent: transition,\n\t\t\t\tenumerationOffset: 0,\n\t\t\t\tascii0: null,\n\t\t\t\tascii8: null,\n\t\t\t\tnum8: null,\n\t\t\t\tstring16: null,\n\t\t\t\tobject16: null,\n\t\t\t\tnum32: null,\n\t\t\t\tfloat64: null,\n\t\t\t\tdate64: null\n\t\t\t};\n\t\t}\n\t\tif (position > safeEnd) {\n\t\t\ttarget = makeRoom(position);\n\t\t\ttargetView = target.dataView;\n\t\t\tposition -= encodingStart;\n\t\t\tstart -= encodingStart;\n\t\t\trefsStartPosition -= encodingStart;\n\t\t\trefPosition -= encodingStart;\n\t\t\tencodingStart = 0;\n\t\t\tsafeEnd = target.length - 10;\n\t\t}\n\t\tswitch (typeof value) {\n\t\t\tcase 'number':\n\t\t\t\tlet number = value;\n\t\t\t\t// first check to see if we are using a lot of ids and should default to wide/common format\n\t\t\t\tif (nextId < 200 || !nextTransition.num64) {\n\t\t\t\t\tif (number >> 0 === number && number < 0x20000000 && number > -0x1f000000) {\n\t\t\t\t\t\tif (number < 0xf6 && number >= 0 && (nextTransition.num8 && !(nextId > 200 && nextTransition.num32) || number < 0x20 && !nextTransition.num32)) {\n\t\t\t\t\t\t\ttransition = nextTransition.num8 || createTypeTransition(nextTransition, NUMBER, 1);\n\t\t\t\t\t\t\ttarget[position++] = number;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\ttransition = nextTransition.num32 || createTypeTransition(nextTransition, NUMBER, 4);\n\t\t\t\t\t\t\ttargetView.setUint32(position, number, true);\n\t\t\t\t\t\t\tposition += 4;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t} else if (number < 0x100000000 && number >= -0x80000000) {\n\t\t\t\t\t\ttargetView.setFloat32(position, number, true);\n\t\t\t\t\t\tif (float32Headers[target[position + 3] >>> 5]) {\n\t\t\t\t\t\t\tlet xShifted;\n\t\t\t\t\t\t\t// this checks for rounding of numbers that were encoded in 32-bit float to nearest significant decimal digit that could be preserved\n\t\t\t\t\t\t\tif (((xShifted = number * mult10[((target[position + 3] & 0x7f) << 1) | (target[position + 2] >> 7)]) >> 0) === xShifted) {\n\t\t\t\t\t\t\t\ttransition = nextTransition.num32 || createTypeTransition(nextTransition, NUMBER, 4);\n\t\t\t\t\t\t\t\tposition += 4;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\ttransition = nextTransition.num64 || createTypeTransition(nextTransition, NUMBER, 8);\n\t\t\t\ttargetView.setFloat64(position, number, true);\n\t\t\t\tposition += 8;\n\t\t\t\tbreak;\n\t\t\tcase 'string':\n\t\t\t\tlet strLength = value.length;\n\t\t\t\trefOffset = refPosition - refsStartPosition;\n\t\t\t\tif ((strLength << 2) + refPosition > safeEnd) {\n\t\t\t\t\ttarget = makeRoom((strLength << 2) + refPosition);\n\t\t\t\t\ttargetView = target.dataView;\n\t\t\t\t\tposition -= encodingStart;\n\t\t\t\t\tstart -= encodingStart;\n\t\t\t\t\trefsStartPosition -= encodingStart;\n\t\t\t\t\trefPosition -= encodingStart;\n\t\t\t\t\tencodingStart = 0;\n\t\t\t\t\tsafeEnd = target.length - 10;\n\t\t\t\t}\n\t\t\t\tif (strLength > ((0xff00 + refOffset) >> 2)) {\n\t\t\t\t\tqueuedReferences.push(key, value, position - start);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tlet isNotAscii;\n\t\t\t\tlet strStart = refPosition;\n\t\t\t\tif (strLength < 0x40) {\n\t\t\t\t\tlet i, c1, c2;\n\t\t\t\t\tfor (i = 0; i < strLength; i++) {\n\t\t\t\t\t\tc1 = value.charCodeAt(i);\n\t\t\t\t\t\tif (c1 < 0x80) {\n\t\t\t\t\t\t\ttarget[refPosition++] = c1;\n\t\t\t\t\t\t} else if (c1 < 0x800) {\n\t\t\t\t\t\t\tisNotAscii = true;\n\t\t\t\t\t\t\ttarget[refPosition++] = c1 >> 6 | 0xc0;\n\t\t\t\t\t\t\ttarget[refPosition++] = c1 & 0x3f | 0x80;\n\t\t\t\t\t\t} else if (\n\t\t\t\t\t\t\t(c1 & 0xfc00) === 0xd800 &&\n\t\t\t\t\t\t\t((c2 = value.charCodeAt(i + 1)) & 0xfc00) === 0xdc00\n\t\t\t\t\t\t) {\n\t\t\t\t\t\t\tisNotAscii = true;\n\t\t\t\t\t\t\tc1 = 0x10000 + ((c1 & 0x03ff) << 10) + (c2 & 0x03ff);\n\t\t\t\t\t\t\ti++;\n\t\t\t\t\t\t\ttarget[refPosition++] = c1 >> 18 | 0xf0;\n\t\t\t\t\t\t\ttarget[refPosition++] = c1 >> 12 & 0x3f | 0x80;\n\t\t\t\t\t\t\ttarget[refPosition++] = c1 >> 6 & 0x3f | 0x80;\n\t\t\t\t\t\t\ttarget[refPosition++] = c1 & 0x3f | 0x80;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tisNotAscii = true;\n\t\t\t\t\t\t\ttarget[refPosition++] = c1 >> 12 | 0xe0;\n\t\t\t\t\t\t\ttarget[refPosition++] = c1 >> 6 & 0x3f | 0x80;\n\t\t\t\t\t\t\ttarget[refPosition++] = c1 & 0x3f | 0x80;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\trefPosition += encodeUtf8(target, value, refPosition);\n\t\t\t\t\tisNotAscii = refPosition - strStart > strLength;\n\t\t\t\t}\n\t\t\t\tif (refOffset < 0xa0 || (refOffset < 0xf6 && (nextTransition.ascii8 || nextTransition.string8))) {\n\t\t\t\t\t// short strings\n\t\t\t\t\tif (isNotAscii) {\n\t\t\t\t\t\tif (!(transition = nextTransition.string8)) {\n\t\t\t\t\t\t\tif (typedStructs.length > 10 && (transition = nextTransition.ascii8)) {\n\t\t\t\t\t\t\t\t// we can safely change ascii to utf8 in place since they are compatible\n\t\t\t\t\t\t\t\ttransition.__type = UTF8;\n\t\t\t\t\t\t\t\tnextTransition.ascii8 = null;\n\t\t\t\t\t\t\t\tnextTransition.string8 = transition;\n\t\t\t\t\t\t\t\tpack(null, 0, true); // special call to notify that structures have been updated\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\ttransition = createTypeTransition(nextTransition, UTF8, 1);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t} else if (refOffset === 0 && !usedAscii0) {\n\t\t\t\t\t\tusedAscii0 = true;\n\t\t\t\t\t\ttransition = nextTransition.ascii0 || createTypeTransition(nextTransition, ASCII, 0);\n\t\t\t\t\t\tbreak; // don't increment position\n\t\t\t\t\t}// else ascii:\n\t\t\t\t\telse if (!(transition = nextTransition.ascii8) && !(typedStructs.length > 10 && (transition = nextTransition.string8)))\n\t\t\t\t\t\ttransition = createTypeTransition(nextTransition, ASCII, 1);\n\t\t\t\t\ttarget[position++] = refOffset;\n\t\t\t\t} else {\n\t\t\t\t\t// TODO: Enable ascii16 at some point, but get the logic right\n\t\t\t\t\t//if (isNotAscii)\n\t\t\t\t\t\ttransition = nextTransition.string16 || createTypeTransition(nextTransition, UTF8, 2);\n\t\t\t\t\t//else\n\t\t\t\t\t\t//transition = nextTransition.ascii16 || createTypeTransition(nextTransition, ASCII, 2);\n\t\t\t\t\ttargetView.setUint16(position, refOffset, true);\n\t\t\t\t\tposition += 2;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 'object':\n\t\t\t\tif (value) {\n\t\t\t\t\tif (value.constructor === Date) {\n\t\t\t\t\t\ttransition = nextTransition.date64 || createTypeTransition(nextTransition, DATE, 8);\n\t\t\t\t\t\ttargetView.setFloat64(position, value.getTime(), true);\n\t\t\t\t\t\tposition += 8;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tqueuedReferences.push(key, value, keyIndex);\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t} else { // null\n\t\t\t\t\tnextTransition = anyType(nextTransition, position, targetView, -10); // match CBOR with this\n\t\t\t\t\tif (nextTransition) {\n\t\t\t\t\t\ttransition = nextTransition;\n\t\t\t\t\t\tposition = updatedPosition;\n\t\t\t\t\t} else queuedReferences.push(key, value, keyIndex);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 'boolean':\n\t\t\t\ttransition = nextTransition.num8 || nextTransition.ascii8 || createTypeTransition(nextTransition, NUMBER, 1);\n\t\t\t\ttarget[position++] = value ? 0xf9 : 0xf8; // match CBOR with these\n\t\t\t\tbreak;\n\t\t\tcase 'undefined':\n\t\t\t\tnextTransition = anyType(nextTransition, position, targetView, -9); // match CBOR with this\n\t\t\t\tif (nextTransition) {\n\t\t\t\t\ttransition = nextTransition;\n\t\t\t\t\tposition = updatedPosition;\n\t\t\t\t} else queuedReferences.push(key, value, keyIndex);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tqueuedReferences.push(key, value, keyIndex);\n\t\t}\n\t\tkeyIndex++;\n\t}\n\n\tfor (let i = 0, l = queuedReferences.length; i < l;) {\n\t\tlet key = queuedReferences[i++];\n\t\tlet value = queuedReferences[i++];\n\t\tlet propertyIndex = queuedReferences[i++];\n\t\tlet nextTransition = transition[key];\n\t\tif (!nextTransition) {\n\t\t\ttransition[key] = nextTransition = {\n\t\t\t\tkey,\n\t\t\t\tparent: transition,\n\t\t\t\tenumerationOffset: propertyIndex - keyIndex,\n\t\t\t\tascii0: null,\n\t\t\t\tascii8: null,\n\t\t\t\tnum8: null,\n\t\t\t\tstring16: null,\n\t\t\t\tobject16: null,\n\t\t\t\tnum32: null,\n\t\t\t\tfloat64: null\n\t\t\t};\n\t\t}\n\t\tlet newPosition;\n\t\tif (value) {\n\t\t\t/*if (typeof value === 'string') { // TODO: we could re-enable long strings\n\t\t\t\tif (position + value.length * 3 > safeEnd) {\n\t\t\t\t\ttarget = makeRoom(position + value.length * 3);\n\t\t\t\t\tposition -= start;\n\t\t\t\t\ttargetView = target.dataView;\n\t\t\t\t\tstart = 0;\n\t\t\t\t}\n\t\t\t\tnewPosition = position + target.utf8Write(value, position, 0xffffffff);\n\t\t\t} else { */\n\t\t\tlet size;\n\t\t\trefOffset = refPosition - refsStartPosition;\n\t\t\tif (refOffset < 0xff00) {\n\t\t\t\ttransition = nextTransition.object16;\n\t\t\t\tif (transition)\n\t\t\t\t\tsize = 2;\n\t\t\t\telse if ((transition = nextTransition.object32))\n\t\t\t\t\tsize = 4;\n\t\t\t\telse {\n\t\t\t\t\ttransition = createTypeTransition(nextTransition, OBJECT_DATA, 2);\n\t\t\t\t\tsize = 2;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\ttransition = nextTransition.object32 || createTypeTransition(nextTransition, OBJECT_DATA, 4);\n\t\t\t\tsize = 4;\n\t\t\t}\n\t\t\tnewPosition = pack(value, refPosition);\n\t\t\t//}\n\t\t\tif (typeof newPosition === 'object') {\n\t\t\t\t// re-allocated\n\t\t\t\trefPosition = newPosition.position;\n\t\t\t\ttargetView = newPosition.targetView;\n\t\t\t\ttarget = newPosition.target;\n\t\t\t\trefsStartPosition -= encodingStart;\n\t\t\t\tposition -= encodingStart;\n\t\t\t\tstart -= encodingStart;\n\t\t\t\tencodingStart = 0;\n\t\t\t} else\n\t\t\t\trefPosition = newPosition;\n\t\t\tif (size === 2) {\n\t\t\t\ttargetView.setUint16(position, refOffset, true);\n\t\t\t\tposition += 2;\n\t\t\t} else {\n\t\t\t\ttargetView.setUint32(position, refOffset, true);\n\t\t\t\tposition += 4;\n\t\t\t}\n\t\t} else { // null or undefined\n\t\t\ttransition = nextTransition.object16 || createTypeTransition(nextTransition, OBJECT_DATA, 2);\n\t\t\ttargetView.setInt16(position, value === null ? -10 : -9, true);\n\t\t\tposition += 2;\n\t\t}\n\t\tkeyIndex++;\n\t}\n\n\n\tlet recordId = transition[RECORD_SYMBOL];\n\tif (recordId == null) {\n\t\trecordId = packr.typedStructs.length;\n\t\tlet structure = [];\n\t\tlet nextTransition = transition;\n\t\tlet key, type;\n\t\twhile ((type = nextTransition.__type) !== undefined) {\n\t\t\tlet size = nextTransition.__size;\n\t\t\tnextTransition = nextTransition.__parent;\n\t\t\tkey = nextTransition.key;\n\t\t\tlet property = [type, size, key];\n\t\t\tif (nextTransition.enumerationOffset)\n\t\t\t\tproperty.push(nextTransition.enumerationOffset);\n\t\t\tstructure.push(property);\n\t\t\tnextTransition = nextTransition.parent;\n\t\t}\n\t\tstructure.reverse();\n\t\ttransition[RECORD_SYMBOL] = recordId;\n\t\tpackr.typedStructs[recordId] = structure;\n\t\tpack(null, 0, true); // special call to notify that structures have been updated\n\t}\n\n\n\tswitch (headerSize) {\n\t\tcase 1:\n\t\t\tif (recordId >= 0x10) return 0;\n\t\t\ttarget[start] = recordId + 0x20;\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tif (recordId >= 0x100) return 0;\n\t\t\ttarget[start] = 0x38;\n\t\t\ttarget[start + 1] = recordId;\n\t\t\tbreak;\n\t\tcase 3:\n\t\t\tif (recordId >= 0x10000) return 0;\n\t\t\ttarget[start] = 0x39;\n\t\t\ttargetView.setUint16(start + 1, recordId, true);\n\t\t\tbreak;\n\t\tcase 4:\n\t\t\tif (recordId >= 0x1000000) return 0;\n\t\t\ttargetView.setUint32(start, (recordId << 8) + 0x3a, true);\n\t\t\tbreak;\n\t}\n\n\tif (position < refsStartPosition) {\n\t\tif (refsStartPosition === refPosition)\n\t\t\treturn position; // no refs\n\t\t// adjust positioning\n\t\ttarget.copyWithin(position, refsStartPosition, refPosition);\n\t\trefPosition += position - refsStartPosition;\n\t\ttypedStructs.lastStringStart = position - start;\n\t} else if (position > refsStartPosition) {\n\t\tif (refsStartPosition === refPosition)\n\t\t\treturn position; // no refs\n\t\ttypedStructs.lastStringStart = position - start;\n\t\treturn writeStruct(object, target, encodingStart, start, structures, makeRoom, pack, packr);\n\t}\n\treturn refPosition;\n}\nfunction anyType(transition, position, targetView, value) {\n\tlet nextTransition;\n\tif ((nextTransition = transition.ascii8 || transition.num8)) {\n\t\ttargetView.setInt8(position, value, true);\n\t\tupdatedPosition = position + 1;\n\t\treturn nextTransition;\n\t}\n\tif ((nextTransition = transition.string16 || transition.object16)) {\n\t\ttargetView.setInt16(position, value, true);\n\t\tupdatedPosition = position + 2;\n\t\treturn nextTransition;\n\t}\n\tif (nextTransition = transition.num32) {\n\t\ttargetView.setUint32(position, 0xe0000100 + value, true);\n\t\tupdatedPosition = position + 4;\n\t\treturn nextTransition;\n\t}\n\t// transition.float64\n\tif (nextTransition = transition.num64) {\n\t\ttargetView.setFloat64(position, NaN, true);\n\t\ttargetView.setInt8(position, value);\n\t\tupdatedPosition = position + 8;\n\t\treturn nextTransition;\n\t}\n\tupdatedPosition = position;\n\t// TODO: can we do an \"any\" type where we defer the decision?\n\treturn;\n}\nfunction createTypeTransition(transition, type, size) {\n\tlet typeName = TYPE_NAMES[type] + (size << 3);\n\tlet newTransition = transition[typeName] || (transition[typeName] = Object.create(null));\n\tnewTransition.__type = type;\n\tnewTransition.__size = size;\n\tnewTransition.__parent = transition;\n\treturn newTransition;\n}\nfunction onLoadedStructures(sharedData) {\n\tif (!(sharedData instanceof Map))\n\t\treturn sharedData;\n\tlet typed = sharedData.get('typed') || [];\n\tif (Object.isFrozen(typed))\n\t\ttyped = typed.map(structure => structure.slice(0));\n\tlet named = sharedData.get('named');\n\tlet transitions = Object.create(null);\n\tfor (let i = 0, l = typed.length; i < l; i++) {\n\t\tlet structure = typed[i];\n\t\tlet transition = transitions;\n\t\tfor (let [type, size, key] of structure) {\n\t\t\tlet nextTransition = transition[key];\n\t\t\tif (!nextTransition) {\n\t\t\t\ttransition[key] = nextTransition = {\n\t\t\t\t\tkey,\n\t\t\t\t\tparent: transition,\n\t\t\t\t\tenumerationOffset: 0,\n\t\t\t\t\tascii0: null,\n\t\t\t\t\tascii8: null,\n\t\t\t\t\tnum8: null,\n\t\t\t\t\tstring16: null,\n\t\t\t\t\tobject16: null,\n\t\t\t\t\tnum32: null,\n\t\t\t\t\tfloat64: null,\n\t\t\t\t\tdate64: null,\n\t\t\t\t};\n\t\t\t}\n\t\t\ttransition = createTypeTransition(nextTransition, type, size);\n\t\t}\n\t\ttransition[RECORD_SYMBOL] = i;\n\t}\n\ttyped.transitions = transitions;\n\tthis.typedStructs = typed;\n\tthis.lastTypedStructuresLength = typed.length;\n\treturn named;\n}\nvar sourceSymbol = Symbol.for('source');\nfunction readStruct(src, position, srcEnd, unpackr) {\n\tlet recordId = src[position++] - 0x20;\n\tif (recordId >= 24) {\n\t\tswitch(recordId) {\n\t\t\tcase 24: recordId = src[position++]; break;\n\t\t\t// little endian:\n\t\t\tcase 25: recordId = src[position++] + (src[position++] << 8); break;\n\t\t\tcase 26: recordId = src[position++] + (src[position++] << 8) + (src[position++] << 16); break;\n\t\t\tcase 27: recordId = src[position++] + (src[position++] << 8) + (src[position++] << 16) + (src[position++] << 24); break;\n\t\t}\n\t}\n\tlet structure = unpackr.typedStructs && unpackr.typedStructs[recordId];\n\tif (!structure) {\n\t\t// copy src buffer because getStructures will override it\n\t\tsrc = Uint8Array.prototype.slice.call(src, position, srcEnd);\n\t\tsrcEnd -= position;\n\t\tposition = 0;\n\t\tif (!unpackr.getStructures)\n\t\t\tthrow new Error(`Reference to shared structure ${recordId} without getStructures method`);\n\t\tunpackr._mergeStructures(unpackr.getStructures());\n\t\tif (!unpackr.typedStructs)\n\t\t\tthrow new Error('Could not find any shared typed structures');\n\t\tunpackr.lastTypedStructuresLength = unpackr.typedStructs.length;\n\t\tstructure = unpackr.typedStructs[recordId];\n\t\tif (!structure)\n\t\t\tthrow new Error('Could not find typed structure ' + recordId);\n\t}\n\tvar construct = structure.construct;\n\tif (!construct) {\n\t\tconstruct = structure.construct = function LazyObject() {\n\t\t};\n\t\tvar prototype = construct.prototype;\n\t\tlet properties = [];\n\t\tlet currentOffset = 0;\n\t\tlet lastRefProperty;\n\t\tfor (let i = 0, l = structure.length; i < l; i++) {\n\t\t\tlet definition = structure[i];\n\t\t\tlet [ type, size, key, enumerationOffset ] = definition;\n\t\t\tif (key === '__proto__')\n\t\t\t\tkey = '__proto_';\n\t\t\tlet property = {\n\t\t\t\tkey,\n\t\t\t\toffset: currentOffset,\n\t\t\t};\n\t\t\tif (enumerationOffset)\n\t\t\t\tproperties.splice(i + enumerationOffset, 0, property);\n\t\t\telse\n\t\t\t\tproperties.push(property);\n\t\t\tlet getRef;\n\t\t\tswitch(size) { // TODO: Move into a separate function\n\t\t\t\tcase 0: getRef = () => 0; break;\n\t\t\t\tcase 1:\n\t\t\t\t\tgetRef = (source, position) => {\n\t\t\t\t\t\tlet ref = source.bytes[position + property.offset];\n\t\t\t\t\t\treturn ref >= 0xf6 ? toConstant(ref) : ref;\n\t\t\t\t\t};\n\t\t\t\t\tbreak;\n\t\t\t\tcase 2:\n\t\t\t\t\tgetRef = (source, position) => {\n\t\t\t\t\t\tlet src = source.bytes;\n\t\t\t\t\t\tlet dataView = src.dataView || (src.dataView = new DataView(src.buffer, src.byteOffset, src.byteLength));\n\t\t\t\t\t\tlet ref = dataView.getUint16(position + property.offset, true);\n\t\t\t\t\t\treturn ref >= 0xff00 ? toConstant(ref & 0xff) : ref;\n\t\t\t\t\t};\n\t\t\t\t\tbreak;\n\t\t\t\tcase 4:\n\t\t\t\t\tgetRef = (source, position) => {\n\t\t\t\t\t\tlet src = source.bytes;\n\t\t\t\t\t\tlet dataView = src.dataView || (src.dataView = new DataView(src.buffer, src.byteOffset, src.byteLength));\n\t\t\t\t\t\tlet ref = dataView.getUint32(position + property.offset, true);\n\t\t\t\t\t\treturn ref >= 0xffffff00 ? toConstant(ref & 0xff) : ref;\n\t\t\t\t\t};\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tproperty.getRef = getRef;\n\t\t\tcurrentOffset += size;\n\t\t\tlet get;\n\t\t\tswitch(type) {\n\t\t\t\tcase ASCII:\n\t\t\t\t\tif (lastRefProperty && !lastRefProperty.next)\n\t\t\t\t\t\tlastRefProperty.next = property;\n\t\t\t\t\tlastRefProperty = property;\n\t\t\t\t\tproperty.multiGetCount = 0;\n\t\t\t\t\tget = function(source) {\n\t\t\t\t\t\tlet src = source.bytes;\n\t\t\t\t\t\tlet position = source.position;\n\t\t\t\t\t\tlet refStart = currentOffset + position;\n\t\t\t\t\t\tlet ref = getRef(source, position);\n\t\t\t\t\t\tif (typeof ref !== 'number') return ref;\n\n\t\t\t\t\t\tlet end, next = property.next;\n\t\t\t\t\t\twhile(next) {\n\t\t\t\t\t\t\tend = next.getRef(source, position);\n\t\t\t\t\t\t\tif (typeof end === 'number')\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\tend = null;\n\t\t\t\t\t\t\tnext = next.next;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (end == null)\n\t\t\t\t\t\t\tend = source.bytesEnd - refStart;\n\t\t\t\t\t\tif (source.srcString) {\n\t\t\t\t\t\t\treturn source.srcString.slice(ref, end);\n\t\t\t\t\t\t}\n\t\t\t\t\t\t/*if (property.multiGetCount > 0) {\n\t\t\t\t\t\t\tlet asciiEnd;\n\t\t\t\t\t\t\tnext = firstRefProperty;\n\t\t\t\t\t\t\tlet dataView = src.dataView || (src.dataView = new DataView(src.buffer, src.byteOffset, src.byteLength));\n\t\t\t\t\t\t\tdo {\n\t\t\t\t\t\t\t\tasciiEnd = dataView.getUint16(source.position + next.offset, true);\n\t\t\t\t\t\t\t\tif (asciiEnd < 0xff00)\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\t\tasciiEnd = null;\n\t\t\t\t\t\t\t} while((next = next.next));\n\t\t\t\t\t\t\tif (asciiEnd == null)\n\t\t\t\t\t\t\t\tasciiEnd = source.bytesEnd - refStart\n\t\t\t\t\t\t\tsource.srcString = src.toString('latin1', refStart, refStart + asciiEnd);\n\t\t\t\t\t\t\treturn source.srcString.slice(ref, end);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (source.prevStringGet) {\n\t\t\t\t\t\t\tsource.prevStringGet.multiGetCount += 2;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tsource.prevStringGet = property;\n\t\t\t\t\t\t\tproperty.multiGetCount--;\n\t\t\t\t\t\t}*/\n\t\t\t\t\t\treturn readString(src, ref + refStart, end - ref);\n\t\t\t\t\t\t//return src.toString('latin1', ref + refStart, end + refStart);\n\t\t\t\t\t};\n\t\t\t\t\tbreak;\n\t\t\t\tcase UTF8: case OBJECT_DATA:\n\t\t\t\t\tif (lastRefProperty && !lastRefProperty.next)\n\t\t\t\t\t\tlastRefProperty.next = property;\n\t\t\t\t\tlastRefProperty = property;\n\t\t\t\t\tget = function(source) {\n\t\t\t\t\t\tlet position = source.position;\n\t\t\t\t\t\tlet refStart = currentOffset + position;\n\t\t\t\t\t\tlet ref = getRef(source, position);\n\t\t\t\t\t\tif (typeof ref !== 'number') return ref;\n\t\t\t\t\t\tlet src = source.bytes;\n\t\t\t\t\t\tlet end, next = property.next;\n\t\t\t\t\t\twhile(next) {\n\t\t\t\t\t\t\tend = next.getRef(source, position);\n\t\t\t\t\t\t\tif (typeof end === 'number')\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\tend = null;\n\t\t\t\t\t\t\tnext = next.next;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (end == null)\n\t\t\t\t\t\t\tend = source.bytesEnd - refStart;\n\t\t\t\t\t\tif (type === UTF8) {\n\t\t\t\t\t\t\treturn src.toString('utf8', ref + refStart, end + refStart);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tcurrentSource = source;\n\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\treturn unpackr.unpack(src, { start: ref + refStart, end: end + refStart });\n\t\t\t\t\t\t\t} finally {\n\t\t\t\t\t\t\t\tcurrentSource = null;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t};\n\t\t\t\t\tbreak;\n\t\t\t\tcase NUMBER:\n\t\t\t\t\tswitch(size) {\n\t\t\t\t\t\tcase 4:\n\t\t\t\t\t\t\tget = function (source) {\n\t\t\t\t\t\t\t\tlet src = source.bytes;\n\t\t\t\t\t\t\t\tlet dataView = src.dataView || (src.dataView = new DataView(src.buffer, src.byteOffset, src.byteLength));\n\t\t\t\t\t\t\t\tlet position = source.position + property.offset;\n\t\t\t\t\t\t\t\tlet value = dataView.getInt32(position, true);\n\t\t\t\t\t\t\t\tif (value < 0x20000000) {\n\t\t\t\t\t\t\t\t\tif (value > -0x1f000000)\n\t\t\t\t\t\t\t\t\t\treturn value;\n\t\t\t\t\t\t\t\t\tif (value > -0x20000000)\n\t\t\t\t\t\t\t\t\t\treturn toConstant(value & 0xff);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tlet fValue = dataView.getFloat32(position, true);\n\t\t\t\t\t\t\t\t// this does rounding of numbers that were encoded in 32-bit float to nearest significant decimal digit that could be preserved\n\t\t\t\t\t\t\t\tlet multiplier = mult10[((src[position + 3] & 0x7f) << 1) | (src[position + 2] >> 7)];\n\t\t\t\t\t\t\t\treturn ((multiplier * fValue + (fValue > 0 ? 0.5 : -0.5)) >> 0) / multiplier;\n\t\t\t\t\t\t\t};\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 8:\n\t\t\t\t\t\t\tget = function (source) {\n\t\t\t\t\t\t\t\tlet src = source.bytes;\n\t\t\t\t\t\t\t\tlet dataView = src.dataView || (src.dataView = new DataView(src.buffer, src.byteOffset, src.byteLength));\n\t\t\t\t\t\t\t\tlet value = dataView.getFloat64(source.position + property.offset, true);\n\t\t\t\t\t\t\t\tif (isNaN(value)) {\n\t\t\t\t\t\t\t\t\tlet byte = src[source.position + property.offset];\n\t\t\t\t\t\t\t\t\tif (byte >= 0xf6)\n\t\t\t\t\t\t\t\t\t\treturn toConstant(byte);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\treturn value;\n\t\t\t\t\t\t\t};\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 1:\n\t\t\t\t\t\t\tget = function (source) {\n\t\t\t\t\t\t\t\tlet src = source.bytes;\n\t\t\t\t\t\t\t\tlet value = src[source.position + property.offset];\n\t\t\t\t\t\t\t\treturn value < 0xf6 ? value : toConstant(value);\n\t\t\t\t\t\t\t};\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase DATE:\n\t\t\t\t\tget = function (source) {\n\t\t\t\t\t\tlet src = source.bytes;\n\t\t\t\t\t\tlet dataView = src.dataView || (src.dataView = new DataView(src.buffer, src.byteOffset, src.byteLength));\n\t\t\t\t\t\treturn new Date(dataView.getFloat64(source.position + property.offset, true));\n\t\t\t\t\t};\n\t\t\t\t\tbreak;\n\n\t\t\t}\n\t\t\tproperty.get = get;\n\t\t}\n\t\t// TODO: load the srcString for faster string decoding on toJSON\n\t\tif (evalSupported) {\n\t\t\tlet objectLiteralProperties = [];\n\t\t\tlet args = [];\n\t\t\tlet i = 0;\n\t\t\tlet hasInheritedProperties;\n\t\t\tfor (let property of properties) { // assign in enumeration order\n\t\t\t\tif (unpackr.alwaysLazyProperty && unpackr.alwaysLazyProperty(property.key)) {\n\t\t\t\t\t// these properties are not eagerly evaluated and this can be used for creating properties\n\t\t\t\t\t// that are not serialized as JSON\n\t\t\t\t\thasInheritedProperties = true;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tObject.defineProperty(prototype, property.key, { get: withSource(property.get), enumerable: true });\n\t\t\t\tlet valueFunction = 'v' + i++;\n\t\t\t\targs.push(valueFunction);\n\t\t\t\tobjectLiteralProperties.push('[' + JSON.stringify(property.key) + ']:' + valueFunction + '(s)');\n\t\t\t}\n\t\t\tif (hasInheritedProperties) {\n\t\t\t\tobjectLiteralProperties.push('__proto__:this');\n\t\t\t}\n\t\t\tlet toObject = (new Function(...args, 'return function(s){return{' + objectLiteralProperties.join(',') + '}}')).apply(null, properties.map(prop => prop.get));\n\t\t\tObject.defineProperty(prototype, 'toJSON', {\n\t\t\t\tvalue(omitUnderscoredProperties) {\n\t\t\t\t\treturn toObject.call(this, this[sourceSymbol]);\n\t\t\t\t}\n\t\t\t});\n\t\t} else {\n\t\t\tObject.defineProperty(prototype, 'toJSON', {\n\t\t\t\tvalue(omitUnderscoredProperties) {\n\t\t\t\t\t// return an enumerable object with own properties to JSON stringify\n\t\t\t\t\tlet resolved = {};\n\t\t\t\t\tfor (let i = 0, l = properties.length; i < l; i++) {\n\t\t\t\t\t\t// TODO: check alwaysLazyProperty\n\t\t\t\t\t\tlet key = properties[i].key;\n\n\t\t\t\t\t\tresolved[key] = this[key];\n\t\t\t\t\t}\n\t\t\t\t\treturn resolved;\n\t\t\t\t},\n\t\t\t\t// not enumerable or anything\n\t\t\t});\n\t\t}\n\t}\n\tvar instance = new construct();\n\tinstance[sourceSymbol] = {\n\t\tbytes: src,\n\t\tposition,\n\t\tsrcString: '',\n\t\tbytesEnd: srcEnd\n\t};\n\treturn instance;\n}\nfunction toConstant(code) {\n\tswitch(code) {\n\t\tcase 0xf6: return null;\n\t\tcase 0xf7: return undefined;\n\t\tcase 0xf8: return false;\n\t\tcase 0xf9: return true;\n\t}\n\tthrow new Error('Unknown constant');\n}\nfunction withSource(get) {\n\treturn function() {\n\t\treturn get(this[sourceSymbol]);\n\t}\n}\n\nfunction saveState() {\n\tif (currentSource) {\n\t\tcurrentSource.bytes = Uint8Array.prototype.slice.call(currentSource.bytes, currentSource.position, currentSource.bytesEnd);\n\t\tcurrentSource.position = 0;\n\t\tcurrentSource.bytesEnd = currentSource.bytes.length;\n\t}\n}\nfunction prepareStructures(structures, packr) {\n\tif (packr.typedStructs) {\n\t\tlet structMap = new Map();\n\t\tstructMap.set('named', structures);\n\t\tstructMap.set('typed', packr.typedStructs);\n\t\tstructures = structMap;\n\t}\n\tlet lastTypedStructuresLength = packr.lastTypedStructuresLength || 0;\n\tstructures.isCompatible = existing => {\n\t\tlet compatible = true;\n\t\tif (existing instanceof Map) {\n\t\t\tlet named = existing.get('named') || [];\n\t\t\tif (named.length !== (packr.lastNamedStructuresLength || 0))\n\t\t\t\tcompatible = false;\n\t\t\tlet typed = existing.get('typed') || [];\n\t\t\tif (typed.length !== lastTypedStructuresLength)\n\t\t\t\tcompatible = false;\n\t\t} else if (existing instanceof Array || Array.isArray(existing)) {\n\t\t\tif (existing.length !== (packr.lastNamedStructuresLength || 0))\n\t\t\t\tcompatible = false;\n\t\t}\n\t\tif (!compatible)\n\t\t\tpackr._mergeStructures(existing);\n\t\treturn compatible;\n\t};\n\tpackr.lastTypedStructuresLength = packr.typedStructs && packr.typedStructs.length;\n\treturn structures;\n}\n\nsetReadStruct(readStruct, onLoadedStructures, saveState);\n\nclass PackrStream extends stream.Transform {\n\tconstructor(options) {\n\t\tif (!options)\n\t\t\toptions = {};\n\t\toptions.writableObjectMode = true;\n\t\tsuper(options);\n\t\toptions.sequential = true;\n\t\tthis.packr = options.packr || new Packr(options);\n\t}\n\t_transform(value, encoding, callback) {\n\t\tthis.push(this.packr.pack(value));\n\t\tcallback();\n\t}\n}\n\nclass UnpackrStream extends stream.Transform {\n\tconstructor(options) {\n\t\tif (!options)\n\t\t\toptions = {};\n\t\toptions.objectMode = true;\n\t\tsuper(options);\n\t\toptions.structures = [];\n\t\tthis.unpackr = options.unpackr || new Unpackr(options);\n\t}\n\t_transform(chunk, encoding, callback) {\n\t\tif (this.incompleteBuffer) {\n\t\t\tchunk = Buffer.concat([this.incompleteBuffer, chunk]);\n\t\t\tthis.incompleteBuffer = null;\n\t\t}\n\t\tlet values;\n\t\ttry {\n\t\t\tvalues = this.unpackr.unpackMultiple(chunk);\n\t\t} catch(error) {\n\t\t\tif (error.incomplete) {\n\t\t\t\tthis.incompleteBuffer = chunk.slice(error.lastPosition);\n\t\t\t\tvalues = error.values;\n\t\t\t}\n\t\t\telse\n\t\t\t\tthrow error\n\t\t} finally {\n\t\t\tfor (let value of values || []) {\n\t\t\t\tif (value === null)\n\t\t\t\t\tvalue = this.getNullValue();\n\t\t\t\tthis.push(value);\n\t\t\t}\n\t\t}\n\t\tif (callback) callback();\n\t}\n\tgetNullValue() {\n\t\treturn Symbol.for(null)\n\t}\n}\n\n/**\n * Given an Iterable first argument, returns an Iterable where each value is packed as a Buffer\n * If the argument is only Async Iterable, the return value will be an Async Iterable.\n * @param {Iterable|Iterator|AsyncIterable|AsyncIterator} objectIterator - iterable source, like a Readable object stream, an array, Set, or custom object\n * @param {options} [options] - msgpackr pack options\n * @returns {IterableIterator|Promise.<AsyncIterableIterator>}\n */\nfunction packIter (objectIterator, options = {}) {\n  if (!objectIterator || typeof objectIterator !== 'object') {\n    throw new Error('first argument must be an Iterable, Async Iterable, or a Promise for an Async Iterable')\n  } else if (typeof objectIterator[Symbol.iterator] === 'function') {\n    return packIterSync(objectIterator, options)\n  } else if (typeof objectIterator.then === 'function' || typeof objectIterator[Symbol.asyncIterator] === 'function') {\n    return packIterAsync(objectIterator, options)\n  } else {\n    throw new Error('first argument must be an Iterable, Async Iterable, Iterator, Async Iterator, or a Promise')\n  }\n}\n\nfunction * packIterSync (objectIterator, options) {\n  const packr = new Packr(options);\n  for (const value of objectIterator) {\n    yield packr.pack(value);\n  }\n}\n\nasync function * packIterAsync (objectIterator, options) {\n  const packr = new Packr(options);\n  for await (const value of objectIterator) {\n    yield packr.pack(value);\n  }\n}\n\n/**\n * Given an Iterable/Iterator input which yields buffers, returns an IterableIterator which yields sync decoded objects\n * Or, given an Async Iterable/Iterator which yields promises resolving in buffers, returns an AsyncIterableIterator.\n * @param {Iterable|Iterator|AsyncIterable|AsyncIterableIterator} bufferIterator\n * @param {object} [options] - unpackr options\n * @returns {IterableIterator|Promise.<AsyncIterableIterator}\n */\nfunction unpackIter (bufferIterator, options = {}) {\n  if (!bufferIterator || typeof bufferIterator !== 'object') {\n    throw new Error('first argument must be an Iterable, Async Iterable, Iterator, Async Iterator, or a promise')\n  }\n\n  const unpackr = new Unpackr(options);\n  let incomplete;\n  const parser = (chunk) => {\n    let yields;\n    // if there's incomplete data from previous chunk, concatinate and try again\n    if (incomplete) {\n      chunk = Buffer.concat([incomplete, chunk]);\n      incomplete = undefined;\n    }\n\n    try {\n      yields = unpackr.unpackMultiple(chunk);\n    } catch (err) {\n      if (err.incomplete) {\n        incomplete = chunk.slice(err.lastPosition);\n        yields = err.values;\n      } else {\n        throw err\n      }\n    }\n    return yields\n  };\n\n  if (typeof bufferIterator[Symbol.iterator] === 'function') {\n    return (function * iter () {\n      for (const value of bufferIterator) {\n        yield * parser(value);\n      }\n    })()\n  } else if (typeof bufferIterator[Symbol.asyncIterator] === 'function') {\n    return (async function * iter () {\n      for await (const value of bufferIterator) {\n        yield * parser(value);\n      }\n    })()\n  }\n}\nconst decodeIter = unpackIter;\nconst encodeIter = packIter;\n\nconst useRecords = false;\nconst mapsAsObjects = true;\n\nconst nativeAccelerationDisabled = process.env.MSGPACKR_NATIVE_ACCELERATION_DISABLED !== undefined && process.env.MSGPACKR_NATIVE_ACCELERATION_DISABLED.toLowerCase() === 'true';\n\nif (!nativeAccelerationDisabled) {\n\tlet extractor;\n\ttry {\n\t\tif (true)\n\t\t\textractor = __webpack_require__(/*! msgpackr-extract */ \"(rsc)/./node_modules/msgpackr-extract/index.js\");\n\t\telse\n\t\t\t{}\n\t\tif (extractor)\n\t\t\tsetExtractor(extractor.extractStrings);\n\t} catch (error) {\n\t\t// native module is optional\n\t}\n}\n\nexports.ALWAYS = ALWAYS;\nexports.C1 = C1;\nexports.DECIMAL_FIT = DECIMAL_FIT;\nexports.DECIMAL_ROUND = DECIMAL_ROUND;\nexports.Decoder = Decoder;\nexports.DecoderStream = UnpackrStream;\nexports.Encoder = Encoder;\nexports.EncoderStream = PackrStream;\nexports.FLOAT32_OPTIONS = FLOAT32_OPTIONS;\nexports.NEVER = NEVER;\nexports.Packr = Packr;\nexports.PackrStream = PackrStream;\nexports.Unpackr = Unpackr;\nexports.UnpackrStream = UnpackrStream;\nexports.addExtension = addExtension;\nexports.clearSource = clearSource;\nexports.decode = decode;\nexports.decodeIter = decodeIter;\nexports.encode = encode;\nexports.encodeIter = encodeIter;\nexports.mapsAsObjects = mapsAsObjects;\nexports.pack = pack;\nexports.roundFloat32 = roundFloat32;\nexports.unpack = unpack;\nexports.unpackMultiple = unpackMultiple;\nexports.useRecords = useRecords;\n//# sourceMappingURL=node.cjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvbXNncGFja3IvZGlzdC9ub2RlLmNqcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYixhQUFhLG1CQUFPLENBQUMsc0JBQVE7QUFDN0IsZUFBZSxtQkFBTyxDQUFDLHNCQUFROztBQUUvQjtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0RBQW9EO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0NBQStDLE9BQU87QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQSwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSxtRkFBbUYsTUFBTTtBQUN6RixLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFdBQVc7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0Esb0JBQW9CLFdBQVc7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLG1CQUFtQixXQUFXO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQSxRQUFRO0FBQ1IscUJBQXFCO0FBQ3JCO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHLE9BQU87QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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QTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFlBQVk7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxLQUFLO0FBQ0wsb0JBQW9CLFlBQVk7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQSw4QkFBOEI7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QyxPQUFPO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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O0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQztBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSwrQkFBK0IsbUJBQW1CO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBLFFBQVEsNENBQTRDO0FBQ3BEO0FBQ0E7QUFDQTs7QUFFQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLGVBQWU7QUFDaEM7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLGFBQWE7QUFDYixNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxNQUFNLE9BQU87QUFDYiwwRUFBMEU7QUFDMUU7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDO0FBQzlDO0FBQ0E7QUFDQSx3RUFBd0U7QUFDeEU7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSw4Q0FBOEMsTUFBTTtBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSyxPQUFPO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsSUFBSSxPQUFPO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QjtBQUN2Qjs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtB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S0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBTSxJQUE0QjtBQUNsQyxlQUFlLG1CQUFPLENBQUMsd0VBQWtCO0FBQ3pDO0FBQ0EsR0FBRyxFQUE0UDtBQUMvUDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQSxjQUFjO0FBQ2QsVUFBVTtBQUNWLG1CQUFtQjtBQUNuQixxQkFBcUI7QUFDckIsZUFBZTtBQUNmLHFCQUFxQjtBQUNyQixlQUFlO0FBQ2YscUJBQXFCO0FBQ3JCLHVCQUF1QjtBQUN2QixhQUFhO0FBQ2IsYUFBYTtBQUNiLG1CQUFtQjtBQUNuQixlQUFlO0FBQ2YscUJBQXFCO0FBQ3JCLG9CQUFvQjtBQUNwQixtQkFBbUI7QUFDbkIsY0FBYztBQUNkLGtCQUFrQjtBQUNsQixjQUFjO0FBQ2Qsa0JBQWtCO0FBQ2xCLHFCQUFxQjtBQUNyQixZQUFZO0FBQ1osb0JBQW9CO0FBQ3BCLGNBQWM7QUFDZCxzQkFBc0I7QUFDdEIsa0JBQWtCO0FBQ2xCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbXktYXBwLy4vbm9kZV9tb2R1bGVzL21zZ3BhY2tyL2Rpc3Qvbm9kZS5janM/ZGI4ZSJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbnZhciBzdHJlYW0gPSByZXF1aXJlKCdzdHJlYW0nKTtcbnZhciBtb2R1bGUkMSA9IHJlcXVpcmUoJ21vZHVsZScpO1xuXG52YXIgZGVjb2RlcjtcbnRyeSB7XG5cdGRlY29kZXIgPSBuZXcgVGV4dERlY29kZXIoKTtcbn0gY2F0Y2goZXJyb3IpIHt9XG52YXIgc3JjO1xudmFyIHNyY0VuZDtcbnZhciBwb3NpdGlvbiQxID0gMDtcbmNvbnN0IEVNUFRZX0FSUkFZID0gW107XG52YXIgc3RyaW5ncyA9IEVNUFRZX0FSUkFZO1xudmFyIHN0cmluZ1Bvc2l0aW9uID0gMDtcbnZhciBjdXJyZW50VW5wYWNrciA9IHt9O1xudmFyIGN1cnJlbnRTdHJ1Y3R1cmVzO1xudmFyIHNyY1N0cmluZztcbnZhciBzcmNTdHJpbmdTdGFydCA9IDA7XG52YXIgc3JjU3RyaW5nRW5kID0gMDtcbnZhciBidW5kbGVkU3RyaW5ncyQxO1xudmFyIHJlZmVyZW5jZU1hcDtcbnZhciBjdXJyZW50RXh0ZW5zaW9ucyA9IFtdO1xudmFyIGRhdGFWaWV3O1xudmFyIGRlZmF1bHRPcHRpb25zID0ge1xuXHR1c2VSZWNvcmRzOiBmYWxzZSxcblx0bWFwc0FzT2JqZWN0czogdHJ1ZVxufTtcbmNsYXNzIEMxVHlwZSB7fVxuY29uc3QgQzEgPSBuZXcgQzFUeXBlKCk7XG5DMS5uYW1lID0gJ01lc3NhZ2VQYWNrIDB4QzEnO1xudmFyIHNlcXVlbnRpYWxNb2RlID0gZmFsc2U7XG52YXIgaW5saW5lT2JqZWN0UmVhZFRocmVzaG9sZCA9IDI7XG52YXIgcmVhZFN0cnVjdCQxLCBvbkxvYWRlZFN0cnVjdHVyZXMkMSwgb25TYXZlU3RhdGU7XG4vLyBuby1ldmFsIGJ1aWxkXG50cnkge1xuXHRuZXcgRnVuY3Rpb24oJycpO1xufSBjYXRjaChlcnJvcikge1xuXHQvLyBpZiBldmFsIHZhcmlhbnRzIGFyZSBub3Qgc3VwcG9ydGVkLCBkbyBub3QgY3JlYXRlIGlubGluZSBvYmplY3QgcmVhZGVycyBldmVyXG5cdGlubGluZU9iamVjdFJlYWRUaHJlc2hvbGQgPSBJbmZpbml0eTtcbn1cblxuY2xhc3MgVW5wYWNrciB7XG5cdGNvbnN0cnVjdG9yKG9wdGlvbnMpIHtcblx0XHRpZiAob3B0aW9ucykge1xuXHRcdFx0aWYgKG9wdGlvbnMudXNlUmVjb3JkcyA9PT0gZmFsc2UgJiYgb3B0aW9ucy5tYXBzQXNPYmplY3RzID09PSB1bmRlZmluZWQpXG5cdFx0XHRcdG9wdGlvbnMubWFwc0FzT2JqZWN0cyA9IHRydWU7XG5cdFx0XHRpZiAob3B0aW9ucy5zZXF1ZW50aWFsICYmIG9wdGlvbnMudHJ1c3RlZCAhPT0gZmFsc2UpIHtcblx0XHRcdFx0b3B0aW9ucy50cnVzdGVkID0gdHJ1ZTtcblx0XHRcdFx0aWYgKCFvcHRpb25zLnN0cnVjdHVyZXMgJiYgb3B0aW9ucy51c2VSZWNvcmRzICE9IGZhbHNlKSB7XG5cdFx0XHRcdFx0b3B0aW9ucy5zdHJ1Y3R1cmVzID0gW107XG5cdFx0XHRcdFx0aWYgKCFvcHRpb25zLm1heFNoYXJlZFN0cnVjdHVyZXMpXG5cdFx0XHRcdFx0XHRvcHRpb25zLm1heFNoYXJlZFN0cnVjdHVyZXMgPSAwO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRpZiAob3B0aW9ucy5zdHJ1Y3R1cmVzKVxuXHRcdFx0XHRvcHRpb25zLnN0cnVjdHVyZXMuc2hhcmVkTGVuZ3RoID0gb3B0aW9ucy5zdHJ1Y3R1cmVzLmxlbmd0aDtcblx0XHRcdGVsc2UgaWYgKG9wdGlvbnMuZ2V0U3RydWN0dXJlcykge1xuXHRcdFx0XHQob3B0aW9ucy5zdHJ1Y3R1cmVzID0gW10pLnVuaW5pdGlhbGl6ZWQgPSB0cnVlOyAvLyB0aGlzIGlzIHdoYXQgd2UgdXNlIHRvIGRlbm90ZSBhbiB1bmluaXRpYWxpemVkIHN0cnVjdHVyZXNcblx0XHRcdFx0b3B0aW9ucy5zdHJ1Y3R1cmVzLnNoYXJlZExlbmd0aCA9IDA7XG5cdFx0XHR9XG5cdFx0XHRpZiAob3B0aW9ucy5pbnQ2NEFzTnVtYmVyKSB7XG5cdFx0XHRcdG9wdGlvbnMuaW50NjRBc1R5cGUgPSAnbnVtYmVyJztcblx0XHRcdH1cblx0XHR9XG5cdFx0T2JqZWN0LmFzc2lnbih0aGlzLCBvcHRpb25zKTtcblx0fVxuXHR1bnBhY2soc291cmNlLCBvcHRpb25zKSB7XG5cdFx0aWYgKHNyYykge1xuXHRcdFx0Ly8gcmUtZW50cmFudCBleGVjdXRpb24sIHNhdmUgdGhlIHN0YXRlIGFuZCByZXN0b3JlIGl0IGFmdGVyIHdlIGRvIHRoaXMgdW5wYWNrXG5cdFx0XHRyZXR1cm4gc2F2ZVN0YXRlJDEoKCkgPT4ge1xuXHRcdFx0XHRjbGVhclNvdXJjZSgpO1xuXHRcdFx0XHRyZXR1cm4gdGhpcyA/IHRoaXMudW5wYWNrKHNvdXJjZSwgb3B0aW9ucykgOiBVbnBhY2tyLnByb3RvdHlwZS51bnBhY2suY2FsbChkZWZhdWx0T3B0aW9ucywgc291cmNlLCBvcHRpb25zKVxuXHRcdFx0fSlcblx0XHR9XG5cdFx0aWYgKCFzb3VyY2UuYnVmZmVyICYmIHNvdXJjZS5jb25zdHJ1Y3RvciA9PT0gQXJyYXlCdWZmZXIpXG5cdFx0XHRzb3VyY2UgPSB0eXBlb2YgQnVmZmVyICE9PSAndW5kZWZpbmVkJyA/IEJ1ZmZlci5mcm9tKHNvdXJjZSkgOiBuZXcgVWludDhBcnJheShzb3VyY2UpO1xuXHRcdGlmICh0eXBlb2Ygb3B0aW9ucyA9PT0gJ29iamVjdCcpIHtcblx0XHRcdHNyY0VuZCA9IG9wdGlvbnMuZW5kIHx8IHNvdXJjZS5sZW5ndGg7XG5cdFx0XHRwb3NpdGlvbiQxID0gb3B0aW9ucy5zdGFydCB8fCAwO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRwb3NpdGlvbiQxID0gMDtcblx0XHRcdHNyY0VuZCA9IG9wdGlvbnMgPiAtMSA/IG9wdGlvbnMgOiBzb3VyY2UubGVuZ3RoO1xuXHRcdH1cblx0XHRzdHJpbmdQb3NpdGlvbiA9IDA7XG5cdFx0c3JjU3RyaW5nRW5kID0gMDtcblx0XHRzcmNTdHJpbmcgPSBudWxsO1xuXHRcdHN0cmluZ3MgPSBFTVBUWV9BUlJBWTtcblx0XHRidW5kbGVkU3RyaW5ncyQxID0gbnVsbDtcblx0XHRzcmMgPSBzb3VyY2U7XG5cdFx0Ly8gdGhpcyBwcm92aWRlcyBjYWNoZWQgYWNjZXNzIHRvIHRoZSBkYXRhIHZpZXcgZm9yIGEgYnVmZmVyIGlmIGl0IGlzIGdldHRpbmcgcmV1c2VkLCB3aGljaCBpcyBhIHJlY29tbWVuZFxuXHRcdC8vIHRlY2huaXF1ZSBmb3IgZ2V0dGluZyBkYXRhIGZyb20gYSBkYXRhYmFzZSB3aGVyZSBpdCBjYW4gYmUgY29waWVkIGludG8gYW4gZXhpc3RpbmcgYnVmZmVyIGluc3RlYWQgb2YgY3JlYXRpbmdcblx0XHQvLyBuZXcgb25lc1xuXHRcdHRyeSB7XG5cdFx0XHRkYXRhVmlldyA9IHNvdXJjZS5kYXRhVmlldyB8fCAoc291cmNlLmRhdGFWaWV3ID0gbmV3IERhdGFWaWV3KHNvdXJjZS5idWZmZXIsIHNvdXJjZS5ieXRlT2Zmc2V0LCBzb3VyY2UuYnl0ZUxlbmd0aCkpO1xuXHRcdH0gY2F0Y2goZXJyb3IpIHtcblx0XHRcdC8vIGlmIGl0IGRvZXNuJ3QgaGF2ZSBhIGJ1ZmZlciwgbWF5YmUgaXQgaXMgdGhlIHdyb25nIHR5cGUgb2Ygb2JqZWN0XG5cdFx0XHRzcmMgPSBudWxsO1xuXHRcdFx0aWYgKHNvdXJjZSBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkpXG5cdFx0XHRcdHRocm93IGVycm9yXG5cdFx0XHR0aHJvdyBuZXcgRXJyb3IoJ1NvdXJjZSBtdXN0IGJlIGEgVWludDhBcnJheSBvciBCdWZmZXIgYnV0IHdhcyBhICcgKyAoKHNvdXJjZSAmJiB0eXBlb2Ygc291cmNlID09ICdvYmplY3QnKSA/IHNvdXJjZS5jb25zdHJ1Y3Rvci5uYW1lIDogdHlwZW9mIHNvdXJjZSkpXG5cdFx0fVxuXHRcdGlmICh0aGlzIGluc3RhbmNlb2YgVW5wYWNrcikge1xuXHRcdFx0Y3VycmVudFVucGFja3IgPSB0aGlzO1xuXHRcdFx0aWYgKHRoaXMuc3RydWN0dXJlcykge1xuXHRcdFx0XHRjdXJyZW50U3RydWN0dXJlcyA9IHRoaXMuc3RydWN0dXJlcztcblx0XHRcdFx0cmV0dXJuIGNoZWNrZWRSZWFkKG9wdGlvbnMpXG5cdFx0XHR9IGVsc2UgaWYgKCFjdXJyZW50U3RydWN0dXJlcyB8fCBjdXJyZW50U3RydWN0dXJlcy5sZW5ndGggPiAwKSB7XG5cdFx0XHRcdGN1cnJlbnRTdHJ1Y3R1cmVzID0gW107XG5cdFx0XHR9XG5cdFx0fSBlbHNlIHtcblx0XHRcdGN1cnJlbnRVbnBhY2tyID0gZGVmYXVsdE9wdGlvbnM7XG5cdFx0XHRpZiAoIWN1cnJlbnRTdHJ1Y3R1cmVzIHx8IGN1cnJlbnRTdHJ1Y3R1cmVzLmxlbmd0aCA+IDApXG5cdFx0XHRcdGN1cnJlbnRTdHJ1Y3R1cmVzID0gW107XG5cdFx0fVxuXHRcdHJldHVybiBjaGVja2VkUmVhZChvcHRpb25zKVxuXHR9XG5cdHVucGFja011bHRpcGxlKHNvdXJjZSwgZm9yRWFjaCkge1xuXHRcdGxldCB2YWx1ZXMsIGxhc3RQb3NpdGlvbiA9IDA7XG5cdFx0dHJ5IHtcblx0XHRcdHNlcXVlbnRpYWxNb2RlID0gdHJ1ZTtcblx0XHRcdGxldCBzaXplID0gc291cmNlLmxlbmd0aDtcblx0XHRcdGxldCB2YWx1ZSA9IHRoaXMgPyB0aGlzLnVucGFjayhzb3VyY2UsIHNpemUpIDogZGVmYXVsdFVucGFja3IudW5wYWNrKHNvdXJjZSwgc2l6ZSk7XG5cdFx0XHRpZiAoZm9yRWFjaCkge1xuXHRcdFx0XHRpZiAoZm9yRWFjaCh2YWx1ZSwgbGFzdFBvc2l0aW9uLCBwb3NpdGlvbiQxKSA9PT0gZmFsc2UpIHJldHVybjtcblx0XHRcdFx0d2hpbGUocG9zaXRpb24kMSA8IHNpemUpIHtcblx0XHRcdFx0XHRsYXN0UG9zaXRpb24gPSBwb3NpdGlvbiQxO1xuXHRcdFx0XHRcdGlmIChmb3JFYWNoKGNoZWNrZWRSZWFkKCksIGxhc3RQb3NpdGlvbiwgcG9zaXRpb24kMSkgPT09IGZhbHNlKSB7XG5cdFx0XHRcdFx0XHRyZXR1cm5cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdGVsc2Uge1xuXHRcdFx0XHR2YWx1ZXMgPSBbIHZhbHVlIF07XG5cdFx0XHRcdHdoaWxlKHBvc2l0aW9uJDEgPCBzaXplKSB7XG5cdFx0XHRcdFx0bGFzdFBvc2l0aW9uID0gcG9zaXRpb24kMTtcblx0XHRcdFx0XHR2YWx1ZXMucHVzaChjaGVja2VkUmVhZCgpKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gdmFsdWVzXG5cdFx0XHR9XG5cdFx0fSBjYXRjaChlcnJvcikge1xuXHRcdFx0ZXJyb3IubGFzdFBvc2l0aW9uID0gbGFzdFBvc2l0aW9uO1xuXHRcdFx0ZXJyb3IudmFsdWVzID0gdmFsdWVzO1xuXHRcdFx0dGhyb3cgZXJyb3Jcblx0XHR9IGZpbmFsbHkge1xuXHRcdFx0c2VxdWVudGlhbE1vZGUgPSBmYWxzZTtcblx0XHRcdGNsZWFyU291cmNlKCk7XG5cdFx0fVxuXHR9XG5cdF9tZXJnZVN0cnVjdHVyZXMobG9hZGVkU3RydWN0dXJlcywgZXhpc3RpbmdTdHJ1Y3R1cmVzKSB7XG5cdFx0aWYgKG9uTG9hZGVkU3RydWN0dXJlcyQxKVxuXHRcdFx0bG9hZGVkU3RydWN0dXJlcyA9IG9uTG9hZGVkU3RydWN0dXJlcyQxLmNhbGwodGhpcywgbG9hZGVkU3RydWN0dXJlcyk7XG5cdFx0bG9hZGVkU3RydWN0dXJlcyA9IGxvYWRlZFN0cnVjdHVyZXMgfHwgW107XG5cdFx0aWYgKE9iamVjdC5pc0Zyb3plbihsb2FkZWRTdHJ1Y3R1cmVzKSlcblx0XHRcdGxvYWRlZFN0cnVjdHVyZXMgPSBsb2FkZWRTdHJ1Y3R1cmVzLm1hcChzdHJ1Y3R1cmUgPT4gc3RydWN0dXJlLnNsaWNlKDApKTtcblx0XHRmb3IgKGxldCBpID0gMCwgbCA9IGxvYWRlZFN0cnVjdHVyZXMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG5cdFx0XHRsZXQgc3RydWN0dXJlID0gbG9hZGVkU3RydWN0dXJlc1tpXTtcblx0XHRcdGlmIChzdHJ1Y3R1cmUpIHtcblx0XHRcdFx0c3RydWN0dXJlLmlzU2hhcmVkID0gdHJ1ZTtcblx0XHRcdFx0aWYgKGkgPj0gMzIpXG5cdFx0XHRcdFx0c3RydWN0dXJlLmhpZ2hCeXRlID0gKGkgLSAzMikgPj4gNTtcblx0XHRcdH1cblx0XHR9XG5cdFx0bG9hZGVkU3RydWN0dXJlcy5zaGFyZWRMZW5ndGggPSBsb2FkZWRTdHJ1Y3R1cmVzLmxlbmd0aDtcblx0XHRmb3IgKGxldCBpZCBpbiBleGlzdGluZ1N0cnVjdHVyZXMgfHwgW10pIHtcblx0XHRcdGlmIChpZCA+PSAwKSB7XG5cdFx0XHRcdGxldCBzdHJ1Y3R1cmUgPSBsb2FkZWRTdHJ1Y3R1cmVzW2lkXTtcblx0XHRcdFx0bGV0IGV4aXN0aW5nID0gZXhpc3RpbmdTdHJ1Y3R1cmVzW2lkXTtcblx0XHRcdFx0aWYgKGV4aXN0aW5nKSB7XG5cdFx0XHRcdFx0aWYgKHN0cnVjdHVyZSlcblx0XHRcdFx0XHRcdChsb2FkZWRTdHJ1Y3R1cmVzLnJlc3RvcmVTdHJ1Y3R1cmVzIHx8IChsb2FkZWRTdHJ1Y3R1cmVzLnJlc3RvcmVTdHJ1Y3R1cmVzID0gW10pKVtpZF0gPSBzdHJ1Y3R1cmU7XG5cdFx0XHRcdFx0bG9hZGVkU3RydWN0dXJlc1tpZF0gPSBleGlzdGluZztcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0XHRyZXR1cm4gdGhpcy5zdHJ1Y3R1cmVzID0gbG9hZGVkU3RydWN0dXJlc1xuXHR9XG5cdGRlY29kZShzb3VyY2UsIG9wdGlvbnMpIHtcblx0XHRyZXR1cm4gdGhpcy51bnBhY2soc291cmNlLCBvcHRpb25zKVxuXHR9XG59XG5mdW5jdGlvbiBjaGVja2VkUmVhZChvcHRpb25zKSB7XG5cdHRyeSB7XG5cdFx0aWYgKCFjdXJyZW50VW5wYWNrci50cnVzdGVkICYmICFzZXF1ZW50aWFsTW9kZSkge1xuXHRcdFx0bGV0IHNoYXJlZExlbmd0aCA9IGN1cnJlbnRTdHJ1Y3R1cmVzLnNoYXJlZExlbmd0aCB8fCAwO1xuXHRcdFx0aWYgKHNoYXJlZExlbmd0aCA8IGN1cnJlbnRTdHJ1Y3R1cmVzLmxlbmd0aClcblx0XHRcdFx0Y3VycmVudFN0cnVjdHVyZXMubGVuZ3RoID0gc2hhcmVkTGVuZ3RoO1xuXHRcdH1cblx0XHRsZXQgcmVzdWx0O1xuXHRcdGlmIChjdXJyZW50VW5wYWNrci5yYW5kb21BY2Nlc3NTdHJ1Y3R1cmUgJiYgc3JjW3Bvc2l0aW9uJDFdIDwgMHg0MCAmJiBzcmNbcG9zaXRpb24kMV0gPj0gMHgyMCAmJiByZWFkU3RydWN0JDEpIHtcblx0XHRcdHJlc3VsdCA9IHJlYWRTdHJ1Y3QkMShzcmMsIHBvc2l0aW9uJDEsIHNyY0VuZCwgY3VycmVudFVucGFja3IpO1xuXHRcdFx0c3JjID0gbnVsbDsgLy8gZGlzcG9zZSBvZiB0aGlzIHNvIHRoYXQgcmVjdXJzaXZlIHVucGFjayBjYWxscyBkb24ndCBzYXZlIHN0YXRlXG5cdFx0XHRpZiAoIShvcHRpb25zICYmIG9wdGlvbnMubGF6eSkgJiYgcmVzdWx0KVxuXHRcdFx0XHRyZXN1bHQgPSByZXN1bHQudG9KU09OKCk7XG5cdFx0XHRwb3NpdGlvbiQxID0gc3JjRW5kO1xuXHRcdH0gZWxzZVxuXHRcdFx0cmVzdWx0ID0gcmVhZCgpO1xuXHRcdGlmIChidW5kbGVkU3RyaW5ncyQxKSB7IC8vIGJ1bmRsZWQgc3RyaW5ncyB0byBza2lwIHBhc3Rcblx0XHRcdHBvc2l0aW9uJDEgPSBidW5kbGVkU3RyaW5ncyQxLnBvc3RCdW5kbGVQb3NpdGlvbjtcblx0XHRcdGJ1bmRsZWRTdHJpbmdzJDEgPSBudWxsO1xuXHRcdH1cblx0XHRpZiAoc2VxdWVudGlhbE1vZGUpXG5cdFx0XHQvLyB3ZSBvbmx5IG5lZWQgdG8gcmVzdG9yZSB0aGUgc3RydWN0dXJlcyBpZiB0aGVyZSB3YXMgYW4gZXJyb3IsIGJ1dCBpZiB3ZSBjb21wbGV0ZWQgYSByZWFkLFxuXHRcdFx0Ly8gd2UgY2FuIGNsZWFyIHRoaXMgb3V0IGFuZCBrZWVwIHRoZSBzdHJ1Y3R1cmVzIHdlIHJlYWRcblx0XHRcdGN1cnJlbnRTdHJ1Y3R1cmVzLnJlc3RvcmVTdHJ1Y3R1cmVzID0gbnVsbDtcblxuXHRcdGlmIChwb3NpdGlvbiQxID09IHNyY0VuZCkge1xuXHRcdFx0Ly8gZmluaXNoZWQgcmVhZGluZyB0aGlzIHNvdXJjZSwgY2xlYW51cCByZWZlcmVuY2VzXG5cdFx0XHRpZiAoY3VycmVudFN0cnVjdHVyZXMgJiYgY3VycmVudFN0cnVjdHVyZXMucmVzdG9yZVN0cnVjdHVyZXMpXG5cdFx0XHRcdHJlc3RvcmVTdHJ1Y3R1cmVzKCk7XG5cdFx0XHRjdXJyZW50U3RydWN0dXJlcyA9IG51bGw7XG5cdFx0XHRzcmMgPSBudWxsO1xuXHRcdFx0aWYgKHJlZmVyZW5jZU1hcClcblx0XHRcdFx0cmVmZXJlbmNlTWFwID0gbnVsbDtcblx0XHR9IGVsc2UgaWYgKHBvc2l0aW9uJDEgPiBzcmNFbmQpIHtcblx0XHRcdC8vIG92ZXIgcmVhZFxuXHRcdFx0dGhyb3cgbmV3IEVycm9yKCdVbmV4cGVjdGVkIGVuZCBvZiBNZXNzYWdlUGFjayBkYXRhJylcblx0XHR9IGVsc2UgaWYgKCFzZXF1ZW50aWFsTW9kZSkge1xuXHRcdFx0bGV0IGpzb25WaWV3O1xuXHRcdFx0dHJ5IHtcblx0XHRcdFx0anNvblZpZXcgPSBKU09OLnN0cmluZ2lmeShyZXN1bHQsIChfLCB2YWx1ZSkgPT4gdHlwZW9mIHZhbHVlID09PSBcImJpZ2ludFwiID8gYCR7dmFsdWV9bmAgOiB2YWx1ZSkuc2xpY2UoMCwgMTAwKTtcblx0XHRcdH0gY2F0Y2goZXJyb3IpIHtcblx0XHRcdFx0anNvblZpZXcgPSAnKEpTT04gdmlldyBub3QgYXZhaWxhYmxlICcgKyBlcnJvciArICcpJztcblx0XHRcdH1cblx0XHRcdHRocm93IG5ldyBFcnJvcignRGF0YSByZWFkLCBidXQgZW5kIG9mIGJ1ZmZlciBub3QgcmVhY2hlZCAnICsganNvblZpZXcpXG5cdFx0fVxuXHRcdC8vIGVsc2UgbW9yZSB0byByZWFkLCBidXQgd2UgYXJlIHJlYWRpbmcgc2VxdWVudGlhbGx5LCBzbyBkb24ndCBjbGVhciBzb3VyY2UgeWV0XG5cdFx0cmV0dXJuIHJlc3VsdFxuXHR9IGNhdGNoKGVycm9yKSB7XG5cdFx0aWYgKGN1cnJlbnRTdHJ1Y3R1cmVzICYmIGN1cnJlbnRTdHJ1Y3R1cmVzLnJlc3RvcmVTdHJ1Y3R1cmVzKVxuXHRcdFx0cmVzdG9yZVN0cnVjdHVyZXMoKTtcblx0XHRjbGVhclNvdXJjZSgpO1xuXHRcdGlmIChlcnJvciBpbnN0YW5jZW9mIFJhbmdlRXJyb3IgfHwgZXJyb3IubWVzc2FnZS5zdGFydHNXaXRoKCdVbmV4cGVjdGVkIGVuZCBvZiBidWZmZXInKSB8fCBwb3NpdGlvbiQxID4gc3JjRW5kKSB7XG5cdFx0XHRlcnJvci5pbmNvbXBsZXRlID0gdHJ1ZTtcblx0XHR9XG5cdFx0dGhyb3cgZXJyb3Jcblx0fVxufVxuXG5mdW5jdGlvbiByZXN0b3JlU3RydWN0dXJlcygpIHtcblx0Zm9yIChsZXQgaWQgaW4gY3VycmVudFN0cnVjdHVyZXMucmVzdG9yZVN0cnVjdHVyZXMpIHtcblx0XHRjdXJyZW50U3RydWN0dXJlc1tpZF0gPSBjdXJyZW50U3RydWN0dXJlcy5yZXN0b3JlU3RydWN0dXJlc1tpZF07XG5cdH1cblx0Y3VycmVudFN0cnVjdHVyZXMucmVzdG9yZVN0cnVjdHVyZXMgPSBudWxsO1xufVxuXG5mdW5jdGlvbiByZWFkKCkge1xuXHRsZXQgdG9rZW4gPSBzcmNbcG9zaXRpb24kMSsrXTtcblx0aWYgKHRva2VuIDwgMHhhMCkge1xuXHRcdGlmICh0b2tlbiA8IDB4ODApIHtcblx0XHRcdGlmICh0b2tlbiA8IDB4NDApXG5cdFx0XHRcdHJldHVybiB0b2tlblxuXHRcdFx0ZWxzZSB7XG5cdFx0XHRcdGxldCBzdHJ1Y3R1cmUgPSBjdXJyZW50U3RydWN0dXJlc1t0b2tlbiAmIDB4M2ZdIHx8XG5cdFx0XHRcdFx0Y3VycmVudFVucGFja3IuZ2V0U3RydWN0dXJlcyAmJiBsb2FkU3RydWN0dXJlcygpW3Rva2VuICYgMHgzZl07XG5cdFx0XHRcdGlmIChzdHJ1Y3R1cmUpIHtcblx0XHRcdFx0XHRpZiAoIXN0cnVjdHVyZS5yZWFkKSB7XG5cdFx0XHRcdFx0XHRzdHJ1Y3R1cmUucmVhZCA9IGNyZWF0ZVN0cnVjdHVyZVJlYWRlcihzdHJ1Y3R1cmUsIHRva2VuICYgMHgzZik7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHJldHVybiBzdHJ1Y3R1cmUucmVhZCgpXG5cdFx0XHRcdH0gZWxzZVxuXHRcdFx0XHRcdHJldHVybiB0b2tlblxuXHRcdFx0fVxuXHRcdH0gZWxzZSBpZiAodG9rZW4gPCAweDkwKSB7XG5cdFx0XHQvLyBtYXBcblx0XHRcdHRva2VuIC09IDB4ODA7XG5cdFx0XHRpZiAoY3VycmVudFVucGFja3IubWFwc0FzT2JqZWN0cykge1xuXHRcdFx0XHRsZXQgb2JqZWN0ID0ge307XG5cdFx0XHRcdGZvciAobGV0IGkgPSAwOyBpIDwgdG9rZW47IGkrKykge1xuXHRcdFx0XHRcdGxldCBrZXkgPSByZWFkS2V5KCk7XG5cdFx0XHRcdFx0aWYgKGtleSA9PT0gJ19fcHJvdG9fXycpXG5cdFx0XHRcdFx0XHRrZXkgPSAnX19wcm90b18nO1xuXHRcdFx0XHRcdG9iamVjdFtrZXldID0gcmVhZCgpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiBvYmplY3Rcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGxldCBtYXAgPSBuZXcgTWFwKCk7XG5cdFx0XHRcdGZvciAobGV0IGkgPSAwOyBpIDwgdG9rZW47IGkrKykge1xuXHRcdFx0XHRcdG1hcC5zZXQocmVhZCgpLCByZWFkKCkpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiBtYXBcblx0XHRcdH1cblx0XHR9IGVsc2Uge1xuXHRcdFx0dG9rZW4gLT0gMHg5MDtcblx0XHRcdGxldCBhcnJheSA9IG5ldyBBcnJheSh0b2tlbik7XG5cdFx0XHRmb3IgKGxldCBpID0gMDsgaSA8IHRva2VuOyBpKyspIHtcblx0XHRcdFx0YXJyYXlbaV0gPSByZWFkKCk7XG5cdFx0XHR9XG5cdFx0XHRpZiAoY3VycmVudFVucGFja3IuZnJlZXplRGF0YSlcblx0XHRcdFx0cmV0dXJuIE9iamVjdC5mcmVlemUoYXJyYXkpXG5cdFx0XHRyZXR1cm4gYXJyYXlcblx0XHR9XG5cdH0gZWxzZSBpZiAodG9rZW4gPCAweGMwKSB7XG5cdFx0Ly8gZml4c3RyXG5cdFx0bGV0IGxlbmd0aCA9IHRva2VuIC0gMHhhMDtcblx0XHRpZiAoc3JjU3RyaW5nRW5kID49IHBvc2l0aW9uJDEpIHtcblx0XHRcdHJldHVybiBzcmNTdHJpbmcuc2xpY2UocG9zaXRpb24kMSAtIHNyY1N0cmluZ1N0YXJ0LCAocG9zaXRpb24kMSArPSBsZW5ndGgpIC0gc3JjU3RyaW5nU3RhcnQpXG5cdFx0fVxuXHRcdGlmIChzcmNTdHJpbmdFbmQgPT0gMCAmJiBzcmNFbmQgPCAxNDApIHtcblx0XHRcdC8vIGZvciBzbWFsbCBibG9ja3MsIGF2b2lkaW5nIHRoZSBvdmVyaGVhZCBvZiB0aGUgZXh0cmFjdCBjYWxsIGlzIGhlbHBmdWxcblx0XHRcdGxldCBzdHJpbmcgPSBsZW5ndGggPCAxNiA/IHNob3J0U3RyaW5nSW5KUyhsZW5ndGgpIDogbG9uZ1N0cmluZ0luSlMobGVuZ3RoKTtcblx0XHRcdGlmIChzdHJpbmcgIT0gbnVsbClcblx0XHRcdFx0cmV0dXJuIHN0cmluZ1xuXHRcdH1cblx0XHRyZXR1cm4gcmVhZEZpeGVkU3RyaW5nKGxlbmd0aClcblx0fSBlbHNlIHtcblx0XHRsZXQgdmFsdWU7XG5cdFx0c3dpdGNoICh0b2tlbikge1xuXHRcdFx0Y2FzZSAweGMwOiByZXR1cm4gbnVsbFxuXHRcdFx0Y2FzZSAweGMxOlxuXHRcdFx0XHRpZiAoYnVuZGxlZFN0cmluZ3MkMSkge1xuXHRcdFx0XHRcdHZhbHVlID0gcmVhZCgpOyAvLyBmb2xsb3dlZCBieSB0aGUgbGVuZ3RoIG9mIHRoZSBzdHJpbmcgaW4gY2hhcmFjdGVycyAobm90IGJ5dGVzISlcblx0XHRcdFx0XHRpZiAodmFsdWUgPiAwKVxuXHRcdFx0XHRcdFx0cmV0dXJuIGJ1bmRsZWRTdHJpbmdzJDFbMV0uc2xpY2UoYnVuZGxlZFN0cmluZ3MkMS5wb3NpdGlvbjEsIGJ1bmRsZWRTdHJpbmdzJDEucG9zaXRpb24xICs9IHZhbHVlKVxuXHRcdFx0XHRcdGVsc2Vcblx0XHRcdFx0XHRcdHJldHVybiBidW5kbGVkU3RyaW5ncyQxWzBdLnNsaWNlKGJ1bmRsZWRTdHJpbmdzJDEucG9zaXRpb24wLCBidW5kbGVkU3RyaW5ncyQxLnBvc2l0aW9uMCAtPSB2YWx1ZSlcblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gQzE7IC8vIFwibmV2ZXItdXNlZFwiLCByZXR1cm4gc3BlY2lhbCBvYmplY3QgdG8gZGVub3RlIHRoYXRcblx0XHRcdGNhc2UgMHhjMjogcmV0dXJuIGZhbHNlXG5cdFx0XHRjYXNlIDB4YzM6IHJldHVybiB0cnVlXG5cdFx0XHRjYXNlIDB4YzQ6XG5cdFx0XHRcdC8vIGJpbiA4XG5cdFx0XHRcdHZhbHVlID0gc3JjW3Bvc2l0aW9uJDErK107XG5cdFx0XHRcdGlmICh2YWx1ZSA9PT0gdW5kZWZpbmVkKVxuXHRcdFx0XHRcdHRocm93IG5ldyBFcnJvcignVW5leHBlY3RlZCBlbmQgb2YgYnVmZmVyJylcblx0XHRcdFx0cmV0dXJuIHJlYWRCaW4odmFsdWUpXG5cdFx0XHRjYXNlIDB4YzU6XG5cdFx0XHRcdC8vIGJpbiAxNlxuXHRcdFx0XHR2YWx1ZSA9IGRhdGFWaWV3LmdldFVpbnQxNihwb3NpdGlvbiQxKTtcblx0XHRcdFx0cG9zaXRpb24kMSArPSAyO1xuXHRcdFx0XHRyZXR1cm4gcmVhZEJpbih2YWx1ZSlcblx0XHRcdGNhc2UgMHhjNjpcblx0XHRcdFx0Ly8gYmluIDMyXG5cdFx0XHRcdHZhbHVlID0gZGF0YVZpZXcuZ2V0VWludDMyKHBvc2l0aW9uJDEpO1xuXHRcdFx0XHRwb3NpdGlvbiQxICs9IDQ7XG5cdFx0XHRcdHJldHVybiByZWFkQmluKHZhbHVlKVxuXHRcdFx0Y2FzZSAweGM3OlxuXHRcdFx0XHQvLyBleHQgOFxuXHRcdFx0XHRyZXR1cm4gcmVhZEV4dChzcmNbcG9zaXRpb24kMSsrXSlcblx0XHRcdGNhc2UgMHhjODpcblx0XHRcdFx0Ly8gZXh0IDE2XG5cdFx0XHRcdHZhbHVlID0gZGF0YVZpZXcuZ2V0VWludDE2KHBvc2l0aW9uJDEpO1xuXHRcdFx0XHRwb3NpdGlvbiQxICs9IDI7XG5cdFx0XHRcdHJldHVybiByZWFkRXh0KHZhbHVlKVxuXHRcdFx0Y2FzZSAweGM5OlxuXHRcdFx0XHQvLyBleHQgMzJcblx0XHRcdFx0dmFsdWUgPSBkYXRhVmlldy5nZXRVaW50MzIocG9zaXRpb24kMSk7XG5cdFx0XHRcdHBvc2l0aW9uJDEgKz0gNDtcblx0XHRcdFx0cmV0dXJuIHJlYWRFeHQodmFsdWUpXG5cdFx0XHRjYXNlIDB4Y2E6XG5cdFx0XHRcdHZhbHVlID0gZGF0YVZpZXcuZ2V0RmxvYXQzMihwb3NpdGlvbiQxKTtcblx0XHRcdFx0aWYgKGN1cnJlbnRVbnBhY2tyLnVzZUZsb2F0MzIgPiAyKSB7XG5cdFx0XHRcdFx0Ly8gdGhpcyBkb2VzIHJvdW5kaW5nIG9mIG51bWJlcnMgdGhhdCB3ZXJlIGVuY29kZWQgaW4gMzItYml0IGZsb2F0IHRvIG5lYXJlc3Qgc2lnbmlmaWNhbnQgZGVjaW1hbCBkaWdpdCB0aGF0IGNvdWxkIGJlIHByZXNlcnZlZFxuXHRcdFx0XHRcdGxldCBtdWx0aXBsaWVyID0gbXVsdDEwWygoc3JjW3Bvc2l0aW9uJDFdICYgMHg3ZikgPDwgMSkgfCAoc3JjW3Bvc2l0aW9uJDEgKyAxXSA+PiA3KV07XG5cdFx0XHRcdFx0cG9zaXRpb24kMSArPSA0O1xuXHRcdFx0XHRcdHJldHVybiAoKG11bHRpcGxpZXIgKiB2YWx1ZSArICh2YWx1ZSA+IDAgPyAwLjUgOiAtMC41KSkgPj4gMCkgLyBtdWx0aXBsaWVyXG5cdFx0XHRcdH1cblx0XHRcdFx0cG9zaXRpb24kMSArPSA0O1xuXHRcdFx0XHRyZXR1cm4gdmFsdWVcblx0XHRcdGNhc2UgMHhjYjpcblx0XHRcdFx0dmFsdWUgPSBkYXRhVmlldy5nZXRGbG9hdDY0KHBvc2l0aW9uJDEpO1xuXHRcdFx0XHRwb3NpdGlvbiQxICs9IDg7XG5cdFx0XHRcdHJldHVybiB2YWx1ZVxuXHRcdFx0Ly8gdWludCBoYW5kbGVyc1xuXHRcdFx0Y2FzZSAweGNjOlxuXHRcdFx0XHRyZXR1cm4gc3JjW3Bvc2l0aW9uJDErK11cblx0XHRcdGNhc2UgMHhjZDpcblx0XHRcdFx0dmFsdWUgPSBkYXRhVmlldy5nZXRVaW50MTYocG9zaXRpb24kMSk7XG5cdFx0XHRcdHBvc2l0aW9uJDEgKz0gMjtcblx0XHRcdFx0cmV0dXJuIHZhbHVlXG5cdFx0XHRjYXNlIDB4Y2U6XG5cdFx0XHRcdHZhbHVlID0gZGF0YVZpZXcuZ2V0VWludDMyKHBvc2l0aW9uJDEpO1xuXHRcdFx0XHRwb3NpdGlvbiQxICs9IDQ7XG5cdFx0XHRcdHJldHVybiB2YWx1ZVxuXHRcdFx0Y2FzZSAweGNmOlxuXHRcdFx0XHRpZiAoY3VycmVudFVucGFja3IuaW50NjRBc1R5cGUgPT09ICdudW1iZXInKSB7XG5cdFx0XHRcdFx0dmFsdWUgPSBkYXRhVmlldy5nZXRVaW50MzIocG9zaXRpb24kMSkgKiAweDEwMDAwMDAwMDtcblx0XHRcdFx0XHR2YWx1ZSArPSBkYXRhVmlldy5nZXRVaW50MzIocG9zaXRpb24kMSArIDQpO1xuXHRcdFx0XHR9IGVsc2UgaWYgKGN1cnJlbnRVbnBhY2tyLmludDY0QXNUeXBlID09PSAnc3RyaW5nJykge1xuXHRcdFx0XHRcdHZhbHVlID0gZGF0YVZpZXcuZ2V0QmlnVWludDY0KHBvc2l0aW9uJDEpLnRvU3RyaW5nKCk7XG5cdFx0XHRcdH0gZWxzZSBpZiAoY3VycmVudFVucGFja3IuaW50NjRBc1R5cGUgPT09ICdhdXRvJykge1xuXHRcdFx0XHRcdHZhbHVlID0gZGF0YVZpZXcuZ2V0QmlnVWludDY0KHBvc2l0aW9uJDEpO1xuXHRcdFx0XHRcdGlmICh2YWx1ZTw9QmlnSW50KDIpPDxCaWdJbnQoNTIpKSB2YWx1ZT1OdW1iZXIodmFsdWUpO1xuXHRcdFx0XHR9IGVsc2Vcblx0XHRcdFx0XHR2YWx1ZSA9IGRhdGFWaWV3LmdldEJpZ1VpbnQ2NChwb3NpdGlvbiQxKTtcblx0XHRcdFx0cG9zaXRpb24kMSArPSA4O1xuXHRcdFx0XHRyZXR1cm4gdmFsdWVcblxuXHRcdFx0Ly8gaW50IGhhbmRsZXJzXG5cdFx0XHRjYXNlIDB4ZDA6XG5cdFx0XHRcdHJldHVybiBkYXRhVmlldy5nZXRJbnQ4KHBvc2l0aW9uJDErKylcblx0XHRcdGNhc2UgMHhkMTpcblx0XHRcdFx0dmFsdWUgPSBkYXRhVmlldy5nZXRJbnQxNihwb3NpdGlvbiQxKTtcblx0XHRcdFx0cG9zaXRpb24kMSArPSAyO1xuXHRcdFx0XHRyZXR1cm4gdmFsdWVcblx0XHRcdGNhc2UgMHhkMjpcblx0XHRcdFx0dmFsdWUgPSBkYXRhVmlldy5nZXRJbnQzMihwb3NpdGlvbiQxKTtcblx0XHRcdFx0cG9zaXRpb24kMSArPSA0O1xuXHRcdFx0XHRyZXR1cm4gdmFsdWVcblx0XHRcdGNhc2UgMHhkMzpcblx0XHRcdFx0aWYgKGN1cnJlbnRVbnBhY2tyLmludDY0QXNUeXBlID09PSAnbnVtYmVyJykge1xuXHRcdFx0XHRcdHZhbHVlID0gZGF0YVZpZXcuZ2V0SW50MzIocG9zaXRpb24kMSkgKiAweDEwMDAwMDAwMDtcblx0XHRcdFx0XHR2YWx1ZSArPSBkYXRhVmlldy5nZXRVaW50MzIocG9zaXRpb24kMSArIDQpO1xuXHRcdFx0XHR9IGVsc2UgaWYgKGN1cnJlbnRVbnBhY2tyLmludDY0QXNUeXBlID09PSAnc3RyaW5nJykge1xuXHRcdFx0XHRcdHZhbHVlID0gZGF0YVZpZXcuZ2V0QmlnSW50NjQocG9zaXRpb24kMSkudG9TdHJpbmcoKTtcblx0XHRcdFx0fSBlbHNlIGlmIChjdXJyZW50VW5wYWNrci5pbnQ2NEFzVHlwZSA9PT0gJ2F1dG8nKSB7XG5cdFx0XHRcdFx0dmFsdWUgPSBkYXRhVmlldy5nZXRCaWdJbnQ2NChwb3NpdGlvbiQxKTtcblx0XHRcdFx0XHRpZiAodmFsdWU+PUJpZ0ludCgtMik8PEJpZ0ludCg1MikmJnZhbHVlPD1CaWdJbnQoMik8PEJpZ0ludCg1MikpIHZhbHVlPU51bWJlcih2YWx1ZSk7XG5cdFx0XHRcdH0gZWxzZVxuXHRcdFx0XHRcdHZhbHVlID0gZGF0YVZpZXcuZ2V0QmlnSW50NjQocG9zaXRpb24kMSk7XG5cdFx0XHRcdHBvc2l0aW9uJDEgKz0gODtcblx0XHRcdFx0cmV0dXJuIHZhbHVlXG5cblx0XHRcdGNhc2UgMHhkNDpcblx0XHRcdFx0Ly8gZml4ZXh0IDFcblx0XHRcdFx0dmFsdWUgPSBzcmNbcG9zaXRpb24kMSsrXTtcblx0XHRcdFx0aWYgKHZhbHVlID09IDB4NzIpIHtcblx0XHRcdFx0XHRyZXR1cm4gcmVjb3JkRGVmaW5pdGlvbihzcmNbcG9zaXRpb24kMSsrXSAmIDB4M2YpXG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0bGV0IGV4dGVuc2lvbiA9IGN1cnJlbnRFeHRlbnNpb25zW3ZhbHVlXTtcblx0XHRcdFx0XHRpZiAoZXh0ZW5zaW9uKSB7XG5cdFx0XHRcdFx0XHRpZiAoZXh0ZW5zaW9uLnJlYWQpIHtcblx0XHRcdFx0XHRcdFx0cG9zaXRpb24kMSsrOyAvLyBza2lwIGZpbGxlciBieXRlXG5cdFx0XHRcdFx0XHRcdHJldHVybiBleHRlbnNpb24ucmVhZChyZWFkKCkpXG5cdFx0XHRcdFx0XHR9IGVsc2UgaWYgKGV4dGVuc2lvbi5ub0J1ZmZlcikge1xuXHRcdFx0XHRcdFx0XHRwb3NpdGlvbiQxKys7IC8vIHNraXAgZmlsbGVyIGJ5dGVcblx0XHRcdFx0XHRcdFx0cmV0dXJuIGV4dGVuc2lvbigpXG5cdFx0XHRcdFx0XHR9IGVsc2Vcblx0XHRcdFx0XHRcdFx0cmV0dXJuIGV4dGVuc2lvbihzcmMuc3ViYXJyYXkocG9zaXRpb24kMSwgKytwb3NpdGlvbiQxKSlcblx0XHRcdFx0XHR9IGVsc2Vcblx0XHRcdFx0XHRcdHRocm93IG5ldyBFcnJvcignVW5rbm93biBleHRlbnNpb24gJyArIHZhbHVlKVxuXHRcdFx0XHR9XG5cdFx0XHRjYXNlIDB4ZDU6XG5cdFx0XHRcdC8vIGZpeGV4dCAyXG5cdFx0XHRcdHZhbHVlID0gc3JjW3Bvc2l0aW9uJDFdO1xuXHRcdFx0XHRpZiAodmFsdWUgPT0gMHg3Mikge1xuXHRcdFx0XHRcdHBvc2l0aW9uJDErKztcblx0XHRcdFx0XHRyZXR1cm4gcmVjb3JkRGVmaW5pdGlvbihzcmNbcG9zaXRpb24kMSsrXSAmIDB4M2YsIHNyY1twb3NpdGlvbiQxKytdKVxuXHRcdFx0XHR9IGVsc2Vcblx0XHRcdFx0XHRyZXR1cm4gcmVhZEV4dCgyKVxuXHRcdFx0Y2FzZSAweGQ2OlxuXHRcdFx0XHQvLyBmaXhleHQgNFxuXHRcdFx0XHRyZXR1cm4gcmVhZEV4dCg0KVxuXHRcdFx0Y2FzZSAweGQ3OlxuXHRcdFx0XHQvLyBmaXhleHQgOFxuXHRcdFx0XHRyZXR1cm4gcmVhZEV4dCg4KVxuXHRcdFx0Y2FzZSAweGQ4OlxuXHRcdFx0XHQvLyBmaXhleHQgMTZcblx0XHRcdFx0cmV0dXJuIHJlYWRFeHQoMTYpXG5cdFx0XHRjYXNlIDB4ZDk6XG5cdFx0XHQvLyBzdHIgOFxuXHRcdFx0XHR2YWx1ZSA9IHNyY1twb3NpdGlvbiQxKytdO1xuXHRcdFx0XHRpZiAoc3JjU3RyaW5nRW5kID49IHBvc2l0aW9uJDEpIHtcblx0XHRcdFx0XHRyZXR1cm4gc3JjU3RyaW5nLnNsaWNlKHBvc2l0aW9uJDEgLSBzcmNTdHJpbmdTdGFydCwgKHBvc2l0aW9uJDEgKz0gdmFsdWUpIC0gc3JjU3RyaW5nU3RhcnQpXG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIHJlYWRTdHJpbmc4KHZhbHVlKVxuXHRcdFx0Y2FzZSAweGRhOlxuXHRcdFx0Ly8gc3RyIDE2XG5cdFx0XHRcdHZhbHVlID0gZGF0YVZpZXcuZ2V0VWludDE2KHBvc2l0aW9uJDEpO1xuXHRcdFx0XHRwb3NpdGlvbiQxICs9IDI7XG5cdFx0XHRcdGlmIChzcmNTdHJpbmdFbmQgPj0gcG9zaXRpb24kMSkge1xuXHRcdFx0XHRcdHJldHVybiBzcmNTdHJpbmcuc2xpY2UocG9zaXRpb24kMSAtIHNyY1N0cmluZ1N0YXJ0LCAocG9zaXRpb24kMSArPSB2YWx1ZSkgLSBzcmNTdHJpbmdTdGFydClcblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gcmVhZFN0cmluZzE2KHZhbHVlKVxuXHRcdFx0Y2FzZSAweGRiOlxuXHRcdFx0Ly8gc3RyIDMyXG5cdFx0XHRcdHZhbHVlID0gZGF0YVZpZXcuZ2V0VWludDMyKHBvc2l0aW9uJDEpO1xuXHRcdFx0XHRwb3NpdGlvbiQxICs9IDQ7XG5cdFx0XHRcdGlmIChzcmNTdHJpbmdFbmQgPj0gcG9zaXRpb24kMSkge1xuXHRcdFx0XHRcdHJldHVybiBzcmNTdHJpbmcuc2xpY2UocG9zaXRpb24kMSAtIHNyY1N0cmluZ1N0YXJ0LCAocG9zaXRpb24kMSArPSB2YWx1ZSkgLSBzcmNTdHJpbmdTdGFydClcblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gcmVhZFN0cmluZzMyKHZhbHVlKVxuXHRcdFx0Y2FzZSAweGRjOlxuXHRcdFx0Ly8gYXJyYXkgMTZcblx0XHRcdFx0dmFsdWUgPSBkYXRhVmlldy5nZXRVaW50MTYocG9zaXRpb24kMSk7XG5cdFx0XHRcdHBvc2l0aW9uJDEgKz0gMjtcblx0XHRcdFx0cmV0dXJuIHJlYWRBcnJheSh2YWx1ZSlcblx0XHRcdGNhc2UgMHhkZDpcblx0XHRcdC8vIGFycmF5IDMyXG5cdFx0XHRcdHZhbHVlID0gZGF0YVZpZXcuZ2V0VWludDMyKHBvc2l0aW9uJDEpO1xuXHRcdFx0XHRwb3NpdGlvbiQxICs9IDQ7XG5cdFx0XHRcdHJldHVybiByZWFkQXJyYXkodmFsdWUpXG5cdFx0XHRjYXNlIDB4ZGU6XG5cdFx0XHQvLyBtYXAgMTZcblx0XHRcdFx0dmFsdWUgPSBkYXRhVmlldy5nZXRVaW50MTYocG9zaXRpb24kMSk7XG5cdFx0XHRcdHBvc2l0aW9uJDEgKz0gMjtcblx0XHRcdFx0cmV0dXJuIHJlYWRNYXAodmFsdWUpXG5cdFx0XHRjYXNlIDB4ZGY6XG5cdFx0XHQvLyBtYXAgMzJcblx0XHRcdFx0dmFsdWUgPSBkYXRhVmlldy5nZXRVaW50MzIocG9zaXRpb24kMSk7XG5cdFx0XHRcdHBvc2l0aW9uJDEgKz0gNDtcblx0XHRcdFx0cmV0dXJuIHJlYWRNYXAodmFsdWUpXG5cdFx0XHRkZWZhdWx0OiAvLyBuZWdhdGl2ZSBpbnRcblx0XHRcdFx0aWYgKHRva2VuID49IDB4ZTApXG5cdFx0XHRcdFx0cmV0dXJuIHRva2VuIC0gMHgxMDBcblx0XHRcdFx0aWYgKHRva2VuID09PSB1bmRlZmluZWQpIHtcblx0XHRcdFx0XHRsZXQgZXJyb3IgPSBuZXcgRXJyb3IoJ1VuZXhwZWN0ZWQgZW5kIG9mIE1lc3NhZ2VQYWNrIGRhdGEnKTtcblx0XHRcdFx0XHRlcnJvci5pbmNvbXBsZXRlID0gdHJ1ZTtcblx0XHRcdFx0XHR0aHJvdyBlcnJvclxuXHRcdFx0XHR9XG5cdFx0XHRcdHRocm93IG5ldyBFcnJvcignVW5rbm93biBNZXNzYWdlUGFjayB0b2tlbiAnICsgdG9rZW4pXG5cblx0XHR9XG5cdH1cbn1cbmNvbnN0IHZhbGlkTmFtZSA9IC9eW2EtekEtWl8kXVthLXpBLVpcXGRfJF0qJC87XG5mdW5jdGlvbiBjcmVhdGVTdHJ1Y3R1cmVSZWFkZXIoc3RydWN0dXJlLCBmaXJzdElkKSB7XG5cdGZ1bmN0aW9uIHJlYWRPYmplY3QoKSB7XG5cdFx0Ly8gVGhpcyBpbml0aWFsIGZ1bmN0aW9uIGlzIHF1aWNrIHRvIGluc3RhbnRpYXRlLCBidXQgcnVucyBzbG93ZXIuIEFmdGVyIHNldmVyYWwgaXRlcmF0aW9ucyBwYXkgdGhlIGNvc3QgdG8gYnVpbGQgdGhlIGZhc3RlciBmdW5jdGlvblxuXHRcdGlmIChyZWFkT2JqZWN0LmNvdW50KysgPiBpbmxpbmVPYmplY3RSZWFkVGhyZXNob2xkKSB7XG5cdFx0XHRsZXQgcmVhZE9iamVjdCA9IHN0cnVjdHVyZS5yZWFkID0gKG5ldyBGdW5jdGlvbigncicsICdyZXR1cm4gZnVuY3Rpb24oKXtyZXR1cm4gJyArIChjdXJyZW50VW5wYWNrci5mcmVlemVEYXRhID8gJ09iamVjdC5mcmVlemUnIDogJycpICtcblx0XHRcdFx0Jyh7JyArIHN0cnVjdHVyZS5tYXAoa2V5ID0+IGtleSA9PT0gJ19fcHJvdG9fXycgPyAnX19wcm90b186cigpJyA6IHZhbGlkTmFtZS50ZXN0KGtleSkgPyBrZXkgKyAnOnIoKScgOiAoJ1snICsgSlNPTi5zdHJpbmdpZnkoa2V5KSArICddOnIoKScpKS5qb2luKCcsJykgKyAnfSl9JykpKHJlYWQpO1xuXHRcdFx0aWYgKHN0cnVjdHVyZS5oaWdoQnl0ZSA9PT0gMClcblx0XHRcdFx0c3RydWN0dXJlLnJlYWQgPSBjcmVhdGVTZWNvbmRCeXRlUmVhZGVyKGZpcnN0SWQsIHN0cnVjdHVyZS5yZWFkKTtcblx0XHRcdHJldHVybiByZWFkT2JqZWN0KCkgLy8gc2Vjb25kIGJ5dGUgaXMgYWxyZWFkeSByZWFkLCBpZiB0aGVyZSBpcyBvbmUgc28gaW1tZWRpYXRlbHkgcmVhZCBvYmplY3Rcblx0XHR9XG5cdFx0bGV0IG9iamVjdCA9IHt9O1xuXHRcdGZvciAobGV0IGkgPSAwLCBsID0gc3RydWN0dXJlLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuXHRcdFx0bGV0IGtleSA9IHN0cnVjdHVyZVtpXTtcblx0XHRcdGlmIChrZXkgPT09ICdfX3Byb3RvX18nKVxuXHRcdFx0XHRrZXkgPSAnX19wcm90b18nO1xuXHRcdFx0b2JqZWN0W2tleV0gPSByZWFkKCk7XG5cdFx0fVxuXHRcdGlmIChjdXJyZW50VW5wYWNrci5mcmVlemVEYXRhKVxuXHRcdFx0cmV0dXJuIE9iamVjdC5mcmVlemUob2JqZWN0KTtcblx0XHRyZXR1cm4gb2JqZWN0XG5cdH1cblx0cmVhZE9iamVjdC5jb3VudCA9IDA7XG5cdGlmIChzdHJ1Y3R1cmUuaGlnaEJ5dGUgPT09IDApIHtcblx0XHRyZXR1cm4gY3JlYXRlU2Vjb25kQnl0ZVJlYWRlcihmaXJzdElkLCByZWFkT2JqZWN0KVxuXHR9XG5cdHJldHVybiByZWFkT2JqZWN0XG59XG5cbmNvbnN0IGNyZWF0ZVNlY29uZEJ5dGVSZWFkZXIgPSAoZmlyc3RJZCwgcmVhZDApID0+IHtcblx0cmV0dXJuIGZ1bmN0aW9uKCkge1xuXHRcdGxldCBoaWdoQnl0ZSA9IHNyY1twb3NpdGlvbiQxKytdO1xuXHRcdGlmIChoaWdoQnl0ZSA9PT0gMClcblx0XHRcdHJldHVybiByZWFkMCgpXG5cdFx0bGV0IGlkID0gZmlyc3RJZCA8IDMyID8gLShmaXJzdElkICsgKGhpZ2hCeXRlIDw8IDUpKSA6IGZpcnN0SWQgKyAoaGlnaEJ5dGUgPDwgNSk7XG5cdFx0bGV0IHN0cnVjdHVyZSA9IGN1cnJlbnRTdHJ1Y3R1cmVzW2lkXSB8fCBsb2FkU3RydWN0dXJlcygpW2lkXTtcblx0XHRpZiAoIXN0cnVjdHVyZSkge1xuXHRcdFx0dGhyb3cgbmV3IEVycm9yKCdSZWNvcmQgaWQgaXMgbm90IGRlZmluZWQgZm9yICcgKyBpZClcblx0XHR9XG5cdFx0aWYgKCFzdHJ1Y3R1cmUucmVhZClcblx0XHRcdHN0cnVjdHVyZS5yZWFkID0gY3JlYXRlU3RydWN0dXJlUmVhZGVyKHN0cnVjdHVyZSwgZmlyc3RJZCk7XG5cdFx0cmV0dXJuIHN0cnVjdHVyZS5yZWFkKClcblx0fVxufTtcblxuZnVuY3Rpb24gbG9hZFN0cnVjdHVyZXMoKSB7XG5cdGxldCBsb2FkZWRTdHJ1Y3R1cmVzID0gc2F2ZVN0YXRlJDEoKCkgPT4ge1xuXHRcdC8vIHNhdmUgdGhlIHN0YXRlIGluIGNhc2UgZ2V0U3RydWN0dXJlcyBtb2RpZmllcyBvdXIgYnVmZmVyXG5cdFx0c3JjID0gbnVsbDtcblx0XHRyZXR1cm4gY3VycmVudFVucGFja3IuZ2V0U3RydWN0dXJlcygpXG5cdH0pO1xuXHRyZXR1cm4gY3VycmVudFN0cnVjdHVyZXMgPSBjdXJyZW50VW5wYWNrci5fbWVyZ2VTdHJ1Y3R1cmVzKGxvYWRlZFN0cnVjdHVyZXMsIGN1cnJlbnRTdHJ1Y3R1cmVzKVxufVxuXG52YXIgcmVhZEZpeGVkU3RyaW5nID0gcmVhZFN0cmluZ0pTO1xudmFyIHJlYWRTdHJpbmc4ID0gcmVhZFN0cmluZ0pTO1xudmFyIHJlYWRTdHJpbmcxNiA9IHJlYWRTdHJpbmdKUztcbnZhciByZWFkU3RyaW5nMzIgPSByZWFkU3RyaW5nSlM7XG5leHBvcnRzLmlzTmF0aXZlQWNjZWxlcmF0aW9uRW5hYmxlZCA9IGZhbHNlO1xuXG5mdW5jdGlvbiBzZXRFeHRyYWN0b3IoZXh0cmFjdFN0cmluZ3MpIHtcblx0ZXhwb3J0cy5pc05hdGl2ZUFjY2VsZXJhdGlvbkVuYWJsZWQgPSB0cnVlO1xuXHRyZWFkRml4ZWRTdHJpbmcgPSByZWFkU3RyaW5nKDEpO1xuXHRyZWFkU3RyaW5nOCA9IHJlYWRTdHJpbmcoMik7XG5cdHJlYWRTdHJpbmcxNiA9IHJlYWRTdHJpbmcoMyk7XG5cdHJlYWRTdHJpbmczMiA9IHJlYWRTdHJpbmcoNSk7XG5cdGZ1bmN0aW9uIHJlYWRTdHJpbmcoaGVhZGVyTGVuZ3RoKSB7XG5cdFx0cmV0dXJuIGZ1bmN0aW9uIHJlYWRTdHJpbmcobGVuZ3RoKSB7XG5cdFx0XHRsZXQgc3RyaW5nID0gc3RyaW5nc1tzdHJpbmdQb3NpdGlvbisrXTtcblx0XHRcdGlmIChzdHJpbmcgPT0gbnVsbCkge1xuXHRcdFx0XHRpZiAoYnVuZGxlZFN0cmluZ3MkMSlcblx0XHRcdFx0XHRyZXR1cm4gcmVhZFN0cmluZ0pTKGxlbmd0aClcblx0XHRcdFx0bGV0IGJ5dGVPZmZzZXQgPSBzcmMuYnl0ZU9mZnNldDtcblx0XHRcdFx0bGV0IGV4dHJhY3Rpb24gPSBleHRyYWN0U3RyaW5ncyhwb3NpdGlvbiQxIC0gaGVhZGVyTGVuZ3RoICsgYnl0ZU9mZnNldCwgc3JjRW5kICsgYnl0ZU9mZnNldCwgc3JjLmJ1ZmZlcik7XG5cdFx0XHRcdGlmICh0eXBlb2YgZXh0cmFjdGlvbiA9PSAnc3RyaW5nJykge1xuXHRcdFx0XHRcdHN0cmluZyA9IGV4dHJhY3Rpb247XG5cdFx0XHRcdFx0c3RyaW5ncyA9IEVNUFRZX0FSUkFZO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHN0cmluZ3MgPSBleHRyYWN0aW9uO1xuXHRcdFx0XHRcdHN0cmluZ1Bvc2l0aW9uID0gMTtcblx0XHRcdFx0XHRzcmNTdHJpbmdFbmQgPSAxOyAvLyBldmVuIGlmIGEgdXRmLTggc3RyaW5nIHdhcyBkZWNvZGVkLCBtdXN0IGluZGljYXRlIHdlIGFyZSBpbiB0aGUgbWlkc3Qgb2YgZXh0cmFjdGVkIHN0cmluZ3MgYW5kIGNhbid0IHNraXAgc3RyaW5nc1xuXHRcdFx0XHRcdHN0cmluZyA9IHN0cmluZ3NbMF07XG5cdFx0XHRcdFx0aWYgKHN0cmluZyA9PT0gdW5kZWZpbmVkKVxuXHRcdFx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKCdVbmV4cGVjdGVkIGVuZCBvZiBidWZmZXInKVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRsZXQgc3JjU3RyaW5nTGVuZ3RoID0gc3RyaW5nLmxlbmd0aDtcblx0XHRcdGlmIChzcmNTdHJpbmdMZW5ndGggPD0gbGVuZ3RoKSB7XG5cdFx0XHRcdHBvc2l0aW9uJDEgKz0gbGVuZ3RoO1xuXHRcdFx0XHRyZXR1cm4gc3RyaW5nXG5cdFx0XHR9XG5cdFx0XHRzcmNTdHJpbmcgPSBzdHJpbmc7XG5cdFx0XHRzcmNTdHJpbmdTdGFydCA9IHBvc2l0aW9uJDE7XG5cdFx0XHRzcmNTdHJpbmdFbmQgPSBwb3NpdGlvbiQxICsgc3JjU3RyaW5nTGVuZ3RoO1xuXHRcdFx0cG9zaXRpb24kMSArPSBsZW5ndGg7XG5cdFx0XHRyZXR1cm4gc3RyaW5nLnNsaWNlKDAsIGxlbmd0aCkgLy8gd2Uga25vdyB3ZSBqdXN0IHdhbnQgdGhlIGJlZ2lubmluZ1xuXHRcdH1cblx0fVxufVxuZnVuY3Rpb24gcmVhZFN0cmluZ0pTKGxlbmd0aCkge1xuXHRsZXQgcmVzdWx0O1xuXHRpZiAobGVuZ3RoIDwgMTYpIHtcblx0XHRpZiAocmVzdWx0ID0gc2hvcnRTdHJpbmdJbkpTKGxlbmd0aCkpXG5cdFx0XHRyZXR1cm4gcmVzdWx0XG5cdH1cblx0aWYgKGxlbmd0aCA+IDY0ICYmIGRlY29kZXIpXG5cdFx0cmV0dXJuIGRlY29kZXIuZGVjb2RlKHNyYy5zdWJhcnJheShwb3NpdGlvbiQxLCBwb3NpdGlvbiQxICs9IGxlbmd0aCkpXG5cdGNvbnN0IGVuZCA9IHBvc2l0aW9uJDEgKyBsZW5ndGg7XG5cdGNvbnN0IHVuaXRzID0gW107XG5cdHJlc3VsdCA9ICcnO1xuXHR3aGlsZSAocG9zaXRpb24kMSA8IGVuZCkge1xuXHRcdGNvbnN0IGJ5dGUxID0gc3JjW3Bvc2l0aW9uJDErK107XG5cdFx0aWYgKChieXRlMSAmIDB4ODApID09PSAwKSB7XG5cdFx0XHQvLyAxIGJ5dGVcblx0XHRcdHVuaXRzLnB1c2goYnl0ZTEpO1xuXHRcdH0gZWxzZSBpZiAoKGJ5dGUxICYgMHhlMCkgPT09IDB4YzApIHtcblx0XHRcdC8vIDIgYnl0ZXNcblx0XHRcdGNvbnN0IGJ5dGUyID0gc3JjW3Bvc2l0aW9uJDErK10gJiAweDNmO1xuXHRcdFx0dW5pdHMucHVzaCgoKGJ5dGUxICYgMHgxZikgPDwgNikgfCBieXRlMik7XG5cdFx0fSBlbHNlIGlmICgoYnl0ZTEgJiAweGYwKSA9PT0gMHhlMCkge1xuXHRcdFx0Ly8gMyBieXRlc1xuXHRcdFx0Y29uc3QgYnl0ZTIgPSBzcmNbcG9zaXRpb24kMSsrXSAmIDB4M2Y7XG5cdFx0XHRjb25zdCBieXRlMyA9IHNyY1twb3NpdGlvbiQxKytdICYgMHgzZjtcblx0XHRcdHVuaXRzLnB1c2goKChieXRlMSAmIDB4MWYpIDw8IDEyKSB8IChieXRlMiA8PCA2KSB8IGJ5dGUzKTtcblx0XHR9IGVsc2UgaWYgKChieXRlMSAmIDB4ZjgpID09PSAweGYwKSB7XG5cdFx0XHQvLyA0IGJ5dGVzXG5cdFx0XHRjb25zdCBieXRlMiA9IHNyY1twb3NpdGlvbiQxKytdICYgMHgzZjtcblx0XHRcdGNvbnN0IGJ5dGUzID0gc3JjW3Bvc2l0aW9uJDErK10gJiAweDNmO1xuXHRcdFx0Y29uc3QgYnl0ZTQgPSBzcmNbcG9zaXRpb24kMSsrXSAmIDB4M2Y7XG5cdFx0XHRsZXQgdW5pdCA9ICgoYnl0ZTEgJiAweDA3KSA8PCAweDEyKSB8IChieXRlMiA8PCAweDBjKSB8IChieXRlMyA8PCAweDA2KSB8IGJ5dGU0O1xuXHRcdFx0aWYgKHVuaXQgPiAweGZmZmYpIHtcblx0XHRcdFx0dW5pdCAtPSAweDEwMDAwO1xuXHRcdFx0XHR1bml0cy5wdXNoKCgodW5pdCA+Pj4gMTApICYgMHgzZmYpIHwgMHhkODAwKTtcblx0XHRcdFx0dW5pdCA9IDB4ZGMwMCB8ICh1bml0ICYgMHgzZmYpO1xuXHRcdFx0fVxuXHRcdFx0dW5pdHMucHVzaCh1bml0KTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0dW5pdHMucHVzaChieXRlMSk7XG5cdFx0fVxuXG5cdFx0aWYgKHVuaXRzLmxlbmd0aCA+PSAweDEwMDApIHtcblx0XHRcdHJlc3VsdCArPSBmcm9tQ2hhckNvZGUuYXBwbHkoU3RyaW5nLCB1bml0cyk7XG5cdFx0XHR1bml0cy5sZW5ndGggPSAwO1xuXHRcdH1cblx0fVxuXG5cdGlmICh1bml0cy5sZW5ndGggPiAwKSB7XG5cdFx0cmVzdWx0ICs9IGZyb21DaGFyQ29kZS5hcHBseShTdHJpbmcsIHVuaXRzKTtcblx0fVxuXG5cdHJldHVybiByZXN1bHRcbn1cbmZ1bmN0aW9uIHJlYWRTdHJpbmcoc291cmNlLCBzdGFydCwgbGVuZ3RoKSB7XG5cdGxldCBleGlzdGluZ1NyYyA9IHNyYztcblx0c3JjID0gc291cmNlO1xuXHRwb3NpdGlvbiQxID0gc3RhcnQ7XG5cdHRyeSB7XG5cdFx0cmV0dXJuIHJlYWRTdHJpbmdKUyhsZW5ndGgpO1xuXHR9IGZpbmFsbHkge1xuXHRcdHNyYyA9IGV4aXN0aW5nU3JjO1xuXHR9XG59XG5cbmZ1bmN0aW9uIHJlYWRBcnJheShsZW5ndGgpIHtcblx0bGV0IGFycmF5ID0gbmV3IEFycmF5KGxlbmd0aCk7XG5cdGZvciAobGV0IGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcblx0XHRhcnJheVtpXSA9IHJlYWQoKTtcblx0fVxuXHRpZiAoY3VycmVudFVucGFja3IuZnJlZXplRGF0YSlcblx0XHRyZXR1cm4gT2JqZWN0LmZyZWV6ZShhcnJheSlcblx0cmV0dXJuIGFycmF5XG59XG5cbmZ1bmN0aW9uIHJlYWRNYXAobGVuZ3RoKSB7XG5cdGlmIChjdXJyZW50VW5wYWNrci5tYXBzQXNPYmplY3RzKSB7XG5cdFx0bGV0IG9iamVjdCA9IHt9O1xuXHRcdGZvciAobGV0IGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcblx0XHRcdGxldCBrZXkgPSByZWFkS2V5KCk7XG5cdFx0XHRpZiAoa2V5ID09PSAnX19wcm90b19fJylcblx0XHRcdFx0a2V5ID0gJ19fcHJvdG9fJztcblx0XHRcdG9iamVjdFtrZXldID0gcmVhZCgpO1xuXHRcdH1cblx0XHRyZXR1cm4gb2JqZWN0XG5cdH0gZWxzZSB7XG5cdFx0bGV0IG1hcCA9IG5ldyBNYXAoKTtcblx0XHRmb3IgKGxldCBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG5cdFx0XHRtYXAuc2V0KHJlYWQoKSwgcmVhZCgpKTtcblx0XHR9XG5cdFx0cmV0dXJuIG1hcFxuXHR9XG59XG5cbnZhciBmcm9tQ2hhckNvZGUgPSBTdHJpbmcuZnJvbUNoYXJDb2RlO1xuZnVuY3Rpb24gbG9uZ1N0cmluZ0luSlMobGVuZ3RoKSB7XG5cdGxldCBzdGFydCA9IHBvc2l0aW9uJDE7XG5cdGxldCBieXRlcyA9IG5ldyBBcnJheShsZW5ndGgpO1xuXHRmb3IgKGxldCBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG5cdFx0Y29uc3QgYnl0ZSA9IHNyY1twb3NpdGlvbiQxKytdO1xuXHRcdGlmICgoYnl0ZSAmIDB4ODApID4gMCkge1xuXHRcdFx0XHRwb3NpdGlvbiQxID0gc3RhcnQ7XG5cdFx0XHRcdHJldHVyblxuXHRcdFx0fVxuXHRcdFx0Ynl0ZXNbaV0gPSBieXRlO1xuXHRcdH1cblx0XHRyZXR1cm4gZnJvbUNoYXJDb2RlLmFwcGx5KFN0cmluZywgYnl0ZXMpXG59XG5mdW5jdGlvbiBzaG9ydFN0cmluZ0luSlMobGVuZ3RoKSB7XG5cdGlmIChsZW5ndGggPCA0KSB7XG5cdFx0aWYgKGxlbmd0aCA8IDIpIHtcblx0XHRcdGlmIChsZW5ndGggPT09IDApXG5cdFx0XHRcdHJldHVybiAnJ1xuXHRcdFx0ZWxzZSB7XG5cdFx0XHRcdGxldCBhID0gc3JjW3Bvc2l0aW9uJDErK107XG5cdFx0XHRcdGlmICgoYSAmIDB4ODApID4gMSkge1xuXHRcdFx0XHRcdHBvc2l0aW9uJDEgLT0gMTtcblx0XHRcdFx0XHRyZXR1cm5cblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gZnJvbUNoYXJDb2RlKGEpXG5cdFx0XHR9XG5cdFx0fSBlbHNlIHtcblx0XHRcdGxldCBhID0gc3JjW3Bvc2l0aW9uJDErK107XG5cdFx0XHRsZXQgYiA9IHNyY1twb3NpdGlvbiQxKytdO1xuXHRcdFx0aWYgKChhICYgMHg4MCkgPiAwIHx8IChiICYgMHg4MCkgPiAwKSB7XG5cdFx0XHRcdHBvc2l0aW9uJDEgLT0gMjtcblx0XHRcdFx0cmV0dXJuXG5cdFx0XHR9XG5cdFx0XHRpZiAobGVuZ3RoIDwgMylcblx0XHRcdFx0cmV0dXJuIGZyb21DaGFyQ29kZShhLCBiKVxuXHRcdFx0bGV0IGMgPSBzcmNbcG9zaXRpb24kMSsrXTtcblx0XHRcdGlmICgoYyAmIDB4ODApID4gMCkge1xuXHRcdFx0XHRwb3NpdGlvbiQxIC09IDM7XG5cdFx0XHRcdHJldHVyblxuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIGZyb21DaGFyQ29kZShhLCBiLCBjKVxuXHRcdH1cblx0fSBlbHNlIHtcblx0XHRsZXQgYSA9IHNyY1twb3NpdGlvbiQxKytdO1xuXHRcdGxldCBiID0gc3JjW3Bvc2l0aW9uJDErK107XG5cdFx0bGV0IGMgPSBzcmNbcG9zaXRpb24kMSsrXTtcblx0XHRsZXQgZCA9IHNyY1twb3NpdGlvbiQxKytdO1xuXHRcdGlmICgoYSAmIDB4ODApID4gMCB8fCAoYiAmIDB4ODApID4gMCB8fCAoYyAmIDB4ODApID4gMCB8fCAoZCAmIDB4ODApID4gMCkge1xuXHRcdFx0cG9zaXRpb24kMSAtPSA0O1xuXHRcdFx0cmV0dXJuXG5cdFx0fVxuXHRcdGlmIChsZW5ndGggPCA2KSB7XG5cdFx0XHRpZiAobGVuZ3RoID09PSA0KVxuXHRcdFx0XHRyZXR1cm4gZnJvbUNoYXJDb2RlKGEsIGIsIGMsIGQpXG5cdFx0XHRlbHNlIHtcblx0XHRcdFx0bGV0IGUgPSBzcmNbcG9zaXRpb24kMSsrXTtcblx0XHRcdFx0aWYgKChlICYgMHg4MCkgPiAwKSB7XG5cdFx0XHRcdFx0cG9zaXRpb24kMSAtPSA1O1xuXHRcdFx0XHRcdHJldHVyblxuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiBmcm9tQ2hhckNvZGUoYSwgYiwgYywgZCwgZSlcblx0XHRcdH1cblx0XHR9IGVsc2UgaWYgKGxlbmd0aCA8IDgpIHtcblx0XHRcdGxldCBlID0gc3JjW3Bvc2l0aW9uJDErK107XG5cdFx0XHRsZXQgZiA9IHNyY1twb3NpdGlvbiQxKytdO1xuXHRcdFx0aWYgKChlICYgMHg4MCkgPiAwIHx8IChmICYgMHg4MCkgPiAwKSB7XG5cdFx0XHRcdHBvc2l0aW9uJDEgLT0gNjtcblx0XHRcdFx0cmV0dXJuXG5cdFx0XHR9XG5cdFx0XHRpZiAobGVuZ3RoIDwgNylcblx0XHRcdFx0cmV0dXJuIGZyb21DaGFyQ29kZShhLCBiLCBjLCBkLCBlLCBmKVxuXHRcdFx0bGV0IGcgPSBzcmNbcG9zaXRpb24kMSsrXTtcblx0XHRcdGlmICgoZyAmIDB4ODApID4gMCkge1xuXHRcdFx0XHRwb3NpdGlvbiQxIC09IDc7XG5cdFx0XHRcdHJldHVyblxuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIGZyb21DaGFyQ29kZShhLCBiLCBjLCBkLCBlLCBmLCBnKVxuXHRcdH0gZWxzZSB7XG5cdFx0XHRsZXQgZSA9IHNyY1twb3NpdGlvbiQxKytdO1xuXHRcdFx0bGV0IGYgPSBzcmNbcG9zaXRpb24kMSsrXTtcblx0XHRcdGxldCBnID0gc3JjW3Bvc2l0aW9uJDErK107XG5cdFx0XHRsZXQgaCA9IHNyY1twb3NpdGlvbiQxKytdO1xuXHRcdFx0aWYgKChlICYgMHg4MCkgPiAwIHx8IChmICYgMHg4MCkgPiAwIHx8IChnICYgMHg4MCkgPiAwIHx8IChoICYgMHg4MCkgPiAwKSB7XG5cdFx0XHRcdHBvc2l0aW9uJDEgLT0gODtcblx0XHRcdFx0cmV0dXJuXG5cdFx0XHR9XG5cdFx0XHRpZiAobGVuZ3RoIDwgMTApIHtcblx0XHRcdFx0aWYgKGxlbmd0aCA9PT0gOClcblx0XHRcdFx0XHRyZXR1cm4gZnJvbUNoYXJDb2RlKGEsIGIsIGMsIGQsIGUsIGYsIGcsIGgpXG5cdFx0XHRcdGVsc2Uge1xuXHRcdFx0XHRcdGxldCBpID0gc3JjW3Bvc2l0aW9uJDErK107XG5cdFx0XHRcdFx0aWYgKChpICYgMHg4MCkgPiAwKSB7XG5cdFx0XHRcdFx0XHRwb3NpdGlvbiQxIC09IDk7XG5cdFx0XHRcdFx0XHRyZXR1cm5cblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0cmV0dXJuIGZyb21DaGFyQ29kZShhLCBiLCBjLCBkLCBlLCBmLCBnLCBoLCBpKVxuXHRcdFx0XHR9XG5cdFx0XHR9IGVsc2UgaWYgKGxlbmd0aCA8IDEyKSB7XG5cdFx0XHRcdGxldCBpID0gc3JjW3Bvc2l0aW9uJDErK107XG5cdFx0XHRcdGxldCBqID0gc3JjW3Bvc2l0aW9uJDErK107XG5cdFx0XHRcdGlmICgoaSAmIDB4ODApID4gMCB8fCAoaiAmIDB4ODApID4gMCkge1xuXHRcdFx0XHRcdHBvc2l0aW9uJDEgLT0gMTA7XG5cdFx0XHRcdFx0cmV0dXJuXG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKGxlbmd0aCA8IDExKVxuXHRcdFx0XHRcdHJldHVybiBmcm9tQ2hhckNvZGUoYSwgYiwgYywgZCwgZSwgZiwgZywgaCwgaSwgailcblx0XHRcdFx0bGV0IGsgPSBzcmNbcG9zaXRpb24kMSsrXTtcblx0XHRcdFx0aWYgKChrICYgMHg4MCkgPiAwKSB7XG5cdFx0XHRcdFx0cG9zaXRpb24kMSAtPSAxMTtcblx0XHRcdFx0XHRyZXR1cm5cblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gZnJvbUNoYXJDb2RlKGEsIGIsIGMsIGQsIGUsIGYsIGcsIGgsIGksIGosIGspXG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRsZXQgaSA9IHNyY1twb3NpdGlvbiQxKytdO1xuXHRcdFx0XHRsZXQgaiA9IHNyY1twb3NpdGlvbiQxKytdO1xuXHRcdFx0XHRsZXQgayA9IHNyY1twb3NpdGlvbiQxKytdO1xuXHRcdFx0XHRsZXQgbCA9IHNyY1twb3NpdGlvbiQxKytdO1xuXHRcdFx0XHRpZiAoKGkgJiAweDgwKSA+IDAgfHwgKGogJiAweDgwKSA+IDAgfHwgKGsgJiAweDgwKSA+IDAgfHwgKGwgJiAweDgwKSA+IDApIHtcblx0XHRcdFx0XHRwb3NpdGlvbiQxIC09IDEyO1xuXHRcdFx0XHRcdHJldHVyblxuXHRcdFx0XHR9XG5cdFx0XHRcdGlmIChsZW5ndGggPCAxNCkge1xuXHRcdFx0XHRcdGlmIChsZW5ndGggPT09IDEyKVxuXHRcdFx0XHRcdFx0cmV0dXJuIGZyb21DaGFyQ29kZShhLCBiLCBjLCBkLCBlLCBmLCBnLCBoLCBpLCBqLCBrLCBsKVxuXHRcdFx0XHRcdGVsc2Uge1xuXHRcdFx0XHRcdFx0bGV0IG0gPSBzcmNbcG9zaXRpb24kMSsrXTtcblx0XHRcdFx0XHRcdGlmICgobSAmIDB4ODApID4gMCkge1xuXHRcdFx0XHRcdFx0XHRwb3NpdGlvbiQxIC09IDEzO1xuXHRcdFx0XHRcdFx0XHRyZXR1cm5cblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdHJldHVybiBmcm9tQ2hhckNvZGUoYSwgYiwgYywgZCwgZSwgZiwgZywgaCwgaSwgaiwgaywgbCwgbSlcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0bGV0IG0gPSBzcmNbcG9zaXRpb24kMSsrXTtcblx0XHRcdFx0XHRsZXQgbiA9IHNyY1twb3NpdGlvbiQxKytdO1xuXHRcdFx0XHRcdGlmICgobSAmIDB4ODApID4gMCB8fCAobiAmIDB4ODApID4gMCkge1xuXHRcdFx0XHRcdFx0cG9zaXRpb24kMSAtPSAxNDtcblx0XHRcdFx0XHRcdHJldHVyblxuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRpZiAobGVuZ3RoIDwgMTUpXG5cdFx0XHRcdFx0XHRyZXR1cm4gZnJvbUNoYXJDb2RlKGEsIGIsIGMsIGQsIGUsIGYsIGcsIGgsIGksIGosIGssIGwsIG0sIG4pXG5cdFx0XHRcdFx0bGV0IG8gPSBzcmNbcG9zaXRpb24kMSsrXTtcblx0XHRcdFx0XHRpZiAoKG8gJiAweDgwKSA+IDApIHtcblx0XHRcdFx0XHRcdHBvc2l0aW9uJDEgLT0gMTU7XG5cdFx0XHRcdFx0XHRyZXR1cm5cblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0cmV0dXJuIGZyb21DaGFyQ29kZShhLCBiLCBjLCBkLCBlLCBmLCBnLCBoLCBpLCBqLCBrLCBsLCBtLCBuLCBvKVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG59XG5cbmZ1bmN0aW9uIHJlYWRPbmx5SlNTdHJpbmcoKSB7XG5cdGxldCB0b2tlbiA9IHNyY1twb3NpdGlvbiQxKytdO1xuXHRsZXQgbGVuZ3RoO1xuXHRpZiAodG9rZW4gPCAweGMwKSB7XG5cdFx0Ly8gZml4c3RyXG5cdFx0bGVuZ3RoID0gdG9rZW4gLSAweGEwO1xuXHR9IGVsc2Uge1xuXHRcdHN3aXRjaCh0b2tlbikge1xuXHRcdFx0Y2FzZSAweGQ5OlxuXHRcdFx0Ly8gc3RyIDhcblx0XHRcdFx0bGVuZ3RoID0gc3JjW3Bvc2l0aW9uJDErK107XG5cdFx0XHRcdGJyZWFrXG5cdFx0XHRjYXNlIDB4ZGE6XG5cdFx0XHQvLyBzdHIgMTZcblx0XHRcdFx0bGVuZ3RoID0gZGF0YVZpZXcuZ2V0VWludDE2KHBvc2l0aW9uJDEpO1xuXHRcdFx0XHRwb3NpdGlvbiQxICs9IDI7XG5cdFx0XHRcdGJyZWFrXG5cdFx0XHRjYXNlIDB4ZGI6XG5cdFx0XHQvLyBzdHIgMzJcblx0XHRcdFx0bGVuZ3RoID0gZGF0YVZpZXcuZ2V0VWludDMyKHBvc2l0aW9uJDEpO1xuXHRcdFx0XHRwb3NpdGlvbiQxICs9IDQ7XG5cdFx0XHRcdGJyZWFrXG5cdFx0XHRkZWZhdWx0OlxuXHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IoJ0V4cGVjdGVkIHN0cmluZycpXG5cdFx0fVxuXHR9XG5cdHJldHVybiByZWFkU3RyaW5nSlMobGVuZ3RoKVxufVxuXG5cbmZ1bmN0aW9uIHJlYWRCaW4obGVuZ3RoKSB7XG5cdHJldHVybiBjdXJyZW50VW5wYWNrci5jb3B5QnVmZmVycyA/XG5cdFx0Ly8gc3BlY2lmaWNhbGx5IHVzZSB0aGUgY29weWluZyBzbGljZSAobm90IHRoZSBub2RlIG9uZSlcblx0XHRVaW50OEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKHNyYywgcG9zaXRpb24kMSwgcG9zaXRpb24kMSArPSBsZW5ndGgpIDpcblx0XHRzcmMuc3ViYXJyYXkocG9zaXRpb24kMSwgcG9zaXRpb24kMSArPSBsZW5ndGgpXG59XG5mdW5jdGlvbiByZWFkRXh0KGxlbmd0aCkge1xuXHRsZXQgdHlwZSA9IHNyY1twb3NpdGlvbiQxKytdO1xuXHRpZiAoY3VycmVudEV4dGVuc2lvbnNbdHlwZV0pIHtcblx0XHRsZXQgZW5kO1xuXHRcdHJldHVybiBjdXJyZW50RXh0ZW5zaW9uc1t0eXBlXShzcmMuc3ViYXJyYXkocG9zaXRpb24kMSwgZW5kID0gKHBvc2l0aW9uJDEgKz0gbGVuZ3RoKSksIChyZWFkUG9zaXRpb24pID0+IHtcblx0XHRcdHBvc2l0aW9uJDEgPSByZWFkUG9zaXRpb247XG5cdFx0XHR0cnkge1xuXHRcdFx0XHRyZXR1cm4gcmVhZCgpO1xuXHRcdFx0fSBmaW5hbGx5IHtcblx0XHRcdFx0cG9zaXRpb24kMSA9IGVuZDtcblx0XHRcdH1cblx0XHR9KVxuXHR9XG5cdGVsc2Vcblx0XHR0aHJvdyBuZXcgRXJyb3IoJ1Vua25vd24gZXh0ZW5zaW9uIHR5cGUgJyArIHR5cGUpXG59XG5cbnZhciBrZXlDYWNoZSA9IG5ldyBBcnJheSg0MDk2KTtcbmZ1bmN0aW9uIHJlYWRLZXkoKSB7XG5cdGxldCBsZW5ndGggPSBzcmNbcG9zaXRpb24kMSsrXTtcblx0aWYgKGxlbmd0aCA+PSAweGEwICYmIGxlbmd0aCA8IDB4YzApIHtcblx0XHQvLyBmaXhzdHIsIHBvdGVudGlhbGx5IHVzZSBrZXkgY2FjaGVcblx0XHRsZW5ndGggPSBsZW5ndGggLSAweGEwO1xuXHRcdGlmIChzcmNTdHJpbmdFbmQgPj0gcG9zaXRpb24kMSkgLy8gaWYgaXQgaGFzIGJlZW4gZXh0cmFjdGVkLCBtdXN0IHVzZSBpdCAoYW5kIGZhc3RlciBhbnl3YXkpXG5cdFx0XHRyZXR1cm4gc3JjU3RyaW5nLnNsaWNlKHBvc2l0aW9uJDEgLSBzcmNTdHJpbmdTdGFydCwgKHBvc2l0aW9uJDEgKz0gbGVuZ3RoKSAtIHNyY1N0cmluZ1N0YXJ0KVxuXHRcdGVsc2UgaWYgKCEoc3JjU3RyaW5nRW5kID09IDAgJiYgc3JjRW5kIDwgMTgwKSlcblx0XHRcdHJldHVybiByZWFkRml4ZWRTdHJpbmcobGVuZ3RoKVxuXHR9IGVsc2UgeyAvLyBub3QgY2FjaGVhYmxlLCBnbyBiYWNrIGFuZCBkbyBhIHN0YW5kYXJkIHJlYWRcblx0XHRwb3NpdGlvbiQxLS07XG5cdFx0cmV0dXJuIGFzU2FmZVN0cmluZyhyZWFkKCkpXG5cdH1cblx0bGV0IGtleSA9ICgobGVuZ3RoIDw8IDUpIF4gKGxlbmd0aCA+IDEgPyBkYXRhVmlldy5nZXRVaW50MTYocG9zaXRpb24kMSkgOiBsZW5ndGggPiAwID8gc3JjW3Bvc2l0aW9uJDFdIDogMCkpICYgMHhmZmY7XG5cdGxldCBlbnRyeSA9IGtleUNhY2hlW2tleV07XG5cdGxldCBjaGVja1Bvc2l0aW9uID0gcG9zaXRpb24kMTtcblx0bGV0IGVuZCA9IHBvc2l0aW9uJDEgKyBsZW5ndGggLSAzO1xuXHRsZXQgY2h1bms7XG5cdGxldCBpID0gMDtcblx0aWYgKGVudHJ5ICYmIGVudHJ5LmJ5dGVzID09IGxlbmd0aCkge1xuXHRcdHdoaWxlIChjaGVja1Bvc2l0aW9uIDwgZW5kKSB7XG5cdFx0XHRjaHVuayA9IGRhdGFWaWV3LmdldFVpbnQzMihjaGVja1Bvc2l0aW9uKTtcblx0XHRcdGlmIChjaHVuayAhPSBlbnRyeVtpKytdKSB7XG5cdFx0XHRcdGNoZWNrUG9zaXRpb24gPSAweDcwMDAwMDAwO1xuXHRcdFx0XHRicmVha1xuXHRcdFx0fVxuXHRcdFx0Y2hlY2tQb3NpdGlvbiArPSA0O1xuXHRcdH1cblx0XHRlbmQgKz0gMztcblx0XHR3aGlsZSAoY2hlY2tQb3NpdGlvbiA8IGVuZCkge1xuXHRcdFx0Y2h1bmsgPSBzcmNbY2hlY2tQb3NpdGlvbisrXTtcblx0XHRcdGlmIChjaHVuayAhPSBlbnRyeVtpKytdKSB7XG5cdFx0XHRcdGNoZWNrUG9zaXRpb24gPSAweDcwMDAwMDAwO1xuXHRcdFx0XHRicmVha1xuXHRcdFx0fVxuXHRcdH1cblx0XHRpZiAoY2hlY2tQb3NpdGlvbiA9PT0gZW5kKSB7XG5cdFx0XHRwb3NpdGlvbiQxID0gY2hlY2tQb3NpdGlvbjtcblx0XHRcdHJldHVybiBlbnRyeS5zdHJpbmdcblx0XHR9XG5cdFx0ZW5kIC09IDM7XG5cdFx0Y2hlY2tQb3NpdGlvbiA9IHBvc2l0aW9uJDE7XG5cdH1cblx0ZW50cnkgPSBbXTtcblx0a2V5Q2FjaGVba2V5XSA9IGVudHJ5O1xuXHRlbnRyeS5ieXRlcyA9IGxlbmd0aDtcblx0d2hpbGUgKGNoZWNrUG9zaXRpb24gPCBlbmQpIHtcblx0XHRjaHVuayA9IGRhdGFWaWV3LmdldFVpbnQzMihjaGVja1Bvc2l0aW9uKTtcblx0XHRlbnRyeS5wdXNoKGNodW5rKTtcblx0XHRjaGVja1Bvc2l0aW9uICs9IDQ7XG5cdH1cblx0ZW5kICs9IDM7XG5cdHdoaWxlIChjaGVja1Bvc2l0aW9uIDwgZW5kKSB7XG5cdFx0Y2h1bmsgPSBzcmNbY2hlY2tQb3NpdGlvbisrXTtcblx0XHRlbnRyeS5wdXNoKGNodW5rKTtcblx0fVxuXHQvLyBmb3Igc21hbGwgYmxvY2tzLCBhdm9pZGluZyB0aGUgb3ZlcmhlYWQgb2YgdGhlIGV4dHJhY3QgY2FsbCBpcyBoZWxwZnVsXG5cdGxldCBzdHJpbmcgPSBsZW5ndGggPCAxNiA/IHNob3J0U3RyaW5nSW5KUyhsZW5ndGgpIDogbG9uZ1N0cmluZ0luSlMobGVuZ3RoKTtcblx0aWYgKHN0cmluZyAhPSBudWxsKVxuXHRcdHJldHVybiBlbnRyeS5zdHJpbmcgPSBzdHJpbmdcblx0cmV0dXJuIGVudHJ5LnN0cmluZyA9IHJlYWRGaXhlZFN0cmluZyhsZW5ndGgpXG59XG5cbmZ1bmN0aW9uIGFzU2FmZVN0cmluZyhwcm9wZXJ0eSkge1xuXHQvLyBwcm90ZWN0IGFnYWluc3QgZXhwZW5zaXZlIChEb1MpIHN0cmluZyBjb252ZXJzaW9uc1xuXHRpZiAodHlwZW9mIHByb3BlcnR5ID09PSAnc3RyaW5nJykgcmV0dXJuIHByb3BlcnR5O1xuXHRpZiAodHlwZW9mIHByb3BlcnR5ID09PSAnbnVtYmVyJyB8fCB0eXBlb2YgcHJvcGVydHkgPT09ICdib29sZWFuJyB8fCB0eXBlb2YgcHJvcGVydHkgPT09ICdiaWdpbnQnKSByZXR1cm4gcHJvcGVydHkudG9TdHJpbmcoKTtcblx0aWYgKHByb3BlcnR5ID09IG51bGwpIHJldHVybiBwcm9wZXJ0eSArICcnO1xuXHR0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgcHJvcGVydHkgdHlwZSBmb3IgcmVjb3JkJywgdHlwZW9mIHByb3BlcnR5KTtcbn1cbi8vIHRoZSByZWdpc3RyYXRpb24gb2YgdGhlIHJlY29yZCBkZWZpbml0aW9uIGV4dGVuc2lvbiAoYXMgXCJyXCIpXG5jb25zdCByZWNvcmREZWZpbml0aW9uID0gKGlkLCBoaWdoQnl0ZSkgPT4ge1xuXHRsZXQgc3RydWN0dXJlID0gcmVhZCgpLm1hcChhc1NhZmVTdHJpbmcpOyAvLyBlbnN1cmUgdGhhdCBhbGwga2V5cyBhcmUgc3RyaW5ncyBhbmRcblx0Ly8gdGhhdCB0aGUgYXJyYXkgaXMgbXV0YWJsZVxuXHRsZXQgZmlyc3RCeXRlID0gaWQ7XG5cdGlmIChoaWdoQnl0ZSAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0aWQgPSBpZCA8IDMyID8gLSgoaGlnaEJ5dGUgPDwgNSkgKyBpZCkgOiAoKGhpZ2hCeXRlIDw8IDUpICsgaWQpO1xuXHRcdHN0cnVjdHVyZS5oaWdoQnl0ZSA9IGhpZ2hCeXRlO1xuXHR9XG5cdGxldCBleGlzdGluZ1N0cnVjdHVyZSA9IGN1cnJlbnRTdHJ1Y3R1cmVzW2lkXTtcblx0Ly8gSWYgaXQgaXMgYSBzaGFyZWQgc3RydWN0dXJlLCB3ZSBuZWVkIHRvIHJlc3RvcmUgYW55IGNoYW5nZXMgYWZ0ZXIgcmVhZGluZy5cblx0Ly8gQWxzbyBpbiBzZXF1ZW50aWFsIG1vZGUsIHdlIG1heSBnZXQgaW5jb21wbGV0ZSByZWFkcyBhbmQgdGh1cyBlcnJvcnMsIGFuZCB3ZSBuZWVkIHRvIHJlc3RvcmVcblx0Ly8gdG8gdGhlIHN0YXRlIHByaW9yIHRvIGFuIGluY29tcGxldGUgcmVhZCBpbiBvcmRlciB0byBwcm9wZXJseSByZXN1bWUuXG5cdGlmIChleGlzdGluZ1N0cnVjdHVyZSAmJiAoZXhpc3RpbmdTdHJ1Y3R1cmUuaXNTaGFyZWQgfHwgc2VxdWVudGlhbE1vZGUpKSB7XG5cdFx0KGN1cnJlbnRTdHJ1Y3R1cmVzLnJlc3RvcmVTdHJ1Y3R1cmVzIHx8IChjdXJyZW50U3RydWN0dXJlcy5yZXN0b3JlU3RydWN0dXJlcyA9IFtdKSlbaWRdID0gZXhpc3RpbmdTdHJ1Y3R1cmU7XG5cdH1cblx0Y3VycmVudFN0cnVjdHVyZXNbaWRdID0gc3RydWN0dXJlO1xuXHRzdHJ1Y3R1cmUucmVhZCA9IGNyZWF0ZVN0cnVjdHVyZVJlYWRlcihzdHJ1Y3R1cmUsIGZpcnN0Qnl0ZSk7XG5cdHJldHVybiBzdHJ1Y3R1cmUucmVhZCgpXG59O1xuY3VycmVudEV4dGVuc2lvbnNbMF0gPSAoKSA9PiB7fTsgLy8gbm90ZXBhY2sgZGVmaW5lcyBleHRlbnNpb24gMCB0byBtZWFuIHVuZGVmaW5lZCwgc28gdXNlIHRoYXQgYXMgdGhlIGRlZmF1bHQgaGVyZVxuY3VycmVudEV4dGVuc2lvbnNbMF0ubm9CdWZmZXIgPSB0cnVlO1xuXG5jdXJyZW50RXh0ZW5zaW9uc1sweDQyXSA9IChkYXRhKSA9PiB7XG5cdC8vIGRlY29kZSBiaWdpbnRcblx0bGV0IGxlbmd0aCA9IGRhdGEubGVuZ3RoO1xuXHRsZXQgdmFsdWUgPSBCaWdJbnQoZGF0YVswXSAmIDB4ODAgPyBkYXRhWzBdIC0gMHgxMDAgOiBkYXRhWzBdKTtcblx0Zm9yIChsZXQgaSA9IDE7IGkgPCBsZW5ndGg7IGkrKykge1xuXHRcdHZhbHVlIDw8PSA4bjtcblx0XHR2YWx1ZSArPSBCaWdJbnQoZGF0YVtpXSk7XG5cdH1cblx0cmV0dXJuIHZhbHVlO1xufTtcblxubGV0IGVycm9ycyA9IHsgRXJyb3IsIFR5cGVFcnJvciwgUmVmZXJlbmNlRXJyb3IgfTtcbmN1cnJlbnRFeHRlbnNpb25zWzB4NjVdID0gKCkgPT4ge1xuXHRsZXQgZGF0YSA9IHJlYWQoKTtcblx0cmV0dXJuIChlcnJvcnNbZGF0YVswXV0gfHwgRXJyb3IpKGRhdGFbMV0sIHsgY2F1c2U6IGRhdGFbMl0gfSlcbn07XG5cbmN1cnJlbnRFeHRlbnNpb25zWzB4NjldID0gKGRhdGEpID0+IHtcblx0Ly8gaWQgZXh0ZW5zaW9uIChmb3Igc3RydWN0dXJlZCBjbG9uZXMpXG5cdGlmIChjdXJyZW50VW5wYWNrci5zdHJ1Y3R1cmVkQ2xvbmUgPT09IGZhbHNlKSB0aHJvdyBuZXcgRXJyb3IoJ1N0cnVjdHVyZWQgY2xvbmUgZXh0ZW5zaW9uIGlzIGRpc2FibGVkJylcblx0bGV0IGlkID0gZGF0YVZpZXcuZ2V0VWludDMyKHBvc2l0aW9uJDEgLSA0KTtcblx0aWYgKCFyZWZlcmVuY2VNYXApXG5cdFx0cmVmZXJlbmNlTWFwID0gbmV3IE1hcCgpO1xuXHRsZXQgdG9rZW4gPSBzcmNbcG9zaXRpb24kMV07XG5cdGxldCB0YXJnZXQ7XG5cdC8vIFRPRE86IGhhbmRsZSBNYXBzLCBTZXRzLCBhbmQgb3RoZXIgdHlwZXMgdGhhdCBjYW4gY3ljbGU7IHRoaXMgaXMgY29tcGxpY2F0ZWQsIGJlY2F1c2UgeW91IHBvdGVudGlhbGx5IG5lZWQgdG8gcmVhZFxuXHQvLyBhaGVhZCBwYXN0IHJlZmVyZW5jZXMgdG8gcmVjb3JkIHN0cnVjdHVyZSBkZWZpbml0aW9uc1xuXHRpZiAodG9rZW4gPj0gMHg5MCAmJiB0b2tlbiA8IDB4YTAgfHwgdG9rZW4gPT0gMHhkYyB8fCB0b2tlbiA9PSAweGRkKVxuXHRcdHRhcmdldCA9IFtdO1xuXHRlbHNlXG5cdFx0dGFyZ2V0ID0ge307XG5cblx0bGV0IHJlZkVudHJ5ID0geyB0YXJnZXQgfTsgLy8gYSBwbGFjZWhvbGRlciBvYmplY3Rcblx0cmVmZXJlbmNlTWFwLnNldChpZCwgcmVmRW50cnkpO1xuXHRsZXQgdGFyZ2V0UHJvcGVydGllcyA9IHJlYWQoKTsgLy8gcmVhZCB0aGUgbmV4dCB2YWx1ZSBhcyB0aGUgdGFyZ2V0IG9iamVjdCB0byBpZFxuXHRpZiAocmVmRW50cnkudXNlZCkgLy8gdGhlcmUgaXMgYSBjeWNsZSwgc28gd2UgaGF2ZSB0byBhc3NpZ24gcHJvcGVydGllcyB0byBvcmlnaW5hbCB0YXJnZXRcblx0XHRyZXR1cm4gT2JqZWN0LmFzc2lnbih0YXJnZXQsIHRhcmdldFByb3BlcnRpZXMpXG5cdHJlZkVudHJ5LnRhcmdldCA9IHRhcmdldFByb3BlcnRpZXM7IC8vIHRoZSBwbGFjZWhvbGRlciB3YXNuJ3QgdXNlZCwgcmVwbGFjZSB3aXRoIHRoZSBkZXNlcmlhbGl6ZWQgb25lXG5cdHJldHVybiB0YXJnZXRQcm9wZXJ0aWVzIC8vIG5vIGN5Y2xlLCBjYW4ganVzdCB1c2UgdGhlIHJldHVybmVkIHJlYWQgb2JqZWN0XG59O1xuXG5jdXJyZW50RXh0ZW5zaW9uc1sweDcwXSA9IChkYXRhKSA9PiB7XG5cdC8vIHBvaW50ZXIgZXh0ZW5zaW9uIChmb3Igc3RydWN0dXJlZCBjbG9uZXMpXG5cdGlmIChjdXJyZW50VW5wYWNrci5zdHJ1Y3R1cmVkQ2xvbmUgPT09IGZhbHNlKSB0aHJvdyBuZXcgRXJyb3IoJ1N0cnVjdHVyZWQgY2xvbmUgZXh0ZW5zaW9uIGlzIGRpc2FibGVkJylcblx0bGV0IGlkID0gZGF0YVZpZXcuZ2V0VWludDMyKHBvc2l0aW9uJDEgLSA0KTtcblx0bGV0IHJlZkVudHJ5ID0gcmVmZXJlbmNlTWFwLmdldChpZCk7XG5cdHJlZkVudHJ5LnVzZWQgPSB0cnVlO1xuXHRyZXR1cm4gcmVmRW50cnkudGFyZ2V0XG59O1xuXG5jdXJyZW50RXh0ZW5zaW9uc1sweDczXSA9ICgpID0+IG5ldyBTZXQocmVhZCgpKTtcblxuY29uc3QgdHlwZWRBcnJheXMgPSBbJ0ludDgnLCdVaW50OCcsJ1VpbnQ4Q2xhbXBlZCcsJ0ludDE2JywnVWludDE2JywnSW50MzInLCdVaW50MzInLCdGbG9hdDMyJywnRmxvYXQ2NCcsJ0JpZ0ludDY0JywnQmlnVWludDY0J10ubWFwKHR5cGUgPT4gdHlwZSArICdBcnJheScpO1xuXG5sZXQgZ2xibCA9IHR5cGVvZiBnbG9iYWxUaGlzID09PSAnb2JqZWN0JyA/IGdsb2JhbFRoaXMgOiB3aW5kb3c7XG5jdXJyZW50RXh0ZW5zaW9uc1sweDc0XSA9IChkYXRhKSA9PiB7XG5cdGxldCB0eXBlQ29kZSA9IGRhdGFbMF07XG5cdGxldCB0eXBlZEFycmF5TmFtZSA9IHR5cGVkQXJyYXlzW3R5cGVDb2RlXTtcblx0aWYgKCF0eXBlZEFycmF5TmFtZSkge1xuXHRcdGlmICh0eXBlQ29kZSA9PT0gMTYpIHtcblx0XHRcdGxldCBhYiA9IG5ldyBBcnJheUJ1ZmZlcihkYXRhLmxlbmd0aCAtIDEpO1xuXHRcdFx0bGV0IHU4ID0gbmV3IFVpbnQ4QXJyYXkoYWIpO1xuXHRcdFx0dTguc2V0KGRhdGEuc3ViYXJyYXkoMSkpO1xuXHRcdFx0cmV0dXJuIGFiO1xuXHRcdH1cblx0XHR0aHJvdyBuZXcgRXJyb3IoJ0NvdWxkIG5vdCBmaW5kIHR5cGVkIGFycmF5IGZvciBjb2RlICcgKyB0eXBlQ29kZSlcblx0fVxuXHQvLyB3ZSBoYXZlIHRvIGFsd2F5cyBzbGljZS9jb3B5IGhlcmUgdG8gZ2V0IGEgbmV3IEFycmF5QnVmZmVyIHRoYXQgaXMgd29yZC9ieXRlIGFsaWduZWRcblx0cmV0dXJuIG5ldyBnbGJsW3R5cGVkQXJyYXlOYW1lXShVaW50OEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGRhdGEsIDEpLmJ1ZmZlcilcbn07XG5jdXJyZW50RXh0ZW5zaW9uc1sweDc4XSA9ICgpID0+IHtcblx0bGV0IGRhdGEgPSByZWFkKCk7XG5cdHJldHVybiBuZXcgUmVnRXhwKGRhdGFbMF0sIGRhdGFbMV0pXG59O1xuY29uc3QgVEVNUF9CVU5ETEUgPSBbXTtcbmN1cnJlbnRFeHRlbnNpb25zWzB4NjJdID0gKGRhdGEpID0+IHtcblx0bGV0IGRhdGFTaXplID0gKGRhdGFbMF0gPDwgMjQpICsgKGRhdGFbMV0gPDwgMTYpICsgKGRhdGFbMl0gPDwgOCkgKyBkYXRhWzNdO1xuXHRsZXQgZGF0YVBvc2l0aW9uID0gcG9zaXRpb24kMTtcblx0cG9zaXRpb24kMSArPSBkYXRhU2l6ZSAtIGRhdGEubGVuZ3RoO1xuXHRidW5kbGVkU3RyaW5ncyQxID0gVEVNUF9CVU5ETEU7XG5cdGJ1bmRsZWRTdHJpbmdzJDEgPSBbcmVhZE9ubHlKU1N0cmluZygpLCByZWFkT25seUpTU3RyaW5nKCldO1xuXHRidW5kbGVkU3RyaW5ncyQxLnBvc2l0aW9uMCA9IDA7XG5cdGJ1bmRsZWRTdHJpbmdzJDEucG9zaXRpb24xID0gMDtcblx0YnVuZGxlZFN0cmluZ3MkMS5wb3N0QnVuZGxlUG9zaXRpb24gPSBwb3NpdGlvbiQxO1xuXHRwb3NpdGlvbiQxID0gZGF0YVBvc2l0aW9uO1xuXHRyZXR1cm4gcmVhZCgpXG59O1xuXG5jdXJyZW50RXh0ZW5zaW9uc1sweGZmXSA9IChkYXRhKSA9PiB7XG5cdC8vIDMyLWJpdCBkYXRlIGV4dGVuc2lvblxuXHRpZiAoZGF0YS5sZW5ndGggPT0gNClcblx0XHRyZXR1cm4gbmV3IERhdGUoKGRhdGFbMF0gKiAweDEwMDAwMDAgKyAoZGF0YVsxXSA8PCAxNikgKyAoZGF0YVsyXSA8PCA4KSArIGRhdGFbM10pICogMTAwMClcblx0ZWxzZSBpZiAoZGF0YS5sZW5ndGggPT0gOClcblx0XHRyZXR1cm4gbmV3IERhdGUoXG5cdFx0XHQoKGRhdGFbMF0gPDwgMjIpICsgKGRhdGFbMV0gPDwgMTQpICsgKGRhdGFbMl0gPDwgNikgKyAoZGF0YVszXSA+PiAyKSkgLyAxMDAwMDAwICtcblx0XHRcdCgoZGF0YVszXSAmIDB4MykgKiAweDEwMDAwMDAwMCArIGRhdGFbNF0gKiAweDEwMDAwMDAgKyAoZGF0YVs1XSA8PCAxNikgKyAoZGF0YVs2XSA8PCA4KSArIGRhdGFbN10pICogMTAwMClcblx0ZWxzZSBpZiAoZGF0YS5sZW5ndGggPT0gMTIpLy8gVE9ETzogSW1wbGVtZW50IHN1cHBvcnQgZm9yIG5lZ2F0aXZlXG5cdFx0cmV0dXJuIG5ldyBEYXRlKFxuXHRcdFx0KChkYXRhWzBdIDw8IDI0KSArIChkYXRhWzFdIDw8IDE2KSArIChkYXRhWzJdIDw8IDgpICsgZGF0YVszXSkgLyAxMDAwMDAwICtcblx0XHRcdCgoKGRhdGFbNF0gJiAweDgwKSA/IC0weDEwMDAwMDAwMDAwMDAgOiAwKSArIGRhdGFbNl0gKiAweDEwMDAwMDAwMDAwICsgZGF0YVs3XSAqIDB4MTAwMDAwMDAwICsgZGF0YVs4XSAqIDB4MTAwMDAwMCArIChkYXRhWzldIDw8IDE2KSArIChkYXRhWzEwXSA8PCA4KSArIGRhdGFbMTFdKSAqIDEwMDApXG5cdGVsc2Vcblx0XHRyZXR1cm4gbmV3IERhdGUoJ2ludmFsaWQnKVxufTsgLy8gbm90ZXBhY2sgZGVmaW5lcyBleHRlbnNpb24gMCB0byBtZWFuIHVuZGVmaW5lZCwgc28gdXNlIHRoYXQgYXMgdGhlIGRlZmF1bHQgaGVyZVxuLy8gcmVnaXN0cmF0aW9uIG9mIGJ1bGsgcmVjb3JkIGRlZmluaXRpb24/XG4vLyBjdXJyZW50RXh0ZW5zaW9uc1sweDUyXSA9ICgpID0+XG5cbmZ1bmN0aW9uIHNhdmVTdGF0ZSQxKGNhbGxiYWNrKSB7XG5cdGlmIChvblNhdmVTdGF0ZSlcblx0XHRvblNhdmVTdGF0ZSgpO1xuXHRsZXQgc2F2ZWRTcmNFbmQgPSBzcmNFbmQ7XG5cdGxldCBzYXZlZFBvc2l0aW9uID0gcG9zaXRpb24kMTtcblx0bGV0IHNhdmVkU3RyaW5nUG9zaXRpb24gPSBzdHJpbmdQb3NpdGlvbjtcblx0bGV0IHNhdmVkU3JjU3RyaW5nU3RhcnQgPSBzcmNTdHJpbmdTdGFydDtcblx0bGV0IHNhdmVkU3JjU3RyaW5nRW5kID0gc3JjU3RyaW5nRW5kO1xuXHRsZXQgc2F2ZWRTcmNTdHJpbmcgPSBzcmNTdHJpbmc7XG5cdGxldCBzYXZlZFN0cmluZ3MgPSBzdHJpbmdzO1xuXHRsZXQgc2F2ZWRSZWZlcmVuY2VNYXAgPSByZWZlcmVuY2VNYXA7XG5cdGxldCBzYXZlZEJ1bmRsZWRTdHJpbmdzID0gYnVuZGxlZFN0cmluZ3MkMTtcblxuXHQvLyBUT0RPOiBXZSBtYXkgbmVlZCB0byByZXZpc2l0IHRoaXMgaWYgd2UgZG8gbW9yZSBleHRlcm5hbCBjYWxscyB0byB1c2VyIGNvZGUgKHNpbmNlIGl0IGNvdWxkIGJlIHNsb3cpXG5cdGxldCBzYXZlZFNyYyA9IG5ldyBVaW50OEFycmF5KHNyYy5zbGljZSgwLCBzcmNFbmQpKTsgLy8gd2UgY29weSB0aGUgZGF0YSBpbiBjYXNlIGl0IGNoYW5nZXMgd2hpbGUgZXh0ZXJuYWwgZGF0YSBpcyBwcm9jZXNzZWRcblx0bGV0IHNhdmVkU3RydWN0dXJlcyA9IGN1cnJlbnRTdHJ1Y3R1cmVzO1xuXHRsZXQgc2F2ZWRTdHJ1Y3R1cmVzQ29udGVudHMgPSBjdXJyZW50U3RydWN0dXJlcy5zbGljZSgwLCBjdXJyZW50U3RydWN0dXJlcy5sZW5ndGgpO1xuXHRsZXQgc2F2ZWRQYWNrciA9IGN1cnJlbnRVbnBhY2tyO1xuXHRsZXQgc2F2ZWRTZXF1ZW50aWFsTW9kZSA9IHNlcXVlbnRpYWxNb2RlO1xuXHRsZXQgdmFsdWUgPSBjYWxsYmFjaygpO1xuXHRzcmNFbmQgPSBzYXZlZFNyY0VuZDtcblx0cG9zaXRpb24kMSA9IHNhdmVkUG9zaXRpb247XG5cdHN0cmluZ1Bvc2l0aW9uID0gc2F2ZWRTdHJpbmdQb3NpdGlvbjtcblx0c3JjU3RyaW5nU3RhcnQgPSBzYXZlZFNyY1N0cmluZ1N0YXJ0O1xuXHRzcmNTdHJpbmdFbmQgPSBzYXZlZFNyY1N0cmluZ0VuZDtcblx0c3JjU3RyaW5nID0gc2F2ZWRTcmNTdHJpbmc7XG5cdHN0cmluZ3MgPSBzYXZlZFN0cmluZ3M7XG5cdHJlZmVyZW5jZU1hcCA9IHNhdmVkUmVmZXJlbmNlTWFwO1xuXHRidW5kbGVkU3RyaW5ncyQxID0gc2F2ZWRCdW5kbGVkU3RyaW5ncztcblx0c3JjID0gc2F2ZWRTcmM7XG5cdHNlcXVlbnRpYWxNb2RlID0gc2F2ZWRTZXF1ZW50aWFsTW9kZTtcblx0Y3VycmVudFN0cnVjdHVyZXMgPSBzYXZlZFN0cnVjdHVyZXM7XG5cdGN1cnJlbnRTdHJ1Y3R1cmVzLnNwbGljZSgwLCBjdXJyZW50U3RydWN0dXJlcy5sZW5ndGgsIC4uLnNhdmVkU3RydWN0dXJlc0NvbnRlbnRzKTtcblx0Y3VycmVudFVucGFja3IgPSBzYXZlZFBhY2tyO1xuXHRkYXRhVmlldyA9IG5ldyBEYXRhVmlldyhzcmMuYnVmZmVyLCBzcmMuYnl0ZU9mZnNldCwgc3JjLmJ5dGVMZW5ndGgpO1xuXHRyZXR1cm4gdmFsdWVcbn1cbmZ1bmN0aW9uIGNsZWFyU291cmNlKCkge1xuXHRzcmMgPSBudWxsO1xuXHRyZWZlcmVuY2VNYXAgPSBudWxsO1xuXHRjdXJyZW50U3RydWN0dXJlcyA9IG51bGw7XG59XG5cbmZ1bmN0aW9uIGFkZEV4dGVuc2lvbiQxKGV4dGVuc2lvbikge1xuXHRpZiAoZXh0ZW5zaW9uLnVucGFjaylcblx0XHRjdXJyZW50RXh0ZW5zaW9uc1tleHRlbnNpb24udHlwZV0gPSBleHRlbnNpb24udW5wYWNrO1xuXHRlbHNlXG5cdFx0Y3VycmVudEV4dGVuc2lvbnNbZXh0ZW5zaW9uLnR5cGVdID0gZXh0ZW5zaW9uO1xufVxuXG5jb25zdCBtdWx0MTAgPSBuZXcgQXJyYXkoMTQ3KTsgLy8gdGhpcyBpcyBhIHRhYmxlIG1hdGNoaW5nIGJpbmFyeSBleHBvbmVudHMgdG8gdGhlIG11bHRpcGxpZXIgdG8gZGV0ZXJtaW5lIHNpZ25pZmljYW50IGRpZ2l0IHJvdW5kaW5nXG5mb3IgKGxldCBpID0gMDsgaSA8IDI1NjsgaSsrKSB7XG5cdG11bHQxMFtpXSA9ICsoJzFlJyArIE1hdGguZmxvb3IoNDUuMTUgLSBpICogMC4zMDEwMykpO1xufVxuY29uc3QgRGVjb2RlciA9IFVucGFja3I7XG52YXIgZGVmYXVsdFVucGFja3IgPSBuZXcgVW5wYWNrcih7IHVzZVJlY29yZHM6IGZhbHNlIH0pO1xuY29uc3QgdW5wYWNrID0gZGVmYXVsdFVucGFja3IudW5wYWNrO1xuY29uc3QgdW5wYWNrTXVsdGlwbGUgPSBkZWZhdWx0VW5wYWNrci51bnBhY2tNdWx0aXBsZTtcbmNvbnN0IGRlY29kZSA9IGRlZmF1bHRVbnBhY2tyLnVucGFjaztcbmNvbnN0IEZMT0FUMzJfT1BUSU9OUyA9IHtcblx0TkVWRVI6IDAsXG5cdEFMV0FZUzogMSxcblx0REVDSU1BTF9ST1VORDogMyxcblx0REVDSU1BTF9GSVQ6IDRcbn07XG5sZXQgZjMyQXJyYXkgPSBuZXcgRmxvYXQzMkFycmF5KDEpO1xubGV0IHU4QXJyYXkgPSBuZXcgVWludDhBcnJheShmMzJBcnJheS5idWZmZXIsIDAsIDQpO1xuZnVuY3Rpb24gcm91bmRGbG9hdDMyKGZsb2F0MzJOdW1iZXIpIHtcblx0ZjMyQXJyYXlbMF0gPSBmbG9hdDMyTnVtYmVyO1xuXHRsZXQgbXVsdGlwbGllciA9IG11bHQxMFsoKHU4QXJyYXlbM10gJiAweDdmKSA8PCAxKSB8ICh1OEFycmF5WzJdID4+IDcpXTtcblx0cmV0dXJuICgobXVsdGlwbGllciAqIGZsb2F0MzJOdW1iZXIgKyAoZmxvYXQzMk51bWJlciA+IDAgPyAwLjUgOiAtMC41KSkgPj4gMCkgLyBtdWx0aXBsaWVyXG59XG5mdW5jdGlvbiBzZXRSZWFkU3RydWN0KHVwZGF0ZWRSZWFkU3RydWN0LCBsb2FkZWRTdHJ1Y3RzLCBzYXZlU3RhdGUpIHtcblx0cmVhZFN0cnVjdCQxID0gdXBkYXRlZFJlYWRTdHJ1Y3Q7XG5cdG9uTG9hZGVkU3RydWN0dXJlcyQxID0gbG9hZGVkU3RydWN0cztcblx0b25TYXZlU3RhdGUgPSBzYXZlU3RhdGU7XG59XG5cbmxldCB0ZXh0RW5jb2RlciQxO1xudHJ5IHtcblx0dGV4dEVuY29kZXIkMSA9IG5ldyBUZXh0RW5jb2RlcigpO1xufSBjYXRjaCAoZXJyb3IpIHt9XG5sZXQgZXh0ZW5zaW9ucywgZXh0ZW5zaW9uQ2xhc3NlcztcbmNvbnN0IGhhc05vZGVCdWZmZXIkMSA9IHR5cGVvZiBCdWZmZXIgIT09ICd1bmRlZmluZWQnO1xuY29uc3QgQnl0ZUFycmF5QWxsb2NhdGUgPSBoYXNOb2RlQnVmZmVyJDEgP1xuXHRmdW5jdGlvbihsZW5ndGgpIHsgcmV0dXJuIEJ1ZmZlci5hbGxvY1Vuc2FmZVNsb3cobGVuZ3RoKSB9IDogVWludDhBcnJheTtcbmNvbnN0IEJ5dGVBcnJheSA9IGhhc05vZGVCdWZmZXIkMSA/IEJ1ZmZlciA6IFVpbnQ4QXJyYXk7XG5jb25zdCBNQVhfQlVGRkVSX1NJWkUgPSBoYXNOb2RlQnVmZmVyJDEgPyAweDEwMDAwMDAwMCA6IDB4N2ZkMDAwMDA7XG5sZXQgdGFyZ2V0LCBrZXlzVGFyZ2V0O1xubGV0IHRhcmdldFZpZXc7XG5sZXQgcG9zaXRpb24gPSAwO1xubGV0IHNhZmVFbmQ7XG5sZXQgYnVuZGxlZFN0cmluZ3MgPSBudWxsO1xubGV0IHdyaXRlU3RydWN0U2xvdHM7XG5jb25zdCBNQVhfQlVORExFX1NJWkUgPSAweDU1MDA7IC8vIG1heGltdW0gY2hhcmFjdGVycyBzdWNoIHRoYXQgdGhlIGVuY29kZWQgYnl0ZXMgZml0cyBpbiAxNiBiaXRzLlxuY29uc3QgaGFzTm9uTGF0aW4gPSAvW1xcdTAwODAtXFx1RkZGRl0vO1xuY29uc3QgUkVDT1JEX1NZTUJPTCA9IFN5bWJvbCgncmVjb3JkLWlkJyk7XG5jbGFzcyBQYWNrciBleHRlbmRzIFVucGFja3Ige1xuXHRjb25zdHJ1Y3RvcihvcHRpb25zKSB7XG5cdFx0c3VwZXIob3B0aW9ucyk7XG5cdFx0dGhpcy5vZmZzZXQgPSAwO1xuXHRcdGxldCBzdGFydDtcblx0XHRsZXQgaGFzU2hhcmVkVXBkYXRlO1xuXHRcdGxldCBzdHJ1Y3R1cmVzO1xuXHRcdGxldCByZWZlcmVuY2VNYXA7XG5cdFx0bGV0IGVuY29kZVV0ZjggPSBCeXRlQXJyYXkucHJvdG90eXBlLnV0ZjhXcml0ZSA/IGZ1bmN0aW9uKHN0cmluZywgcG9zaXRpb24pIHtcblx0XHRcdHJldHVybiB0YXJnZXQudXRmOFdyaXRlKHN0cmluZywgcG9zaXRpb24sIDB4ZmZmZmZmZmYpXG5cdFx0fSA6ICh0ZXh0RW5jb2RlciQxICYmIHRleHRFbmNvZGVyJDEuZW5jb2RlSW50bykgP1xuXHRcdFx0ZnVuY3Rpb24oc3RyaW5nLCBwb3NpdGlvbikge1xuXHRcdFx0XHRyZXR1cm4gdGV4dEVuY29kZXIkMS5lbmNvZGVJbnRvKHN0cmluZywgdGFyZ2V0LnN1YmFycmF5KHBvc2l0aW9uKSkud3JpdHRlblxuXHRcdFx0fSA6IGZhbHNlO1xuXG5cdFx0bGV0IHBhY2tyID0gdGhpcztcblx0XHRpZiAoIW9wdGlvbnMpXG5cdFx0XHRvcHRpb25zID0ge307XG5cdFx0bGV0IGlzU2VxdWVudGlhbCA9IG9wdGlvbnMgJiYgb3B0aW9ucy5zZXF1ZW50aWFsO1xuXHRcdGxldCBoYXNTaGFyZWRTdHJ1Y3R1cmVzID0gb3B0aW9ucy5zdHJ1Y3R1cmVzIHx8IG9wdGlvbnMuc2F2ZVN0cnVjdHVyZXM7XG5cdFx0bGV0IG1heFNoYXJlZFN0cnVjdHVyZXMgPSBvcHRpb25zLm1heFNoYXJlZFN0cnVjdHVyZXM7XG5cdFx0aWYgKG1heFNoYXJlZFN0cnVjdHVyZXMgPT0gbnVsbClcblx0XHRcdG1heFNoYXJlZFN0cnVjdHVyZXMgPSBoYXNTaGFyZWRTdHJ1Y3R1cmVzID8gMzIgOiAwO1xuXHRcdGlmIChtYXhTaGFyZWRTdHJ1Y3R1cmVzID4gODE2MClcblx0XHRcdHRocm93IG5ldyBFcnJvcignTWF4aW11bSBtYXhTaGFyZWRTdHJ1Y3R1cmUgaXMgODE2MCcpXG5cdFx0aWYgKG9wdGlvbnMuc3RydWN0dXJlZENsb25lICYmIG9wdGlvbnMubW9yZVR5cGVzID09IHVuZGVmaW5lZCkge1xuXHRcdFx0dGhpcy5tb3JlVHlwZXMgPSB0cnVlO1xuXHRcdH1cblx0XHRsZXQgbWF4T3duU3RydWN0dXJlcyA9IG9wdGlvbnMubWF4T3duU3RydWN0dXJlcztcblx0XHRpZiAobWF4T3duU3RydWN0dXJlcyA9PSBudWxsKVxuXHRcdFx0bWF4T3duU3RydWN0dXJlcyA9IGhhc1NoYXJlZFN0cnVjdHVyZXMgPyAzMiA6IDY0O1xuXHRcdGlmICghdGhpcy5zdHJ1Y3R1cmVzICYmIG9wdGlvbnMudXNlUmVjb3JkcyAhPSBmYWxzZSlcblx0XHRcdHRoaXMuc3RydWN0dXJlcyA9IFtdO1xuXHRcdC8vIHR3byBieXRlIHJlY29yZCBpZHMgZm9yIHNoYXJlZCBzdHJ1Y3R1cmVzXG5cdFx0bGV0IHVzZVR3b0J5dGVSZWNvcmRzID0gbWF4U2hhcmVkU3RydWN0dXJlcyA+IDMyIHx8IChtYXhPd25TdHJ1Y3R1cmVzICsgbWF4U2hhcmVkU3RydWN0dXJlcyA+IDY0KTtcblx0XHRsZXQgc2hhcmVkTGltaXRJZCA9IG1heFNoYXJlZFN0cnVjdHVyZXMgKyAweDQwO1xuXHRcdGxldCBtYXhTdHJ1Y3R1cmVJZCA9IG1heFNoYXJlZFN0cnVjdHVyZXMgKyBtYXhPd25TdHJ1Y3R1cmVzICsgMHg0MDtcblx0XHRpZiAobWF4U3RydWN0dXJlSWQgPiA4MjU2KSB7XG5cdFx0XHR0aHJvdyBuZXcgRXJyb3IoJ01heGltdW0gbWF4U2hhcmVkU3RydWN0dXJlICsgbWF4T3duU3RydWN0dXJlIGlzIDgxOTInKVxuXHRcdH1cblx0XHRsZXQgcmVjb3JkSWRzVG9SZW1vdmUgPSBbXTtcblx0XHRsZXQgdHJhbnNpdGlvbnNDb3VudCA9IDA7XG5cdFx0bGV0IHNlcmlhbGl6YXRpb25zU2luY2VUcmFuc2l0aW9uUmVidWlsZCA9IDA7XG5cblx0XHR0aGlzLnBhY2sgPSB0aGlzLmVuY29kZSA9IGZ1bmN0aW9uKHZhbHVlLCBlbmNvZGVPcHRpb25zKSB7XG5cdFx0XHRpZiAoIXRhcmdldCkge1xuXHRcdFx0XHR0YXJnZXQgPSBuZXcgQnl0ZUFycmF5QWxsb2NhdGUoODE5Mik7XG5cdFx0XHRcdHRhcmdldFZpZXcgPSB0YXJnZXQuZGF0YVZpZXcgfHwgKHRhcmdldC5kYXRhVmlldyA9IG5ldyBEYXRhVmlldyh0YXJnZXQuYnVmZmVyLCAwLCA4MTkyKSk7XG5cdFx0XHRcdHBvc2l0aW9uID0gMDtcblx0XHRcdH1cblx0XHRcdHNhZmVFbmQgPSB0YXJnZXQubGVuZ3RoIC0gMTA7XG5cdFx0XHRpZiAoc2FmZUVuZCAtIHBvc2l0aW9uIDwgMHg4MDApIHtcblx0XHRcdFx0Ly8gZG9uJ3Qgc3RhcnQgdG9vIGNsb3NlIHRvIHRoZSBlbmQsXG5cdFx0XHRcdHRhcmdldCA9IG5ldyBCeXRlQXJyYXlBbGxvY2F0ZSh0YXJnZXQubGVuZ3RoKTtcblx0XHRcdFx0dGFyZ2V0VmlldyA9IHRhcmdldC5kYXRhVmlldyB8fCAodGFyZ2V0LmRhdGFWaWV3ID0gbmV3IERhdGFWaWV3KHRhcmdldC5idWZmZXIsIDAsIHRhcmdldC5sZW5ndGgpKTtcblx0XHRcdFx0c2FmZUVuZCA9IHRhcmdldC5sZW5ndGggLSAxMDtcblx0XHRcdFx0cG9zaXRpb24gPSAwO1xuXHRcdFx0fSBlbHNlXG5cdFx0XHRcdHBvc2l0aW9uID0gKHBvc2l0aW9uICsgNykgJiAweDdmZmZmZmY4OyAvLyBXb3JkIGFsaWduIHRvIG1ha2UgYW55IGZ1dHVyZSBjb3B5aW5nIG9mIHRoaXMgYnVmZmVyIGZhc3RlclxuXHRcdFx0c3RhcnQgPSBwb3NpdGlvbjtcblx0XHRcdGlmIChlbmNvZGVPcHRpb25zICYgUkVTRVJWRV9TVEFSVF9TUEFDRSkgcG9zaXRpb24gKz0gKGVuY29kZU9wdGlvbnMgJiAweGZmKTtcblx0XHRcdHJlZmVyZW5jZU1hcCA9IHBhY2tyLnN0cnVjdHVyZWRDbG9uZSA/IG5ldyBNYXAoKSA6IG51bGw7XG5cdFx0XHRpZiAocGFja3IuYnVuZGxlU3RyaW5ncyAmJiB0eXBlb2YgdmFsdWUgIT09ICdzdHJpbmcnKSB7XG5cdFx0XHRcdGJ1bmRsZWRTdHJpbmdzID0gW107XG5cdFx0XHRcdGJ1bmRsZWRTdHJpbmdzLnNpemUgPSBJbmZpbml0eTsgLy8gZm9yY2UgYSBuZXcgYnVuZGxlIHN0YXJ0IG9uIGZpcnN0IHN0cmluZ1xuXHRcdFx0fSBlbHNlXG5cdFx0XHRcdGJ1bmRsZWRTdHJpbmdzID0gbnVsbDtcblx0XHRcdHN0cnVjdHVyZXMgPSBwYWNrci5zdHJ1Y3R1cmVzO1xuXHRcdFx0aWYgKHN0cnVjdHVyZXMpIHtcblx0XHRcdFx0aWYgKHN0cnVjdHVyZXMudW5pbml0aWFsaXplZClcblx0XHRcdFx0XHRzdHJ1Y3R1cmVzID0gcGFja3IuX21lcmdlU3RydWN0dXJlcyhwYWNrci5nZXRTdHJ1Y3R1cmVzKCkpO1xuXHRcdFx0XHRsZXQgc2hhcmVkTGVuZ3RoID0gc3RydWN0dXJlcy5zaGFyZWRMZW5ndGggfHwgMDtcblx0XHRcdFx0aWYgKHNoYXJlZExlbmd0aCA+IG1heFNoYXJlZFN0cnVjdHVyZXMpIHtcblx0XHRcdFx0XHQvL2lmIChtYXhTaGFyZWRTdHJ1Y3R1cmVzIDw9IDMyICYmIHN0cnVjdHVyZXMuc2hhcmVkTGVuZ3RoID4gMzIpIC8vIFRPRE86IGNvdWxkIHN1cHBvcnQgdGhpcywgYnV0IHdvdWxkIG5lZWQgdG8gdXBkYXRlIHRoZSBsaW1pdCBpZHNcblx0XHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IoJ1NoYXJlZCBzdHJ1Y3R1cmVzIGlzIGxhcmdlciB0aGFuIG1heGltdW0gc2hhcmVkIHN0cnVjdHVyZXMsIHRyeSBpbmNyZWFzaW5nIG1heFNoYXJlZFN0cnVjdHVyZXMgdG8gJyArIHN0cnVjdHVyZXMuc2hhcmVkTGVuZ3RoKVxuXHRcdFx0XHR9XG5cdFx0XHRcdGlmICghc3RydWN0dXJlcy50cmFuc2l0aW9ucykge1xuXHRcdFx0XHRcdC8vIHJlYnVpbGQgb3VyIHN0cnVjdHVyZSB0cmFuc2l0aW9uc1xuXHRcdFx0XHRcdHN0cnVjdHVyZXMudHJhbnNpdGlvbnMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuXHRcdFx0XHRcdGZvciAobGV0IGkgPSAwOyBpIDwgc2hhcmVkTGVuZ3RoOyBpKyspIHtcblx0XHRcdFx0XHRcdGxldCBrZXlzID0gc3RydWN0dXJlc1tpXTtcblx0XHRcdFx0XHRcdGlmICgha2V5cylcblx0XHRcdFx0XHRcdFx0Y29udGludWVcblx0XHRcdFx0XHRcdGxldCBuZXh0VHJhbnNpdGlvbiwgdHJhbnNpdGlvbiA9IHN0cnVjdHVyZXMudHJhbnNpdGlvbnM7XG5cdFx0XHRcdFx0XHRmb3IgKGxldCBqID0gMCwgbCA9IGtleXMubGVuZ3RoOyBqIDwgbDsgaisrKSB7XG5cdFx0XHRcdFx0XHRcdGxldCBrZXkgPSBrZXlzW2pdO1xuXHRcdFx0XHRcdFx0XHRuZXh0VHJhbnNpdGlvbiA9IHRyYW5zaXRpb25ba2V5XTtcblx0XHRcdFx0XHRcdFx0aWYgKCFuZXh0VHJhbnNpdGlvbikge1xuXHRcdFx0XHRcdFx0XHRcdG5leHRUcmFuc2l0aW9uID0gdHJhbnNpdGlvbltrZXldID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHR0cmFuc2l0aW9uID0gbmV4dFRyYW5zaXRpb247XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR0cmFuc2l0aW9uW1JFQ09SRF9TWU1CT0xdID0gaSArIDB4NDA7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHRoaXMubGFzdE5hbWVkU3RydWN0dXJlc0xlbmd0aCA9IHNoYXJlZExlbmd0aDtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAoIWlzU2VxdWVudGlhbCkge1xuXHRcdFx0XHRcdHN0cnVjdHVyZXMubmV4dElkID0gc2hhcmVkTGVuZ3RoICsgMHg0MDtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0aWYgKGhhc1NoYXJlZFVwZGF0ZSlcblx0XHRcdFx0aGFzU2hhcmVkVXBkYXRlID0gZmFsc2U7XG5cdFx0XHRsZXQgZW5jb2RpbmdFcnJvcjtcblx0XHRcdHRyeSB7XG5cdFx0XHRcdGlmIChwYWNrci5yYW5kb21BY2Nlc3NTdHJ1Y3R1cmUgJiYgdmFsdWUgJiYgdmFsdWUuY29uc3RydWN0b3IgJiYgdmFsdWUuY29uc3RydWN0b3IgPT09IE9iamVjdClcblx0XHRcdFx0XHR3cml0ZVN0cnVjdCh2YWx1ZSk7XG5cdFx0XHRcdGVsc2Vcblx0XHRcdFx0XHRwYWNrKHZhbHVlKTtcblx0XHRcdFx0bGV0IGxhc3RCdW5kbGUgPSBidW5kbGVkU3RyaW5ncztcblx0XHRcdFx0aWYgKGJ1bmRsZWRTdHJpbmdzKVxuXHRcdFx0XHRcdHdyaXRlQnVuZGxlcyhzdGFydCwgcGFjaywgMCk7XG5cdFx0XHRcdGlmIChyZWZlcmVuY2VNYXAgJiYgcmVmZXJlbmNlTWFwLmlkc1RvSW5zZXJ0KSB7XG5cdFx0XHRcdFx0bGV0IGlkc1RvSW5zZXJ0ID0gcmVmZXJlbmNlTWFwLmlkc1RvSW5zZXJ0LnNvcnQoKGEsIGIpID0+IGEub2Zmc2V0ID4gYi5vZmZzZXQgPyAxIDogLTEpO1xuXHRcdFx0XHRcdGxldCBpID0gaWRzVG9JbnNlcnQubGVuZ3RoO1xuXHRcdFx0XHRcdGxldCBpbmNyZW1lbnRQb3NpdGlvbiA9IC0xO1xuXHRcdFx0XHRcdHdoaWxlIChsYXN0QnVuZGxlICYmIGkgPiAwKSB7XG5cdFx0XHRcdFx0XHRsZXQgaW5zZXJ0aW9uUG9pbnQgPSBpZHNUb0luc2VydFstLWldLm9mZnNldCArIHN0YXJ0O1xuXHRcdFx0XHRcdFx0aWYgKGluc2VydGlvblBvaW50IDwgKGxhc3RCdW5kbGUuc3RyaW5nc1Bvc2l0aW9uICsgc3RhcnQpICYmIGluY3JlbWVudFBvc2l0aW9uID09PSAtMSlcblx0XHRcdFx0XHRcdFx0aW5jcmVtZW50UG9zaXRpb24gPSAwO1xuXHRcdFx0XHRcdFx0aWYgKGluc2VydGlvblBvaW50ID4gKGxhc3RCdW5kbGUucG9zaXRpb24gKyBzdGFydCkpIHtcblx0XHRcdFx0XHRcdFx0aWYgKGluY3JlbWVudFBvc2l0aW9uID49IDApXG5cdFx0XHRcdFx0XHRcdFx0aW5jcmVtZW50UG9zaXRpb24gKz0gNjtcblx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRcdGlmIChpbmNyZW1lbnRQb3NpdGlvbiA+PSAwKSB7XG5cdFx0XHRcdFx0XHRcdFx0Ly8gdXBkYXRlIHRoZSBidW5kbGUgcmVmZXJlbmNlIG5vd1xuXHRcdFx0XHRcdFx0XHRcdHRhcmdldFZpZXcuc2V0VWludDMyKGxhc3RCdW5kbGUucG9zaXRpb24gKyBzdGFydCxcblx0XHRcdFx0XHRcdFx0XHRcdHRhcmdldFZpZXcuZ2V0VWludDMyKGxhc3RCdW5kbGUucG9zaXRpb24gKyBzdGFydCkgKyBpbmNyZW1lbnRQb3NpdGlvbik7XG5cdFx0XHRcdFx0XHRcdFx0aW5jcmVtZW50UG9zaXRpb24gPSAtMTsgLy8gcmVzZXRcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRsYXN0QnVuZGxlID0gbGFzdEJ1bmRsZS5wcmV2aW91cztcblx0XHRcdFx0XHRcdFx0aSsrO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRpZiAoaW5jcmVtZW50UG9zaXRpb24gPj0gMCAmJiBsYXN0QnVuZGxlKSB7XG5cdFx0XHRcdFx0XHQvLyB1cGRhdGUgdGhlIGJ1bmRsZSByZWZlcmVuY2Ugbm93XG5cdFx0XHRcdFx0XHR0YXJnZXRWaWV3LnNldFVpbnQzMihsYXN0QnVuZGxlLnBvc2l0aW9uICsgc3RhcnQsXG5cdFx0XHRcdFx0XHRcdHRhcmdldFZpZXcuZ2V0VWludDMyKGxhc3RCdW5kbGUucG9zaXRpb24gKyBzdGFydCkgKyBpbmNyZW1lbnRQb3NpdGlvbik7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHBvc2l0aW9uICs9IGlkc1RvSW5zZXJ0Lmxlbmd0aCAqIDY7XG5cdFx0XHRcdFx0aWYgKHBvc2l0aW9uID4gc2FmZUVuZClcblx0XHRcdFx0XHRcdG1ha2VSb29tKHBvc2l0aW9uKTtcblx0XHRcdFx0XHRwYWNrci5vZmZzZXQgPSBwb3NpdGlvbjtcblx0XHRcdFx0XHRsZXQgc2VyaWFsaXplZCA9IGluc2VydElkcyh0YXJnZXQuc3ViYXJyYXkoc3RhcnQsIHBvc2l0aW9uKSwgaWRzVG9JbnNlcnQpO1xuXHRcdFx0XHRcdHJlZmVyZW5jZU1hcCA9IG51bGw7XG5cdFx0XHRcdFx0cmV0dXJuIHNlcmlhbGl6ZWRcblx0XHRcdFx0fVxuXHRcdFx0XHRwYWNrci5vZmZzZXQgPSBwb3NpdGlvbjsgLy8gdXBkYXRlIHRoZSBvZmZzZXQgc28gbmV4dCBzZXJpYWxpemF0aW9uIGRvZXNuJ3Qgd3JpdGUgb3ZlciBvdXIgYnVmZmVyLCBidXQgY2FuIGNvbnRpbnVlIHdyaXRpbmcgdG8gc2FtZSBidWZmZXIgc2VxdWVudGlhbGx5XG5cdFx0XHRcdGlmIChlbmNvZGVPcHRpb25zICYgUkVVU0VfQlVGRkVSX01PREUpIHtcblx0XHRcdFx0XHR0YXJnZXQuc3RhcnQgPSBzdGFydDtcblx0XHRcdFx0XHR0YXJnZXQuZW5kID0gcG9zaXRpb247XG5cdFx0XHRcdFx0cmV0dXJuIHRhcmdldFxuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiB0YXJnZXQuc3ViYXJyYXkoc3RhcnQsIHBvc2l0aW9uKSAvLyBwb3NpdGlvbiBjYW4gY2hhbmdlIGlmIHdlIGNhbGwgcGFjayBhZ2FpbiBpbiBzYXZlU3RydWN0dXJlcywgc28gd2UgZ2V0IHRoZSBidWZmZXIgbm93XG5cdFx0XHR9IGNhdGNoKGVycm9yKSB7XG5cdFx0XHRcdGVuY29kaW5nRXJyb3IgPSBlcnJvcjtcblx0XHRcdFx0dGhyb3cgZXJyb3I7XG5cdFx0XHR9IGZpbmFsbHkge1xuXHRcdFx0XHRpZiAoc3RydWN0dXJlcykge1xuXHRcdFx0XHRcdHJlc2V0U3RydWN0dXJlcygpO1xuXHRcdFx0XHRcdGlmIChoYXNTaGFyZWRVcGRhdGUgJiYgcGFja3Iuc2F2ZVN0cnVjdHVyZXMpIHtcblx0XHRcdFx0XHRcdGxldCBzaGFyZWRMZW5ndGggPSBzdHJ1Y3R1cmVzLnNoYXJlZExlbmd0aCB8fCAwO1xuXHRcdFx0XHRcdFx0Ly8gd2UgY2FuJ3QgcmVseSBvbiBzdGFydC9lbmQgd2l0aCBSRVVTRV9CVUZGRVJfTU9ERSBzaW5jZSB0aGV5IHdpbGwgKHByb2JhYmx5KSBjaGFuZ2Ugd2hlbiB3ZSBzYXZlXG5cdFx0XHRcdFx0XHRsZXQgcmV0dXJuQnVmZmVyID0gdGFyZ2V0LnN1YmFycmF5KHN0YXJ0LCBwb3NpdGlvbik7XG5cdFx0XHRcdFx0XHRsZXQgbmV3U2hhcmVkRGF0YSA9IHByZXBhcmVTdHJ1Y3R1cmVzJDEoc3RydWN0dXJlcywgcGFja3IpO1xuXHRcdFx0XHRcdFx0aWYgKCFlbmNvZGluZ0Vycm9yKSB7IC8vIFRPRE86IElmIHRoZXJlIGlzIGFuIGVuY29kaW5nIGVycm9yLCBzaG91bGQgbWFrZSB0aGUgc3RydWN0dXJlcyBhcyB1bmluaXRpYWxpemVkIHNvIHRoZXkgZ2V0IHJlYnVpbHQgbmV4dCB0aW1lXG5cdFx0XHRcdFx0XHRcdGlmIChwYWNrci5zYXZlU3RydWN0dXJlcyhuZXdTaGFyZWREYXRhLCBuZXdTaGFyZWREYXRhLmlzQ29tcGF0aWJsZSkgPT09IGZhbHNlKSB7XG5cdFx0XHRcdFx0XHRcdFx0Ly8gZ2V0IHVwZGF0ZWQgc3RydWN0dXJlcyBhbmQgdHJ5IGFnYWluIGlmIHRoZSB1cGRhdGUgZmFpbGVkXG5cdFx0XHRcdFx0XHRcdFx0cmV0dXJuIHBhY2tyLnBhY2sodmFsdWUsIGVuY29kZU9wdGlvbnMpXG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0cGFja3IubGFzdE5hbWVkU3RydWN0dXJlc0xlbmd0aCA9IHNoYXJlZExlbmd0aDtcblx0XHRcdFx0XHRcdFx0Ly8gZG9uJ3Qga2VlcCBsYXJnZSBidWZmZXJzIGFyb3VuZFxuXHRcdFx0XHRcdFx0XHRpZiAodGFyZ2V0Lmxlbmd0aCA+IDB4NDAwMDAwMDApIHRhcmdldCA9IG51bGw7XG5cdFx0XHRcdFx0XHRcdHJldHVybiByZXR1cm5CdWZmZXJcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdFx0Ly8gZG9uJ3Qga2VlcCBsYXJnZSBidWZmZXJzIGFyb3VuZCwgdGhleSB0YWtlIHRvbyBtdWNoIG1lbW9yeSBhbmQgY2F1c2UgcHJvYmxlbXMgKGxpbWl0IGF0IDFHQilcblx0XHRcdFx0aWYgKHRhcmdldC5sZW5ndGggPiAweDQwMDAwMDAwKSB0YXJnZXQgPSBudWxsO1xuXHRcdFx0XHRpZiAoZW5jb2RlT3B0aW9ucyAmIFJFU0VUX0JVRkZFUl9NT0RFKVxuXHRcdFx0XHRcdHBvc2l0aW9uID0gc3RhcnQ7XG5cdFx0XHR9XG5cdFx0fTtcblx0XHRjb25zdCByZXNldFN0cnVjdHVyZXMgPSAoKSA9PiB7XG5cdFx0XHRpZiAoc2VyaWFsaXphdGlvbnNTaW5jZVRyYW5zaXRpb25SZWJ1aWxkIDwgMTApXG5cdFx0XHRcdHNlcmlhbGl6YXRpb25zU2luY2VUcmFuc2l0aW9uUmVidWlsZCsrO1xuXHRcdFx0bGV0IHNoYXJlZExlbmd0aCA9IHN0cnVjdHVyZXMuc2hhcmVkTGVuZ3RoIHx8IDA7XG5cdFx0XHRpZiAoc3RydWN0dXJlcy5sZW5ndGggPiBzaGFyZWRMZW5ndGggJiYgIWlzU2VxdWVudGlhbClcblx0XHRcdFx0c3RydWN0dXJlcy5sZW5ndGggPSBzaGFyZWRMZW5ndGg7XG5cdFx0XHRpZiAodHJhbnNpdGlvbnNDb3VudCA+IDEwMDAwKSB7XG5cdFx0XHRcdC8vIGZvcmNlIGEgcmVidWlsZCBvY2Nhc2lvbmFsbHkgYWZ0ZXIgYSBsb3Qgb2YgdHJhbnNpdGlvbnMgc28gaXQgY2FuIGdldCBjbGVhbmVkIHVwXG5cdFx0XHRcdHN0cnVjdHVyZXMudHJhbnNpdGlvbnMgPSBudWxsO1xuXHRcdFx0XHRzZXJpYWxpemF0aW9uc1NpbmNlVHJhbnNpdGlvblJlYnVpbGQgPSAwO1xuXHRcdFx0XHR0cmFuc2l0aW9uc0NvdW50ID0gMDtcblx0XHRcdFx0aWYgKHJlY29yZElkc1RvUmVtb3ZlLmxlbmd0aCA+IDApXG5cdFx0XHRcdFx0cmVjb3JkSWRzVG9SZW1vdmUgPSBbXTtcblx0XHRcdH0gZWxzZSBpZiAocmVjb3JkSWRzVG9SZW1vdmUubGVuZ3RoID4gMCAmJiAhaXNTZXF1ZW50aWFsKSB7XG5cdFx0XHRcdGZvciAobGV0IGkgPSAwLCBsID0gcmVjb3JkSWRzVG9SZW1vdmUubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG5cdFx0XHRcdFx0cmVjb3JkSWRzVG9SZW1vdmVbaV1bUkVDT1JEX1NZTUJPTF0gPSAwO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHJlY29yZElkc1RvUmVtb3ZlID0gW107XG5cdFx0XHR9XG5cdFx0fTtcblx0XHRjb25zdCBwYWNrQXJyYXkgPSAodmFsdWUpID0+IHtcblx0XHRcdHZhciBsZW5ndGggPSB2YWx1ZS5sZW5ndGg7XG5cdFx0XHRpZiAobGVuZ3RoIDwgMHgxMCkge1xuXHRcdFx0XHR0YXJnZXRbcG9zaXRpb24rK10gPSAweDkwIHwgbGVuZ3RoO1xuXHRcdFx0fSBlbHNlIGlmIChsZW5ndGggPCAweDEwMDAwKSB7XG5cdFx0XHRcdHRhcmdldFtwb3NpdGlvbisrXSA9IDB4ZGM7XG5cdFx0XHRcdHRhcmdldFtwb3NpdGlvbisrXSA9IGxlbmd0aCA+PiA4O1xuXHRcdFx0XHR0YXJnZXRbcG9zaXRpb24rK10gPSBsZW5ndGggJiAweGZmO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0dGFyZ2V0W3Bvc2l0aW9uKytdID0gMHhkZDtcblx0XHRcdFx0dGFyZ2V0Vmlldy5zZXRVaW50MzIocG9zaXRpb24sIGxlbmd0aCk7XG5cdFx0XHRcdHBvc2l0aW9uICs9IDQ7XG5cdFx0XHR9XG5cdFx0XHRmb3IgKGxldCBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG5cdFx0XHRcdHBhY2sodmFsdWVbaV0pO1xuXHRcdFx0fVxuXHRcdH07XG5cdFx0Y29uc3QgcGFjayA9ICh2YWx1ZSkgPT4ge1xuXHRcdFx0aWYgKHBvc2l0aW9uID4gc2FmZUVuZClcblx0XHRcdFx0dGFyZ2V0ID0gbWFrZVJvb20ocG9zaXRpb24pO1xuXG5cdFx0XHR2YXIgdHlwZSA9IHR5cGVvZiB2YWx1ZTtcblx0XHRcdHZhciBsZW5ndGg7XG5cdFx0XHRpZiAodHlwZSA9PT0gJ3N0cmluZycpIHtcblx0XHRcdFx0bGV0IHN0ckxlbmd0aCA9IHZhbHVlLmxlbmd0aDtcblx0XHRcdFx0aWYgKGJ1bmRsZWRTdHJpbmdzICYmIHN0ckxlbmd0aCA+PSA0ICYmIHN0ckxlbmd0aCA8IDB4MTAwMCkge1xuXHRcdFx0XHRcdGlmICgoYnVuZGxlZFN0cmluZ3Muc2l6ZSArPSBzdHJMZW5ndGgpID4gTUFYX0JVTkRMRV9TSVpFKSB7XG5cdFx0XHRcdFx0XHRsZXQgZXh0U3RhcnQ7XG5cdFx0XHRcdFx0XHRsZXQgbWF4Qnl0ZXMgPSAoYnVuZGxlZFN0cmluZ3NbMF0gPyBidW5kbGVkU3RyaW5nc1swXS5sZW5ndGggKiAzICsgYnVuZGxlZFN0cmluZ3NbMV0ubGVuZ3RoIDogMCkgKyAxMDtcblx0XHRcdFx0XHRcdGlmIChwb3NpdGlvbiArIG1heEJ5dGVzID4gc2FmZUVuZClcblx0XHRcdFx0XHRcdFx0dGFyZ2V0ID0gbWFrZVJvb20ocG9zaXRpb24gKyBtYXhCeXRlcyk7XG5cdFx0XHRcdFx0XHRsZXQgbGFzdEJ1bmRsZTtcblx0XHRcdFx0XHRcdGlmIChidW5kbGVkU3RyaW5ncy5wb3NpdGlvbikgeyAvLyBoZXJlIHdlIHVzZSB0aGUgMHg2MiBleHRlbnNpb24gdG8gd3JpdGUgdGhlIGxhc3QgYnVuZGxlIGFuZCByZXNlcnZlIHNwYWNlIGZvciB0aGUgcmVmZXJlbmNlIHBvaW50ZXIgdG8gdGhlIG5leHQvY3VycmVudCBidW5kbGVcblx0XHRcdFx0XHRcdFx0bGFzdEJ1bmRsZSA9IGJ1bmRsZWRTdHJpbmdzO1xuXHRcdFx0XHRcdFx0XHR0YXJnZXRbcG9zaXRpb25dID0gMHhjODsgLy8gZXh0IDE2XG5cdFx0XHRcdFx0XHRcdHBvc2l0aW9uICs9IDM7IC8vIHJlc2VydmUgZm9yIHRoZSB3cml0aW5nIGJ1bmRsZSBzaXplXG5cdFx0XHRcdFx0XHRcdHRhcmdldFtwb3NpdGlvbisrXSA9IDB4NjI7IC8vICdiJ1xuXHRcdFx0XHRcdFx0XHRleHRTdGFydCA9IHBvc2l0aW9uIC0gc3RhcnQ7XG5cdFx0XHRcdFx0XHRcdHBvc2l0aW9uICs9IDQ7IC8vIHJlc2VydmUgZm9yIHdyaXRpbmcgYnVuZGxlIHJlZmVyZW5jZVxuXHRcdFx0XHRcdFx0XHR3cml0ZUJ1bmRsZXMoc3RhcnQsIHBhY2ssIDApOyAvLyB3cml0ZSB0aGUgbGFzdCBidW5kbGVzXG5cdFx0XHRcdFx0XHRcdHRhcmdldFZpZXcuc2V0VWludDE2KGV4dFN0YXJ0ICsgc3RhcnQgLSAzLCBwb3NpdGlvbiAtIHN0YXJ0IC0gZXh0U3RhcnQpO1xuXHRcdFx0XHRcdFx0fSBlbHNlIHsgLy8gaGVyZSB3ZSB1c2UgdGhlIDB4NjIgZXh0ZW5zaW9uIGp1c3QgdG8gcmVzZXJ2ZSB0aGUgc3BhY2UgZm9yIHRoZSByZWZlcmVuY2UgcG9pbnRlciB0byB0aGUgYnVuZGxlICh3aWxsIGJlIHVwZGF0ZWQgb25jZSB0aGUgYnVuZGxlIGlzIHdyaXR0ZW4pXG5cdFx0XHRcdFx0XHRcdHRhcmdldFtwb3NpdGlvbisrXSA9IDB4ZDY7IC8vIGZpeGV4dCA0XG5cdFx0XHRcdFx0XHRcdHRhcmdldFtwb3NpdGlvbisrXSA9IDB4NjI7IC8vICdiJ1xuXHRcdFx0XHRcdFx0XHRleHRTdGFydCA9IHBvc2l0aW9uIC0gc3RhcnQ7XG5cdFx0XHRcdFx0XHRcdHBvc2l0aW9uICs9IDQ7IC8vIHJlc2VydmUgZm9yIHdyaXRpbmcgYnVuZGxlIHJlZmVyZW5jZVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0YnVuZGxlZFN0cmluZ3MgPSBbJycsICcnXTsgLy8gY3JlYXRlIG5ldyBvbmVzXG5cdFx0XHRcdFx0XHRidW5kbGVkU3RyaW5ncy5wcmV2aW91cyA9IGxhc3RCdW5kbGU7XG5cdFx0XHRcdFx0XHRidW5kbGVkU3RyaW5ncy5zaXplID0gMDtcblx0XHRcdFx0XHRcdGJ1bmRsZWRTdHJpbmdzLnBvc2l0aW9uID0gZXh0U3RhcnQ7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGxldCB0d29CeXRlID0gaGFzTm9uTGF0aW4udGVzdCh2YWx1ZSk7XG5cdFx0XHRcdFx0YnVuZGxlZFN0cmluZ3NbdHdvQnl0ZSA/IDAgOiAxXSArPSB2YWx1ZTtcblx0XHRcdFx0XHR0YXJnZXRbcG9zaXRpb24rK10gPSAweGMxO1xuXHRcdFx0XHRcdHBhY2sodHdvQnl0ZSA/IC1zdHJMZW5ndGggOiBzdHJMZW5ndGgpO1xuXHRcdFx0XHRcdHJldHVyblxuXHRcdFx0XHR9XG5cdFx0XHRcdGxldCBoZWFkZXJTaXplO1xuXHRcdFx0XHQvLyBmaXJzdCB3ZSBlc3RpbWF0ZSB0aGUgaGVhZGVyIHNpemUsIHNvIHdlIGNhbiB3cml0ZSB0byB0aGUgY29ycmVjdCBsb2NhdGlvblxuXHRcdFx0XHRpZiAoc3RyTGVuZ3RoIDwgMHgyMCkge1xuXHRcdFx0XHRcdGhlYWRlclNpemUgPSAxO1xuXHRcdFx0XHR9IGVsc2UgaWYgKHN0ckxlbmd0aCA8IDB4MTAwKSB7XG5cdFx0XHRcdFx0aGVhZGVyU2l6ZSA9IDI7XG5cdFx0XHRcdH0gZWxzZSBpZiAoc3RyTGVuZ3RoIDwgMHgxMDAwMCkge1xuXHRcdFx0XHRcdGhlYWRlclNpemUgPSAzO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdGhlYWRlclNpemUgPSA1O1xuXHRcdFx0XHR9XG5cdFx0XHRcdGxldCBtYXhCeXRlcyA9IHN0ckxlbmd0aCAqIDM7XG5cdFx0XHRcdGlmIChwb3NpdGlvbiArIG1heEJ5dGVzID4gc2FmZUVuZClcblx0XHRcdFx0XHR0YXJnZXQgPSBtYWtlUm9vbShwb3NpdGlvbiArIG1heEJ5dGVzKTtcblxuXHRcdFx0XHRpZiAoc3RyTGVuZ3RoIDwgMHg0MCB8fCAhZW5jb2RlVXRmOCkge1xuXHRcdFx0XHRcdGxldCBpLCBjMSwgYzIsIHN0clBvc2l0aW9uID0gcG9zaXRpb24gKyBoZWFkZXJTaXplO1xuXHRcdFx0XHRcdGZvciAoaSA9IDA7IGkgPCBzdHJMZW5ndGg7IGkrKykge1xuXHRcdFx0XHRcdFx0YzEgPSB2YWx1ZS5jaGFyQ29kZUF0KGkpO1xuXHRcdFx0XHRcdFx0aWYgKGMxIDwgMHg4MCkge1xuXHRcdFx0XHRcdFx0XHR0YXJnZXRbc3RyUG9zaXRpb24rK10gPSBjMTtcblx0XHRcdFx0XHRcdH0gZWxzZSBpZiAoYzEgPCAweDgwMCkge1xuXHRcdFx0XHRcdFx0XHR0YXJnZXRbc3RyUG9zaXRpb24rK10gPSBjMSA+PiA2IHwgMHhjMDtcblx0XHRcdFx0XHRcdFx0dGFyZ2V0W3N0clBvc2l0aW9uKytdID0gYzEgJiAweDNmIHwgMHg4MDtcblx0XHRcdFx0XHRcdH0gZWxzZSBpZiAoXG5cdFx0XHRcdFx0XHRcdChjMSAmIDB4ZmMwMCkgPT09IDB4ZDgwMCAmJlxuXHRcdFx0XHRcdFx0XHQoKGMyID0gdmFsdWUuY2hhckNvZGVBdChpICsgMSkpICYgMHhmYzAwKSA9PT0gMHhkYzAwXG5cdFx0XHRcdFx0XHQpIHtcblx0XHRcdFx0XHRcdFx0YzEgPSAweDEwMDAwICsgKChjMSAmIDB4MDNmZikgPDwgMTApICsgKGMyICYgMHgwM2ZmKTtcblx0XHRcdFx0XHRcdFx0aSsrO1xuXHRcdFx0XHRcdFx0XHR0YXJnZXRbc3RyUG9zaXRpb24rK10gPSBjMSA+PiAxOCB8IDB4ZjA7XG5cdFx0XHRcdFx0XHRcdHRhcmdldFtzdHJQb3NpdGlvbisrXSA9IGMxID4+IDEyICYgMHgzZiB8IDB4ODA7XG5cdFx0XHRcdFx0XHRcdHRhcmdldFtzdHJQb3NpdGlvbisrXSA9IGMxID4+IDYgJiAweDNmIHwgMHg4MDtcblx0XHRcdFx0XHRcdFx0dGFyZ2V0W3N0clBvc2l0aW9uKytdID0gYzEgJiAweDNmIHwgMHg4MDtcblx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRcdHRhcmdldFtzdHJQb3NpdGlvbisrXSA9IGMxID4+IDEyIHwgMHhlMDtcblx0XHRcdFx0XHRcdFx0dGFyZ2V0W3N0clBvc2l0aW9uKytdID0gYzEgPj4gNiAmIDB4M2YgfCAweDgwO1xuXHRcdFx0XHRcdFx0XHR0YXJnZXRbc3RyUG9zaXRpb24rK10gPSBjMSAmIDB4M2YgfCAweDgwO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRsZW5ndGggPSBzdHJQb3NpdGlvbiAtIHBvc2l0aW9uIC0gaGVhZGVyU2l6ZTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRsZW5ndGggPSBlbmNvZGVVdGY4KHZhbHVlLCBwb3NpdGlvbiArIGhlYWRlclNpemUpO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0aWYgKGxlbmd0aCA8IDB4MjApIHtcblx0XHRcdFx0XHR0YXJnZXRbcG9zaXRpb24rK10gPSAweGEwIHwgbGVuZ3RoO1xuXHRcdFx0XHR9IGVsc2UgaWYgKGxlbmd0aCA8IDB4MTAwKSB7XG5cdFx0XHRcdFx0aWYgKGhlYWRlclNpemUgPCAyKSB7XG5cdFx0XHRcdFx0XHR0YXJnZXQuY29weVdpdGhpbihwb3NpdGlvbiArIDIsIHBvc2l0aW9uICsgMSwgcG9zaXRpb24gKyAxICsgbGVuZ3RoKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0dGFyZ2V0W3Bvc2l0aW9uKytdID0gMHhkOTtcblx0XHRcdFx0XHR0YXJnZXRbcG9zaXRpb24rK10gPSBsZW5ndGg7XG5cdFx0XHRcdH0gZWxzZSBpZiAobGVuZ3RoIDwgMHgxMDAwMCkge1xuXHRcdFx0XHRcdGlmIChoZWFkZXJTaXplIDwgMykge1xuXHRcdFx0XHRcdFx0dGFyZ2V0LmNvcHlXaXRoaW4ocG9zaXRpb24gKyAzLCBwb3NpdGlvbiArIDIsIHBvc2l0aW9uICsgMiArIGxlbmd0aCk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHRhcmdldFtwb3NpdGlvbisrXSA9IDB4ZGE7XG5cdFx0XHRcdFx0dGFyZ2V0W3Bvc2l0aW9uKytdID0gbGVuZ3RoID4+IDg7XG5cdFx0XHRcdFx0dGFyZ2V0W3Bvc2l0aW9uKytdID0gbGVuZ3RoICYgMHhmZjtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRpZiAoaGVhZGVyU2l6ZSA8IDUpIHtcblx0XHRcdFx0XHRcdHRhcmdldC5jb3B5V2l0aGluKHBvc2l0aW9uICsgNSwgcG9zaXRpb24gKyAzLCBwb3NpdGlvbiArIDMgKyBsZW5ndGgpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHR0YXJnZXRbcG9zaXRpb24rK10gPSAweGRiO1xuXHRcdFx0XHRcdHRhcmdldFZpZXcuc2V0VWludDMyKHBvc2l0aW9uLCBsZW5ndGgpO1xuXHRcdFx0XHRcdHBvc2l0aW9uICs9IDQ7XG5cdFx0XHRcdH1cblx0XHRcdFx0cG9zaXRpb24gKz0gbGVuZ3RoO1xuXHRcdFx0fSBlbHNlIGlmICh0eXBlID09PSAnbnVtYmVyJykge1xuXHRcdFx0XHRpZiAodmFsdWUgPj4+IDAgPT09IHZhbHVlKSB7Ly8gcG9zaXRpdmUgaW50ZWdlciwgMzItYml0IG9yIGxlc3Ncblx0XHRcdFx0XHQvLyBwb3NpdGl2ZSB1aW50XG5cdFx0XHRcdFx0aWYgKHZhbHVlIDwgMHgyMCB8fCAodmFsdWUgPCAweDgwICYmIHRoaXMudXNlUmVjb3JkcyA9PT0gZmFsc2UpIHx8ICh2YWx1ZSA8IDB4NDAgJiYgIXRoaXMucmFuZG9tQWNjZXNzU3RydWN0dXJlKSkge1xuXHRcdFx0XHRcdFx0dGFyZ2V0W3Bvc2l0aW9uKytdID0gdmFsdWU7XG5cdFx0XHRcdFx0fSBlbHNlIGlmICh2YWx1ZSA8IDB4MTAwKSB7XG5cdFx0XHRcdFx0XHR0YXJnZXRbcG9zaXRpb24rK10gPSAweGNjO1xuXHRcdFx0XHRcdFx0dGFyZ2V0W3Bvc2l0aW9uKytdID0gdmFsdWU7XG5cdFx0XHRcdFx0fSBlbHNlIGlmICh2YWx1ZSA8IDB4MTAwMDApIHtcblx0XHRcdFx0XHRcdHRhcmdldFtwb3NpdGlvbisrXSA9IDB4Y2Q7XG5cdFx0XHRcdFx0XHR0YXJnZXRbcG9zaXRpb24rK10gPSB2YWx1ZSA+PiA4O1xuXHRcdFx0XHRcdFx0dGFyZ2V0W3Bvc2l0aW9uKytdID0gdmFsdWUgJiAweGZmO1xuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHR0YXJnZXRbcG9zaXRpb24rK10gPSAweGNlO1xuXHRcdFx0XHRcdFx0dGFyZ2V0Vmlldy5zZXRVaW50MzIocG9zaXRpb24sIHZhbHVlKTtcblx0XHRcdFx0XHRcdHBvc2l0aW9uICs9IDQ7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9IGVsc2UgaWYgKHZhbHVlID4+IDAgPT09IHZhbHVlKSB7IC8vIG5lZ2F0aXZlIGludGVnZXJcblx0XHRcdFx0XHRpZiAodmFsdWUgPj0gLTB4MjApIHtcblx0XHRcdFx0XHRcdHRhcmdldFtwb3NpdGlvbisrXSA9IDB4MTAwICsgdmFsdWU7XG5cdFx0XHRcdFx0fSBlbHNlIGlmICh2YWx1ZSA+PSAtMHg4MCkge1xuXHRcdFx0XHRcdFx0dGFyZ2V0W3Bvc2l0aW9uKytdID0gMHhkMDtcblx0XHRcdFx0XHRcdHRhcmdldFtwb3NpdGlvbisrXSA9IHZhbHVlICsgMHgxMDA7XG5cdFx0XHRcdFx0fSBlbHNlIGlmICh2YWx1ZSA+PSAtMHg4MDAwKSB7XG5cdFx0XHRcdFx0XHR0YXJnZXRbcG9zaXRpb24rK10gPSAweGQxO1xuXHRcdFx0XHRcdFx0dGFyZ2V0Vmlldy5zZXRJbnQxNihwb3NpdGlvbiwgdmFsdWUpO1xuXHRcdFx0XHRcdFx0cG9zaXRpb24gKz0gMjtcblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0dGFyZ2V0W3Bvc2l0aW9uKytdID0gMHhkMjtcblx0XHRcdFx0XHRcdHRhcmdldFZpZXcuc2V0SW50MzIocG9zaXRpb24sIHZhbHVlKTtcblx0XHRcdFx0XHRcdHBvc2l0aW9uICs9IDQ7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdGxldCB1c2VGbG9hdDMyO1xuXHRcdFx0XHRcdGlmICgodXNlRmxvYXQzMiA9IHRoaXMudXNlRmxvYXQzMikgPiAwICYmIHZhbHVlIDwgMHgxMDAwMDAwMDAgJiYgdmFsdWUgPj0gLTB4ODAwMDAwMDApIHtcblx0XHRcdFx0XHRcdHRhcmdldFtwb3NpdGlvbisrXSA9IDB4Y2E7XG5cdFx0XHRcdFx0XHR0YXJnZXRWaWV3LnNldEZsb2F0MzIocG9zaXRpb24sIHZhbHVlKTtcblx0XHRcdFx0XHRcdGxldCB4U2hpZnRlZDtcblx0XHRcdFx0XHRcdGlmICh1c2VGbG9hdDMyIDwgNCB8fFxuXHRcdFx0XHRcdFx0XHRcdC8vIHRoaXMgY2hlY2tzIGZvciByb3VuZGluZyBvZiBudW1iZXJzIHRoYXQgd2VyZSBlbmNvZGVkIGluIDMyLWJpdCBmbG9hdCB0byBuZWFyZXN0IHNpZ25pZmljYW50IGRlY2ltYWwgZGlnaXQgdGhhdCBjb3VsZCBiZSBwcmVzZXJ2ZWRcblx0XHRcdFx0XHRcdFx0XHQoKHhTaGlmdGVkID0gdmFsdWUgKiBtdWx0MTBbKCh0YXJnZXRbcG9zaXRpb25dICYgMHg3ZikgPDwgMSkgfCAodGFyZ2V0W3Bvc2l0aW9uICsgMV0gPj4gNyldKSA+PiAwKSA9PT0geFNoaWZ0ZWQpIHtcblx0XHRcdFx0XHRcdFx0cG9zaXRpb24gKz0gNDtcblx0XHRcdFx0XHRcdFx0cmV0dXJuXG5cdFx0XHRcdFx0XHR9IGVsc2Vcblx0XHRcdFx0XHRcdFx0cG9zaXRpb24tLTsgLy8gbW92ZSBiYWNrIGludG8gcG9zaXRpb24gZm9yIHdyaXRpbmcgYSBkb3VibGVcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0dGFyZ2V0W3Bvc2l0aW9uKytdID0gMHhjYjtcblx0XHRcdFx0XHR0YXJnZXRWaWV3LnNldEZsb2F0NjQocG9zaXRpb24sIHZhbHVlKTtcblx0XHRcdFx0XHRwb3NpdGlvbiArPSA4O1xuXHRcdFx0XHR9XG5cdFx0XHR9IGVsc2UgaWYgKHR5cGUgPT09ICdvYmplY3QnIHx8IHR5cGUgPT09ICdmdW5jdGlvbicpIHtcblx0XHRcdFx0aWYgKCF2YWx1ZSlcblx0XHRcdFx0XHR0YXJnZXRbcG9zaXRpb24rK10gPSAweGMwO1xuXHRcdFx0XHRlbHNlIHtcblx0XHRcdFx0XHRpZiAocmVmZXJlbmNlTWFwKSB7XG5cdFx0XHRcdFx0XHRsZXQgcmVmZXJlZSA9IHJlZmVyZW5jZU1hcC5nZXQodmFsdWUpO1xuXHRcdFx0XHRcdFx0aWYgKHJlZmVyZWUpIHtcblx0XHRcdFx0XHRcdFx0aWYgKCFyZWZlcmVlLmlkKSB7XG5cdFx0XHRcdFx0XHRcdFx0bGV0IGlkc1RvSW5zZXJ0ID0gcmVmZXJlbmNlTWFwLmlkc1RvSW5zZXJ0IHx8IChyZWZlcmVuY2VNYXAuaWRzVG9JbnNlcnQgPSBbXSk7XG5cdFx0XHRcdFx0XHRcdFx0cmVmZXJlZS5pZCA9IGlkc1RvSW5zZXJ0LnB1c2gocmVmZXJlZSk7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0dGFyZ2V0W3Bvc2l0aW9uKytdID0gMHhkNjsgLy8gZml4ZXh0IDRcblx0XHRcdFx0XHRcdFx0dGFyZ2V0W3Bvc2l0aW9uKytdID0gMHg3MDsgLy8gXCJwXCIgZm9yIHBvaW50ZXJcblx0XHRcdFx0XHRcdFx0dGFyZ2V0Vmlldy5zZXRVaW50MzIocG9zaXRpb24sIHJlZmVyZWUuaWQpO1xuXHRcdFx0XHRcdFx0XHRwb3NpdGlvbiArPSA0O1xuXHRcdFx0XHRcdFx0XHRyZXR1cm5cblx0XHRcdFx0XHRcdH0gZWxzZVxuXHRcdFx0XHRcdFx0XHRyZWZlcmVuY2VNYXAuc2V0KHZhbHVlLCB7IG9mZnNldDogcG9zaXRpb24gLSBzdGFydCB9KTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0bGV0IGNvbnN0cnVjdG9yID0gdmFsdWUuY29uc3RydWN0b3I7XG5cdFx0XHRcdFx0aWYgKGNvbnN0cnVjdG9yID09PSBPYmplY3QpIHtcblx0XHRcdFx0XHRcdHdyaXRlT2JqZWN0KHZhbHVlKTtcblx0XHRcdFx0XHR9IGVsc2UgaWYgKGNvbnN0cnVjdG9yID09PSBBcnJheSkge1xuXHRcdFx0XHRcdFx0cGFja0FycmF5KHZhbHVlKTtcblx0XHRcdFx0XHR9IGVsc2UgaWYgKGNvbnN0cnVjdG9yID09PSBNYXApIHtcblx0XHRcdFx0XHRcdGlmICh0aGlzLm1hcEFzRW1wdHlPYmplY3QpIHRhcmdldFtwb3NpdGlvbisrXSA9IDB4ODA7XG5cdFx0XHRcdFx0XHRlbHNlIHtcblx0XHRcdFx0XHRcdFx0bGVuZ3RoID0gdmFsdWUuc2l6ZTtcblx0XHRcdFx0XHRcdFx0aWYgKGxlbmd0aCA8IDB4MTApIHtcblx0XHRcdFx0XHRcdFx0XHR0YXJnZXRbcG9zaXRpb24rK10gPSAweDgwIHwgbGVuZ3RoO1xuXHRcdFx0XHRcdFx0XHR9IGVsc2UgaWYgKGxlbmd0aCA8IDB4MTAwMDApIHtcblx0XHRcdFx0XHRcdFx0XHR0YXJnZXRbcG9zaXRpb24rK10gPSAweGRlO1xuXHRcdFx0XHRcdFx0XHRcdHRhcmdldFtwb3NpdGlvbisrXSA9IGxlbmd0aCA+PiA4O1xuXHRcdFx0XHRcdFx0XHRcdHRhcmdldFtwb3NpdGlvbisrXSA9IGxlbmd0aCAmIDB4ZmY7XG5cdFx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRcdFx0dGFyZ2V0W3Bvc2l0aW9uKytdID0gMHhkZjtcblx0XHRcdFx0XHRcdFx0XHR0YXJnZXRWaWV3LnNldFVpbnQzMihwb3NpdGlvbiwgbGVuZ3RoKTtcblx0XHRcdFx0XHRcdFx0XHRwb3NpdGlvbiArPSA0O1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdGZvciAobGV0IFtrZXksIGVudHJ5VmFsdWVdIG9mIHZhbHVlKSB7XG5cdFx0XHRcdFx0XHRcdFx0cGFjayhrZXkpO1xuXHRcdFx0XHRcdFx0XHRcdHBhY2soZW50cnlWYWx1ZSk7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0Zm9yIChsZXQgaSA9IDAsIGwgPSBleHRlbnNpb25zLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuXHRcdFx0XHRcdFx0XHRsZXQgZXh0ZW5zaW9uQ2xhc3MgPSBleHRlbnNpb25DbGFzc2VzW2ldO1xuXHRcdFx0XHRcdFx0XHRpZiAodmFsdWUgaW5zdGFuY2VvZiBleHRlbnNpb25DbGFzcykge1xuXHRcdFx0XHRcdFx0XHRcdGxldCBleHRlbnNpb24gPSBleHRlbnNpb25zW2ldO1xuXHRcdFx0XHRcdFx0XHRcdGlmIChleHRlbnNpb24ud3JpdGUpIHtcblx0XHRcdFx0XHRcdFx0XHRcdGlmIChleHRlbnNpb24udHlwZSkge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR0YXJnZXRbcG9zaXRpb24rK10gPSAweGQ0OyAvLyBvbmUgYnl0ZSBcInRhZ1wiIGV4dGVuc2lvblxuXHRcdFx0XHRcdFx0XHRcdFx0XHR0YXJnZXRbcG9zaXRpb24rK10gPSBleHRlbnNpb24udHlwZTtcblx0XHRcdFx0XHRcdFx0XHRcdFx0dGFyZ2V0W3Bvc2l0aW9uKytdID0gMDtcblx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHRcdGxldCB3cml0ZVJlc3VsdCA9IGV4dGVuc2lvbi53cml0ZS5jYWxsKHRoaXMsIHZhbHVlKTtcblx0XHRcdFx0XHRcdFx0XHRcdGlmICh3cml0ZVJlc3VsdCA9PT0gdmFsdWUpIHsgLy8gYXZvaWQgaW5maW5pdGUgcmVjdXJzaW9uXG5cdFx0XHRcdFx0XHRcdFx0XHRcdGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdHBhY2tBcnJheSh2YWx1ZSk7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0d3JpdGVPYmplY3QodmFsdWUpO1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRwYWNrKHdyaXRlUmVzdWx0KTtcblx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHRcdHJldHVyblxuXHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHRsZXQgY3VycmVudFRhcmdldCA9IHRhcmdldDtcblx0XHRcdFx0XHRcdFx0XHRsZXQgY3VycmVudFRhcmdldFZpZXcgPSB0YXJnZXRWaWV3O1xuXHRcdFx0XHRcdFx0XHRcdGxldCBjdXJyZW50UG9zaXRpb24gPSBwb3NpdGlvbjtcblx0XHRcdFx0XHRcdFx0XHR0YXJnZXQgPSBudWxsO1xuXHRcdFx0XHRcdFx0XHRcdGxldCByZXN1bHQ7XG5cdFx0XHRcdFx0XHRcdFx0dHJ5IHtcblx0XHRcdFx0XHRcdFx0XHRcdHJlc3VsdCA9IGV4dGVuc2lvbi5wYWNrLmNhbGwodGhpcywgdmFsdWUsIChzaXplKSA9PiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdC8vIHJlc3RvcmUgdGFyZ2V0IGFuZCB1c2UgaXRcblx0XHRcdFx0XHRcdFx0XHRcdFx0dGFyZ2V0ID0gY3VycmVudFRhcmdldDtcblx0XHRcdFx0XHRcdFx0XHRcdFx0Y3VycmVudFRhcmdldCA9IG51bGw7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHBvc2l0aW9uICs9IHNpemU7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdGlmIChwb3NpdGlvbiA+IHNhZmVFbmQpXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0bWFrZVJvb20ocG9zaXRpb24pO1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRyZXR1cm4ge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdHRhcmdldCwgdGFyZ2V0VmlldywgcG9zaXRpb246IHBvc2l0aW9uIC0gc2l6ZVxuXHRcdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0XHR9LCBwYWNrKTtcblx0XHRcdFx0XHRcdFx0XHR9IGZpbmFsbHkge1xuXHRcdFx0XHRcdFx0XHRcdFx0Ly8gcmVzdG9yZSBjdXJyZW50IHRhcmdldCBpbmZvcm1hdGlvbiAodW5sZXNzIGFscmVhZHkgcmVzdG9yZWQpXG5cdFx0XHRcdFx0XHRcdFx0XHRpZiAoY3VycmVudFRhcmdldCkge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR0YXJnZXQgPSBjdXJyZW50VGFyZ2V0O1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR0YXJnZXRWaWV3ID0gY3VycmVudFRhcmdldFZpZXc7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHBvc2l0aW9uID0gY3VycmVudFBvc2l0aW9uO1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRzYWZlRW5kID0gdGFyZ2V0Lmxlbmd0aCAtIDEwO1xuXHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHRpZiAocmVzdWx0KSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRpZiAocmVzdWx0Lmxlbmd0aCArIHBvc2l0aW9uID4gc2FmZUVuZClcblx0XHRcdFx0XHRcdFx0XHRcdFx0bWFrZVJvb20ocmVzdWx0Lmxlbmd0aCArIHBvc2l0aW9uKTtcblx0XHRcdFx0XHRcdFx0XHRcdHBvc2l0aW9uID0gd3JpdGVFeHRlbnNpb25EYXRhKHJlc3VsdCwgdGFyZ2V0LCBwb3NpdGlvbiwgZXh0ZW5zaW9uLnR5cGUpO1xuXHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHRyZXR1cm5cblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0Ly8gY2hlY2sgaXNBcnJheSBhZnRlciBleHRlbnNpb25zLCBiZWNhdXNlIGV4dGVuc2lvbnMgY2FuIGV4dGVuZCBBcnJheVxuXHRcdFx0XHRcdFx0aWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG5cdFx0XHRcdFx0XHRcdHBhY2tBcnJheSh2YWx1ZSk7XG5cdFx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0XHQvLyB1c2UgdGhpcyBhcyBhbiBhbHRlcm5hdGUgbWVjaGFuaXNtIGZvciBleHByZXNzaW5nIGhvdyB0byBzZXJpYWxpemVcblx0XHRcdFx0XHRcdFx0aWYgKHZhbHVlLnRvSlNPTikge1xuXHRcdFx0XHRcdFx0XHRcdGNvbnN0IGpzb24gPSB2YWx1ZS50b0pTT04oKTtcblx0XHRcdFx0XHRcdFx0XHQvLyBpZiBmb3Igc29tZSByZWFzb24gdmFsdWUudG9KU09OIHJldHVybnMgaXRzZWxmIGl0J2xsIGxvb3AgZm9yZXZlclxuXHRcdFx0XHRcdFx0XHRcdGlmIChqc29uICE9PSB2YWx1ZSlcblx0XHRcdFx0XHRcdFx0XHRcdHJldHVybiBwYWNrKGpzb24pXG5cdFx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0XHQvLyBpZiB0aGVyZSBpcyBhIHdyaXRlRnVuY3Rpb24sIHVzZSBpdCwgb3RoZXJ3aXNlIGp1c3QgZW5jb2RlIGFzIHVuZGVmaW5lZFxuXHRcdFx0XHRcdFx0XHRpZiAodHlwZSA9PT0gJ2Z1bmN0aW9uJylcblx0XHRcdFx0XHRcdFx0XHRyZXR1cm4gcGFjayh0aGlzLndyaXRlRnVuY3Rpb24gJiYgdGhpcy53cml0ZUZ1bmN0aW9uKHZhbHVlKSk7XG5cblx0XHRcdFx0XHRcdFx0Ly8gbm8gZXh0ZW5zaW9uIGZvdW5kLCB3cml0ZSBhcyBwbGFpbiBvYmplY3Rcblx0XHRcdFx0XHRcdFx0d3JpdGVPYmplY3QodmFsdWUpO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fSBlbHNlIGlmICh0eXBlID09PSAnYm9vbGVhbicpIHtcblx0XHRcdFx0dGFyZ2V0W3Bvc2l0aW9uKytdID0gdmFsdWUgPyAweGMzIDogMHhjMjtcblx0XHRcdH0gZWxzZSBpZiAodHlwZSA9PT0gJ2JpZ2ludCcpIHtcblx0XHRcdFx0aWYgKHZhbHVlIDwgKEJpZ0ludCgxKTw8QmlnSW50KDYzKSkgJiYgdmFsdWUgPj0gLShCaWdJbnQoMSk8PEJpZ0ludCg2MykpKSB7XG5cdFx0XHRcdFx0Ly8gdXNlIGEgc2lnbmVkIGludCBhcyBsb25nIGFzIGl0IGZpdHNcblx0XHRcdFx0XHR0YXJnZXRbcG9zaXRpb24rK10gPSAweGQzO1xuXHRcdFx0XHRcdHRhcmdldFZpZXcuc2V0QmlnSW50NjQocG9zaXRpb24sIHZhbHVlKTtcblx0XHRcdFx0fSBlbHNlIGlmICh2YWx1ZSA8IChCaWdJbnQoMSk8PEJpZ0ludCg2NCkpICYmIHZhbHVlID4gMCkge1xuXHRcdFx0XHRcdC8vIGlmIHdlIGNhbiBmaXQgYW4gdW5zaWduZWQgaW50LCB1c2UgdGhhdFxuXHRcdFx0XHRcdHRhcmdldFtwb3NpdGlvbisrXSA9IDB4Y2Y7XG5cdFx0XHRcdFx0dGFyZ2V0Vmlldy5zZXRCaWdVaW50NjQocG9zaXRpb24sIHZhbHVlKTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHQvLyBvdmVyZmxvd1xuXHRcdFx0XHRcdGlmICh0aGlzLmxhcmdlQmlnSW50VG9GbG9hdCkge1xuXHRcdFx0XHRcdFx0dGFyZ2V0W3Bvc2l0aW9uKytdID0gMHhjYjtcblx0XHRcdFx0XHRcdHRhcmdldFZpZXcuc2V0RmxvYXQ2NChwb3NpdGlvbiwgTnVtYmVyKHZhbHVlKSk7XG5cdFx0XHRcdFx0fSBlbHNlIGlmICh0aGlzLnVzZUJpZ0ludEV4dGVuc2lvbiAmJiB2YWx1ZSA8IDJuKiooMTAyM24pICYmIHZhbHVlID4gLSgybioqKDEwMjNuKSkpIHtcblx0XHRcdFx0XHRcdHRhcmdldFtwb3NpdGlvbisrXSA9IDB4Yzc7XG5cdFx0XHRcdFx0XHRwb3NpdGlvbisrO1xuXHRcdFx0XHRcdFx0dGFyZ2V0W3Bvc2l0aW9uKytdID0gMHg0MjsgLy8gXCJCXCIgZm9yIEJpZ0ludFxuXHRcdFx0XHRcdFx0bGV0IGJ5dGVzID0gW107XG5cdFx0XHRcdFx0XHRsZXQgYWxpZ25lZFNpZ247XG5cdFx0XHRcdFx0XHRkbyB7XG5cdFx0XHRcdFx0XHRcdGxldCBieXRlID0gdmFsdWUgJiAweGZmbjtcblx0XHRcdFx0XHRcdFx0YWxpZ25lZFNpZ24gPSAoYnl0ZSAmIDB4ODBuKSA9PT0gKHZhbHVlIDwgMG4gPyAweDgwbiA6IDBuKTtcblx0XHRcdFx0XHRcdFx0Ynl0ZXMucHVzaChieXRlKTtcblx0XHRcdFx0XHRcdFx0dmFsdWUgPj49IDhuO1xuXHRcdFx0XHRcdFx0fSB3aGlsZSAoISgodmFsdWUgPT09IDBuIHx8IHZhbHVlID09PSAtMW4pICYmIGFsaWduZWRTaWduKSk7XG5cdFx0XHRcdFx0XHR0YXJnZXRbcG9zaXRpb24tMl0gPSBieXRlcy5sZW5ndGg7XG5cdFx0XHRcdFx0XHRmb3IgKGxldCBpID0gYnl0ZXMubGVuZ3RoOyBpID4gMDspIHtcblx0XHRcdFx0XHRcdFx0dGFyZ2V0W3Bvc2l0aW9uKytdID0gTnVtYmVyKGJ5dGVzWy0taV0pO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0cmV0dXJuXG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdHRocm93IG5ldyBSYW5nZUVycm9yKHZhbHVlICsgJyB3YXMgdG9vIGxhcmdlIHRvIGZpdCBpbiBNZXNzYWdlUGFjayA2NC1iaXQgaW50ZWdlciBmb3JtYXQsIHVzZScgK1xuXHRcdFx0XHRcdFx0XHQnIHVzZUJpZ0ludEV4dGVuc2lvbiBvciBzZXQgbGFyZ2VCaWdJbnRUb0Zsb2F0IHRvIGNvbnZlcnQgdG8gZmxvYXQtNjQnKVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0XHRwb3NpdGlvbiArPSA4O1xuXHRcdFx0fSBlbHNlIGlmICh0eXBlID09PSAndW5kZWZpbmVkJykge1xuXHRcdFx0XHRpZiAodGhpcy5lbmNvZGVVbmRlZmluZWRBc05pbClcblx0XHRcdFx0XHR0YXJnZXRbcG9zaXRpb24rK10gPSAweGMwO1xuXHRcdFx0XHRlbHNlIHtcblx0XHRcdFx0XHR0YXJnZXRbcG9zaXRpb24rK10gPSAweGQ0OyAvLyBhIG51bWJlciBvZiBpbXBsZW1lbnRhdGlvbnMgdXNlIGZpeGV4dDEgd2l0aCB0eXBlIDAsIGRhdGEgMCB0byBkZW5vdGUgdW5kZWZpbmVkLCBzbyB3ZSBmb2xsb3cgc3VpdGVcblx0XHRcdFx0XHR0YXJnZXRbcG9zaXRpb24rK10gPSAwO1xuXHRcdFx0XHRcdHRhcmdldFtwb3NpdGlvbisrXSA9IDA7XG5cdFx0XHRcdH1cblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHRocm93IG5ldyBFcnJvcignVW5rbm93biB0eXBlOiAnICsgdHlwZSlcblx0XHRcdH1cblx0XHR9O1xuXG5cdFx0Y29uc3Qgd3JpdGVQbGFpbk9iamVjdCA9ICh0aGlzLnZhcmlhYmxlTWFwU2l6ZSB8fCB0aGlzLmNvZXJjaWJsZUtleUFzTnVtYmVyIHx8IHRoaXMuc2tpcFZhbHVlcykgPyAob2JqZWN0KSA9PiB7XG5cdFx0XHQvLyB0aGlzIG1ldGhvZCBpcyBzbGlnaHRseSBzbG93ZXIsIGJ1dCBnZW5lcmF0ZXMgXCJwcmVmZXJyZWQgc2VyaWFsaXphdGlvblwiIChvcHRpbWFsbHkgc21hbGwgZm9yIHNtYWxsZXIgb2JqZWN0cylcblx0XHRcdGxldCBrZXlzO1xuXHRcdFx0aWYgKHRoaXMuc2tpcFZhbHVlcykge1xuXHRcdFx0XHRrZXlzID0gW107XG5cdFx0XHRcdGZvciAobGV0IGtleSBpbiBvYmplY3QpIHtcblx0XHRcdFx0XHRpZiAoKHR5cGVvZiBvYmplY3QuaGFzT3duUHJvcGVydHkgIT09ICdmdW5jdGlvbicgfHwgb2JqZWN0Lmhhc093blByb3BlcnR5KGtleSkpICYmXG5cdFx0XHRcdFx0XHQhdGhpcy5za2lwVmFsdWVzLmluY2x1ZGVzKG9iamVjdFtrZXldKSlcblx0XHRcdFx0XHRcdGtleXMucHVzaChrZXkpO1xuXHRcdFx0XHR9XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRrZXlzID0gT2JqZWN0LmtleXMob2JqZWN0KTtcblx0XHRcdH1cblx0XHRcdGxldCBsZW5ndGggPSBrZXlzLmxlbmd0aDtcblx0XHRcdGlmIChsZW5ndGggPCAweDEwKSB7XG5cdFx0XHRcdHRhcmdldFtwb3NpdGlvbisrXSA9IDB4ODAgfCBsZW5ndGg7XG5cdFx0XHR9IGVsc2UgaWYgKGxlbmd0aCA8IDB4MTAwMDApIHtcblx0XHRcdFx0dGFyZ2V0W3Bvc2l0aW9uKytdID0gMHhkZTtcblx0XHRcdFx0dGFyZ2V0W3Bvc2l0aW9uKytdID0gbGVuZ3RoID4+IDg7XG5cdFx0XHRcdHRhcmdldFtwb3NpdGlvbisrXSA9IGxlbmd0aCAmIDB4ZmY7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR0YXJnZXRbcG9zaXRpb24rK10gPSAweGRmO1xuXHRcdFx0XHR0YXJnZXRWaWV3LnNldFVpbnQzMihwb3NpdGlvbiwgbGVuZ3RoKTtcblx0XHRcdFx0cG9zaXRpb24gKz0gNDtcblx0XHRcdH1cblx0XHRcdGxldCBrZXk7XG5cdFx0XHRpZiAodGhpcy5jb2VyY2libGVLZXlBc051bWJlcikge1xuXHRcdFx0XHRmb3IgKGxldCBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG5cdFx0XHRcdFx0a2V5ID0ga2V5c1tpXTtcblx0XHRcdFx0XHRsZXQgbnVtID0gTnVtYmVyKGtleSk7XG5cdFx0XHRcdFx0cGFjayhpc05hTihudW0pID8ga2V5IDogbnVtKTtcblx0XHRcdFx0XHRwYWNrKG9iamVjdFtrZXldKTtcblx0XHRcdFx0fVxuXG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRmb3IgKGxldCBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG5cdFx0XHRcdFx0cGFjayhrZXkgPSBrZXlzW2ldKTtcblx0XHRcdFx0XHRwYWNrKG9iamVjdFtrZXldKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH0gOlxuXHRcdChvYmplY3QpID0+IHtcblx0XHRcdHRhcmdldFtwb3NpdGlvbisrXSA9IDB4ZGU7IC8vIGFsd2F5cyB1c2luZyBtYXAgMTYsIHNvIHdlIGNhbiBwcmVhbGxvY2F0ZSBhbmQgc2V0IHRoZSBsZW5ndGggYWZ0ZXJ3YXJkc1xuXHRcdFx0bGV0IG9iamVjdE9mZnNldCA9IHBvc2l0aW9uIC0gc3RhcnQ7XG5cdFx0XHRwb3NpdGlvbiArPSAyO1xuXHRcdFx0bGV0IHNpemUgPSAwO1xuXHRcdFx0Zm9yIChsZXQga2V5IGluIG9iamVjdCkge1xuXHRcdFx0XHRpZiAodHlwZW9mIG9iamVjdC5oYXNPd25Qcm9wZXJ0eSAhPT0gJ2Z1bmN0aW9uJyB8fCBvYmplY3QuaGFzT3duUHJvcGVydHkoa2V5KSkge1xuXHRcdFx0XHRcdHBhY2soa2V5KTtcblx0XHRcdFx0XHRwYWNrKG9iamVjdFtrZXldKTtcblx0XHRcdFx0XHRzaXplKys7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdHRhcmdldFtvYmplY3RPZmZzZXQrKyArIHN0YXJ0XSA9IHNpemUgPj4gODtcblx0XHRcdHRhcmdldFtvYmplY3RPZmZzZXQgKyBzdGFydF0gPSBzaXplICYgMHhmZjtcblx0XHR9O1xuXG5cdFx0Y29uc3Qgd3JpdGVSZWNvcmQgPSB0aGlzLnVzZVJlY29yZHMgPT09IGZhbHNlID8gd3JpdGVQbGFpbk9iamVjdCA6XG5cdFx0KG9wdGlvbnMucHJvZ3Jlc3NpdmVSZWNvcmRzICYmICF1c2VUd29CeXRlUmVjb3JkcykgPyAgLy8gdGhpcyBpcyBhYm91dCAyJSBmYXN0ZXIgZm9yIGhpZ2hseSBzdGFibGUgc3RydWN0dXJlcywgc2luY2UgaXQgb25seSByZXF1aXJlcyBvbmUgZm9yLWluIGxvb3AgKGJ1dCBtdWNoIG1vcmUgZXhwZW5zaXZlIHdoZW4gbmV3IHN0cnVjdHVyZSBuZWVkcyB0byBiZSB3cml0dGVuKVxuXHRcdChvYmplY3QpID0+IHtcblx0XHRcdGxldCBuZXh0VHJhbnNpdGlvbiwgdHJhbnNpdGlvbiA9IHN0cnVjdHVyZXMudHJhbnNpdGlvbnMgfHwgKHN0cnVjdHVyZXMudHJhbnNpdGlvbnMgPSBPYmplY3QuY3JlYXRlKG51bGwpKTtcblx0XHRcdGxldCBvYmplY3RPZmZzZXQgPSBwb3NpdGlvbisrIC0gc3RhcnQ7XG5cdFx0XHRsZXQgd3JvdGVLZXlzO1xuXHRcdFx0Zm9yIChsZXQga2V5IGluIG9iamVjdCkge1xuXHRcdFx0XHRpZiAodHlwZW9mIG9iamVjdC5oYXNPd25Qcm9wZXJ0eSAhPT0gJ2Z1bmN0aW9uJyB8fCBvYmplY3QuaGFzT3duUHJvcGVydHkoa2V5KSkge1xuXHRcdFx0XHRcdG5leHRUcmFuc2l0aW9uID0gdHJhbnNpdGlvbltrZXldO1xuXHRcdFx0XHRcdGlmIChuZXh0VHJhbnNpdGlvbilcblx0XHRcdFx0XHRcdHRyYW5zaXRpb24gPSBuZXh0VHJhbnNpdGlvbjtcblx0XHRcdFx0XHRlbHNlIHtcblx0XHRcdFx0XHRcdC8vIHJlY29yZCBkb2Vzbid0IGV4aXN0LCBjcmVhdGUgZnVsbCBuZXcgcmVjb3JkIGFuZCBpbnNlcnQgaXRcblx0XHRcdFx0XHRcdGxldCBrZXlzID0gT2JqZWN0LmtleXMob2JqZWN0KTtcblx0XHRcdFx0XHRcdGxldCBsYXN0VHJhbnNpdGlvbiA9IHRyYW5zaXRpb247XG5cdFx0XHRcdFx0XHR0cmFuc2l0aW9uID0gc3RydWN0dXJlcy50cmFuc2l0aW9ucztcblx0XHRcdFx0XHRcdGxldCBuZXdUcmFuc2l0aW9ucyA9IDA7XG5cdFx0XHRcdFx0XHRmb3IgKGxldCBpID0gMCwgbCA9IGtleXMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG5cdFx0XHRcdFx0XHRcdGxldCBrZXkgPSBrZXlzW2ldO1xuXHRcdFx0XHRcdFx0XHRuZXh0VHJhbnNpdGlvbiA9IHRyYW5zaXRpb25ba2V5XTtcblx0XHRcdFx0XHRcdFx0aWYgKCFuZXh0VHJhbnNpdGlvbikge1xuXHRcdFx0XHRcdFx0XHRcdG5leHRUcmFuc2l0aW9uID0gdHJhbnNpdGlvbltrZXldID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcblx0XHRcdFx0XHRcdFx0XHRuZXdUcmFuc2l0aW9ucysrO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdHRyYW5zaXRpb24gPSBuZXh0VHJhbnNpdGlvbjtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdGlmIChvYmplY3RPZmZzZXQgKyBzdGFydCArIDEgPT0gcG9zaXRpb24pIHtcblx0XHRcdFx0XHRcdFx0Ly8gZmlyc3Qga2V5LCBzbyB3ZSBkb24ndCBuZWVkIHRvIGluc2VydCwgd2UgY2FuIGp1c3Qgd3JpdGUgcmVjb3JkIGRpcmVjdGx5XG5cdFx0XHRcdFx0XHRcdHBvc2l0aW9uLS07XG5cdFx0XHRcdFx0XHRcdG5ld1JlY29yZCh0cmFuc2l0aW9uLCBrZXlzLCBuZXdUcmFuc2l0aW9ucyk7XG5cdFx0XHRcdFx0XHR9IGVsc2UgLy8gb3RoZXJ3aXNlIHdlIG5lZWQgdG8gaW5zZXJ0IHRoZSByZWNvcmQsIG1vdmluZyBleGlzdGluZyBkYXRhIGFmdGVyIHRoZSByZWNvcmRcblx0XHRcdFx0XHRcdFx0aW5zZXJ0TmV3UmVjb3JkKHRyYW5zaXRpb24sIGtleXMsIG9iamVjdE9mZnNldCwgbmV3VHJhbnNpdGlvbnMpO1xuXHRcdFx0XHRcdFx0d3JvdGVLZXlzID0gdHJ1ZTtcblx0XHRcdFx0XHRcdHRyYW5zaXRpb24gPSBsYXN0VHJhbnNpdGlvbltrZXldO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRwYWNrKG9iamVjdFtrZXldKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0aWYgKCF3cm90ZUtleXMpIHtcblx0XHRcdFx0bGV0IHJlY29yZElkID0gdHJhbnNpdGlvbltSRUNPUkRfU1lNQk9MXTtcblx0XHRcdFx0aWYgKHJlY29yZElkKVxuXHRcdFx0XHRcdHRhcmdldFtvYmplY3RPZmZzZXQgKyBzdGFydF0gPSByZWNvcmRJZDtcblx0XHRcdFx0ZWxzZVxuXHRcdFx0XHRcdGluc2VydE5ld1JlY29yZCh0cmFuc2l0aW9uLCBPYmplY3Qua2V5cyhvYmplY3QpLCBvYmplY3RPZmZzZXQsIDApO1xuXHRcdFx0fVxuXHRcdH0gOlxuXHRcdChvYmplY3QpID0+IHtcblx0XHRcdGxldCBuZXh0VHJhbnNpdGlvbiwgdHJhbnNpdGlvbiA9IHN0cnVjdHVyZXMudHJhbnNpdGlvbnMgfHwgKHN0cnVjdHVyZXMudHJhbnNpdGlvbnMgPSBPYmplY3QuY3JlYXRlKG51bGwpKTtcblx0XHRcdGxldCBuZXdUcmFuc2l0aW9ucyA9IDA7XG5cdFx0XHRmb3IgKGxldCBrZXkgaW4gb2JqZWN0KSBpZiAodHlwZW9mIG9iamVjdC5oYXNPd25Qcm9wZXJ0eSAhPT0gJ2Z1bmN0aW9uJyB8fCBvYmplY3QuaGFzT3duUHJvcGVydHkoa2V5KSkge1xuXHRcdFx0XHRuZXh0VHJhbnNpdGlvbiA9IHRyYW5zaXRpb25ba2V5XTtcblx0XHRcdFx0aWYgKCFuZXh0VHJhbnNpdGlvbikge1xuXHRcdFx0XHRcdG5leHRUcmFuc2l0aW9uID0gdHJhbnNpdGlvbltrZXldID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcblx0XHRcdFx0XHRuZXdUcmFuc2l0aW9ucysrO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHRyYW5zaXRpb24gPSBuZXh0VHJhbnNpdGlvbjtcblx0XHRcdH1cblx0XHRcdGxldCByZWNvcmRJZCA9IHRyYW5zaXRpb25bUkVDT1JEX1NZTUJPTF07XG5cdFx0XHRpZiAocmVjb3JkSWQpIHtcblx0XHRcdFx0aWYgKHJlY29yZElkID49IDB4NjAgJiYgdXNlVHdvQnl0ZVJlY29yZHMpIHtcblx0XHRcdFx0XHR0YXJnZXRbcG9zaXRpb24rK10gPSAoKHJlY29yZElkIC09IDB4NjApICYgMHgxZikgKyAweDYwO1xuXHRcdFx0XHRcdHRhcmdldFtwb3NpdGlvbisrXSA9IHJlY29yZElkID4+IDU7XG5cdFx0XHRcdH0gZWxzZVxuXHRcdFx0XHRcdHRhcmdldFtwb3NpdGlvbisrXSA9IHJlY29yZElkO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0bmV3UmVjb3JkKHRyYW5zaXRpb24sIHRyYW5zaXRpb24uX19rZXlzX18gfHwgT2JqZWN0LmtleXMob2JqZWN0KSwgbmV3VHJhbnNpdGlvbnMpO1xuXHRcdFx0fVxuXHRcdFx0Ly8gbm93IHdyaXRlIHRoZSB2YWx1ZXNcblx0XHRcdGZvciAobGV0IGtleSBpbiBvYmplY3QpXG5cdFx0XHRcdGlmICh0eXBlb2Ygb2JqZWN0Lmhhc093blByb3BlcnR5ICE9PSAnZnVuY3Rpb24nIHx8IG9iamVjdC5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XG5cdFx0XHRcdFx0cGFjayhvYmplY3Rba2V5XSk7XG5cdFx0XHRcdH1cblx0XHR9O1xuXG5cdFx0Ly8gY3JlYXRlIHJlZmVyZW5jZSB0byB1c2VSZWNvcmRzIGlmIHVzZVJlY29yZHMgaXMgYSBmdW5jdGlvblxuXHRcdGNvbnN0IGNoZWNrVXNlUmVjb3JkcyA9IHR5cGVvZiB0aGlzLnVzZVJlY29yZHMgPT0gJ2Z1bmN0aW9uJyAmJiB0aGlzLnVzZVJlY29yZHM7XG5cblx0XHRjb25zdCB3cml0ZU9iamVjdCA9IGNoZWNrVXNlUmVjb3JkcyA/IChvYmplY3QpID0+IHtcblx0XHRcdGNoZWNrVXNlUmVjb3JkcyhvYmplY3QpID8gd3JpdGVSZWNvcmQob2JqZWN0KSA6IHdyaXRlUGxhaW5PYmplY3Qob2JqZWN0KTtcblx0XHR9IDogd3JpdGVSZWNvcmQ7XG5cblx0XHRjb25zdCBtYWtlUm9vbSA9IChlbmQpID0+IHtcblx0XHRcdGxldCBuZXdTaXplO1xuXHRcdFx0aWYgKGVuZCA+IDB4MTAwMDAwMCkge1xuXHRcdFx0XHQvLyBzcGVjaWFsIGhhbmRsaW5nIGZvciByZWFsbHkgbGFyZ2UgYnVmZmVyc1xuXHRcdFx0XHRpZiAoKGVuZCAtIHN0YXJ0KSA+IE1BWF9CVUZGRVJfU0laRSlcblx0XHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IoJ1BhY2tlZCBidWZmZXIgd291bGQgYmUgbGFyZ2VyIHRoYW4gbWF4aW11bSBidWZmZXIgc2l6ZScpXG5cdFx0XHRcdG5ld1NpemUgPSBNYXRoLm1pbihNQVhfQlVGRkVSX1NJWkUsXG5cdFx0XHRcdFx0TWF0aC5yb3VuZChNYXRoLm1heCgoZW5kIC0gc3RhcnQpICogKGVuZCA+IDB4NDAwMDAwMCA/IDEuMjUgOiAyKSwgMHg0MDAwMDApIC8gMHgxMDAwKSAqIDB4MTAwMCk7XG5cdFx0XHR9IGVsc2UgLy8gZmFzdGVyIGhhbmRsaW5nIGZvciBzbWFsbGVyIGJ1ZmZlcnNcblx0XHRcdFx0bmV3U2l6ZSA9ICgoTWF0aC5tYXgoKGVuZCAtIHN0YXJ0KSA8PCAyLCB0YXJnZXQubGVuZ3RoIC0gMSkgPj4gMTIpICsgMSkgPDwgMTI7XG5cdFx0XHRsZXQgbmV3QnVmZmVyID0gbmV3IEJ5dGVBcnJheUFsbG9jYXRlKG5ld1NpemUpO1xuXHRcdFx0dGFyZ2V0VmlldyA9IG5ld0J1ZmZlci5kYXRhVmlldyB8fCAobmV3QnVmZmVyLmRhdGFWaWV3ID0gbmV3IERhdGFWaWV3KG5ld0J1ZmZlci5idWZmZXIsIDAsIG5ld1NpemUpKTtcblx0XHRcdGVuZCA9IE1hdGgubWluKGVuZCwgdGFyZ2V0Lmxlbmd0aCk7XG5cdFx0XHRpZiAodGFyZ2V0LmNvcHkpXG5cdFx0XHRcdHRhcmdldC5jb3B5KG5ld0J1ZmZlciwgMCwgc3RhcnQsIGVuZCk7XG5cdFx0XHRlbHNlXG5cdFx0XHRcdG5ld0J1ZmZlci5zZXQodGFyZ2V0LnNsaWNlKHN0YXJ0LCBlbmQpKTtcblx0XHRcdHBvc2l0aW9uIC09IHN0YXJ0O1xuXHRcdFx0c3RhcnQgPSAwO1xuXHRcdFx0c2FmZUVuZCA9IG5ld0J1ZmZlci5sZW5ndGggLSAxMDtcblx0XHRcdHJldHVybiB0YXJnZXQgPSBuZXdCdWZmZXJcblx0XHR9O1xuXHRcdGNvbnN0IG5ld1JlY29yZCA9ICh0cmFuc2l0aW9uLCBrZXlzLCBuZXdUcmFuc2l0aW9ucykgPT4ge1xuXHRcdFx0bGV0IHJlY29yZElkID0gc3RydWN0dXJlcy5uZXh0SWQ7XG5cdFx0XHRpZiAoIXJlY29yZElkKVxuXHRcdFx0XHRyZWNvcmRJZCA9IDB4NDA7XG5cdFx0XHRpZiAocmVjb3JkSWQgPCBzaGFyZWRMaW1pdElkICYmIHRoaXMuc2hvdWxkU2hhcmVTdHJ1Y3R1cmUgJiYgIXRoaXMuc2hvdWxkU2hhcmVTdHJ1Y3R1cmUoa2V5cykpIHtcblx0XHRcdFx0cmVjb3JkSWQgPSBzdHJ1Y3R1cmVzLm5leHRPd25JZDtcblx0XHRcdFx0aWYgKCEocmVjb3JkSWQgPCBtYXhTdHJ1Y3R1cmVJZCkpXG5cdFx0XHRcdFx0cmVjb3JkSWQgPSBzaGFyZWRMaW1pdElkO1xuXHRcdFx0XHRzdHJ1Y3R1cmVzLm5leHRPd25JZCA9IHJlY29yZElkICsgMTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGlmIChyZWNvcmRJZCA+PSBtYXhTdHJ1Y3R1cmVJZCkvLyBjeWNsZSBiYWNrIGFyb3VuZFxuXHRcdFx0XHRcdHJlY29yZElkID0gc2hhcmVkTGltaXRJZDtcblx0XHRcdFx0c3RydWN0dXJlcy5uZXh0SWQgPSByZWNvcmRJZCArIDE7XG5cdFx0XHR9XG5cdFx0XHRsZXQgaGlnaEJ5dGUgPSBrZXlzLmhpZ2hCeXRlID0gcmVjb3JkSWQgPj0gMHg2MCAmJiB1c2VUd29CeXRlUmVjb3JkcyA/IChyZWNvcmRJZCAtIDB4NjApID4+IDUgOiAtMTtcblx0XHRcdHRyYW5zaXRpb25bUkVDT1JEX1NZTUJPTF0gPSByZWNvcmRJZDtcblx0XHRcdHRyYW5zaXRpb24uX19rZXlzX18gPSBrZXlzO1xuXHRcdFx0c3RydWN0dXJlc1tyZWNvcmRJZCAtIDB4NDBdID0ga2V5cztcblxuXHRcdFx0aWYgKHJlY29yZElkIDwgc2hhcmVkTGltaXRJZCkge1xuXHRcdFx0XHRrZXlzLmlzU2hhcmVkID0gdHJ1ZTtcblx0XHRcdFx0c3RydWN0dXJlcy5zaGFyZWRMZW5ndGggPSByZWNvcmRJZCAtIDB4M2Y7XG5cdFx0XHRcdGhhc1NoYXJlZFVwZGF0ZSA9IHRydWU7XG5cdFx0XHRcdGlmIChoaWdoQnl0ZSA+PSAwKSB7XG5cdFx0XHRcdFx0dGFyZ2V0W3Bvc2l0aW9uKytdID0gKHJlY29yZElkICYgMHgxZikgKyAweDYwO1xuXHRcdFx0XHRcdHRhcmdldFtwb3NpdGlvbisrXSA9IGhpZ2hCeXRlO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHRhcmdldFtwb3NpdGlvbisrXSA9IHJlY29yZElkO1xuXHRcdFx0XHR9XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRpZiAoaGlnaEJ5dGUgPj0gMCkge1xuXHRcdFx0XHRcdHRhcmdldFtwb3NpdGlvbisrXSA9IDB4ZDU7IC8vIGZpeGV4dCAyXG5cdFx0XHRcdFx0dGFyZ2V0W3Bvc2l0aW9uKytdID0gMHg3MjsgLy8gXCJyXCIgcmVjb3JkIGRlZmludGlvbiBleHRlbnNpb24gdHlwZVxuXHRcdFx0XHRcdHRhcmdldFtwb3NpdGlvbisrXSA9IChyZWNvcmRJZCAmIDB4MWYpICsgMHg2MDtcblx0XHRcdFx0XHR0YXJnZXRbcG9zaXRpb24rK10gPSBoaWdoQnl0ZTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHR0YXJnZXRbcG9zaXRpb24rK10gPSAweGQ0OyAvLyBmaXhleHQgMVxuXHRcdFx0XHRcdHRhcmdldFtwb3NpdGlvbisrXSA9IDB4NzI7IC8vIFwiclwiIHJlY29yZCBkZWZpbnRpb24gZXh0ZW5zaW9uIHR5cGVcblx0XHRcdFx0XHR0YXJnZXRbcG9zaXRpb24rK10gPSByZWNvcmRJZDtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGlmIChuZXdUcmFuc2l0aW9ucylcblx0XHRcdFx0XHR0cmFuc2l0aW9uc0NvdW50ICs9IHNlcmlhbGl6YXRpb25zU2luY2VUcmFuc2l0aW9uUmVidWlsZCAqIG5ld1RyYW5zaXRpb25zO1xuXHRcdFx0XHQvLyByZWNvcmQgdGhlIHJlbW92YWwgb2YgdGhlIGlkLCB3ZSBjYW4gbWFpbnRhaW4gb3VyIHNoYXJlZCBzdHJ1Y3R1cmVcblx0XHRcdFx0aWYgKHJlY29yZElkc1RvUmVtb3ZlLmxlbmd0aCA+PSBtYXhPd25TdHJ1Y3R1cmVzKVxuXHRcdFx0XHRcdHJlY29yZElkc1RvUmVtb3ZlLnNoaWZ0KClbUkVDT1JEX1NZTUJPTF0gPSAwOyAvLyB3ZSBhcmUgY3ljbGluZyBiYWNrIHRocm91Z2gsIGFuZCBoYXZlIHRvIHJlbW92ZSBvbGQgb25lc1xuXHRcdFx0XHRyZWNvcmRJZHNUb1JlbW92ZS5wdXNoKHRyYW5zaXRpb24pO1xuXHRcdFx0XHRwYWNrKGtleXMpO1xuXHRcdFx0fVxuXHRcdH07XG5cdFx0Y29uc3QgaW5zZXJ0TmV3UmVjb3JkID0gKHRyYW5zaXRpb24sIGtleXMsIGluc2VydGlvbk9mZnNldCwgbmV3VHJhbnNpdGlvbnMpID0+IHtcblx0XHRcdGxldCBtYWluVGFyZ2V0ID0gdGFyZ2V0O1xuXHRcdFx0bGV0IG1haW5Qb3NpdGlvbiA9IHBvc2l0aW9uO1xuXHRcdFx0bGV0IG1haW5TYWZlRW5kID0gc2FmZUVuZDtcblx0XHRcdGxldCBtYWluU3RhcnQgPSBzdGFydDtcblx0XHRcdHRhcmdldCA9IGtleXNUYXJnZXQ7XG5cdFx0XHRwb3NpdGlvbiA9IDA7XG5cdFx0XHRzdGFydCA9IDA7XG5cdFx0XHRpZiAoIXRhcmdldClcblx0XHRcdFx0a2V5c1RhcmdldCA9IHRhcmdldCA9IG5ldyBCeXRlQXJyYXlBbGxvY2F0ZSg4MTkyKTtcblx0XHRcdHNhZmVFbmQgPSB0YXJnZXQubGVuZ3RoIC0gMTA7XG5cdFx0XHRuZXdSZWNvcmQodHJhbnNpdGlvbiwga2V5cywgbmV3VHJhbnNpdGlvbnMpO1xuXHRcdFx0a2V5c1RhcmdldCA9IHRhcmdldDtcblx0XHRcdGxldCBrZXlzUG9zaXRpb24gPSBwb3NpdGlvbjtcblx0XHRcdHRhcmdldCA9IG1haW5UYXJnZXQ7XG5cdFx0XHRwb3NpdGlvbiA9IG1haW5Qb3NpdGlvbjtcblx0XHRcdHNhZmVFbmQgPSBtYWluU2FmZUVuZDtcblx0XHRcdHN0YXJ0ID0gbWFpblN0YXJ0O1xuXHRcdFx0aWYgKGtleXNQb3NpdGlvbiA+IDEpIHtcblx0XHRcdFx0bGV0IG5ld0VuZCA9IHBvc2l0aW9uICsga2V5c1Bvc2l0aW9uIC0gMTtcblx0XHRcdFx0aWYgKG5ld0VuZCA+IHNhZmVFbmQpXG5cdFx0XHRcdFx0bWFrZVJvb20obmV3RW5kKTtcblx0XHRcdFx0bGV0IGluc2VydGlvblBvc2l0aW9uID0gaW5zZXJ0aW9uT2Zmc2V0ICsgc3RhcnQ7XG5cdFx0XHRcdHRhcmdldC5jb3B5V2l0aGluKGluc2VydGlvblBvc2l0aW9uICsga2V5c1Bvc2l0aW9uLCBpbnNlcnRpb25Qb3NpdGlvbiArIDEsIHBvc2l0aW9uKTtcblx0XHRcdFx0dGFyZ2V0LnNldChrZXlzVGFyZ2V0LnNsaWNlKDAsIGtleXNQb3NpdGlvbiksIGluc2VydGlvblBvc2l0aW9uKTtcblx0XHRcdFx0cG9zaXRpb24gPSBuZXdFbmQ7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR0YXJnZXRbaW5zZXJ0aW9uT2Zmc2V0ICsgc3RhcnRdID0ga2V5c1RhcmdldFswXTtcblx0XHRcdH1cblx0XHR9O1xuXHRcdGNvbnN0IHdyaXRlU3RydWN0ID0gKG9iamVjdCkgPT4ge1xuXHRcdFx0bGV0IG5ld1Bvc2l0aW9uID0gd3JpdGVTdHJ1Y3RTbG90cyhvYmplY3QsIHRhcmdldCwgc3RhcnQsIHBvc2l0aW9uLCBzdHJ1Y3R1cmVzLCBtYWtlUm9vbSwgKHZhbHVlLCBuZXdQb3NpdGlvbiwgbm90aWZ5U2hhcmVkVXBkYXRlKSA9PiB7XG5cdFx0XHRcdGlmIChub3RpZnlTaGFyZWRVcGRhdGUpXG5cdFx0XHRcdFx0cmV0dXJuIGhhc1NoYXJlZFVwZGF0ZSA9IHRydWU7XG5cdFx0XHRcdHBvc2l0aW9uID0gbmV3UG9zaXRpb247XG5cdFx0XHRcdGxldCBzdGFydFRhcmdldCA9IHRhcmdldDtcblx0XHRcdFx0cGFjayh2YWx1ZSk7XG5cdFx0XHRcdHJlc2V0U3RydWN0dXJlcygpO1xuXHRcdFx0XHRpZiAoc3RhcnRUYXJnZXQgIT09IHRhcmdldCkge1xuXHRcdFx0XHRcdHJldHVybiB7IHBvc2l0aW9uLCB0YXJnZXRWaWV3LCB0YXJnZXQgfTsgLy8gaW5kaWNhdGUgdGhlIGJ1ZmZlciB3YXMgcmUtYWxsb2NhdGVkXG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIHBvc2l0aW9uO1xuXHRcdFx0fSwgdGhpcyk7XG5cdFx0XHRpZiAobmV3UG9zaXRpb24gPT09IDApIC8vIGJhaWwgYW5kIGdvIHRvIGEgbXNncGFjayBvYmplY3Rcblx0XHRcdFx0cmV0dXJuIHdyaXRlT2JqZWN0KG9iamVjdCk7XG5cdFx0XHRwb3NpdGlvbiA9IG5ld1Bvc2l0aW9uO1xuXHRcdH07XG5cdH1cblx0dXNlQnVmZmVyKGJ1ZmZlcikge1xuXHRcdC8vIHRoaXMgbWVhbnMgd2UgYXJlIGZpbmlzaGVkIHVzaW5nIG91ciBvd24gYnVmZmVyIGFuZCB3ZSBjYW4gd3JpdGUgb3ZlciBpdCBzYWZlbHlcblx0XHR0YXJnZXQgPSBidWZmZXI7XG5cdFx0dGFyZ2V0LmRhdGFWaWV3IHx8ICh0YXJnZXQuZGF0YVZpZXcgPSBuZXcgRGF0YVZpZXcodGFyZ2V0LmJ1ZmZlciwgdGFyZ2V0LmJ5dGVPZmZzZXQsIHRhcmdldC5ieXRlTGVuZ3RoKSk7XG5cdFx0cG9zaXRpb24gPSAwO1xuXHR9XG5cdHNldCBwb3NpdGlvbiAodmFsdWUpIHtcblx0XHRwb3NpdGlvbiA9IHZhbHVlO1xuXHR9XG5cdGdldCBwb3NpdGlvbigpIHtcblx0XHRyZXR1cm4gcG9zaXRpb247XG5cdH1cblx0Y2xlYXJTaGFyZWREYXRhKCkge1xuXHRcdGlmICh0aGlzLnN0cnVjdHVyZXMpXG5cdFx0XHR0aGlzLnN0cnVjdHVyZXMgPSBbXTtcblx0XHRpZiAodGhpcy50eXBlZFN0cnVjdHMpXG5cdFx0XHR0aGlzLnR5cGVkU3RydWN0cyA9IFtdO1xuXHR9XG59XG5cbmV4dGVuc2lvbkNsYXNzZXMgPSBbIERhdGUsIFNldCwgRXJyb3IsIFJlZ0V4cCwgQXJyYXlCdWZmZXIsIE9iamVjdC5nZXRQcm90b3R5cGVPZihVaW50OEFycmF5LnByb3RvdHlwZSkuY29uc3RydWN0b3IgLypUeXBlZEFycmF5Ki8sIEMxVHlwZSBdO1xuZXh0ZW5zaW9ucyA9IFt7XG5cdHBhY2soZGF0ZSwgYWxsb2NhdGVGb3JXcml0ZSwgcGFjaykge1xuXHRcdGxldCBzZWNvbmRzID0gZGF0ZS5nZXRUaW1lKCkgLyAxMDAwO1xuXHRcdGlmICgodGhpcy51c2VUaW1lc3RhbXAzMiB8fCBkYXRlLmdldE1pbGxpc2Vjb25kcygpID09PSAwKSAmJiBzZWNvbmRzID49IDAgJiYgc2Vjb25kcyA8IDB4MTAwMDAwMDAwKSB7XG5cdFx0XHQvLyBUaW1lc3RhbXAgMzJcblx0XHRcdGxldCB7IHRhcmdldCwgdGFyZ2V0VmlldywgcG9zaXRpb259ID0gYWxsb2NhdGVGb3JXcml0ZSg2KTtcblx0XHRcdHRhcmdldFtwb3NpdGlvbisrXSA9IDB4ZDY7XG5cdFx0XHR0YXJnZXRbcG9zaXRpb24rK10gPSAweGZmO1xuXHRcdFx0dGFyZ2V0Vmlldy5zZXRVaW50MzIocG9zaXRpb24sIHNlY29uZHMpO1xuXHRcdH0gZWxzZSBpZiAoc2Vjb25kcyA+IDAgJiYgc2Vjb25kcyA8IDB4MTAwMDAwMDAwKSB7XG5cdFx0XHQvLyBUaW1lc3RhbXAgNjRcblx0XHRcdGxldCB7IHRhcmdldCwgdGFyZ2V0VmlldywgcG9zaXRpb259ID0gYWxsb2NhdGVGb3JXcml0ZSgxMCk7XG5cdFx0XHR0YXJnZXRbcG9zaXRpb24rK10gPSAweGQ3O1xuXHRcdFx0dGFyZ2V0W3Bvc2l0aW9uKytdID0gMHhmZjtcblx0XHRcdHRhcmdldFZpZXcuc2V0VWludDMyKHBvc2l0aW9uLCBkYXRlLmdldE1pbGxpc2Vjb25kcygpICogNDAwMDAwMCArICgoc2Vjb25kcyAvIDEwMDAgLyAweDEwMDAwMDAwMCkgPj4gMCkpO1xuXHRcdFx0dGFyZ2V0Vmlldy5zZXRVaW50MzIocG9zaXRpb24gKyA0LCBzZWNvbmRzKTtcblx0XHR9IGVsc2UgaWYgKGlzTmFOKHNlY29uZHMpKSB7XG5cdFx0XHRpZiAodGhpcy5vbkludmFsaWREYXRlKSB7XG5cdFx0XHRcdGFsbG9jYXRlRm9yV3JpdGUoMCk7XG5cdFx0XHRcdHJldHVybiBwYWNrKHRoaXMub25JbnZhbGlkRGF0ZSgpKVxuXHRcdFx0fVxuXHRcdFx0Ly8gSW50ZW50aW9uYWxseSBpbnZhbGlkIHRpbWVzdGFtcFxuXHRcdFx0bGV0IHsgdGFyZ2V0LCB0YXJnZXRWaWV3LCBwb3NpdGlvbn0gPSBhbGxvY2F0ZUZvcldyaXRlKDMpO1xuXHRcdFx0dGFyZ2V0W3Bvc2l0aW9uKytdID0gMHhkNDtcblx0XHRcdHRhcmdldFtwb3NpdGlvbisrXSA9IDB4ZmY7XG5cdFx0XHR0YXJnZXRbcG9zaXRpb24rK10gPSAweGZmO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHQvLyBUaW1lc3RhbXAgOTZcblx0XHRcdGxldCB7IHRhcmdldCwgdGFyZ2V0VmlldywgcG9zaXRpb259ID0gYWxsb2NhdGVGb3JXcml0ZSgxNSk7XG5cdFx0XHR0YXJnZXRbcG9zaXRpb24rK10gPSAweGM3O1xuXHRcdFx0dGFyZ2V0W3Bvc2l0aW9uKytdID0gMTI7XG5cdFx0XHR0YXJnZXRbcG9zaXRpb24rK10gPSAweGZmO1xuXHRcdFx0dGFyZ2V0Vmlldy5zZXRVaW50MzIocG9zaXRpb24sIGRhdGUuZ2V0TWlsbGlzZWNvbmRzKCkgKiAxMDAwMDAwKTtcblx0XHRcdHRhcmdldFZpZXcuc2V0QmlnSW50NjQocG9zaXRpb24gKyA0LCBCaWdJbnQoTWF0aC5mbG9vcihzZWNvbmRzKSkpO1xuXHRcdH1cblx0fVxufSwge1xuXHRwYWNrKHNldCwgYWxsb2NhdGVGb3JXcml0ZSwgcGFjaykge1xuXHRcdGlmICh0aGlzLnNldEFzRW1wdHlPYmplY3QpIHtcblx0XHRcdGFsbG9jYXRlRm9yV3JpdGUoMCk7XG5cdFx0XHRyZXR1cm4gcGFjayh7fSlcblx0XHR9XG5cdFx0bGV0IGFycmF5ID0gQXJyYXkuZnJvbShzZXQpO1xuXHRcdGxldCB7IHRhcmdldCwgcG9zaXRpb259ID0gYWxsb2NhdGVGb3JXcml0ZSh0aGlzLm1vcmVUeXBlcyA/IDMgOiAwKTtcblx0XHRpZiAodGhpcy5tb3JlVHlwZXMpIHtcblx0XHRcdHRhcmdldFtwb3NpdGlvbisrXSA9IDB4ZDQ7XG5cdFx0XHR0YXJnZXRbcG9zaXRpb24rK10gPSAweDczOyAvLyAncycgZm9yIFNldFxuXHRcdFx0dGFyZ2V0W3Bvc2l0aW9uKytdID0gMDtcblx0XHR9XG5cdFx0cGFjayhhcnJheSk7XG5cdH1cbn0sIHtcblx0cGFjayhlcnJvciwgYWxsb2NhdGVGb3JXcml0ZSwgcGFjaykge1xuXHRcdGxldCB7IHRhcmdldCwgcG9zaXRpb259ID0gYWxsb2NhdGVGb3JXcml0ZSh0aGlzLm1vcmVUeXBlcyA/IDMgOiAwKTtcblx0XHRpZiAodGhpcy5tb3JlVHlwZXMpIHtcblx0XHRcdHRhcmdldFtwb3NpdGlvbisrXSA9IDB4ZDQ7XG5cdFx0XHR0YXJnZXRbcG9zaXRpb24rK10gPSAweDY1OyAvLyAnZScgZm9yIGVycm9yXG5cdFx0XHR0YXJnZXRbcG9zaXRpb24rK10gPSAwO1xuXHRcdH1cblx0XHRwYWNrKFsgZXJyb3IubmFtZSwgZXJyb3IubWVzc2FnZSwgZXJyb3IuY2F1c2UgXSk7XG5cdH1cbn0sIHtcblx0cGFjayhyZWdleCwgYWxsb2NhdGVGb3JXcml0ZSwgcGFjaykge1xuXHRcdGxldCB7IHRhcmdldCwgcG9zaXRpb259ID0gYWxsb2NhdGVGb3JXcml0ZSh0aGlzLm1vcmVUeXBlcyA/IDMgOiAwKTtcblx0XHRpZiAodGhpcy5tb3JlVHlwZXMpIHtcblx0XHRcdHRhcmdldFtwb3NpdGlvbisrXSA9IDB4ZDQ7XG5cdFx0XHR0YXJnZXRbcG9zaXRpb24rK10gPSAweDc4OyAvLyAneCcgZm9yIHJlZ2VYcFxuXHRcdFx0dGFyZ2V0W3Bvc2l0aW9uKytdID0gMDtcblx0XHR9XG5cdFx0cGFjayhbIHJlZ2V4LnNvdXJjZSwgcmVnZXguZmxhZ3MgXSk7XG5cdH1cbn0sIHtcblx0cGFjayhhcnJheUJ1ZmZlciwgYWxsb2NhdGVGb3JXcml0ZSkge1xuXHRcdGlmICh0aGlzLm1vcmVUeXBlcylcblx0XHRcdHdyaXRlRXh0QnVmZmVyKGFycmF5QnVmZmVyLCAweDEwLCBhbGxvY2F0ZUZvcldyaXRlKTtcblx0XHRlbHNlXG5cdFx0XHR3cml0ZUJ1ZmZlcihoYXNOb2RlQnVmZmVyJDEgPyBCdWZmZXIuZnJvbShhcnJheUJ1ZmZlcikgOiBuZXcgVWludDhBcnJheShhcnJheUJ1ZmZlciksIGFsbG9jYXRlRm9yV3JpdGUpO1xuXHR9XG59LCB7XG5cdHBhY2sodHlwZWRBcnJheSwgYWxsb2NhdGVGb3JXcml0ZSkge1xuXHRcdGxldCBjb25zdHJ1Y3RvciA9IHR5cGVkQXJyYXkuY29uc3RydWN0b3I7XG5cdFx0aWYgKGNvbnN0cnVjdG9yICE9PSBCeXRlQXJyYXkgJiYgdGhpcy5tb3JlVHlwZXMpXG5cdFx0XHR3cml0ZUV4dEJ1ZmZlcih0eXBlZEFycmF5LCB0eXBlZEFycmF5cy5pbmRleE9mKGNvbnN0cnVjdG9yLm5hbWUpLCBhbGxvY2F0ZUZvcldyaXRlKTtcblx0XHRlbHNlXG5cdFx0XHR3cml0ZUJ1ZmZlcih0eXBlZEFycmF5LCBhbGxvY2F0ZUZvcldyaXRlKTtcblx0fVxufSwge1xuXHRwYWNrKGMxLCBhbGxvY2F0ZUZvcldyaXRlKSB7IC8vIHNwZWNpZmljIDB4QzEgb2JqZWN0XG5cdFx0bGV0IHsgdGFyZ2V0LCBwb3NpdGlvbn0gPSBhbGxvY2F0ZUZvcldyaXRlKDEpO1xuXHRcdHRhcmdldFtwb3NpdGlvbl0gPSAweGMxO1xuXHR9XG59XTtcblxuZnVuY3Rpb24gd3JpdGVFeHRCdWZmZXIodHlwZWRBcnJheSwgdHlwZSwgYWxsb2NhdGVGb3JXcml0ZSwgZW5jb2RlKSB7XG5cdGxldCBsZW5ndGggPSB0eXBlZEFycmF5LmJ5dGVMZW5ndGg7XG5cdGlmIChsZW5ndGggKyAxIDwgMHgxMDApIHtcblx0XHR2YXIgeyB0YXJnZXQsIHBvc2l0aW9uIH0gPSBhbGxvY2F0ZUZvcldyaXRlKDQgKyBsZW5ndGgpO1xuXHRcdHRhcmdldFtwb3NpdGlvbisrXSA9IDB4Yzc7XG5cdFx0dGFyZ2V0W3Bvc2l0aW9uKytdID0gbGVuZ3RoICsgMTtcblx0fSBlbHNlIGlmIChsZW5ndGggKyAxIDwgMHgxMDAwMCkge1xuXHRcdHZhciB7IHRhcmdldCwgcG9zaXRpb24gfSA9IGFsbG9jYXRlRm9yV3JpdGUoNSArIGxlbmd0aCk7XG5cdFx0dGFyZ2V0W3Bvc2l0aW9uKytdID0gMHhjODtcblx0XHR0YXJnZXRbcG9zaXRpb24rK10gPSAobGVuZ3RoICsgMSkgPj4gODtcblx0XHR0YXJnZXRbcG9zaXRpb24rK10gPSAobGVuZ3RoICsgMSkgJiAweGZmO1xuXHR9IGVsc2Uge1xuXHRcdHZhciB7IHRhcmdldCwgcG9zaXRpb24sIHRhcmdldFZpZXcgfSA9IGFsbG9jYXRlRm9yV3JpdGUoNyArIGxlbmd0aCk7XG5cdFx0dGFyZ2V0W3Bvc2l0aW9uKytdID0gMHhjOTtcblx0XHR0YXJnZXRWaWV3LnNldFVpbnQzMihwb3NpdGlvbiwgbGVuZ3RoICsgMSk7IC8vIHBsdXMgb25lIGZvciB0aGUgdHlwZSBieXRlXG5cdFx0cG9zaXRpb24gKz0gNDtcblx0fVxuXHR0YXJnZXRbcG9zaXRpb24rK10gPSAweDc0OyAvLyBcInRcIiBmb3IgdHlwZWQgYXJyYXlcblx0dGFyZ2V0W3Bvc2l0aW9uKytdID0gdHlwZTtcblx0aWYgKCF0eXBlZEFycmF5LmJ1ZmZlcikgdHlwZWRBcnJheSA9IG5ldyBVaW50OEFycmF5KHR5cGVkQXJyYXkpO1xuXHR0YXJnZXQuc2V0KG5ldyBVaW50OEFycmF5KHR5cGVkQXJyYXkuYnVmZmVyLCB0eXBlZEFycmF5LmJ5dGVPZmZzZXQsIHR5cGVkQXJyYXkuYnl0ZUxlbmd0aCksIHBvc2l0aW9uKTtcbn1cbmZ1bmN0aW9uIHdyaXRlQnVmZmVyKGJ1ZmZlciwgYWxsb2NhdGVGb3JXcml0ZSkge1xuXHRsZXQgbGVuZ3RoID0gYnVmZmVyLmJ5dGVMZW5ndGg7XG5cdHZhciB0YXJnZXQsIHBvc2l0aW9uO1xuXHRpZiAobGVuZ3RoIDwgMHgxMDApIHtcblx0XHR2YXIgeyB0YXJnZXQsIHBvc2l0aW9uIH0gPSBhbGxvY2F0ZUZvcldyaXRlKGxlbmd0aCArIDIpO1xuXHRcdHRhcmdldFtwb3NpdGlvbisrXSA9IDB4YzQ7XG5cdFx0dGFyZ2V0W3Bvc2l0aW9uKytdID0gbGVuZ3RoO1xuXHR9IGVsc2UgaWYgKGxlbmd0aCA8IDB4MTAwMDApIHtcblx0XHR2YXIgeyB0YXJnZXQsIHBvc2l0aW9uIH0gPSBhbGxvY2F0ZUZvcldyaXRlKGxlbmd0aCArIDMpO1xuXHRcdHRhcmdldFtwb3NpdGlvbisrXSA9IDB4YzU7XG5cdFx0dGFyZ2V0W3Bvc2l0aW9uKytdID0gbGVuZ3RoID4+IDg7XG5cdFx0dGFyZ2V0W3Bvc2l0aW9uKytdID0gbGVuZ3RoICYgMHhmZjtcblx0fSBlbHNlIHtcblx0XHR2YXIgeyB0YXJnZXQsIHBvc2l0aW9uLCB0YXJnZXRWaWV3IH0gPSBhbGxvY2F0ZUZvcldyaXRlKGxlbmd0aCArIDUpO1xuXHRcdHRhcmdldFtwb3NpdGlvbisrXSA9IDB4YzY7XG5cdFx0dGFyZ2V0Vmlldy5zZXRVaW50MzIocG9zaXRpb24sIGxlbmd0aCk7XG5cdFx0cG9zaXRpb24gKz0gNDtcblx0fVxuXHR0YXJnZXQuc2V0KGJ1ZmZlciwgcG9zaXRpb24pO1xufVxuXG5mdW5jdGlvbiB3cml0ZUV4dGVuc2lvbkRhdGEocmVzdWx0LCB0YXJnZXQsIHBvc2l0aW9uLCB0eXBlKSB7XG5cdGxldCBsZW5ndGggPSByZXN1bHQubGVuZ3RoO1xuXHRzd2l0Y2ggKGxlbmd0aCkge1xuXHRcdGNhc2UgMTpcblx0XHRcdHRhcmdldFtwb3NpdGlvbisrXSA9IDB4ZDQ7XG5cdFx0XHRicmVha1xuXHRcdGNhc2UgMjpcblx0XHRcdHRhcmdldFtwb3NpdGlvbisrXSA9IDB4ZDU7XG5cdFx0XHRicmVha1xuXHRcdGNhc2UgNDpcblx0XHRcdHRhcmdldFtwb3NpdGlvbisrXSA9IDB4ZDY7XG5cdFx0XHRicmVha1xuXHRcdGNhc2UgODpcblx0XHRcdHRhcmdldFtwb3NpdGlvbisrXSA9IDB4ZDc7XG5cdFx0XHRicmVha1xuXHRcdGNhc2UgMTY6XG5cdFx0XHR0YXJnZXRbcG9zaXRpb24rK10gPSAweGQ4O1xuXHRcdFx0YnJlYWtcblx0XHRkZWZhdWx0OlxuXHRcdFx0aWYgKGxlbmd0aCA8IDB4MTAwKSB7XG5cdFx0XHRcdHRhcmdldFtwb3NpdGlvbisrXSA9IDB4Yzc7XG5cdFx0XHRcdHRhcmdldFtwb3NpdGlvbisrXSA9IGxlbmd0aDtcblx0XHRcdH0gZWxzZSBpZiAobGVuZ3RoIDwgMHgxMDAwMCkge1xuXHRcdFx0XHR0YXJnZXRbcG9zaXRpb24rK10gPSAweGM4O1xuXHRcdFx0XHR0YXJnZXRbcG9zaXRpb24rK10gPSBsZW5ndGggPj4gODtcblx0XHRcdFx0dGFyZ2V0W3Bvc2l0aW9uKytdID0gbGVuZ3RoICYgMHhmZjtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHRhcmdldFtwb3NpdGlvbisrXSA9IDB4Yzk7XG5cdFx0XHRcdHRhcmdldFtwb3NpdGlvbisrXSA9IGxlbmd0aCA+PiAyNDtcblx0XHRcdFx0dGFyZ2V0W3Bvc2l0aW9uKytdID0gKGxlbmd0aCA+PiAxNikgJiAweGZmO1xuXHRcdFx0XHR0YXJnZXRbcG9zaXRpb24rK10gPSAobGVuZ3RoID4+IDgpICYgMHhmZjtcblx0XHRcdFx0dGFyZ2V0W3Bvc2l0aW9uKytdID0gbGVuZ3RoICYgMHhmZjtcblx0XHRcdH1cblx0fVxuXHR0YXJnZXRbcG9zaXRpb24rK10gPSB0eXBlO1xuXHR0YXJnZXQuc2V0KHJlc3VsdCwgcG9zaXRpb24pO1xuXHRwb3NpdGlvbiArPSBsZW5ndGg7XG5cdHJldHVybiBwb3NpdGlvblxufVxuXG5mdW5jdGlvbiBpbnNlcnRJZHMoc2VyaWFsaXplZCwgaWRzVG9JbnNlcnQpIHtcblx0Ly8gaW5zZXJ0IHRoZSBpZHMgdGhhdCBuZWVkIHRvIGJlIHJlZmVyZW5jZWQgZm9yIHN0cnVjdHVyZWQgY2xvbmVzXG5cdGxldCBuZXh0SWQ7XG5cdGxldCBkaXN0YW5jZVRvTW92ZSA9IGlkc1RvSW5zZXJ0Lmxlbmd0aCAqIDY7XG5cdGxldCBsYXN0RW5kID0gc2VyaWFsaXplZC5sZW5ndGggLSBkaXN0YW5jZVRvTW92ZTtcblx0d2hpbGUgKG5leHRJZCA9IGlkc1RvSW5zZXJ0LnBvcCgpKSB7XG5cdFx0bGV0IG9mZnNldCA9IG5leHRJZC5vZmZzZXQ7XG5cdFx0bGV0IGlkID0gbmV4dElkLmlkO1xuXHRcdHNlcmlhbGl6ZWQuY29weVdpdGhpbihvZmZzZXQgKyBkaXN0YW5jZVRvTW92ZSwgb2Zmc2V0LCBsYXN0RW5kKTtcblx0XHRkaXN0YW5jZVRvTW92ZSAtPSA2O1xuXHRcdGxldCBwb3NpdGlvbiA9IG9mZnNldCArIGRpc3RhbmNlVG9Nb3ZlO1xuXHRcdHNlcmlhbGl6ZWRbcG9zaXRpb24rK10gPSAweGQ2O1xuXHRcdHNlcmlhbGl6ZWRbcG9zaXRpb24rK10gPSAweDY5OyAvLyAnaSdcblx0XHRzZXJpYWxpemVkW3Bvc2l0aW9uKytdID0gaWQgPj4gMjQ7XG5cdFx0c2VyaWFsaXplZFtwb3NpdGlvbisrXSA9IChpZCA+PiAxNikgJiAweGZmO1xuXHRcdHNlcmlhbGl6ZWRbcG9zaXRpb24rK10gPSAoaWQgPj4gOCkgJiAweGZmO1xuXHRcdHNlcmlhbGl6ZWRbcG9zaXRpb24rK10gPSBpZCAmIDB4ZmY7XG5cdFx0bGFzdEVuZCA9IG9mZnNldDtcblx0fVxuXHRyZXR1cm4gc2VyaWFsaXplZFxufVxuXG5mdW5jdGlvbiB3cml0ZUJ1bmRsZXMoc3RhcnQsIHBhY2ssIGluY3JlbWVudFBvc2l0aW9uKSB7XG5cdGlmIChidW5kbGVkU3RyaW5ncy5sZW5ndGggPiAwKSB7XG5cdFx0dGFyZ2V0Vmlldy5zZXRVaW50MzIoYnVuZGxlZFN0cmluZ3MucG9zaXRpb24gKyBzdGFydCwgcG9zaXRpb24gKyBpbmNyZW1lbnRQb3NpdGlvbiAtIGJ1bmRsZWRTdHJpbmdzLnBvc2l0aW9uIC0gc3RhcnQpO1xuXHRcdGJ1bmRsZWRTdHJpbmdzLnN0cmluZ3NQb3NpdGlvbiA9IHBvc2l0aW9uIC0gc3RhcnQ7XG5cdFx0bGV0IHdyaXRlU3RyaW5ncyA9IGJ1bmRsZWRTdHJpbmdzO1xuXHRcdGJ1bmRsZWRTdHJpbmdzID0gbnVsbDtcblx0XHRwYWNrKHdyaXRlU3RyaW5nc1swXSk7XG5cdFx0cGFjayh3cml0ZVN0cmluZ3NbMV0pO1xuXHR9XG59XG5cbmZ1bmN0aW9uIGFkZEV4dGVuc2lvbihleHRlbnNpb24pIHtcblx0aWYgKGV4dGVuc2lvbi5DbGFzcykge1xuXHRcdGlmICghZXh0ZW5zaW9uLnBhY2sgJiYgIWV4dGVuc2lvbi53cml0ZSlcblx0XHRcdHRocm93IG5ldyBFcnJvcignRXh0ZW5zaW9uIGhhcyBubyBwYWNrIG9yIHdyaXRlIGZ1bmN0aW9uJylcblx0XHRpZiAoZXh0ZW5zaW9uLnBhY2sgJiYgIWV4dGVuc2lvbi50eXBlKVxuXHRcdFx0dGhyb3cgbmV3IEVycm9yKCdFeHRlbnNpb24gaGFzIG5vIHR5cGUgKG51bWVyaWMgY29kZSB0byBpZGVudGlmeSB0aGUgZXh0ZW5zaW9uKScpXG5cdFx0ZXh0ZW5zaW9uQ2xhc3Nlcy51bnNoaWZ0KGV4dGVuc2lvbi5DbGFzcyk7XG5cdFx0ZXh0ZW5zaW9ucy51bnNoaWZ0KGV4dGVuc2lvbik7XG5cdH1cblx0YWRkRXh0ZW5zaW9uJDEoZXh0ZW5zaW9uKTtcbn1cbmZ1bmN0aW9uIHByZXBhcmVTdHJ1Y3R1cmVzJDEoc3RydWN0dXJlcywgcGFja3IpIHtcblx0c3RydWN0dXJlcy5pc0NvbXBhdGlibGUgPSAoZXhpc3RpbmdTdHJ1Y3R1cmVzKSA9PiB7XG5cdFx0bGV0IGNvbXBhdGlibGUgPSAhZXhpc3RpbmdTdHJ1Y3R1cmVzIHx8ICgocGFja3IubGFzdE5hbWVkU3RydWN0dXJlc0xlbmd0aCB8fCAwKSA9PT0gZXhpc3RpbmdTdHJ1Y3R1cmVzLmxlbmd0aCk7XG5cdFx0aWYgKCFjb21wYXRpYmxlKSAvLyB3ZSB3YW50IHRvIG1lcmdlIHRoZXNlIGV4aXN0aW5nIHN0cnVjdHVyZXMgaW1tZWRpYXRlbHkgc2luY2Ugd2UgYWxyZWFkeSBoYXZlIGl0IGFuZCB3ZSBhcmUgaW4gdGhlIHJpZ2h0IHRyYW5zYWN0aW9uXG5cdFx0XHRwYWNrci5fbWVyZ2VTdHJ1Y3R1cmVzKGV4aXN0aW5nU3RydWN0dXJlcyk7XG5cdFx0cmV0dXJuIGNvbXBhdGlibGU7XG5cdH07XG5cdHJldHVybiBzdHJ1Y3R1cmVzXG59XG5mdW5jdGlvbiBzZXRXcml0ZVN0cnVjdFNsb3RzKHdyaXRlU2xvdHMsIG1ha2VTdHJ1Y3R1cmVzKSB7XG5cdHdyaXRlU3RydWN0U2xvdHMgPSB3cml0ZVNsb3RzO1xuXHRwcmVwYXJlU3RydWN0dXJlcyQxID0gbWFrZVN0cnVjdHVyZXM7XG59XG5cbmxldCBkZWZhdWx0UGFja3IgPSBuZXcgUGFja3IoeyB1c2VSZWNvcmRzOiBmYWxzZSB9KTtcbmNvbnN0IHBhY2sgPSBkZWZhdWx0UGFja3IucGFjaztcbmNvbnN0IGVuY29kZSA9IGRlZmF1bHRQYWNrci5wYWNrO1xuY29uc3QgRW5jb2RlciA9IFBhY2tyO1xuY29uc3QgeyBORVZFUiwgQUxXQVlTLCBERUNJTUFMX1JPVU5ELCBERUNJTUFMX0ZJVCB9ID0gRkxPQVQzMl9PUFRJT05TO1xuY29uc3QgUkVVU0VfQlVGRkVSX01PREUgPSA1MTI7XG5jb25zdCBSRVNFVF9CVUZGRVJfTU9ERSA9IDEwMjQ7XG5jb25zdCBSRVNFUlZFX1NUQVJUX1NQQUNFID0gMjA0ODtcblxuY29uc3QgQVNDSUkgPSAzOyAvLyB0aGUgTUlCZW51bSBmcm9tIGh0dHBzOi8vd3d3LmlhbmEub3JnL2Fzc2lnbm1lbnRzL2NoYXJhY3Rlci1zZXRzL2NoYXJhY3Rlci1zZXRzLnhodG1sIChhbmQgb3RoZXIgY2hhcmFjdGVyIGVuY29kaW5ncyBjb3VsZCBiZSByZWZlcmVuY2VkIGJ5IE1JQmVudW0pXG5jb25zdCBOVU1CRVIgPSAwO1xuY29uc3QgVVRGOCA9IDI7XG5jb25zdCBPQkpFQ1RfREFUQSA9IDE7XG5jb25zdCBEQVRFID0gMTY7XG5jb25zdCBUWVBFX05BTUVTID0gWydudW0nLCAnb2JqZWN0JywgJ3N0cmluZycsICdhc2NpaSddO1xuVFlQRV9OQU1FU1tEQVRFXSA9ICdkYXRlJztcbmNvbnN0IGZsb2F0MzJIZWFkZXJzID0gW2ZhbHNlLCB0cnVlLCB0cnVlLCBmYWxzZSwgZmFsc2UsIHRydWUsIHRydWUsIGZhbHNlXTtcbmxldCBldmFsU3VwcG9ydGVkO1xudHJ5IHtcblx0bmV3IEZ1bmN0aW9uKCcnKTtcblx0ZXZhbFN1cHBvcnRlZCA9IHRydWU7XG59IGNhdGNoKGVycm9yKSB7XG5cdC8vIGlmIGV2YWwgdmFyaWFudHMgYXJlIG5vdCBzdXBwb3J0ZWQsIGRvIG5vdCBjcmVhdGUgaW5saW5lIG9iamVjdCByZWFkZXJzIGV2ZXJcbn1cblxubGV0IHVwZGF0ZWRQb3NpdGlvbjtcbmNvbnN0IGhhc05vZGVCdWZmZXIgPSB0eXBlb2YgQnVmZmVyICE9PSAndW5kZWZpbmVkJztcbmxldCB0ZXh0RW5jb2RlciwgY3VycmVudFNvdXJjZTtcbnRyeSB7XG5cdHRleHRFbmNvZGVyID0gbmV3IFRleHRFbmNvZGVyKCk7XG59IGNhdGNoIChlcnJvcikge31cbmNvbnN0IGVuY29kZVV0ZjggPSBoYXNOb2RlQnVmZmVyID8gZnVuY3Rpb24odGFyZ2V0LCBzdHJpbmcsIHBvc2l0aW9uKSB7XG5cdHJldHVybiB0YXJnZXQudXRmOFdyaXRlKHN0cmluZywgcG9zaXRpb24sIDB4ZmZmZmZmZmYpXG59IDogKHRleHRFbmNvZGVyICYmIHRleHRFbmNvZGVyLmVuY29kZUludG8pID9cblx0ZnVuY3Rpb24odGFyZ2V0LCBzdHJpbmcsIHBvc2l0aW9uKSB7XG5cdFx0cmV0dXJuIHRleHRFbmNvZGVyLmVuY29kZUludG8oc3RyaW5nLCB0YXJnZXQuc3ViYXJyYXkocG9zaXRpb24pKS53cml0dGVuXG5cdH0gOiBmYWxzZTtcbnNldFdyaXRlU3RydWN0U2xvdHMod3JpdGVTdHJ1Y3QsIHByZXBhcmVTdHJ1Y3R1cmVzKTtcbmZ1bmN0aW9uIHdyaXRlU3RydWN0KG9iamVjdCwgdGFyZ2V0LCBlbmNvZGluZ1N0YXJ0LCBwb3NpdGlvbiwgc3RydWN0dXJlcywgbWFrZVJvb20sIHBhY2ssIHBhY2tyKSB7XG5cdGxldCB0eXBlZFN0cnVjdHMgPSBwYWNrci50eXBlZFN0cnVjdHMgfHwgKHBhY2tyLnR5cGVkU3RydWN0cyA9IFtdKTtcblx0Ly8gbm90ZSB0aGF0IHdlIHJlbHkgb24gcGFjay5qcyB0byBsb2FkIHN0b3JlZCBzdHJ1Y3R1cmVzIGJlZm9yZSB3ZSBnZXQgdG8gdGhpcyBwb2ludFxuXHRsZXQgdGFyZ2V0VmlldyA9IHRhcmdldC5kYXRhVmlldztcblx0bGV0IHJlZnNTdGFydFBvc2l0aW9uID0gKHR5cGVkU3RydWN0cy5sYXN0U3RyaW5nU3RhcnQgfHwgMTAwKSArIHBvc2l0aW9uO1xuXHRsZXQgc2FmZUVuZCA9IHRhcmdldC5sZW5ndGggLSAxMDtcblx0bGV0IHN0YXJ0ID0gcG9zaXRpb247XG5cdGlmIChwb3NpdGlvbiA+IHNhZmVFbmQpIHtcblx0XHR0YXJnZXQgPSBtYWtlUm9vbShwb3NpdGlvbik7XG5cdFx0dGFyZ2V0VmlldyA9IHRhcmdldC5kYXRhVmlldztcblx0XHRwb3NpdGlvbiAtPSBlbmNvZGluZ1N0YXJ0O1xuXHRcdHN0YXJ0IC09IGVuY29kaW5nU3RhcnQ7XG5cdFx0cmVmc1N0YXJ0UG9zaXRpb24gLT0gZW5jb2RpbmdTdGFydDtcblx0XHRlbmNvZGluZ1N0YXJ0ID0gMDtcblx0XHRzYWZlRW5kID0gdGFyZ2V0Lmxlbmd0aCAtIDEwO1xuXHR9XG5cblx0bGV0IHJlZk9mZnNldCwgcmVmUG9zaXRpb24gPSByZWZzU3RhcnRQb3NpdGlvbjtcblxuXHRsZXQgdHJhbnNpdGlvbiA9IHR5cGVkU3RydWN0cy50cmFuc2l0aW9ucyB8fCAodHlwZWRTdHJ1Y3RzLnRyYW5zaXRpb25zID0gT2JqZWN0LmNyZWF0ZShudWxsKSk7XG5cdGxldCBuZXh0SWQgPSB0eXBlZFN0cnVjdHMubmV4dElkIHx8IHR5cGVkU3RydWN0cy5sZW5ndGg7XG5cdGxldCBoZWFkZXJTaXplID1cblx0XHRuZXh0SWQgPCAweGYgPyAxIDpcblx0XHRcdG5leHRJZCA8IDB4ZjAgPyAyIDpcblx0XHRcdFx0bmV4dElkIDwgMHhmMDAwID8gMyA6XG5cdFx0XHRcdFx0bmV4dElkIDwgMHhmMDAwMDAgPyA0IDogMDtcblx0aWYgKGhlYWRlclNpemUgPT09IDApXG5cdFx0cmV0dXJuIDA7XG5cdHBvc2l0aW9uICs9IGhlYWRlclNpemU7XG5cdGxldCBxdWV1ZWRSZWZlcmVuY2VzID0gW107XG5cdGxldCB1c2VkQXNjaWkwO1xuXHRsZXQga2V5SW5kZXggPSAwO1xuXHRmb3IgKGxldCBrZXkgaW4gb2JqZWN0KSB7XG5cdFx0bGV0IHZhbHVlID0gb2JqZWN0W2tleV07XG5cdFx0bGV0IG5leHRUcmFuc2l0aW9uID0gdHJhbnNpdGlvbltrZXldO1xuXHRcdGlmICghbmV4dFRyYW5zaXRpb24pIHtcblx0XHRcdHRyYW5zaXRpb25ba2V5XSA9IG5leHRUcmFuc2l0aW9uID0ge1xuXHRcdFx0XHRrZXksXG5cdFx0XHRcdHBhcmVudDogdHJhbnNpdGlvbixcblx0XHRcdFx0ZW51bWVyYXRpb25PZmZzZXQ6IDAsXG5cdFx0XHRcdGFzY2lpMDogbnVsbCxcblx0XHRcdFx0YXNjaWk4OiBudWxsLFxuXHRcdFx0XHRudW04OiBudWxsLFxuXHRcdFx0XHRzdHJpbmcxNjogbnVsbCxcblx0XHRcdFx0b2JqZWN0MTY6IG51bGwsXG5cdFx0XHRcdG51bTMyOiBudWxsLFxuXHRcdFx0XHRmbG9hdDY0OiBudWxsLFxuXHRcdFx0XHRkYXRlNjQ6IG51bGxcblx0XHRcdH07XG5cdFx0fVxuXHRcdGlmIChwb3NpdGlvbiA+IHNhZmVFbmQpIHtcblx0XHRcdHRhcmdldCA9IG1ha2VSb29tKHBvc2l0aW9uKTtcblx0XHRcdHRhcmdldFZpZXcgPSB0YXJnZXQuZGF0YVZpZXc7XG5cdFx0XHRwb3NpdGlvbiAtPSBlbmNvZGluZ1N0YXJ0O1xuXHRcdFx0c3RhcnQgLT0gZW5jb2RpbmdTdGFydDtcblx0XHRcdHJlZnNTdGFydFBvc2l0aW9uIC09IGVuY29kaW5nU3RhcnQ7XG5cdFx0XHRyZWZQb3NpdGlvbiAtPSBlbmNvZGluZ1N0YXJ0O1xuXHRcdFx0ZW5jb2RpbmdTdGFydCA9IDA7XG5cdFx0XHRzYWZlRW5kID0gdGFyZ2V0Lmxlbmd0aCAtIDEwO1xuXHRcdH1cblx0XHRzd2l0Y2ggKHR5cGVvZiB2YWx1ZSkge1xuXHRcdFx0Y2FzZSAnbnVtYmVyJzpcblx0XHRcdFx0bGV0IG51bWJlciA9IHZhbHVlO1xuXHRcdFx0XHQvLyBmaXJzdCBjaGVjayB0byBzZWUgaWYgd2UgYXJlIHVzaW5nIGEgbG90IG9mIGlkcyBhbmQgc2hvdWxkIGRlZmF1bHQgdG8gd2lkZS9jb21tb24gZm9ybWF0XG5cdFx0XHRcdGlmIChuZXh0SWQgPCAyMDAgfHwgIW5leHRUcmFuc2l0aW9uLm51bTY0KSB7XG5cdFx0XHRcdFx0aWYgKG51bWJlciA+PiAwID09PSBudW1iZXIgJiYgbnVtYmVyIDwgMHgyMDAwMDAwMCAmJiBudW1iZXIgPiAtMHgxZjAwMDAwMCkge1xuXHRcdFx0XHRcdFx0aWYgKG51bWJlciA8IDB4ZjYgJiYgbnVtYmVyID49IDAgJiYgKG5leHRUcmFuc2l0aW9uLm51bTggJiYgIShuZXh0SWQgPiAyMDAgJiYgbmV4dFRyYW5zaXRpb24ubnVtMzIpIHx8IG51bWJlciA8IDB4MjAgJiYgIW5leHRUcmFuc2l0aW9uLm51bTMyKSkge1xuXHRcdFx0XHRcdFx0XHR0cmFuc2l0aW9uID0gbmV4dFRyYW5zaXRpb24ubnVtOCB8fCBjcmVhdGVUeXBlVHJhbnNpdGlvbihuZXh0VHJhbnNpdGlvbiwgTlVNQkVSLCAxKTtcblx0XHRcdFx0XHRcdFx0dGFyZ2V0W3Bvc2l0aW9uKytdID0gbnVtYmVyO1xuXHRcdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdFx0dHJhbnNpdGlvbiA9IG5leHRUcmFuc2l0aW9uLm51bTMyIHx8IGNyZWF0ZVR5cGVUcmFuc2l0aW9uKG5leHRUcmFuc2l0aW9uLCBOVU1CRVIsIDQpO1xuXHRcdFx0XHRcdFx0XHR0YXJnZXRWaWV3LnNldFVpbnQzMihwb3NpdGlvbiwgbnVtYmVyLCB0cnVlKTtcblx0XHRcdFx0XHRcdFx0cG9zaXRpb24gKz0gNDtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdH0gZWxzZSBpZiAobnVtYmVyIDwgMHgxMDAwMDAwMDAgJiYgbnVtYmVyID49IC0weDgwMDAwMDAwKSB7XG5cdFx0XHRcdFx0XHR0YXJnZXRWaWV3LnNldEZsb2F0MzIocG9zaXRpb24sIG51bWJlciwgdHJ1ZSk7XG5cdFx0XHRcdFx0XHRpZiAoZmxvYXQzMkhlYWRlcnNbdGFyZ2V0W3Bvc2l0aW9uICsgM10gPj4+IDVdKSB7XG5cdFx0XHRcdFx0XHRcdGxldCB4U2hpZnRlZDtcblx0XHRcdFx0XHRcdFx0Ly8gdGhpcyBjaGVja3MgZm9yIHJvdW5kaW5nIG9mIG51bWJlcnMgdGhhdCB3ZXJlIGVuY29kZWQgaW4gMzItYml0IGZsb2F0IHRvIG5lYXJlc3Qgc2lnbmlmaWNhbnQgZGVjaW1hbCBkaWdpdCB0aGF0IGNvdWxkIGJlIHByZXNlcnZlZFxuXHRcdFx0XHRcdFx0XHRpZiAoKCh4U2hpZnRlZCA9IG51bWJlciAqIG11bHQxMFsoKHRhcmdldFtwb3NpdGlvbiArIDNdICYgMHg3ZikgPDwgMSkgfCAodGFyZ2V0W3Bvc2l0aW9uICsgMl0gPj4gNyldKSA+PiAwKSA9PT0geFNoaWZ0ZWQpIHtcblx0XHRcdFx0XHRcdFx0XHR0cmFuc2l0aW9uID0gbmV4dFRyYW5zaXRpb24ubnVtMzIgfHwgY3JlYXRlVHlwZVRyYW5zaXRpb24obmV4dFRyYW5zaXRpb24sIE5VTUJFUiwgNCk7XG5cdFx0XHRcdFx0XHRcdFx0cG9zaXRpb24gKz0gNDtcblx0XHRcdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0XHR0cmFuc2l0aW9uID0gbmV4dFRyYW5zaXRpb24ubnVtNjQgfHwgY3JlYXRlVHlwZVRyYW5zaXRpb24obmV4dFRyYW5zaXRpb24sIE5VTUJFUiwgOCk7XG5cdFx0XHRcdHRhcmdldFZpZXcuc2V0RmxvYXQ2NChwb3NpdGlvbiwgbnVtYmVyLCB0cnVlKTtcblx0XHRcdFx0cG9zaXRpb24gKz0gODtcblx0XHRcdFx0YnJlYWs7XG5cdFx0XHRjYXNlICdzdHJpbmcnOlxuXHRcdFx0XHRsZXQgc3RyTGVuZ3RoID0gdmFsdWUubGVuZ3RoO1xuXHRcdFx0XHRyZWZPZmZzZXQgPSByZWZQb3NpdGlvbiAtIHJlZnNTdGFydFBvc2l0aW9uO1xuXHRcdFx0XHRpZiAoKHN0ckxlbmd0aCA8PCAyKSArIHJlZlBvc2l0aW9uID4gc2FmZUVuZCkge1xuXHRcdFx0XHRcdHRhcmdldCA9IG1ha2VSb29tKChzdHJMZW5ndGggPDwgMikgKyByZWZQb3NpdGlvbik7XG5cdFx0XHRcdFx0dGFyZ2V0VmlldyA9IHRhcmdldC5kYXRhVmlldztcblx0XHRcdFx0XHRwb3NpdGlvbiAtPSBlbmNvZGluZ1N0YXJ0O1xuXHRcdFx0XHRcdHN0YXJ0IC09IGVuY29kaW5nU3RhcnQ7XG5cdFx0XHRcdFx0cmVmc1N0YXJ0UG9zaXRpb24gLT0gZW5jb2RpbmdTdGFydDtcblx0XHRcdFx0XHRyZWZQb3NpdGlvbiAtPSBlbmNvZGluZ1N0YXJ0O1xuXHRcdFx0XHRcdGVuY29kaW5nU3RhcnQgPSAwO1xuXHRcdFx0XHRcdHNhZmVFbmQgPSB0YXJnZXQubGVuZ3RoIC0gMTA7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKHN0ckxlbmd0aCA+ICgoMHhmZjAwICsgcmVmT2Zmc2V0KSA+PiAyKSkge1xuXHRcdFx0XHRcdHF1ZXVlZFJlZmVyZW5jZXMucHVzaChrZXksIHZhbHVlLCBwb3NpdGlvbiAtIHN0YXJ0KTtcblx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0fVxuXHRcdFx0XHRsZXQgaXNOb3RBc2NpaTtcblx0XHRcdFx0bGV0IHN0clN0YXJ0ID0gcmVmUG9zaXRpb247XG5cdFx0XHRcdGlmIChzdHJMZW5ndGggPCAweDQwKSB7XG5cdFx0XHRcdFx0bGV0IGksIGMxLCBjMjtcblx0XHRcdFx0XHRmb3IgKGkgPSAwOyBpIDwgc3RyTGVuZ3RoOyBpKyspIHtcblx0XHRcdFx0XHRcdGMxID0gdmFsdWUuY2hhckNvZGVBdChpKTtcblx0XHRcdFx0XHRcdGlmIChjMSA8IDB4ODApIHtcblx0XHRcdFx0XHRcdFx0dGFyZ2V0W3JlZlBvc2l0aW9uKytdID0gYzE7XG5cdFx0XHRcdFx0XHR9IGVsc2UgaWYgKGMxIDwgMHg4MDApIHtcblx0XHRcdFx0XHRcdFx0aXNOb3RBc2NpaSA9IHRydWU7XG5cdFx0XHRcdFx0XHRcdHRhcmdldFtyZWZQb3NpdGlvbisrXSA9IGMxID4+IDYgfCAweGMwO1xuXHRcdFx0XHRcdFx0XHR0YXJnZXRbcmVmUG9zaXRpb24rK10gPSBjMSAmIDB4M2YgfCAweDgwO1xuXHRcdFx0XHRcdFx0fSBlbHNlIGlmIChcblx0XHRcdFx0XHRcdFx0KGMxICYgMHhmYzAwKSA9PT0gMHhkODAwICYmXG5cdFx0XHRcdFx0XHRcdCgoYzIgPSB2YWx1ZS5jaGFyQ29kZUF0KGkgKyAxKSkgJiAweGZjMDApID09PSAweGRjMDBcblx0XHRcdFx0XHRcdCkge1xuXHRcdFx0XHRcdFx0XHRpc05vdEFzY2lpID0gdHJ1ZTtcblx0XHRcdFx0XHRcdFx0YzEgPSAweDEwMDAwICsgKChjMSAmIDB4MDNmZikgPDwgMTApICsgKGMyICYgMHgwM2ZmKTtcblx0XHRcdFx0XHRcdFx0aSsrO1xuXHRcdFx0XHRcdFx0XHR0YXJnZXRbcmVmUG9zaXRpb24rK10gPSBjMSA+PiAxOCB8IDB4ZjA7XG5cdFx0XHRcdFx0XHRcdHRhcmdldFtyZWZQb3NpdGlvbisrXSA9IGMxID4+IDEyICYgMHgzZiB8IDB4ODA7XG5cdFx0XHRcdFx0XHRcdHRhcmdldFtyZWZQb3NpdGlvbisrXSA9IGMxID4+IDYgJiAweDNmIHwgMHg4MDtcblx0XHRcdFx0XHRcdFx0dGFyZ2V0W3JlZlBvc2l0aW9uKytdID0gYzEgJiAweDNmIHwgMHg4MDtcblx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRcdGlzTm90QXNjaWkgPSB0cnVlO1xuXHRcdFx0XHRcdFx0XHR0YXJnZXRbcmVmUG9zaXRpb24rK10gPSBjMSA+PiAxMiB8IDB4ZTA7XG5cdFx0XHRcdFx0XHRcdHRhcmdldFtyZWZQb3NpdGlvbisrXSA9IGMxID4+IDYgJiAweDNmIHwgMHg4MDtcblx0XHRcdFx0XHRcdFx0dGFyZ2V0W3JlZlBvc2l0aW9uKytdID0gYzEgJiAweDNmIHwgMHg4MDtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0cmVmUG9zaXRpb24gKz0gZW5jb2RlVXRmOCh0YXJnZXQsIHZhbHVlLCByZWZQb3NpdGlvbik7XG5cdFx0XHRcdFx0aXNOb3RBc2NpaSA9IHJlZlBvc2l0aW9uIC0gc3RyU3RhcnQgPiBzdHJMZW5ndGg7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKHJlZk9mZnNldCA8IDB4YTAgfHwgKHJlZk9mZnNldCA8IDB4ZjYgJiYgKG5leHRUcmFuc2l0aW9uLmFzY2lpOCB8fCBuZXh0VHJhbnNpdGlvbi5zdHJpbmc4KSkpIHtcblx0XHRcdFx0XHQvLyBzaG9ydCBzdHJpbmdzXG5cdFx0XHRcdFx0aWYgKGlzTm90QXNjaWkpIHtcblx0XHRcdFx0XHRcdGlmICghKHRyYW5zaXRpb24gPSBuZXh0VHJhbnNpdGlvbi5zdHJpbmc4KSkge1xuXHRcdFx0XHRcdFx0XHRpZiAodHlwZWRTdHJ1Y3RzLmxlbmd0aCA+IDEwICYmICh0cmFuc2l0aW9uID0gbmV4dFRyYW5zaXRpb24uYXNjaWk4KSkge1xuXHRcdFx0XHRcdFx0XHRcdC8vIHdlIGNhbiBzYWZlbHkgY2hhbmdlIGFzY2lpIHRvIHV0ZjggaW4gcGxhY2Ugc2luY2UgdGhleSBhcmUgY29tcGF0aWJsZVxuXHRcdFx0XHRcdFx0XHRcdHRyYW5zaXRpb24uX190eXBlID0gVVRGODtcblx0XHRcdFx0XHRcdFx0XHRuZXh0VHJhbnNpdGlvbi5hc2NpaTggPSBudWxsO1xuXHRcdFx0XHRcdFx0XHRcdG5leHRUcmFuc2l0aW9uLnN0cmluZzggPSB0cmFuc2l0aW9uO1xuXHRcdFx0XHRcdFx0XHRcdHBhY2sobnVsbCwgMCwgdHJ1ZSk7IC8vIHNwZWNpYWwgY2FsbCB0byBub3RpZnkgdGhhdCBzdHJ1Y3R1cmVzIGhhdmUgYmVlbiB1cGRhdGVkXG5cdFx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRcdFx0dHJhbnNpdGlvbiA9IGNyZWF0ZVR5cGVUcmFuc2l0aW9uKG5leHRUcmFuc2l0aW9uLCBVVEY4LCAxKTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH0gZWxzZSBpZiAocmVmT2Zmc2V0ID09PSAwICYmICF1c2VkQXNjaWkwKSB7XG5cdFx0XHRcdFx0XHR1c2VkQXNjaWkwID0gdHJ1ZTtcblx0XHRcdFx0XHRcdHRyYW5zaXRpb24gPSBuZXh0VHJhbnNpdGlvbi5hc2NpaTAgfHwgY3JlYXRlVHlwZVRyYW5zaXRpb24obmV4dFRyYW5zaXRpb24sIEFTQ0lJLCAwKTtcblx0XHRcdFx0XHRcdGJyZWFrOyAvLyBkb24ndCBpbmNyZW1lbnQgcG9zaXRpb25cblx0XHRcdFx0XHR9Ly8gZWxzZSBhc2NpaTpcblx0XHRcdFx0XHRlbHNlIGlmICghKHRyYW5zaXRpb24gPSBuZXh0VHJhbnNpdGlvbi5hc2NpaTgpICYmICEodHlwZWRTdHJ1Y3RzLmxlbmd0aCA+IDEwICYmICh0cmFuc2l0aW9uID0gbmV4dFRyYW5zaXRpb24uc3RyaW5nOCkpKVxuXHRcdFx0XHRcdFx0dHJhbnNpdGlvbiA9IGNyZWF0ZVR5cGVUcmFuc2l0aW9uKG5leHRUcmFuc2l0aW9uLCBBU0NJSSwgMSk7XG5cdFx0XHRcdFx0dGFyZ2V0W3Bvc2l0aW9uKytdID0gcmVmT2Zmc2V0O1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdC8vIFRPRE86IEVuYWJsZSBhc2NpaTE2IGF0IHNvbWUgcG9pbnQsIGJ1dCBnZXQgdGhlIGxvZ2ljIHJpZ2h0XG5cdFx0XHRcdFx0Ly9pZiAoaXNOb3RBc2NpaSlcblx0XHRcdFx0XHRcdHRyYW5zaXRpb24gPSBuZXh0VHJhbnNpdGlvbi5zdHJpbmcxNiB8fCBjcmVhdGVUeXBlVHJhbnNpdGlvbihuZXh0VHJhbnNpdGlvbiwgVVRGOCwgMik7XG5cdFx0XHRcdFx0Ly9lbHNlXG5cdFx0XHRcdFx0XHQvL3RyYW5zaXRpb24gPSBuZXh0VHJhbnNpdGlvbi5hc2NpaTE2IHx8IGNyZWF0ZVR5cGVUcmFuc2l0aW9uKG5leHRUcmFuc2l0aW9uLCBBU0NJSSwgMik7XG5cdFx0XHRcdFx0dGFyZ2V0Vmlldy5zZXRVaW50MTYocG9zaXRpb24sIHJlZk9mZnNldCwgdHJ1ZSk7XG5cdFx0XHRcdFx0cG9zaXRpb24gKz0gMjtcblx0XHRcdFx0fVxuXHRcdFx0XHRicmVhaztcblx0XHRcdGNhc2UgJ29iamVjdCc6XG5cdFx0XHRcdGlmICh2YWx1ZSkge1xuXHRcdFx0XHRcdGlmICh2YWx1ZS5jb25zdHJ1Y3RvciA9PT0gRGF0ZSkge1xuXHRcdFx0XHRcdFx0dHJhbnNpdGlvbiA9IG5leHRUcmFuc2l0aW9uLmRhdGU2NCB8fCBjcmVhdGVUeXBlVHJhbnNpdGlvbihuZXh0VHJhbnNpdGlvbiwgREFURSwgOCk7XG5cdFx0XHRcdFx0XHR0YXJnZXRWaWV3LnNldEZsb2F0NjQocG9zaXRpb24sIHZhbHVlLmdldFRpbWUoKSwgdHJ1ZSk7XG5cdFx0XHRcdFx0XHRwb3NpdGlvbiArPSA4O1xuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRxdWV1ZWRSZWZlcmVuY2VzLnB1c2goa2V5LCB2YWx1ZSwga2V5SW5kZXgpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0fSBlbHNlIHsgLy8gbnVsbFxuXHRcdFx0XHRcdG5leHRUcmFuc2l0aW9uID0gYW55VHlwZShuZXh0VHJhbnNpdGlvbiwgcG9zaXRpb24sIHRhcmdldFZpZXcsIC0xMCk7IC8vIG1hdGNoIENCT1Igd2l0aCB0aGlzXG5cdFx0XHRcdFx0aWYgKG5leHRUcmFuc2l0aW9uKSB7XG5cdFx0XHRcdFx0XHR0cmFuc2l0aW9uID0gbmV4dFRyYW5zaXRpb247XG5cdFx0XHRcdFx0XHRwb3NpdGlvbiA9IHVwZGF0ZWRQb3NpdGlvbjtcblx0XHRcdFx0XHR9IGVsc2UgcXVldWVkUmVmZXJlbmNlcy5wdXNoKGtleSwgdmFsdWUsIGtleUluZGV4KTtcblx0XHRcdFx0fVxuXHRcdFx0XHRicmVhaztcblx0XHRcdGNhc2UgJ2Jvb2xlYW4nOlxuXHRcdFx0XHR0cmFuc2l0aW9uID0gbmV4dFRyYW5zaXRpb24ubnVtOCB8fCBuZXh0VHJhbnNpdGlvbi5hc2NpaTggfHwgY3JlYXRlVHlwZVRyYW5zaXRpb24obmV4dFRyYW5zaXRpb24sIE5VTUJFUiwgMSk7XG5cdFx0XHRcdHRhcmdldFtwb3NpdGlvbisrXSA9IHZhbHVlID8gMHhmOSA6IDB4Zjg7IC8vIG1hdGNoIENCT1Igd2l0aCB0aGVzZVxuXHRcdFx0XHRicmVhaztcblx0XHRcdGNhc2UgJ3VuZGVmaW5lZCc6XG5cdFx0XHRcdG5leHRUcmFuc2l0aW9uID0gYW55VHlwZShuZXh0VHJhbnNpdGlvbiwgcG9zaXRpb24sIHRhcmdldFZpZXcsIC05KTsgLy8gbWF0Y2ggQ0JPUiB3aXRoIHRoaXNcblx0XHRcdFx0aWYgKG5leHRUcmFuc2l0aW9uKSB7XG5cdFx0XHRcdFx0dHJhbnNpdGlvbiA9IG5leHRUcmFuc2l0aW9uO1xuXHRcdFx0XHRcdHBvc2l0aW9uID0gdXBkYXRlZFBvc2l0aW9uO1xuXHRcdFx0XHR9IGVsc2UgcXVldWVkUmVmZXJlbmNlcy5wdXNoKGtleSwgdmFsdWUsIGtleUluZGV4KTtcblx0XHRcdFx0YnJlYWs7XG5cdFx0XHRkZWZhdWx0OlxuXHRcdFx0XHRxdWV1ZWRSZWZlcmVuY2VzLnB1c2goa2V5LCB2YWx1ZSwga2V5SW5kZXgpO1xuXHRcdH1cblx0XHRrZXlJbmRleCsrO1xuXHR9XG5cblx0Zm9yIChsZXQgaSA9IDAsIGwgPSBxdWV1ZWRSZWZlcmVuY2VzLmxlbmd0aDsgaSA8IGw7KSB7XG5cdFx0bGV0IGtleSA9IHF1ZXVlZFJlZmVyZW5jZXNbaSsrXTtcblx0XHRsZXQgdmFsdWUgPSBxdWV1ZWRSZWZlcmVuY2VzW2krK107XG5cdFx0bGV0IHByb3BlcnR5SW5kZXggPSBxdWV1ZWRSZWZlcmVuY2VzW2krK107XG5cdFx0bGV0IG5leHRUcmFuc2l0aW9uID0gdHJhbnNpdGlvbltrZXldO1xuXHRcdGlmICghbmV4dFRyYW5zaXRpb24pIHtcblx0XHRcdHRyYW5zaXRpb25ba2V5XSA9IG5leHRUcmFuc2l0aW9uID0ge1xuXHRcdFx0XHRrZXksXG5cdFx0XHRcdHBhcmVudDogdHJhbnNpdGlvbixcblx0XHRcdFx0ZW51bWVyYXRpb25PZmZzZXQ6IHByb3BlcnR5SW5kZXggLSBrZXlJbmRleCxcblx0XHRcdFx0YXNjaWkwOiBudWxsLFxuXHRcdFx0XHRhc2NpaTg6IG51bGwsXG5cdFx0XHRcdG51bTg6IG51bGwsXG5cdFx0XHRcdHN0cmluZzE2OiBudWxsLFxuXHRcdFx0XHRvYmplY3QxNjogbnVsbCxcblx0XHRcdFx0bnVtMzI6IG51bGwsXG5cdFx0XHRcdGZsb2F0NjQ6IG51bGxcblx0XHRcdH07XG5cdFx0fVxuXHRcdGxldCBuZXdQb3NpdGlvbjtcblx0XHRpZiAodmFsdWUpIHtcblx0XHRcdC8qaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycpIHsgLy8gVE9ETzogd2UgY291bGQgcmUtZW5hYmxlIGxvbmcgc3RyaW5nc1xuXHRcdFx0XHRpZiAocG9zaXRpb24gKyB2YWx1ZS5sZW5ndGggKiAzID4gc2FmZUVuZCkge1xuXHRcdFx0XHRcdHRhcmdldCA9IG1ha2VSb29tKHBvc2l0aW9uICsgdmFsdWUubGVuZ3RoICogMyk7XG5cdFx0XHRcdFx0cG9zaXRpb24gLT0gc3RhcnQ7XG5cdFx0XHRcdFx0dGFyZ2V0VmlldyA9IHRhcmdldC5kYXRhVmlldztcblx0XHRcdFx0XHRzdGFydCA9IDA7XG5cdFx0XHRcdH1cblx0XHRcdFx0bmV3UG9zaXRpb24gPSBwb3NpdGlvbiArIHRhcmdldC51dGY4V3JpdGUodmFsdWUsIHBvc2l0aW9uLCAweGZmZmZmZmZmKTtcblx0XHRcdH0gZWxzZSB7ICovXG5cdFx0XHRsZXQgc2l6ZTtcblx0XHRcdHJlZk9mZnNldCA9IHJlZlBvc2l0aW9uIC0gcmVmc1N0YXJ0UG9zaXRpb247XG5cdFx0XHRpZiAocmVmT2Zmc2V0IDwgMHhmZjAwKSB7XG5cdFx0XHRcdHRyYW5zaXRpb24gPSBuZXh0VHJhbnNpdGlvbi5vYmplY3QxNjtcblx0XHRcdFx0aWYgKHRyYW5zaXRpb24pXG5cdFx0XHRcdFx0c2l6ZSA9IDI7XG5cdFx0XHRcdGVsc2UgaWYgKCh0cmFuc2l0aW9uID0gbmV4dFRyYW5zaXRpb24ub2JqZWN0MzIpKVxuXHRcdFx0XHRcdHNpemUgPSA0O1xuXHRcdFx0XHRlbHNlIHtcblx0XHRcdFx0XHR0cmFuc2l0aW9uID0gY3JlYXRlVHlwZVRyYW5zaXRpb24obmV4dFRyYW5zaXRpb24sIE9CSkVDVF9EQVRBLCAyKTtcblx0XHRcdFx0XHRzaXplID0gMjtcblx0XHRcdFx0fVxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0dHJhbnNpdGlvbiA9IG5leHRUcmFuc2l0aW9uLm9iamVjdDMyIHx8IGNyZWF0ZVR5cGVUcmFuc2l0aW9uKG5leHRUcmFuc2l0aW9uLCBPQkpFQ1RfREFUQSwgNCk7XG5cdFx0XHRcdHNpemUgPSA0O1xuXHRcdFx0fVxuXHRcdFx0bmV3UG9zaXRpb24gPSBwYWNrKHZhbHVlLCByZWZQb3NpdGlvbik7XG5cdFx0XHQvL31cblx0XHRcdGlmICh0eXBlb2YgbmV3UG9zaXRpb24gPT09ICdvYmplY3QnKSB7XG5cdFx0XHRcdC8vIHJlLWFsbG9jYXRlZFxuXHRcdFx0XHRyZWZQb3NpdGlvbiA9IG5ld1Bvc2l0aW9uLnBvc2l0aW9uO1xuXHRcdFx0XHR0YXJnZXRWaWV3ID0gbmV3UG9zaXRpb24udGFyZ2V0Vmlldztcblx0XHRcdFx0dGFyZ2V0ID0gbmV3UG9zaXRpb24udGFyZ2V0O1xuXHRcdFx0XHRyZWZzU3RhcnRQb3NpdGlvbiAtPSBlbmNvZGluZ1N0YXJ0O1xuXHRcdFx0XHRwb3NpdGlvbiAtPSBlbmNvZGluZ1N0YXJ0O1xuXHRcdFx0XHRzdGFydCAtPSBlbmNvZGluZ1N0YXJ0O1xuXHRcdFx0XHRlbmNvZGluZ1N0YXJ0ID0gMDtcblx0XHRcdH0gZWxzZVxuXHRcdFx0XHRyZWZQb3NpdGlvbiA9IG5ld1Bvc2l0aW9uO1xuXHRcdFx0aWYgKHNpemUgPT09IDIpIHtcblx0XHRcdFx0dGFyZ2V0Vmlldy5zZXRVaW50MTYocG9zaXRpb24sIHJlZk9mZnNldCwgdHJ1ZSk7XG5cdFx0XHRcdHBvc2l0aW9uICs9IDI7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR0YXJnZXRWaWV3LnNldFVpbnQzMihwb3NpdGlvbiwgcmVmT2Zmc2V0LCB0cnVlKTtcblx0XHRcdFx0cG9zaXRpb24gKz0gNDtcblx0XHRcdH1cblx0XHR9IGVsc2UgeyAvLyBudWxsIG9yIHVuZGVmaW5lZFxuXHRcdFx0dHJhbnNpdGlvbiA9IG5leHRUcmFuc2l0aW9uLm9iamVjdDE2IHx8IGNyZWF0ZVR5cGVUcmFuc2l0aW9uKG5leHRUcmFuc2l0aW9uLCBPQkpFQ1RfREFUQSwgMik7XG5cdFx0XHR0YXJnZXRWaWV3LnNldEludDE2KHBvc2l0aW9uLCB2YWx1ZSA9PT0gbnVsbCA/IC0xMCA6IC05LCB0cnVlKTtcblx0XHRcdHBvc2l0aW9uICs9IDI7XG5cdFx0fVxuXHRcdGtleUluZGV4Kys7XG5cdH1cblxuXG5cdGxldCByZWNvcmRJZCA9IHRyYW5zaXRpb25bUkVDT1JEX1NZTUJPTF07XG5cdGlmIChyZWNvcmRJZCA9PSBudWxsKSB7XG5cdFx0cmVjb3JkSWQgPSBwYWNrci50eXBlZFN0cnVjdHMubGVuZ3RoO1xuXHRcdGxldCBzdHJ1Y3R1cmUgPSBbXTtcblx0XHRsZXQgbmV4dFRyYW5zaXRpb24gPSB0cmFuc2l0aW9uO1xuXHRcdGxldCBrZXksIHR5cGU7XG5cdFx0d2hpbGUgKCh0eXBlID0gbmV4dFRyYW5zaXRpb24uX190eXBlKSAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRsZXQgc2l6ZSA9IG5leHRUcmFuc2l0aW9uLl9fc2l6ZTtcblx0XHRcdG5leHRUcmFuc2l0aW9uID0gbmV4dFRyYW5zaXRpb24uX19wYXJlbnQ7XG5cdFx0XHRrZXkgPSBuZXh0VHJhbnNpdGlvbi5rZXk7XG5cdFx0XHRsZXQgcHJvcGVydHkgPSBbdHlwZSwgc2l6ZSwga2V5XTtcblx0XHRcdGlmIChuZXh0VHJhbnNpdGlvbi5lbnVtZXJhdGlvbk9mZnNldClcblx0XHRcdFx0cHJvcGVydHkucHVzaChuZXh0VHJhbnNpdGlvbi5lbnVtZXJhdGlvbk9mZnNldCk7XG5cdFx0XHRzdHJ1Y3R1cmUucHVzaChwcm9wZXJ0eSk7XG5cdFx0XHRuZXh0VHJhbnNpdGlvbiA9IG5leHRUcmFuc2l0aW9uLnBhcmVudDtcblx0XHR9XG5cdFx0c3RydWN0dXJlLnJldmVyc2UoKTtcblx0XHR0cmFuc2l0aW9uW1JFQ09SRF9TWU1CT0xdID0gcmVjb3JkSWQ7XG5cdFx0cGFja3IudHlwZWRTdHJ1Y3RzW3JlY29yZElkXSA9IHN0cnVjdHVyZTtcblx0XHRwYWNrKG51bGwsIDAsIHRydWUpOyAvLyBzcGVjaWFsIGNhbGwgdG8gbm90aWZ5IHRoYXQgc3RydWN0dXJlcyBoYXZlIGJlZW4gdXBkYXRlZFxuXHR9XG5cblxuXHRzd2l0Y2ggKGhlYWRlclNpemUpIHtcblx0XHRjYXNlIDE6XG5cdFx0XHRpZiAocmVjb3JkSWQgPj0gMHgxMCkgcmV0dXJuIDA7XG5cdFx0XHR0YXJnZXRbc3RhcnRdID0gcmVjb3JkSWQgKyAweDIwO1xuXHRcdFx0YnJlYWs7XG5cdFx0Y2FzZSAyOlxuXHRcdFx0aWYgKHJlY29yZElkID49IDB4MTAwKSByZXR1cm4gMDtcblx0XHRcdHRhcmdldFtzdGFydF0gPSAweDM4O1xuXHRcdFx0dGFyZ2V0W3N0YXJ0ICsgMV0gPSByZWNvcmRJZDtcblx0XHRcdGJyZWFrO1xuXHRcdGNhc2UgMzpcblx0XHRcdGlmIChyZWNvcmRJZCA+PSAweDEwMDAwKSByZXR1cm4gMDtcblx0XHRcdHRhcmdldFtzdGFydF0gPSAweDM5O1xuXHRcdFx0dGFyZ2V0Vmlldy5zZXRVaW50MTYoc3RhcnQgKyAxLCByZWNvcmRJZCwgdHJ1ZSk7XG5cdFx0XHRicmVhaztcblx0XHRjYXNlIDQ6XG5cdFx0XHRpZiAocmVjb3JkSWQgPj0gMHgxMDAwMDAwKSByZXR1cm4gMDtcblx0XHRcdHRhcmdldFZpZXcuc2V0VWludDMyKHN0YXJ0LCAocmVjb3JkSWQgPDwgOCkgKyAweDNhLCB0cnVlKTtcblx0XHRcdGJyZWFrO1xuXHR9XG5cblx0aWYgKHBvc2l0aW9uIDwgcmVmc1N0YXJ0UG9zaXRpb24pIHtcblx0XHRpZiAocmVmc1N0YXJ0UG9zaXRpb24gPT09IHJlZlBvc2l0aW9uKVxuXHRcdFx0cmV0dXJuIHBvc2l0aW9uOyAvLyBubyByZWZzXG5cdFx0Ly8gYWRqdXN0IHBvc2l0aW9uaW5nXG5cdFx0dGFyZ2V0LmNvcHlXaXRoaW4ocG9zaXRpb24sIHJlZnNTdGFydFBvc2l0aW9uLCByZWZQb3NpdGlvbik7XG5cdFx0cmVmUG9zaXRpb24gKz0gcG9zaXRpb24gLSByZWZzU3RhcnRQb3NpdGlvbjtcblx0XHR0eXBlZFN0cnVjdHMubGFzdFN0cmluZ1N0YXJ0ID0gcG9zaXRpb24gLSBzdGFydDtcblx0fSBlbHNlIGlmIChwb3NpdGlvbiA+IHJlZnNTdGFydFBvc2l0aW9uKSB7XG5cdFx0aWYgKHJlZnNTdGFydFBvc2l0aW9uID09PSByZWZQb3NpdGlvbilcblx0XHRcdHJldHVybiBwb3NpdGlvbjsgLy8gbm8gcmVmc1xuXHRcdHR5cGVkU3RydWN0cy5sYXN0U3RyaW5nU3RhcnQgPSBwb3NpdGlvbiAtIHN0YXJ0O1xuXHRcdHJldHVybiB3cml0ZVN0cnVjdChvYmplY3QsIHRhcmdldCwgZW5jb2RpbmdTdGFydCwgc3RhcnQsIHN0cnVjdHVyZXMsIG1ha2VSb29tLCBwYWNrLCBwYWNrcik7XG5cdH1cblx0cmV0dXJuIHJlZlBvc2l0aW9uO1xufVxuZnVuY3Rpb24gYW55VHlwZSh0cmFuc2l0aW9uLCBwb3NpdGlvbiwgdGFyZ2V0VmlldywgdmFsdWUpIHtcblx0bGV0IG5leHRUcmFuc2l0aW9uO1xuXHRpZiAoKG5leHRUcmFuc2l0aW9uID0gdHJhbnNpdGlvbi5hc2NpaTggfHwgdHJhbnNpdGlvbi5udW04KSkge1xuXHRcdHRhcmdldFZpZXcuc2V0SW50OChwb3NpdGlvbiwgdmFsdWUsIHRydWUpO1xuXHRcdHVwZGF0ZWRQb3NpdGlvbiA9IHBvc2l0aW9uICsgMTtcblx0XHRyZXR1cm4gbmV4dFRyYW5zaXRpb247XG5cdH1cblx0aWYgKChuZXh0VHJhbnNpdGlvbiA9IHRyYW5zaXRpb24uc3RyaW5nMTYgfHwgdHJhbnNpdGlvbi5vYmplY3QxNikpIHtcblx0XHR0YXJnZXRWaWV3LnNldEludDE2KHBvc2l0aW9uLCB2YWx1ZSwgdHJ1ZSk7XG5cdFx0dXBkYXRlZFBvc2l0aW9uID0gcG9zaXRpb24gKyAyO1xuXHRcdHJldHVybiBuZXh0VHJhbnNpdGlvbjtcblx0fVxuXHRpZiAobmV4dFRyYW5zaXRpb24gPSB0cmFuc2l0aW9uLm51bTMyKSB7XG5cdFx0dGFyZ2V0Vmlldy5zZXRVaW50MzIocG9zaXRpb24sIDB4ZTAwMDAxMDAgKyB2YWx1ZSwgdHJ1ZSk7XG5cdFx0dXBkYXRlZFBvc2l0aW9uID0gcG9zaXRpb24gKyA0O1xuXHRcdHJldHVybiBuZXh0VHJhbnNpdGlvbjtcblx0fVxuXHQvLyB0cmFuc2l0aW9uLmZsb2F0NjRcblx0aWYgKG5leHRUcmFuc2l0aW9uID0gdHJhbnNpdGlvbi5udW02NCkge1xuXHRcdHRhcmdldFZpZXcuc2V0RmxvYXQ2NChwb3NpdGlvbiwgTmFOLCB0cnVlKTtcblx0XHR0YXJnZXRWaWV3LnNldEludDgocG9zaXRpb24sIHZhbHVlKTtcblx0XHR1cGRhdGVkUG9zaXRpb24gPSBwb3NpdGlvbiArIDg7XG5cdFx0cmV0dXJuIG5leHRUcmFuc2l0aW9uO1xuXHR9XG5cdHVwZGF0ZWRQb3NpdGlvbiA9IHBvc2l0aW9uO1xuXHQvLyBUT0RPOiBjYW4gd2UgZG8gYW4gXCJhbnlcIiB0eXBlIHdoZXJlIHdlIGRlZmVyIHRoZSBkZWNpc2lvbj9cblx0cmV0dXJuO1xufVxuZnVuY3Rpb24gY3JlYXRlVHlwZVRyYW5zaXRpb24odHJhbnNpdGlvbiwgdHlwZSwgc2l6ZSkge1xuXHRsZXQgdHlwZU5hbWUgPSBUWVBFX05BTUVTW3R5cGVdICsgKHNpemUgPDwgMyk7XG5cdGxldCBuZXdUcmFuc2l0aW9uID0gdHJhbnNpdGlvblt0eXBlTmFtZV0gfHwgKHRyYW5zaXRpb25bdHlwZU5hbWVdID0gT2JqZWN0LmNyZWF0ZShudWxsKSk7XG5cdG5ld1RyYW5zaXRpb24uX190eXBlID0gdHlwZTtcblx0bmV3VHJhbnNpdGlvbi5fX3NpemUgPSBzaXplO1xuXHRuZXdUcmFuc2l0aW9uLl9fcGFyZW50ID0gdHJhbnNpdGlvbjtcblx0cmV0dXJuIG5ld1RyYW5zaXRpb247XG59XG5mdW5jdGlvbiBvbkxvYWRlZFN0cnVjdHVyZXMoc2hhcmVkRGF0YSkge1xuXHRpZiAoIShzaGFyZWREYXRhIGluc3RhbmNlb2YgTWFwKSlcblx0XHRyZXR1cm4gc2hhcmVkRGF0YTtcblx0bGV0IHR5cGVkID0gc2hhcmVkRGF0YS5nZXQoJ3R5cGVkJykgfHwgW107XG5cdGlmIChPYmplY3QuaXNGcm96ZW4odHlwZWQpKVxuXHRcdHR5cGVkID0gdHlwZWQubWFwKHN0cnVjdHVyZSA9PiBzdHJ1Y3R1cmUuc2xpY2UoMCkpO1xuXHRsZXQgbmFtZWQgPSBzaGFyZWREYXRhLmdldCgnbmFtZWQnKTtcblx0bGV0IHRyYW5zaXRpb25zID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcblx0Zm9yIChsZXQgaSA9IDAsIGwgPSB0eXBlZC5sZW5ndGg7IGkgPCBsOyBpKyspIHtcblx0XHRsZXQgc3RydWN0dXJlID0gdHlwZWRbaV07XG5cdFx0bGV0IHRyYW5zaXRpb24gPSB0cmFuc2l0aW9ucztcblx0XHRmb3IgKGxldCBbdHlwZSwgc2l6ZSwga2V5XSBvZiBzdHJ1Y3R1cmUpIHtcblx0XHRcdGxldCBuZXh0VHJhbnNpdGlvbiA9IHRyYW5zaXRpb25ba2V5XTtcblx0XHRcdGlmICghbmV4dFRyYW5zaXRpb24pIHtcblx0XHRcdFx0dHJhbnNpdGlvbltrZXldID0gbmV4dFRyYW5zaXRpb24gPSB7XG5cdFx0XHRcdFx0a2V5LFxuXHRcdFx0XHRcdHBhcmVudDogdHJhbnNpdGlvbixcblx0XHRcdFx0XHRlbnVtZXJhdGlvbk9mZnNldDogMCxcblx0XHRcdFx0XHRhc2NpaTA6IG51bGwsXG5cdFx0XHRcdFx0YXNjaWk4OiBudWxsLFxuXHRcdFx0XHRcdG51bTg6IG51bGwsXG5cdFx0XHRcdFx0c3RyaW5nMTY6IG51bGwsXG5cdFx0XHRcdFx0b2JqZWN0MTY6IG51bGwsXG5cdFx0XHRcdFx0bnVtMzI6IG51bGwsXG5cdFx0XHRcdFx0ZmxvYXQ2NDogbnVsbCxcblx0XHRcdFx0XHRkYXRlNjQ6IG51bGwsXG5cdFx0XHRcdH07XG5cdFx0XHR9XG5cdFx0XHR0cmFuc2l0aW9uID0gY3JlYXRlVHlwZVRyYW5zaXRpb24obmV4dFRyYW5zaXRpb24sIHR5cGUsIHNpemUpO1xuXHRcdH1cblx0XHR0cmFuc2l0aW9uW1JFQ09SRF9TWU1CT0xdID0gaTtcblx0fVxuXHR0eXBlZC50cmFuc2l0aW9ucyA9IHRyYW5zaXRpb25zO1xuXHR0aGlzLnR5cGVkU3RydWN0cyA9IHR5cGVkO1xuXHR0aGlzLmxhc3RUeXBlZFN0cnVjdHVyZXNMZW5ndGggPSB0eXBlZC5sZW5ndGg7XG5cdHJldHVybiBuYW1lZDtcbn1cbnZhciBzb3VyY2VTeW1ib2wgPSBTeW1ib2wuZm9yKCdzb3VyY2UnKTtcbmZ1bmN0aW9uIHJlYWRTdHJ1Y3Qoc3JjLCBwb3NpdGlvbiwgc3JjRW5kLCB1bnBhY2tyKSB7XG5cdGxldCByZWNvcmRJZCA9IHNyY1twb3NpdGlvbisrXSAtIDB4MjA7XG5cdGlmIChyZWNvcmRJZCA+PSAyNCkge1xuXHRcdHN3aXRjaChyZWNvcmRJZCkge1xuXHRcdFx0Y2FzZSAyNDogcmVjb3JkSWQgPSBzcmNbcG9zaXRpb24rK107IGJyZWFrO1xuXHRcdFx0Ly8gbGl0dGxlIGVuZGlhbjpcblx0XHRcdGNhc2UgMjU6IHJlY29yZElkID0gc3JjW3Bvc2l0aW9uKytdICsgKHNyY1twb3NpdGlvbisrXSA8PCA4KTsgYnJlYWs7XG5cdFx0XHRjYXNlIDI2OiByZWNvcmRJZCA9IHNyY1twb3NpdGlvbisrXSArIChzcmNbcG9zaXRpb24rK10gPDwgOCkgKyAoc3JjW3Bvc2l0aW9uKytdIDw8IDE2KTsgYnJlYWs7XG5cdFx0XHRjYXNlIDI3OiByZWNvcmRJZCA9IHNyY1twb3NpdGlvbisrXSArIChzcmNbcG9zaXRpb24rK10gPDwgOCkgKyAoc3JjW3Bvc2l0aW9uKytdIDw8IDE2KSArIChzcmNbcG9zaXRpb24rK10gPDwgMjQpOyBicmVhaztcblx0XHR9XG5cdH1cblx0bGV0IHN0cnVjdHVyZSA9IHVucGFja3IudHlwZWRTdHJ1Y3RzICYmIHVucGFja3IudHlwZWRTdHJ1Y3RzW3JlY29yZElkXTtcblx0aWYgKCFzdHJ1Y3R1cmUpIHtcblx0XHQvLyBjb3B5IHNyYyBidWZmZXIgYmVjYXVzZSBnZXRTdHJ1Y3R1cmVzIHdpbGwgb3ZlcnJpZGUgaXRcblx0XHRzcmMgPSBVaW50OEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKHNyYywgcG9zaXRpb24sIHNyY0VuZCk7XG5cdFx0c3JjRW5kIC09IHBvc2l0aW9uO1xuXHRcdHBvc2l0aW9uID0gMDtcblx0XHRpZiAoIXVucGFja3IuZ2V0U3RydWN0dXJlcylcblx0XHRcdHRocm93IG5ldyBFcnJvcihgUmVmZXJlbmNlIHRvIHNoYXJlZCBzdHJ1Y3R1cmUgJHtyZWNvcmRJZH0gd2l0aG91dCBnZXRTdHJ1Y3R1cmVzIG1ldGhvZGApO1xuXHRcdHVucGFja3IuX21lcmdlU3RydWN0dXJlcyh1bnBhY2tyLmdldFN0cnVjdHVyZXMoKSk7XG5cdFx0aWYgKCF1bnBhY2tyLnR5cGVkU3RydWN0cylcblx0XHRcdHRocm93IG5ldyBFcnJvcignQ291bGQgbm90IGZpbmQgYW55IHNoYXJlZCB0eXBlZCBzdHJ1Y3R1cmVzJyk7XG5cdFx0dW5wYWNrci5sYXN0VHlwZWRTdHJ1Y3R1cmVzTGVuZ3RoID0gdW5wYWNrci50eXBlZFN0cnVjdHMubGVuZ3RoO1xuXHRcdHN0cnVjdHVyZSA9IHVucGFja3IudHlwZWRTdHJ1Y3RzW3JlY29yZElkXTtcblx0XHRpZiAoIXN0cnVjdHVyZSlcblx0XHRcdHRocm93IG5ldyBFcnJvcignQ291bGQgbm90IGZpbmQgdHlwZWQgc3RydWN0dXJlICcgKyByZWNvcmRJZCk7XG5cdH1cblx0dmFyIGNvbnN0cnVjdCA9IHN0cnVjdHVyZS5jb25zdHJ1Y3Q7XG5cdGlmICghY29uc3RydWN0KSB7XG5cdFx0Y29uc3RydWN0ID0gc3RydWN0dXJlLmNvbnN0cnVjdCA9IGZ1bmN0aW9uIExhenlPYmplY3QoKSB7XG5cdFx0fTtcblx0XHR2YXIgcHJvdG90eXBlID0gY29uc3RydWN0LnByb3RvdHlwZTtcblx0XHRsZXQgcHJvcGVydGllcyA9IFtdO1xuXHRcdGxldCBjdXJyZW50T2Zmc2V0ID0gMDtcblx0XHRsZXQgbGFzdFJlZlByb3BlcnR5O1xuXHRcdGZvciAobGV0IGkgPSAwLCBsID0gc3RydWN0dXJlLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuXHRcdFx0bGV0IGRlZmluaXRpb24gPSBzdHJ1Y3R1cmVbaV07XG5cdFx0XHRsZXQgWyB0eXBlLCBzaXplLCBrZXksIGVudW1lcmF0aW9uT2Zmc2V0IF0gPSBkZWZpbml0aW9uO1xuXHRcdFx0aWYgKGtleSA9PT0gJ19fcHJvdG9fXycpXG5cdFx0XHRcdGtleSA9ICdfX3Byb3RvXyc7XG5cdFx0XHRsZXQgcHJvcGVydHkgPSB7XG5cdFx0XHRcdGtleSxcblx0XHRcdFx0b2Zmc2V0OiBjdXJyZW50T2Zmc2V0LFxuXHRcdFx0fTtcblx0XHRcdGlmIChlbnVtZXJhdGlvbk9mZnNldClcblx0XHRcdFx0cHJvcGVydGllcy5zcGxpY2UoaSArIGVudW1lcmF0aW9uT2Zmc2V0LCAwLCBwcm9wZXJ0eSk7XG5cdFx0XHRlbHNlXG5cdFx0XHRcdHByb3BlcnRpZXMucHVzaChwcm9wZXJ0eSk7XG5cdFx0XHRsZXQgZ2V0UmVmO1xuXHRcdFx0c3dpdGNoKHNpemUpIHsgLy8gVE9ETzogTW92ZSBpbnRvIGEgc2VwYXJhdGUgZnVuY3Rpb25cblx0XHRcdFx0Y2FzZSAwOiBnZXRSZWYgPSAoKSA9PiAwOyBicmVhaztcblx0XHRcdFx0Y2FzZSAxOlxuXHRcdFx0XHRcdGdldFJlZiA9IChzb3VyY2UsIHBvc2l0aW9uKSA9PiB7XG5cdFx0XHRcdFx0XHRsZXQgcmVmID0gc291cmNlLmJ5dGVzW3Bvc2l0aW9uICsgcHJvcGVydHkub2Zmc2V0XTtcblx0XHRcdFx0XHRcdHJldHVybiByZWYgPj0gMHhmNiA/IHRvQ29uc3RhbnQocmVmKSA6IHJlZjtcblx0XHRcdFx0XHR9O1xuXHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRjYXNlIDI6XG5cdFx0XHRcdFx0Z2V0UmVmID0gKHNvdXJjZSwgcG9zaXRpb24pID0+IHtcblx0XHRcdFx0XHRcdGxldCBzcmMgPSBzb3VyY2UuYnl0ZXM7XG5cdFx0XHRcdFx0XHRsZXQgZGF0YVZpZXcgPSBzcmMuZGF0YVZpZXcgfHwgKHNyYy5kYXRhVmlldyA9IG5ldyBEYXRhVmlldyhzcmMuYnVmZmVyLCBzcmMuYnl0ZU9mZnNldCwgc3JjLmJ5dGVMZW5ndGgpKTtcblx0XHRcdFx0XHRcdGxldCByZWYgPSBkYXRhVmlldy5nZXRVaW50MTYocG9zaXRpb24gKyBwcm9wZXJ0eS5vZmZzZXQsIHRydWUpO1xuXHRcdFx0XHRcdFx0cmV0dXJuIHJlZiA+PSAweGZmMDAgPyB0b0NvbnN0YW50KHJlZiAmIDB4ZmYpIDogcmVmO1xuXHRcdFx0XHRcdH07XG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdGNhc2UgNDpcblx0XHRcdFx0XHRnZXRSZWYgPSAoc291cmNlLCBwb3NpdGlvbikgPT4ge1xuXHRcdFx0XHRcdFx0bGV0IHNyYyA9IHNvdXJjZS5ieXRlcztcblx0XHRcdFx0XHRcdGxldCBkYXRhVmlldyA9IHNyYy5kYXRhVmlldyB8fCAoc3JjLmRhdGFWaWV3ID0gbmV3IERhdGFWaWV3KHNyYy5idWZmZXIsIHNyYy5ieXRlT2Zmc2V0LCBzcmMuYnl0ZUxlbmd0aCkpO1xuXHRcdFx0XHRcdFx0bGV0IHJlZiA9IGRhdGFWaWV3LmdldFVpbnQzMihwb3NpdGlvbiArIHByb3BlcnR5Lm9mZnNldCwgdHJ1ZSk7XG5cdFx0XHRcdFx0XHRyZXR1cm4gcmVmID49IDB4ZmZmZmZmMDAgPyB0b0NvbnN0YW50KHJlZiAmIDB4ZmYpIDogcmVmO1xuXHRcdFx0XHRcdH07XG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHR9XG5cdFx0XHRwcm9wZXJ0eS5nZXRSZWYgPSBnZXRSZWY7XG5cdFx0XHRjdXJyZW50T2Zmc2V0ICs9IHNpemU7XG5cdFx0XHRsZXQgZ2V0O1xuXHRcdFx0c3dpdGNoKHR5cGUpIHtcblx0XHRcdFx0Y2FzZSBBU0NJSTpcblx0XHRcdFx0XHRpZiAobGFzdFJlZlByb3BlcnR5ICYmICFsYXN0UmVmUHJvcGVydHkubmV4dClcblx0XHRcdFx0XHRcdGxhc3RSZWZQcm9wZXJ0eS5uZXh0ID0gcHJvcGVydHk7XG5cdFx0XHRcdFx0bGFzdFJlZlByb3BlcnR5ID0gcHJvcGVydHk7XG5cdFx0XHRcdFx0cHJvcGVydHkubXVsdGlHZXRDb3VudCA9IDA7XG5cdFx0XHRcdFx0Z2V0ID0gZnVuY3Rpb24oc291cmNlKSB7XG5cdFx0XHRcdFx0XHRsZXQgc3JjID0gc291cmNlLmJ5dGVzO1xuXHRcdFx0XHRcdFx0bGV0IHBvc2l0aW9uID0gc291cmNlLnBvc2l0aW9uO1xuXHRcdFx0XHRcdFx0bGV0IHJlZlN0YXJ0ID0gY3VycmVudE9mZnNldCArIHBvc2l0aW9uO1xuXHRcdFx0XHRcdFx0bGV0IHJlZiA9IGdldFJlZihzb3VyY2UsIHBvc2l0aW9uKTtcblx0XHRcdFx0XHRcdGlmICh0eXBlb2YgcmVmICE9PSAnbnVtYmVyJykgcmV0dXJuIHJlZjtcblxuXHRcdFx0XHRcdFx0bGV0IGVuZCwgbmV4dCA9IHByb3BlcnR5Lm5leHQ7XG5cdFx0XHRcdFx0XHR3aGlsZShuZXh0KSB7XG5cdFx0XHRcdFx0XHRcdGVuZCA9IG5leHQuZ2V0UmVmKHNvdXJjZSwgcG9zaXRpb24pO1xuXHRcdFx0XHRcdFx0XHRpZiAodHlwZW9mIGVuZCA9PT0gJ251bWJlcicpXG5cdFx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0XHRcdGVsc2Vcblx0XHRcdFx0XHRcdFx0XHRlbmQgPSBudWxsO1xuXHRcdFx0XHRcdFx0XHRuZXh0ID0gbmV4dC5uZXh0O1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0aWYgKGVuZCA9PSBudWxsKVxuXHRcdFx0XHRcdFx0XHRlbmQgPSBzb3VyY2UuYnl0ZXNFbmQgLSByZWZTdGFydDtcblx0XHRcdFx0XHRcdGlmIChzb3VyY2Uuc3JjU3RyaW5nKSB7XG5cdFx0XHRcdFx0XHRcdHJldHVybiBzb3VyY2Uuc3JjU3RyaW5nLnNsaWNlKHJlZiwgZW5kKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdC8qaWYgKHByb3BlcnR5Lm11bHRpR2V0Q291bnQgPiAwKSB7XG5cdFx0XHRcdFx0XHRcdGxldCBhc2NpaUVuZDtcblx0XHRcdFx0XHRcdFx0bmV4dCA9IGZpcnN0UmVmUHJvcGVydHk7XG5cdFx0XHRcdFx0XHRcdGxldCBkYXRhVmlldyA9IHNyYy5kYXRhVmlldyB8fCAoc3JjLmRhdGFWaWV3ID0gbmV3IERhdGFWaWV3KHNyYy5idWZmZXIsIHNyYy5ieXRlT2Zmc2V0LCBzcmMuYnl0ZUxlbmd0aCkpO1xuXHRcdFx0XHRcdFx0XHRkbyB7XG5cdFx0XHRcdFx0XHRcdFx0YXNjaWlFbmQgPSBkYXRhVmlldy5nZXRVaW50MTYoc291cmNlLnBvc2l0aW9uICsgbmV4dC5vZmZzZXQsIHRydWUpO1xuXHRcdFx0XHRcdFx0XHRcdGlmIChhc2NpaUVuZCA8IDB4ZmYwMClcblx0XHRcdFx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdFx0XHRcdGVsc2Vcblx0XHRcdFx0XHRcdFx0XHRcdGFzY2lpRW5kID0gbnVsbDtcblx0XHRcdFx0XHRcdFx0fSB3aGlsZSgobmV4dCA9IG5leHQubmV4dCkpO1xuXHRcdFx0XHRcdFx0XHRpZiAoYXNjaWlFbmQgPT0gbnVsbClcblx0XHRcdFx0XHRcdFx0XHRhc2NpaUVuZCA9IHNvdXJjZS5ieXRlc0VuZCAtIHJlZlN0YXJ0XG5cdFx0XHRcdFx0XHRcdHNvdXJjZS5zcmNTdHJpbmcgPSBzcmMudG9TdHJpbmcoJ2xhdGluMScsIHJlZlN0YXJ0LCByZWZTdGFydCArIGFzY2lpRW5kKTtcblx0XHRcdFx0XHRcdFx0cmV0dXJuIHNvdXJjZS5zcmNTdHJpbmcuc2xpY2UocmVmLCBlbmQpO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0aWYgKHNvdXJjZS5wcmV2U3RyaW5nR2V0KSB7XG5cdFx0XHRcdFx0XHRcdHNvdXJjZS5wcmV2U3RyaW5nR2V0Lm11bHRpR2V0Q291bnQgKz0gMjtcblx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRcdHNvdXJjZS5wcmV2U3RyaW5nR2V0ID0gcHJvcGVydHk7XG5cdFx0XHRcdFx0XHRcdHByb3BlcnR5Lm11bHRpR2V0Q291bnQtLTtcblx0XHRcdFx0XHRcdH0qL1xuXHRcdFx0XHRcdFx0cmV0dXJuIHJlYWRTdHJpbmcoc3JjLCByZWYgKyByZWZTdGFydCwgZW5kIC0gcmVmKTtcblx0XHRcdFx0XHRcdC8vcmV0dXJuIHNyYy50b1N0cmluZygnbGF0aW4xJywgcmVmICsgcmVmU3RhcnQsIGVuZCArIHJlZlN0YXJ0KTtcblx0XHRcdFx0XHR9O1xuXHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRjYXNlIFVURjg6IGNhc2UgT0JKRUNUX0RBVEE6XG5cdFx0XHRcdFx0aWYgKGxhc3RSZWZQcm9wZXJ0eSAmJiAhbGFzdFJlZlByb3BlcnR5Lm5leHQpXG5cdFx0XHRcdFx0XHRsYXN0UmVmUHJvcGVydHkubmV4dCA9IHByb3BlcnR5O1xuXHRcdFx0XHRcdGxhc3RSZWZQcm9wZXJ0eSA9IHByb3BlcnR5O1xuXHRcdFx0XHRcdGdldCA9IGZ1bmN0aW9uKHNvdXJjZSkge1xuXHRcdFx0XHRcdFx0bGV0IHBvc2l0aW9uID0gc291cmNlLnBvc2l0aW9uO1xuXHRcdFx0XHRcdFx0bGV0IHJlZlN0YXJ0ID0gY3VycmVudE9mZnNldCArIHBvc2l0aW9uO1xuXHRcdFx0XHRcdFx0bGV0IHJlZiA9IGdldFJlZihzb3VyY2UsIHBvc2l0aW9uKTtcblx0XHRcdFx0XHRcdGlmICh0eXBlb2YgcmVmICE9PSAnbnVtYmVyJykgcmV0dXJuIHJlZjtcblx0XHRcdFx0XHRcdGxldCBzcmMgPSBzb3VyY2UuYnl0ZXM7XG5cdFx0XHRcdFx0XHRsZXQgZW5kLCBuZXh0ID0gcHJvcGVydHkubmV4dDtcblx0XHRcdFx0XHRcdHdoaWxlKG5leHQpIHtcblx0XHRcdFx0XHRcdFx0ZW5kID0gbmV4dC5nZXRSZWYoc291cmNlLCBwb3NpdGlvbik7XG5cdFx0XHRcdFx0XHRcdGlmICh0eXBlb2YgZW5kID09PSAnbnVtYmVyJylcblx0XHRcdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHRcdFx0ZWxzZVxuXHRcdFx0XHRcdFx0XHRcdGVuZCA9IG51bGw7XG5cdFx0XHRcdFx0XHRcdG5leHQgPSBuZXh0Lm5leHQ7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRpZiAoZW5kID09IG51bGwpXG5cdFx0XHRcdFx0XHRcdGVuZCA9IHNvdXJjZS5ieXRlc0VuZCAtIHJlZlN0YXJ0O1xuXHRcdFx0XHRcdFx0aWYgKHR5cGUgPT09IFVURjgpIHtcblx0XHRcdFx0XHRcdFx0cmV0dXJuIHNyYy50b1N0cmluZygndXRmOCcsIHJlZiArIHJlZlN0YXJ0LCBlbmQgKyByZWZTdGFydCk7XG5cdFx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0XHRjdXJyZW50U291cmNlID0gc291cmNlO1xuXHRcdFx0XHRcdFx0XHR0cnkge1xuXHRcdFx0XHRcdFx0XHRcdHJldHVybiB1bnBhY2tyLnVucGFjayhzcmMsIHsgc3RhcnQ6IHJlZiArIHJlZlN0YXJ0LCBlbmQ6IGVuZCArIHJlZlN0YXJ0IH0pO1xuXHRcdFx0XHRcdFx0XHR9IGZpbmFsbHkge1xuXHRcdFx0XHRcdFx0XHRcdGN1cnJlbnRTb3VyY2UgPSBudWxsO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fTtcblx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0Y2FzZSBOVU1CRVI6XG5cdFx0XHRcdFx0c3dpdGNoKHNpemUpIHtcblx0XHRcdFx0XHRcdGNhc2UgNDpcblx0XHRcdFx0XHRcdFx0Z2V0ID0gZnVuY3Rpb24gKHNvdXJjZSkge1xuXHRcdFx0XHRcdFx0XHRcdGxldCBzcmMgPSBzb3VyY2UuYnl0ZXM7XG5cdFx0XHRcdFx0XHRcdFx0bGV0IGRhdGFWaWV3ID0gc3JjLmRhdGFWaWV3IHx8IChzcmMuZGF0YVZpZXcgPSBuZXcgRGF0YVZpZXcoc3JjLmJ1ZmZlciwgc3JjLmJ5dGVPZmZzZXQsIHNyYy5ieXRlTGVuZ3RoKSk7XG5cdFx0XHRcdFx0XHRcdFx0bGV0IHBvc2l0aW9uID0gc291cmNlLnBvc2l0aW9uICsgcHJvcGVydHkub2Zmc2V0O1xuXHRcdFx0XHRcdFx0XHRcdGxldCB2YWx1ZSA9IGRhdGFWaWV3LmdldEludDMyKHBvc2l0aW9uLCB0cnVlKTtcblx0XHRcdFx0XHRcdFx0XHRpZiAodmFsdWUgPCAweDIwMDAwMDAwKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRpZiAodmFsdWUgPiAtMHgxZjAwMDAwMClcblx0XHRcdFx0XHRcdFx0XHRcdFx0cmV0dXJuIHZhbHVlO1xuXHRcdFx0XHRcdFx0XHRcdFx0aWYgKHZhbHVlID4gLTB4MjAwMDAwMDApXG5cdFx0XHRcdFx0XHRcdFx0XHRcdHJldHVybiB0b0NvbnN0YW50KHZhbHVlICYgMHhmZik7XG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdGxldCBmVmFsdWUgPSBkYXRhVmlldy5nZXRGbG9hdDMyKHBvc2l0aW9uLCB0cnVlKTtcblx0XHRcdFx0XHRcdFx0XHQvLyB0aGlzIGRvZXMgcm91bmRpbmcgb2YgbnVtYmVycyB0aGF0IHdlcmUgZW5jb2RlZCBpbiAzMi1iaXQgZmxvYXQgdG8gbmVhcmVzdCBzaWduaWZpY2FudCBkZWNpbWFsIGRpZ2l0IHRoYXQgY291bGQgYmUgcHJlc2VydmVkXG5cdFx0XHRcdFx0XHRcdFx0bGV0IG11bHRpcGxpZXIgPSBtdWx0MTBbKChzcmNbcG9zaXRpb24gKyAzXSAmIDB4N2YpIDw8IDEpIHwgKHNyY1twb3NpdGlvbiArIDJdID4+IDcpXTtcblx0XHRcdFx0XHRcdFx0XHRyZXR1cm4gKChtdWx0aXBsaWVyICogZlZhbHVlICsgKGZWYWx1ZSA+IDAgPyAwLjUgOiAtMC41KSkgPj4gMCkgLyBtdWx0aXBsaWVyO1xuXHRcdFx0XHRcdFx0XHR9O1xuXHRcdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHRcdGNhc2UgODpcblx0XHRcdFx0XHRcdFx0Z2V0ID0gZnVuY3Rpb24gKHNvdXJjZSkge1xuXHRcdFx0XHRcdFx0XHRcdGxldCBzcmMgPSBzb3VyY2UuYnl0ZXM7XG5cdFx0XHRcdFx0XHRcdFx0bGV0IGRhdGFWaWV3ID0gc3JjLmRhdGFWaWV3IHx8IChzcmMuZGF0YVZpZXcgPSBuZXcgRGF0YVZpZXcoc3JjLmJ1ZmZlciwgc3JjLmJ5dGVPZmZzZXQsIHNyYy5ieXRlTGVuZ3RoKSk7XG5cdFx0XHRcdFx0XHRcdFx0bGV0IHZhbHVlID0gZGF0YVZpZXcuZ2V0RmxvYXQ2NChzb3VyY2UucG9zaXRpb24gKyBwcm9wZXJ0eS5vZmZzZXQsIHRydWUpO1xuXHRcdFx0XHRcdFx0XHRcdGlmIChpc05hTih2YWx1ZSkpIHtcblx0XHRcdFx0XHRcdFx0XHRcdGxldCBieXRlID0gc3JjW3NvdXJjZS5wb3NpdGlvbiArIHByb3BlcnR5Lm9mZnNldF07XG5cdFx0XHRcdFx0XHRcdFx0XHRpZiAoYnl0ZSA+PSAweGY2KVxuXHRcdFx0XHRcdFx0XHRcdFx0XHRyZXR1cm4gdG9Db25zdGFudChieXRlKTtcblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0cmV0dXJuIHZhbHVlO1xuXHRcdFx0XHRcdFx0XHR9O1xuXHRcdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHRcdGNhc2UgMTpcblx0XHRcdFx0XHRcdFx0Z2V0ID0gZnVuY3Rpb24gKHNvdXJjZSkge1xuXHRcdFx0XHRcdFx0XHRcdGxldCBzcmMgPSBzb3VyY2UuYnl0ZXM7XG5cdFx0XHRcdFx0XHRcdFx0bGV0IHZhbHVlID0gc3JjW3NvdXJjZS5wb3NpdGlvbiArIHByb3BlcnR5Lm9mZnNldF07XG5cdFx0XHRcdFx0XHRcdFx0cmV0dXJuIHZhbHVlIDwgMHhmNiA/IHZhbHVlIDogdG9Db25zdGFudCh2YWx1ZSk7XG5cdFx0XHRcdFx0XHRcdH07XG5cdFx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0Y2FzZSBEQVRFOlxuXHRcdFx0XHRcdGdldCA9IGZ1bmN0aW9uIChzb3VyY2UpIHtcblx0XHRcdFx0XHRcdGxldCBzcmMgPSBzb3VyY2UuYnl0ZXM7XG5cdFx0XHRcdFx0XHRsZXQgZGF0YVZpZXcgPSBzcmMuZGF0YVZpZXcgfHwgKHNyYy5kYXRhVmlldyA9IG5ldyBEYXRhVmlldyhzcmMuYnVmZmVyLCBzcmMuYnl0ZU9mZnNldCwgc3JjLmJ5dGVMZW5ndGgpKTtcblx0XHRcdFx0XHRcdHJldHVybiBuZXcgRGF0ZShkYXRhVmlldy5nZXRGbG9hdDY0KHNvdXJjZS5wb3NpdGlvbiArIHByb3BlcnR5Lm9mZnNldCwgdHJ1ZSkpO1xuXHRcdFx0XHRcdH07XG5cdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdH1cblx0XHRcdHByb3BlcnR5LmdldCA9IGdldDtcblx0XHR9XG5cdFx0Ly8gVE9ETzogbG9hZCB0aGUgc3JjU3RyaW5nIGZvciBmYXN0ZXIgc3RyaW5nIGRlY29kaW5nIG9uIHRvSlNPTlxuXHRcdGlmIChldmFsU3VwcG9ydGVkKSB7XG5cdFx0XHRsZXQgb2JqZWN0TGl0ZXJhbFByb3BlcnRpZXMgPSBbXTtcblx0XHRcdGxldCBhcmdzID0gW107XG5cdFx0XHRsZXQgaSA9IDA7XG5cdFx0XHRsZXQgaGFzSW5oZXJpdGVkUHJvcGVydGllcztcblx0XHRcdGZvciAobGV0IHByb3BlcnR5IG9mIHByb3BlcnRpZXMpIHsgLy8gYXNzaWduIGluIGVudW1lcmF0aW9uIG9yZGVyXG5cdFx0XHRcdGlmICh1bnBhY2tyLmFsd2F5c0xhenlQcm9wZXJ0eSAmJiB1bnBhY2tyLmFsd2F5c0xhenlQcm9wZXJ0eShwcm9wZXJ0eS5rZXkpKSB7XG5cdFx0XHRcdFx0Ly8gdGhlc2UgcHJvcGVydGllcyBhcmUgbm90IGVhZ2VybHkgZXZhbHVhdGVkIGFuZCB0aGlzIGNhbiBiZSB1c2VkIGZvciBjcmVhdGluZyBwcm9wZXJ0aWVzXG5cdFx0XHRcdFx0Ly8gdGhhdCBhcmUgbm90IHNlcmlhbGl6ZWQgYXMgSlNPTlxuXHRcdFx0XHRcdGhhc0luaGVyaXRlZFByb3BlcnRpZXMgPSB0cnVlO1xuXHRcdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0XHR9XG5cdFx0XHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShwcm90b3R5cGUsIHByb3BlcnR5LmtleSwgeyBnZXQ6IHdpdGhTb3VyY2UocHJvcGVydHkuZ2V0KSwgZW51bWVyYWJsZTogdHJ1ZSB9KTtcblx0XHRcdFx0bGV0IHZhbHVlRnVuY3Rpb24gPSAndicgKyBpKys7XG5cdFx0XHRcdGFyZ3MucHVzaCh2YWx1ZUZ1bmN0aW9uKTtcblx0XHRcdFx0b2JqZWN0TGl0ZXJhbFByb3BlcnRpZXMucHVzaCgnWycgKyBKU09OLnN0cmluZ2lmeShwcm9wZXJ0eS5rZXkpICsgJ106JyArIHZhbHVlRnVuY3Rpb24gKyAnKHMpJyk7XG5cdFx0XHR9XG5cdFx0XHRpZiAoaGFzSW5oZXJpdGVkUHJvcGVydGllcykge1xuXHRcdFx0XHRvYmplY3RMaXRlcmFsUHJvcGVydGllcy5wdXNoKCdfX3Byb3RvX186dGhpcycpO1xuXHRcdFx0fVxuXHRcdFx0bGV0IHRvT2JqZWN0ID0gKG5ldyBGdW5jdGlvbiguLi5hcmdzLCAncmV0dXJuIGZ1bmN0aW9uKHMpe3JldHVybnsnICsgb2JqZWN0TGl0ZXJhbFByb3BlcnRpZXMuam9pbignLCcpICsgJ319JykpLmFwcGx5KG51bGwsIHByb3BlcnRpZXMubWFwKHByb3AgPT4gcHJvcC5nZXQpKTtcblx0XHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShwcm90b3R5cGUsICd0b0pTT04nLCB7XG5cdFx0XHRcdHZhbHVlKG9taXRVbmRlcnNjb3JlZFByb3BlcnRpZXMpIHtcblx0XHRcdFx0XHRyZXR1cm4gdG9PYmplY3QuY2FsbCh0aGlzLCB0aGlzW3NvdXJjZVN5bWJvbF0pO1xuXHRcdFx0XHR9XG5cdFx0XHR9KTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KHByb3RvdHlwZSwgJ3RvSlNPTicsIHtcblx0XHRcdFx0dmFsdWUob21pdFVuZGVyc2NvcmVkUHJvcGVydGllcykge1xuXHRcdFx0XHRcdC8vIHJldHVybiBhbiBlbnVtZXJhYmxlIG9iamVjdCB3aXRoIG93biBwcm9wZXJ0aWVzIHRvIEpTT04gc3RyaW5naWZ5XG5cdFx0XHRcdFx0bGV0IHJlc29sdmVkID0ge307XG5cdFx0XHRcdFx0Zm9yIChsZXQgaSA9IDAsIGwgPSBwcm9wZXJ0aWVzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuXHRcdFx0XHRcdFx0Ly8gVE9ETzogY2hlY2sgYWx3YXlzTGF6eVByb3BlcnR5XG5cdFx0XHRcdFx0XHRsZXQga2V5ID0gcHJvcGVydGllc1tpXS5rZXk7XG5cblx0XHRcdFx0XHRcdHJlc29sdmVkW2tleV0gPSB0aGlzW2tleV07XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHJldHVybiByZXNvbHZlZDtcblx0XHRcdFx0fSxcblx0XHRcdFx0Ly8gbm90IGVudW1lcmFibGUgb3IgYW55dGhpbmdcblx0XHRcdH0pO1xuXHRcdH1cblx0fVxuXHR2YXIgaW5zdGFuY2UgPSBuZXcgY29uc3RydWN0KCk7XG5cdGluc3RhbmNlW3NvdXJjZVN5bWJvbF0gPSB7XG5cdFx0Ynl0ZXM6IHNyYyxcblx0XHRwb3NpdGlvbixcblx0XHRzcmNTdHJpbmc6ICcnLFxuXHRcdGJ5dGVzRW5kOiBzcmNFbmRcblx0fTtcblx0cmV0dXJuIGluc3RhbmNlO1xufVxuZnVuY3Rpb24gdG9Db25zdGFudChjb2RlKSB7XG5cdHN3aXRjaChjb2RlKSB7XG5cdFx0Y2FzZSAweGY2OiByZXR1cm4gbnVsbDtcblx0XHRjYXNlIDB4Zjc6IHJldHVybiB1bmRlZmluZWQ7XG5cdFx0Y2FzZSAweGY4OiByZXR1cm4gZmFsc2U7XG5cdFx0Y2FzZSAweGY5OiByZXR1cm4gdHJ1ZTtcblx0fVxuXHR0aHJvdyBuZXcgRXJyb3IoJ1Vua25vd24gY29uc3RhbnQnKTtcbn1cbmZ1bmN0aW9uIHdpdGhTb3VyY2UoZ2V0KSB7XG5cdHJldHVybiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gZ2V0KHRoaXNbc291cmNlU3ltYm9sXSk7XG5cdH1cbn1cblxuZnVuY3Rpb24gc2F2ZVN0YXRlKCkge1xuXHRpZiAoY3VycmVudFNvdXJjZSkge1xuXHRcdGN1cnJlbnRTb3VyY2UuYnl0ZXMgPSBVaW50OEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGN1cnJlbnRTb3VyY2UuYnl0ZXMsIGN1cnJlbnRTb3VyY2UucG9zaXRpb24sIGN1cnJlbnRTb3VyY2UuYnl0ZXNFbmQpO1xuXHRcdGN1cnJlbnRTb3VyY2UucG9zaXRpb24gPSAwO1xuXHRcdGN1cnJlbnRTb3VyY2UuYnl0ZXNFbmQgPSBjdXJyZW50U291cmNlLmJ5dGVzLmxlbmd0aDtcblx0fVxufVxuZnVuY3Rpb24gcHJlcGFyZVN0cnVjdHVyZXMoc3RydWN0dXJlcywgcGFja3IpIHtcblx0aWYgKHBhY2tyLnR5cGVkU3RydWN0cykge1xuXHRcdGxldCBzdHJ1Y3RNYXAgPSBuZXcgTWFwKCk7XG5cdFx0c3RydWN0TWFwLnNldCgnbmFtZWQnLCBzdHJ1Y3R1cmVzKTtcblx0XHRzdHJ1Y3RNYXAuc2V0KCd0eXBlZCcsIHBhY2tyLnR5cGVkU3RydWN0cyk7XG5cdFx0c3RydWN0dXJlcyA9IHN0cnVjdE1hcDtcblx0fVxuXHRsZXQgbGFzdFR5cGVkU3RydWN0dXJlc0xlbmd0aCA9IHBhY2tyLmxhc3RUeXBlZFN0cnVjdHVyZXNMZW5ndGggfHwgMDtcblx0c3RydWN0dXJlcy5pc0NvbXBhdGlibGUgPSBleGlzdGluZyA9PiB7XG5cdFx0bGV0IGNvbXBhdGlibGUgPSB0cnVlO1xuXHRcdGlmIChleGlzdGluZyBpbnN0YW5jZW9mIE1hcCkge1xuXHRcdFx0bGV0IG5hbWVkID0gZXhpc3RpbmcuZ2V0KCduYW1lZCcpIHx8IFtdO1xuXHRcdFx0aWYgKG5hbWVkLmxlbmd0aCAhPT0gKHBhY2tyLmxhc3ROYW1lZFN0cnVjdHVyZXNMZW5ndGggfHwgMCkpXG5cdFx0XHRcdGNvbXBhdGlibGUgPSBmYWxzZTtcblx0XHRcdGxldCB0eXBlZCA9IGV4aXN0aW5nLmdldCgndHlwZWQnKSB8fCBbXTtcblx0XHRcdGlmICh0eXBlZC5sZW5ndGggIT09IGxhc3RUeXBlZFN0cnVjdHVyZXNMZW5ndGgpXG5cdFx0XHRcdGNvbXBhdGlibGUgPSBmYWxzZTtcblx0XHR9IGVsc2UgaWYgKGV4aXN0aW5nIGluc3RhbmNlb2YgQXJyYXkgfHwgQXJyYXkuaXNBcnJheShleGlzdGluZykpIHtcblx0XHRcdGlmIChleGlzdGluZy5sZW5ndGggIT09IChwYWNrci5sYXN0TmFtZWRTdHJ1Y3R1cmVzTGVuZ3RoIHx8IDApKVxuXHRcdFx0XHRjb21wYXRpYmxlID0gZmFsc2U7XG5cdFx0fVxuXHRcdGlmICghY29tcGF0aWJsZSlcblx0XHRcdHBhY2tyLl9tZXJnZVN0cnVjdHVyZXMoZXhpc3RpbmcpO1xuXHRcdHJldHVybiBjb21wYXRpYmxlO1xuXHR9O1xuXHRwYWNrci5sYXN0VHlwZWRTdHJ1Y3R1cmVzTGVuZ3RoID0gcGFja3IudHlwZWRTdHJ1Y3RzICYmIHBhY2tyLnR5cGVkU3RydWN0cy5sZW5ndGg7XG5cdHJldHVybiBzdHJ1Y3R1cmVzO1xufVxuXG5zZXRSZWFkU3RydWN0KHJlYWRTdHJ1Y3QsIG9uTG9hZGVkU3RydWN0dXJlcywgc2F2ZVN0YXRlKTtcblxuY2xhc3MgUGFja3JTdHJlYW0gZXh0ZW5kcyBzdHJlYW0uVHJhbnNmb3JtIHtcblx0Y29uc3RydWN0b3Iob3B0aW9ucykge1xuXHRcdGlmICghb3B0aW9ucylcblx0XHRcdG9wdGlvbnMgPSB7fTtcblx0XHRvcHRpb25zLndyaXRhYmxlT2JqZWN0TW9kZSA9IHRydWU7XG5cdFx0c3VwZXIob3B0aW9ucyk7XG5cdFx0b3B0aW9ucy5zZXF1ZW50aWFsID0gdHJ1ZTtcblx0XHR0aGlzLnBhY2tyID0gb3B0aW9ucy5wYWNrciB8fCBuZXcgUGFja3Iob3B0aW9ucyk7XG5cdH1cblx0X3RyYW5zZm9ybSh2YWx1ZSwgZW5jb2RpbmcsIGNhbGxiYWNrKSB7XG5cdFx0dGhpcy5wdXNoKHRoaXMucGFja3IucGFjayh2YWx1ZSkpO1xuXHRcdGNhbGxiYWNrKCk7XG5cdH1cbn1cblxuY2xhc3MgVW5wYWNrclN0cmVhbSBleHRlbmRzIHN0cmVhbS5UcmFuc2Zvcm0ge1xuXHRjb25zdHJ1Y3RvcihvcHRpb25zKSB7XG5cdFx0aWYgKCFvcHRpb25zKVxuXHRcdFx0b3B0aW9ucyA9IHt9O1xuXHRcdG9wdGlvbnMub2JqZWN0TW9kZSA9IHRydWU7XG5cdFx0c3VwZXIob3B0aW9ucyk7XG5cdFx0b3B0aW9ucy5zdHJ1Y3R1cmVzID0gW107XG5cdFx0dGhpcy51bnBhY2tyID0gb3B0aW9ucy51bnBhY2tyIHx8IG5ldyBVbnBhY2tyKG9wdGlvbnMpO1xuXHR9XG5cdF90cmFuc2Zvcm0oY2h1bmssIGVuY29kaW5nLCBjYWxsYmFjaykge1xuXHRcdGlmICh0aGlzLmluY29tcGxldGVCdWZmZXIpIHtcblx0XHRcdGNodW5rID0gQnVmZmVyLmNvbmNhdChbdGhpcy5pbmNvbXBsZXRlQnVmZmVyLCBjaHVua10pO1xuXHRcdFx0dGhpcy5pbmNvbXBsZXRlQnVmZmVyID0gbnVsbDtcblx0XHR9XG5cdFx0bGV0IHZhbHVlcztcblx0XHR0cnkge1xuXHRcdFx0dmFsdWVzID0gdGhpcy51bnBhY2tyLnVucGFja011bHRpcGxlKGNodW5rKTtcblx0XHR9IGNhdGNoKGVycm9yKSB7XG5cdFx0XHRpZiAoZXJyb3IuaW5jb21wbGV0ZSkge1xuXHRcdFx0XHR0aGlzLmluY29tcGxldGVCdWZmZXIgPSBjaHVuay5zbGljZShlcnJvci5sYXN0UG9zaXRpb24pO1xuXHRcdFx0XHR2YWx1ZXMgPSBlcnJvci52YWx1ZXM7XG5cdFx0XHR9XG5cdFx0XHRlbHNlXG5cdFx0XHRcdHRocm93IGVycm9yXG5cdFx0fSBmaW5hbGx5IHtcblx0XHRcdGZvciAobGV0IHZhbHVlIG9mIHZhbHVlcyB8fCBbXSkge1xuXHRcdFx0XHRpZiAodmFsdWUgPT09IG51bGwpXG5cdFx0XHRcdFx0dmFsdWUgPSB0aGlzLmdldE51bGxWYWx1ZSgpO1xuXHRcdFx0XHR0aGlzLnB1c2godmFsdWUpO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRpZiAoY2FsbGJhY2spIGNhbGxiYWNrKCk7XG5cdH1cblx0Z2V0TnVsbFZhbHVlKCkge1xuXHRcdHJldHVybiBTeW1ib2wuZm9yKG51bGwpXG5cdH1cbn1cblxuLyoqXG4gKiBHaXZlbiBhbiBJdGVyYWJsZSBmaXJzdCBhcmd1bWVudCwgcmV0dXJucyBhbiBJdGVyYWJsZSB3aGVyZSBlYWNoIHZhbHVlIGlzIHBhY2tlZCBhcyBhIEJ1ZmZlclxuICogSWYgdGhlIGFyZ3VtZW50IGlzIG9ubHkgQXN5bmMgSXRlcmFibGUsIHRoZSByZXR1cm4gdmFsdWUgd2lsbCBiZSBhbiBBc3luYyBJdGVyYWJsZS5cbiAqIEBwYXJhbSB7SXRlcmFibGV8SXRlcmF0b3J8QXN5bmNJdGVyYWJsZXxBc3luY0l0ZXJhdG9yfSBvYmplY3RJdGVyYXRvciAtIGl0ZXJhYmxlIHNvdXJjZSwgbGlrZSBhIFJlYWRhYmxlIG9iamVjdCBzdHJlYW0sIGFuIGFycmF5LCBTZXQsIG9yIGN1c3RvbSBvYmplY3RcbiAqIEBwYXJhbSB7b3B0aW9uc30gW29wdGlvbnNdIC0gbXNncGFja3IgcGFjayBvcHRpb25zXG4gKiBAcmV0dXJucyB7SXRlcmFibGVJdGVyYXRvcnxQcm9taXNlLjxBc3luY0l0ZXJhYmxlSXRlcmF0b3I+fVxuICovXG5mdW5jdGlvbiBwYWNrSXRlciAob2JqZWN0SXRlcmF0b3IsIG9wdGlvbnMgPSB7fSkge1xuICBpZiAoIW9iamVjdEl0ZXJhdG9yIHx8IHR5cGVvZiBvYmplY3RJdGVyYXRvciAhPT0gJ29iamVjdCcpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2ZpcnN0IGFyZ3VtZW50IG11c3QgYmUgYW4gSXRlcmFibGUsIEFzeW5jIEl0ZXJhYmxlLCBvciBhIFByb21pc2UgZm9yIGFuIEFzeW5jIEl0ZXJhYmxlJylcbiAgfSBlbHNlIGlmICh0eXBlb2Ygb2JqZWN0SXRlcmF0b3JbU3ltYm9sLml0ZXJhdG9yXSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHJldHVybiBwYWNrSXRlclN5bmMob2JqZWN0SXRlcmF0b3IsIG9wdGlvbnMpXG4gIH0gZWxzZSBpZiAodHlwZW9mIG9iamVjdEl0ZXJhdG9yLnRoZW4gPT09ICdmdW5jdGlvbicgfHwgdHlwZW9mIG9iamVjdEl0ZXJhdG9yW1N5bWJvbC5hc3luY0l0ZXJhdG9yXSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHJldHVybiBwYWNrSXRlckFzeW5jKG9iamVjdEl0ZXJhdG9yLCBvcHRpb25zKVxuICB9IGVsc2Uge1xuICAgIHRocm93IG5ldyBFcnJvcignZmlyc3QgYXJndW1lbnQgbXVzdCBiZSBhbiBJdGVyYWJsZSwgQXN5bmMgSXRlcmFibGUsIEl0ZXJhdG9yLCBBc3luYyBJdGVyYXRvciwgb3IgYSBQcm9taXNlJylcbiAgfVxufVxuXG5mdW5jdGlvbiAqIHBhY2tJdGVyU3luYyAob2JqZWN0SXRlcmF0b3IsIG9wdGlvbnMpIHtcbiAgY29uc3QgcGFja3IgPSBuZXcgUGFja3Iob3B0aW9ucyk7XG4gIGZvciAoY29uc3QgdmFsdWUgb2Ygb2JqZWN0SXRlcmF0b3IpIHtcbiAgICB5aWVsZCBwYWNrci5wYWNrKHZhbHVlKTtcbiAgfVxufVxuXG5hc3luYyBmdW5jdGlvbiAqIHBhY2tJdGVyQXN5bmMgKG9iamVjdEl0ZXJhdG9yLCBvcHRpb25zKSB7XG4gIGNvbnN0IHBhY2tyID0gbmV3IFBhY2tyKG9wdGlvbnMpO1xuICBmb3IgYXdhaXQgKGNvbnN0IHZhbHVlIG9mIG9iamVjdEl0ZXJhdG9yKSB7XG4gICAgeWllbGQgcGFja3IucGFjayh2YWx1ZSk7XG4gIH1cbn1cblxuLyoqXG4gKiBHaXZlbiBhbiBJdGVyYWJsZS9JdGVyYXRvciBpbnB1dCB3aGljaCB5aWVsZHMgYnVmZmVycywgcmV0dXJucyBhbiBJdGVyYWJsZUl0ZXJhdG9yIHdoaWNoIHlpZWxkcyBzeW5jIGRlY29kZWQgb2JqZWN0c1xuICogT3IsIGdpdmVuIGFuIEFzeW5jIEl0ZXJhYmxlL0l0ZXJhdG9yIHdoaWNoIHlpZWxkcyBwcm9taXNlcyByZXNvbHZpbmcgaW4gYnVmZmVycywgcmV0dXJucyBhbiBBc3luY0l0ZXJhYmxlSXRlcmF0b3IuXG4gKiBAcGFyYW0ge0l0ZXJhYmxlfEl0ZXJhdG9yfEFzeW5jSXRlcmFibGV8QXN5bmNJdGVyYWJsZUl0ZXJhdG9yfSBidWZmZXJJdGVyYXRvclxuICogQHBhcmFtIHtvYmplY3R9IFtvcHRpb25zXSAtIHVucGFja3Igb3B0aW9uc1xuICogQHJldHVybnMge0l0ZXJhYmxlSXRlcmF0b3J8UHJvbWlzZS48QXN5bmNJdGVyYWJsZUl0ZXJhdG9yfVxuICovXG5mdW5jdGlvbiB1bnBhY2tJdGVyIChidWZmZXJJdGVyYXRvciwgb3B0aW9ucyA9IHt9KSB7XG4gIGlmICghYnVmZmVySXRlcmF0b3IgfHwgdHlwZW9mIGJ1ZmZlckl0ZXJhdG9yICE9PSAnb2JqZWN0Jykge1xuICAgIHRocm93IG5ldyBFcnJvcignZmlyc3QgYXJndW1lbnQgbXVzdCBiZSBhbiBJdGVyYWJsZSwgQXN5bmMgSXRlcmFibGUsIEl0ZXJhdG9yLCBBc3luYyBJdGVyYXRvciwgb3IgYSBwcm9taXNlJylcbiAgfVxuXG4gIGNvbnN0IHVucGFja3IgPSBuZXcgVW5wYWNrcihvcHRpb25zKTtcbiAgbGV0IGluY29tcGxldGU7XG4gIGNvbnN0IHBhcnNlciA9IChjaHVuaykgPT4ge1xuICAgIGxldCB5aWVsZHM7XG4gICAgLy8gaWYgdGhlcmUncyBpbmNvbXBsZXRlIGRhdGEgZnJvbSBwcmV2aW91cyBjaHVuaywgY29uY2F0aW5hdGUgYW5kIHRyeSBhZ2FpblxuICAgIGlmIChpbmNvbXBsZXRlKSB7XG4gICAgICBjaHVuayA9IEJ1ZmZlci5jb25jYXQoW2luY29tcGxldGUsIGNodW5rXSk7XG4gICAgICBpbmNvbXBsZXRlID0gdW5kZWZpbmVkO1xuICAgIH1cblxuICAgIHRyeSB7XG4gICAgICB5aWVsZHMgPSB1bnBhY2tyLnVucGFja011bHRpcGxlKGNodW5rKTtcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIGlmIChlcnIuaW5jb21wbGV0ZSkge1xuICAgICAgICBpbmNvbXBsZXRlID0gY2h1bmsuc2xpY2UoZXJyLmxhc3RQb3NpdGlvbik7XG4gICAgICAgIHlpZWxkcyA9IGVyci52YWx1ZXM7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyBlcnJcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHlpZWxkc1xuICB9O1xuXG4gIGlmICh0eXBlb2YgYnVmZmVySXRlcmF0b3JbU3ltYm9sLml0ZXJhdG9yXSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHJldHVybiAoZnVuY3Rpb24gKiBpdGVyICgpIHtcbiAgICAgIGZvciAoY29uc3QgdmFsdWUgb2YgYnVmZmVySXRlcmF0b3IpIHtcbiAgICAgICAgeWllbGQgKiBwYXJzZXIodmFsdWUpO1xuICAgICAgfVxuICAgIH0pKClcbiAgfSBlbHNlIGlmICh0eXBlb2YgYnVmZmVySXRlcmF0b3JbU3ltYm9sLmFzeW5jSXRlcmF0b3JdID09PSAnZnVuY3Rpb24nKSB7XG4gICAgcmV0dXJuIChhc3luYyBmdW5jdGlvbiAqIGl0ZXIgKCkge1xuICAgICAgZm9yIGF3YWl0IChjb25zdCB2YWx1ZSBvZiBidWZmZXJJdGVyYXRvcikge1xuICAgICAgICB5aWVsZCAqIHBhcnNlcih2YWx1ZSk7XG4gICAgICB9XG4gICAgfSkoKVxuICB9XG59XG5jb25zdCBkZWNvZGVJdGVyID0gdW5wYWNrSXRlcjtcbmNvbnN0IGVuY29kZUl0ZXIgPSBwYWNrSXRlcjtcblxuY29uc3QgdXNlUmVjb3JkcyA9IGZhbHNlO1xuY29uc3QgbWFwc0FzT2JqZWN0cyA9IHRydWU7XG5cbmNvbnN0IG5hdGl2ZUFjY2VsZXJhdGlvbkRpc2FibGVkID0gcHJvY2Vzcy5lbnYuTVNHUEFDS1JfTkFUSVZFX0FDQ0VMRVJBVElPTl9ESVNBQkxFRCAhPT0gdW5kZWZpbmVkICYmIHByb2Nlc3MuZW52Lk1TR1BBQ0tSX05BVElWRV9BQ0NFTEVSQVRJT05fRElTQUJMRUQudG9Mb3dlckNhc2UoKSA9PT0gJ3RydWUnO1xuXG5pZiAoIW5hdGl2ZUFjY2VsZXJhdGlvbkRpc2FibGVkKSB7XG5cdGxldCBleHRyYWN0b3I7XG5cdHRyeSB7XG5cdFx0aWYgKHR5cGVvZiByZXF1aXJlID09ICdmdW5jdGlvbicpXG5cdFx0XHRleHRyYWN0b3IgPSByZXF1aXJlKCdtc2dwYWNrci1leHRyYWN0Jyk7XG5cdFx0ZWxzZVxuXHRcdFx0ZXh0cmFjdG9yID0gbW9kdWxlJDEuY3JlYXRlUmVxdWlyZSgodHlwZW9mIGRvY3VtZW50ID09PSAndW5kZWZpbmVkJyA/IG5ldyAocmVxdWlyZSgndScgKyAncmwnKS5VUkwpKCdmaWxlOicgKyBfX2ZpbGVuYW1lKS5ocmVmIDogKGRvY3VtZW50LmN1cnJlbnRTY3JpcHQgJiYgZG9jdW1lbnQuY3VycmVudFNjcmlwdC5zcmMgfHwgbmV3IFVSTCgnbm9kZS5janMnLCBkb2N1bWVudC5iYXNlVVJJKS5ocmVmKSkpKCdtc2dwYWNrci1leHRyYWN0Jyk7XG5cdFx0aWYgKGV4dHJhY3Rvcilcblx0XHRcdHNldEV4dHJhY3RvcihleHRyYWN0b3IuZXh0cmFjdFN0cmluZ3MpO1xuXHR9IGNhdGNoIChlcnJvcikge1xuXHRcdC8vIG5hdGl2ZSBtb2R1bGUgaXMgb3B0aW9uYWxcblx0fVxufVxuXG5leHBvcnRzLkFMV0FZUyA9IEFMV0FZUztcbmV4cG9ydHMuQzEgPSBDMTtcbmV4cG9ydHMuREVDSU1BTF9GSVQgPSBERUNJTUFMX0ZJVDtcbmV4cG9ydHMuREVDSU1BTF9ST1VORCA9IERFQ0lNQUxfUk9VTkQ7XG5leHBvcnRzLkRlY29kZXIgPSBEZWNvZGVyO1xuZXhwb3J0cy5EZWNvZGVyU3RyZWFtID0gVW5wYWNrclN0cmVhbTtcbmV4cG9ydHMuRW5jb2RlciA9IEVuY29kZXI7XG5leHBvcnRzLkVuY29kZXJTdHJlYW0gPSBQYWNrclN0cmVhbTtcbmV4cG9ydHMuRkxPQVQzMl9PUFRJT05TID0gRkxPQVQzMl9PUFRJT05TO1xuZXhwb3J0cy5ORVZFUiA9IE5FVkVSO1xuZXhwb3J0cy5QYWNrciA9IFBhY2tyO1xuZXhwb3J0cy5QYWNrclN0cmVhbSA9IFBhY2tyU3RyZWFtO1xuZXhwb3J0cy5VbnBhY2tyID0gVW5wYWNrcjtcbmV4cG9ydHMuVW5wYWNrclN0cmVhbSA9IFVucGFja3JTdHJlYW07XG5leHBvcnRzLmFkZEV4dGVuc2lvbiA9IGFkZEV4dGVuc2lvbjtcbmV4cG9ydHMuY2xlYXJTb3VyY2UgPSBjbGVhclNvdXJjZTtcbmV4cG9ydHMuZGVjb2RlID0gZGVjb2RlO1xuZXhwb3J0cy5kZWNvZGVJdGVyID0gZGVjb2RlSXRlcjtcbmV4cG9ydHMuZW5jb2RlID0gZW5jb2RlO1xuZXhwb3J0cy5lbmNvZGVJdGVyID0gZW5jb2RlSXRlcjtcbmV4cG9ydHMubWFwc0FzT2JqZWN0cyA9IG1hcHNBc09iamVjdHM7XG5leHBvcnRzLnBhY2sgPSBwYWNrO1xuZXhwb3J0cy5yb3VuZEZsb2F0MzIgPSByb3VuZEZsb2F0MzI7XG5leHBvcnRzLnVucGFjayA9IHVucGFjaztcbmV4cG9ydHMudW5wYWNrTXVsdGlwbGUgPSB1bnBhY2tNdWx0aXBsZTtcbmV4cG9ydHMudXNlUmVjb3JkcyA9IHVzZVJlY29yZHM7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1ub2RlLmNqcy5tYXBcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/msgpackr/dist/node.cjs\n");

/***/ })

};
;